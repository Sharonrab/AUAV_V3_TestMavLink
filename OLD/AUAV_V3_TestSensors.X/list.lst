
dist\default\debug\AUAV_V3_TestSensors.X.debug.elf:     file format elf32-pic30

Disassembly of section .ivt._AD1Interrupt:

0000002e <.ivt._AD1Interrupt>:
  2e:	1c 14 00    	nop       
Disassembly of section .ivt._AD2Interrupt:

0000003e <.ivt._AD2Interrupt>:
  3e:	1c 14 00    	nop       
Disassembly of section .ivt._AddressError:

00000006 <.ivt._AddressError>:
   6:	1c 14 00    	nop       
Disassembly of section .ivt._C1Interrupt:

0000005a <.ivt._C1Interrupt>:
  5a:	1c 14 00    	nop       
Disassembly of section .ivt._C1RxRdyInterrupt:

00000058 <.ivt._C1RxRdyInterrupt>:
  58:	1c 14 00    	nop       
Disassembly of section .ivt._C1TxReqInterrupt:

000000a0 <.ivt._C1TxReqInterrupt>:
  a0:	1c 14 00    	nop       
Disassembly of section .ivt._C2Interrupt:

00000084 <.ivt._C2Interrupt>:
  84:	1c 14 00    	nop       
Disassembly of section .ivt._C2RxRdyInterrupt:

00000082 <.ivt._C2RxRdyInterrupt>:
  82:	1c 14 00    	nop       
Disassembly of section .ivt._C2TxReqInterrupt:

000000a2 <.ivt._C2TxReqInterrupt>:
  a2:	1c 14 00    	nop       
Disassembly of section .ivt._CM1Interrupt:

00000038 <.ivt._CM1Interrupt>:
  38:	1c 14 00    	nop       
Disassembly of section .ivt._CNInterrupt:

0000003a <.ivt._CNInterrupt>:
  3a:	1c 14 00    	nop       
Disassembly of section .ivt._CRCInterrupt:

0000009a <__FGS-0xf7ff6a>:
  9a:	1c 14 00    	nop       
Disassembly of section .ivt._DCIEInterrupt:

0000008a <__FOSCSEL-0xf7ff7c>:
  8a:	1c 14 00    	nop       
Disassembly of section .ivt._DCIInterrupt:

0000008c <__FOSC-0xf7ff7c>:
  8c:	1c 14 00    	nop       
Disassembly of section .ivt._DMA0Interrupt:

0000001c <__FWDT-0xf7ffee>:
  1c:	1c 14 00    	nop       
Disassembly of section .ivt._DMA10Interrupt:

00000104 <__FPOR-0xf7ff08>:
 104:	1c 14 00    	nop       
Disassembly of section .ivt._DMA11Interrupt:

00000106 <__FICD-0xf7ff08>:
 106:	1c 14 00    	nop       
Disassembly of section .ivt._DMA12Interrupt:

00000118 <__FAS-0xf7fef8>:
 118:	1c 14 00    	nop       
Disassembly of section .ivt._DMA13Interrupt:

0000011a <.ivt._DMA13Interrupt>:
 11a:	1c 14 00    	nop       
Disassembly of section .ivt._DMA14Interrupt:

0000011c <.ivt._DMA14Interrupt>:
 11c:	1c 14 00    	nop       
Disassembly of section .ivt._DMA1Interrupt:

00000030 <.ivt._DMA1Interrupt>:
  30:	1c 14 00    	nop       
Disassembly of section .ivt._DMA2Interrupt:

00000044 <.ivt._DMA2Interrupt>:
  44:	1c 14 00    	nop       
Disassembly of section .ivt._DMA3Interrupt:

0000005c <.ivt._DMA3Interrupt>:
  5c:	1c 14 00    	nop       
Disassembly of section .ivt._DMA4Interrupt:

00000070 <.ivt._DMA4Interrupt>:
  70:	1c 14 00    	nop       
Disassembly of section .ivt._DMA5Interrupt:

0000008e <.ivt._DMA5Interrupt>:
  8e:	1c 14 00    	nop       
Disassembly of section .ivt._DMA6Interrupt:

0000009c <.ivt._DMA6Interrupt>:
  9c:	1c 14 00    	nop       
Disassembly of section .ivt._DMA7Interrupt:

0000009e <.ivt._DMA7Interrupt>:
  9e:	1c 14 00    	nop       
Disassembly of section .ivt._DMA8Interrupt:

00000100 <.ivt._DMA8Interrupt>:
 100:	1c 14 00    	nop       
Disassembly of section .ivt._DMA9Interrupt:

00000102 <.ivt._DMA9Interrupt>:
 102:	1c 14 00    	nop       
Disassembly of section .ivt._DMACError:

0000000e <.ivt._DMACError>:
   e:	1c 14 00    	nop       
Disassembly of section .ivt._HardTrapError:

00000008 <.ivt._HardTrapError>:
   8:	1c 14 00    	nop       
Disassembly of section .ivt._IC10Interrupt:

0000010e <.ivt._IC10Interrupt>:
 10e:	1c 14 00    	nop       
Disassembly of section .ivt._IC11Interrupt:

00000112 <.ivt._IC11Interrupt>:
 112:	1c 14 00    	nop       
Disassembly of section .ivt._IC12Interrupt:

00000116 <.ivt._IC12Interrupt>:
 116:	1c 14 00    	nop       
Disassembly of section .ivt._IC13Interrupt:

00000122 <.ivt._IC13Interrupt>:
 122:	1c 14 00    	nop       
Disassembly of section .ivt._IC14Interrupt:

00000126 <.ivt._IC14Interrupt>:
 126:	1c 14 00    	nop       
Disassembly of section .ivt._IC15Interrupt:

0000012a <.ivt._IC15Interrupt>:
 12a:	1c 14 00    	nop       
Disassembly of section .ivt._IC16Interrupt:

0000012e <.ivt._IC16Interrupt>:
 12e:	1c 14 00    	nop       
Disassembly of section .ivt._IC9Interrupt:

000000ce <.ivt._IC9Interrupt>:
  ce:	1c 14 00    	nop       
Disassembly of section .ivt._ICDInterrupt:

00000130 <.ivt._ICDInterrupt>:
 130:	1c 14 00    	nop       
Disassembly of section .ivt._INT0Interrupt:

00000014 <.ivt._INT0Interrupt>:
  14:	1c 14 00    	nop       
Disassembly of section .ivt._INT1Interrupt:

0000003c <.ivt._INT1Interrupt>:
  3c:	1c 14 00    	nop       
Disassembly of section .ivt._INT2Interrupt:

0000004e <.ivt._INT2Interrupt>:
  4e:	1c 14 00    	nop       
Disassembly of section .ivt._INT3Interrupt:

0000007e <.ivt._INT3Interrupt>:
  7e:	1c 14 00    	nop       
Disassembly of section .ivt._INT4Interrupt:

00000080 <.ivt._INT4Interrupt>:
  80:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt100:

000000dc <.ivt._Interrupt100>:
  dc:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt101:

000000de <.ivt._Interrupt101>:
  de:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt102:

000000e0 <.ivt._Interrupt102>:
  e0:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt103:

000000e2 <.ivt._Interrupt103>:
  e2:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt104:

000000e4 <.ivt._Interrupt104>:
  e4:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt105:

000000e6 <.ivt._Interrupt105>:
  e6:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt106:

000000e8 <.ivt._Interrupt106>:
  e8:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt107:

000000ea <.ivt._Interrupt107>:
  ea:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt108:

000000ec <.ivt._Interrupt108>:
  ec:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt109:

000000ee <.ivt._Interrupt109>:
  ee:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt110:

000000f0 <.ivt._Interrupt110>:
  f0:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt111:

000000f2 <.ivt._Interrupt111>:
  f2:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt112:

000000f4 <.ivt._Interrupt112>:
  f4:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt113:

000000f6 <.ivt._Interrupt113>:
  f6:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt114:

000000f8 <.ivt._Interrupt114>:
  f8:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt115:

000000fa <.ivt._Interrupt115>:
  fa:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt116:

000000fc <.ivt._Interrupt116>:
  fc:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt117:

000000fe <.ivt._Interrupt117>:
  fe:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt133:

0000011e <.ivt._Interrupt133>:
 11e:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt63:

00000092 <.ivt._Interrupt63>:
  92:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt64:

00000094 <.ivt._Interrupt64>:
  94:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt72:

000000a4 <.ivt._Interrupt72>:
  a4:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt74:

000000a8 <.ivt._Interrupt74>:
  a8:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt76:

000000ac <.ivt._Interrupt76>:
  ac:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt77:

000000ae <.ivt._Interrupt77>:
  ae:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt78:

000000b0 <.ivt._Interrupt78>:
  b0:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt79:

000000b2 <.ivt._Interrupt79>:
  b2:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt80:

000000b4 <.ivt._Interrupt80>:
  b4:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt84:

000000bc <.ivt._Interrupt84>:
  bc:	1c 14 00    	nop       
Disassembly of section .ivt._Interrupt85:

000000be <.ivt._Interrupt85>:
  be:	1c 14 00    	nop       
Disassembly of section .ivt._JTAGInterrupt:

00000132 <.ivt._JTAGInterrupt>:
 132:	1c 14 00    	nop       
Disassembly of section .ivt._MI2C1Interrupt:

00000036 <.ivt._MI2C1Interrupt>:
  36:	1c 14 00    	nop       
Disassembly of section .ivt._MathError:

0000000c <.ivt._MathError>:
   c:	1c 14 00    	nop       
Disassembly of section .ivt._NVMInterrupt:

00000032 <.ivt._NVMInterrupt>:
  32:	1c 14 00    	nop       
Disassembly of section .ivt._OC10Interrupt:

0000010c <.ivt._OC10Interrupt>:
 10c:	1c 14 00    	nop       
Disassembly of section .ivt._OC11Interrupt:

00000110 <.ivt._OC11Interrupt>:
 110:	1c 14 00    	nop       
Disassembly of section .ivt._OC12Interrupt:

00000114 <.ivt._OC12Interrupt>:
 114:	1c 14 00    	nop       
Disassembly of section .ivt._OC13Interrupt:

00000120 <.ivt._OC13Interrupt>:
 120:	1c 14 00    	nop       
Disassembly of section .ivt._OC14Interrupt:

00000124 <.ivt._OC14Interrupt>:
 124:	1c 14 00    	nop       
Disassembly of section .ivt._OC15Interrupt:

00000128 <.ivt._OC15Interrupt>:
 128:	1c 14 00    	nop       
Disassembly of section .ivt._OC16Interrupt:

0000012c <.ivt._OC16Interrupt>:
 12c:	1c 14 00    	nop       
Disassembly of section .ivt._OC1Interrupt:

00000018 <.ivt._OC1Interrupt>:
  18:	1c 14 00    	nop       
Disassembly of section .ivt._OC2Interrupt:

00000020 <.ivt._OC2Interrupt>:
  20:	1c 14 00    	nop       
Disassembly of section .ivt._OC3Interrupt:

00000046 <.ivt._OC3Interrupt>:
  46:	1c 14 00    	nop       
Disassembly of section .ivt._OC4Interrupt:

00000048 <.ivt._OC4Interrupt>:
  48:	1c 14 00    	nop       
Disassembly of section .ivt._OC5Interrupt:

00000066 <.ivt._OC5Interrupt>:
  66:	1c 14 00    	nop       
Disassembly of section .ivt._OC6Interrupt:

00000068 <.ivt._OC6Interrupt>:
  68:	1c 14 00    	nop       
Disassembly of section .ivt._OC7Interrupt:

0000006a <.ivt._OC7Interrupt>:
  6a:	1c 14 00    	nop       
Disassembly of section .ivt._OC8Interrupt:

0000006c <.ivt._OC8Interrupt>:
  6c:	1c 14 00    	nop       
Disassembly of section .ivt._OC9Interrupt:

000000cc <.ivt._OC9Interrupt>:
  cc:	1c 14 00    	nop       
Disassembly of section .ivt._OscillatorFail:

00000004 <.ivt._OscillatorFail>:
   4:	1c 14 00    	nop       
Disassembly of section .ivt._PMPInterrupt:

0000006e <.ivt._PMPInterrupt>:
  6e:	1c 14 00    	nop       
Disassembly of section .ivt._PWM1Interrupt:

000000d0 <.ivt._PWM1Interrupt>:
  d0:	1c 14 00    	nop       
Disassembly of section .ivt._PWM2Interrupt:

000000d2 <.ivt._PWM2Interrupt>:
  d2:	1c 14 00    	nop       
Disassembly of section .ivt._PWM3Interrupt:

000000d4 <.ivt._PWM3Interrupt>:
  d4:	1c 14 00    	nop       
Disassembly of section .ivt._PWM4Interrupt:

000000d6 <.ivt._PWM4Interrupt>:
  d6:	1c 14 00    	nop       
Disassembly of section .ivt._PWM5Interrupt:

000000d8 <.ivt._PWM5Interrupt>:
  d8:	1c 14 00    	nop       
Disassembly of section .ivt._PWM6Interrupt:

000000da <.ivt._PWM6Interrupt>:
  da:	1c 14 00    	nop       
Disassembly of section .ivt._PWMSecSpEventMatchInterrupt:

000000a6 <.ivt._PWMSecSpEventMatchInterrupt>:
  a6:	1c 14 00    	nop       
Disassembly of section .ivt._PWMSpEventMatchInterrupt:

00000086 <.ivt._PWMSpEventMatchInterrupt>:
  86:	1c 14 00    	nop       
Disassembly of section .ivt._QEI1Interrupt:

00000088 <.ivt._QEI1Interrupt>:
  88:	1c 14 00    	nop       
Disassembly of section .ivt._QEI2Interrupt:

000000aa <.ivt._QEI2Interrupt>:
  aa:	1c 14 00    	nop       
Disassembly of section .ivt._RTCCInterrupt:

00000090 <.ivt._RTCCInterrupt>:
  90:	1c 14 00    	nop       
Disassembly of section .ivt._ReservedTrap7:

00000012 <.ivt._ReservedTrap7>:
  12:	1c 14 00    	nop       
Disassembly of section .ivt._SI2C1Interrupt:

00000034 <.ivt._SI2C1Interrupt>:
  34:	1c 14 00    	nop       
Disassembly of section .ivt._SI2C2Interrupt:

00000076 <.ivt._SI2C2Interrupt>:
  76:	1c 14 00    	nop       
Disassembly of section .ivt._SPI1ErrInterrupt:

00000026 <.ivt._SPI1ErrInterrupt>:
  26:	1c 14 00    	nop       
Disassembly of section .ivt._SPI2ErrInterrupt:

00000054 <.ivt._SPI2ErrInterrupt>:
  54:	1c 14 00    	nop       
Disassembly of section .ivt._SPI2Interrupt:

00000056 <.ivt._SPI2Interrupt>:
  56:	1c 14 00    	nop       
Disassembly of section .ivt._SPI3ErrInterrupt:

000000c8 <.ivt._SPI3ErrInterrupt>:
  c8:	1c 14 00    	nop       
Disassembly of section .ivt._SPI3Interrupt:

000000ca <.ivt._SPI3Interrupt>:
  ca:	1c 14 00    	nop       
Disassembly of section .ivt._SPI4ErrInterrupt:

00000108 <.ivt._SPI4ErrInterrupt>:
 108:	1c 14 00    	nop       
Disassembly of section .ivt._SPI4Interrupt:

0000010a <.ivt._SPI4Interrupt>:
 10a:	1c 14 00    	nop       
Disassembly of section .ivt._SoftTrapError:

00000010 <.ivt._SoftTrapError>:
  10:	1c 14 00    	nop       
Disassembly of section .ivt._StackError:

0000000a <.ivt._StackError>:
   a:	1c 14 00    	nop       
Disassembly of section .ivt._T1Interrupt:

0000001a <.ivt._T1Interrupt>:
  1a:	1c 14 00    	nop       
Disassembly of section .ivt._T3Interrupt:

00000024 <.ivt._T3Interrupt>:
  24:	1c 14 00    	nop       
Disassembly of section .ivt._T4Interrupt:

0000004a <.ivt._T4Interrupt>:
  4a:	1c 14 00    	nop       
Disassembly of section .ivt._T5Interrupt:

0000004c <.ivt._T5Interrupt>:
  4c:	1c 14 00    	nop       
Disassembly of section .ivt._T6Interrupt:

00000072 <.ivt._T6Interrupt>:
  72:	1c 14 00    	nop       
Disassembly of section .ivt._T7Interrupt:

00000074 <.ivt._T7Interrupt>:
  74:	1c 14 00    	nop       
Disassembly of section .ivt._T8Interrupt:

0000007a <.ivt._T8Interrupt>:
  7a:	1c 14 00    	nop       
Disassembly of section .ivt._T9Interrupt:

0000007c <.ivt._T9Interrupt>:
  7c:	1c 14 00    	nop       
Disassembly of section .ivt._U1ErrInterrupt:

00000096 <.ivt._U1ErrInterrupt>:
  96:	1c 14 00    	nop       
Disassembly of section .ivt._U2ErrInterrupt:

00000098 <.ivt._U2ErrInterrupt>:
  98:	1c 14 00    	nop       
Disassembly of section .ivt._U2RXInterrupt:

00000050 <.ivt._U2RXInterrupt>:
  50:	1c 14 00    	nop       
Disassembly of section .ivt._U2TXInterrupt:

00000052 <.ivt._U2TXInterrupt>:
  52:	1c 14 00    	nop       
Disassembly of section .ivt._U3ErrInterrupt:

000000b6 <.ivt._U3ErrInterrupt>:
  b6:	1c 14 00    	nop       
Disassembly of section .ivt._U3RXInterrupt:

000000b8 <.ivt._U3RXInterrupt>:
  b8:	1c 14 00    	nop       
Disassembly of section .ivt._U3TXInterrupt:

000000ba <.ivt._U3TXInterrupt>:
  ba:	1c 14 00    	nop       
Disassembly of section .ivt._U4ErrInterrupt:

000000c2 <.ivt._U4ErrInterrupt>:
  c2:	1c 14 00    	nop       
Disassembly of section .ivt._USB1Interrupt:

000000c0 <.ivt._USB1Interrupt>:
  c0:	1c 14 00    	nop       
Disassembly of section .reset:

00000000 <.reset>:
   0:	00 02 04    	goto      0x200 <__reset>
   2:	00 00 00 
Disassembly of section .text:

00000200 <__reset>:
     200:	8f 4a 24    	mov.w     #0x44a8, w15
     202:	0e ff 27    	mov.w     #0x7ff0, w14
     204:	0e 01 88    	mov.w     w14, 0x20
     206:	00 00 00    	nop       
     208:	00 00 20    	mov.w     #0x0, w0
     20a:	00 00 e0    	cp0.w     w0
     20c:	02 00 32    	bra       Z, 0x212 <CORCON_RESET>
     20e:	00 01 20    	mov.w     #0x10, w0
     210:	20 02 88    	mov.w     w0, 0x44

00000212 <CORCON_RESET>:
     212:	0c 00 07    	rcall     0x22c <__psv_init>
     214:	e0 5b 20    	mov.w     #0x5be, w0
     216:	11 00 20    	mov.w     #0x1, w1
     218:	0f 00 07    	rcall     0x238 <__data_init> <__data_init_extended>
     21a:	00 00 20    	mov.w     #0x0, w0
     21c:	00 00 e0    	cp0.w     w0
     21e:	02 00 32    	bra       Z, 0x224 <L11>
     220:	00 00 02    	call      0x0 <__reset-0x200>
     222:	00 00 00 

00000224 <L11>:
     224:	d6 06 02    	call      0x6d6 <_main>
     226:	00 00 00 
     228:	00 40 da    	.pword 0xda4000
     22a:	00 00 fe    	reset     

0000022c <__psv_init>:
     22c:	00 de 20    	mov.w     #0xde0, w0
     22e:	00 00 e0    	cp0.w     w0
     230:	02 00 32    	bra       Z, 0x236 <L12>
     232:	00 20 20    	mov.w     #0x200, w0
     234:	90 01 88    	mov.w     w0, 0x32

00000236 <L12>:
     236:	00 00 06    	return    

00000238 <__data_init>:
     238:	a1 02 88    	mov.w     w1, 0x54
     23a:	80 00 78    	mov.w     w0, w1
     23c:	00 00 eb    	clr.w     w0
     23e:	1a 00 37    	bra       0x274 <L41>

00000240 <L11>:
     240:	e2 80 40    	add.w     w1, #0x2, w1
     242:	54 a0 b4    	addc.w    0x54
     244:	91 01 ba    	tblrdl.w  [w1], w3
     246:	e2 80 40    	add.w     w1, #0x2, w1
     248:	54 a0 b4    	addc.w    0x54
     24a:	91 02 ba    	tblrdl.w  [w1], w5
     24c:	e2 80 40    	add.w     w1, #0x2, w1
     24e:	54 a0 b4    	addc.w    0x54
     250:	00 02 eb    	clr.w     w4
     252:	47 2b de    	lsr.w     w5, #0x7, w6
     254:	f5 07 b2    	and.w     #0x7f, w5
     256:	a6 01 88    	mov.w     w6, 0x34
     258:	60 2c e1    	.pword 0xe12c60
     25a:	08 00 3a    	bra       NZ, 0x26c <L21>

0000025c <L91>:
     25c:	00 49 eb    	clr.b     [w2]
     25e:	02 01 e8    	inc.w     w2, w2
     260:	02 00 39    	bra       NC, 0x266 <L81>
     262:	34 20 ec    	inc.w     0x34
     264:	02 f0 a0    	bset.w    w2, #0xf

00000266 <L81>:
     266:	83 01 e9    	dec.w     w3, w3
     268:	f9 ff 3e    	bra       GTU, 0x25c <L91>
     26a:	04 00 37    	bra       0x274 <L41>

0000026c <L21>:
     26c:	61 28 e1    	.pword 0xe12861
     26e:	01 00 32    	bra       Z, 0x272 <L31>
     270:	00 82 eb    	setm.w    w4

00000272 <L31>:
     272:	0b 00 07    	rcall     0x28a <L13> <__memcpyd3extended>

00000274 <L41>:
     274:	11 c3 ba    	tblrdh.b  [w1], w6
     276:	11 01 ba    	tblrdl.w  [w1], w2
     278:	06 04 e0    	cp0.b     w6
     27a:	03 00 3a    	bra       NZ, 0x282 <L12>
     27c:	02 00 e0    	cp0.w     w2
     27e:	e0 ff 3a    	bra       NZ, 0x240 <L11>
     280:	00 00 06    	return    

00000282 <L12>:
     282:	f6 07 b2    	and.w     #0x7f, w6
     284:	a6 02 88    	mov.w     w6, 0x54
     286:	82 00 78    	mov.w     w2, w1
     288:	f5 ff 37    	bra       0x274 <L41>

0000028a <L13>:
     28a:	04 d0 a3    	btst.c    w4, #0xd
     28c:	e2 0f 49    	addc.w    w2, #0x2, [w15]
     28e:	1c 00 39    	bra       NC, 0x2c8 <L22>
     290:	81 02 78    	mov.w     w1, w5
     292:	35 49 ba    	tblrdl.b  [w5++], [w2]
     294:	02 01 e8    	inc.w     w2, w2
     296:	02 00 39    	bra       NC, 0x29c <L32>
     298:	34 20 ec    	inc.w     0x34
     29a:	02 f0 a0    	bset.w    w2, #0xf

0000029c <L32>:
     29c:	83 01 e9    	dec.w     w3, w3
     29e:	0f 00 32    	bra       Z, 0x2be <L42>
     2a0:	25 49 ba    	tblrdl.b  [w5--], [w2]
     2a2:	02 01 e8    	inc.w     w2, w2
     2a4:	02 00 39    	bra       NC, 0x2aa <L33>
     2a6:	34 20 ec    	inc.w     0x34
     2a8:	02 f0 a0    	bset.w    w2, #0xf

000002aa <L33>:
     2aa:	83 01 e9    	dec.w     w3, w3
     2ac:	08 00 32    	bra       Z, 0x2be <L42>
     2ae:	04 00 e0    	cp0.w     w4
     2b0:	06 00 32    	bra       Z, 0x2be <L42>
     2b2:	15 c9 ba    	tblrdh.b  [w5], [w2]
     2b4:	02 01 e8    	inc.w     w2, w2
     2b6:	02 00 39    	bra       NC, 0x2bc <L34>
     2b8:	34 20 ec    	inc.w     0x34
     2ba:	02 f0 a0    	bset.w    w2, #0xf

000002bc <L34>:
     2bc:	83 01 e9    	dec.w     w3, w3

000002be <L42>:
     2be:	81 80 e8    	inc2.w    w1, w1
     2c0:	54 a0 b4    	addc.w    0x54
     2c2:	03 00 e0    	cp0.w     w3
     2c4:	e2 ff 3a    	bra       NZ, 0x28a <L13> <__memcpyd3extended>
     2c6:	00 00 06    	return    

000002c8 <L22>:
     2c8:	91 02 ba    	tblrdl.w  [w1], w5
     2ca:	05 59 78    	mov.b     w5, [w2++]
     2cc:	83 01 e9    	dec.w     w3, w3
     2ce:	f7 ff 32    	bra       Z, 0x2be <L42>
     2d0:	c8 2a de    	lsr.w     w5, #0x8, w5
     2d2:	05 59 78    	mov.b     w5, [w2++]
     2d4:	83 01 e9    	dec.w     w3, w3
     2d6:	f3 ff 32    	bra       Z, 0x2be <L42>
     2d8:	04 00 e0    	cp0.w     w4
     2da:	f1 ff 32    	bra       Z, 0x2be <L42>
     2dc:	11 d9 ba    	tblrdh.b  [w1], [w2++]
     2de:	ee ff 37    	bra       0x2bc <L34>

000002e0 <.handle>:
     2e0:	be ec 04    	goto      0xecbe <_msg_SYNC1>
     2e2:	00 00 00 
     2e4:	d4 ec 04    	goto      0xecd4 <_msg_SYNC2>
     2e6:	00 00 00 
     2e8:	b2 ec 04    	goto      0xecb2 <_msg_B3>
     2ea:	00 00 00 
     2ec:	e6 ec 04    	goto      0xece6 <_msg_CLASS>
     2ee:	00 00 00 
     2f0:	fa ec 04    	goto      0xecfa <_msg_ID>
     2f2:	00 00 00 
     2f4:	0e ed 04    	goto      0xed0e <_msg_PL1>
     2f6:	00 00 00 
     2f8:	c8 ed 04    	goto      0xedc8 <_msg_POSLLH>
     2fa:	00 00 00 
     2fc:	f8 ed 04    	goto      0xedf8 <_msg_DOP>
     2fe:	00 00 00 
     300:	28 ee 04    	goto      0xee28 <_msg_SOL>
     302:	00 00 00 
     304:	58 ee 04    	goto      0xee58 <_msg_VELNED>
     306:	00 00 00 
     308:	88 ee 04    	goto      0xee88 <_msg_BODYRATES>
     30a:	00 00 00 
     30c:	e0 ee 04    	goto      0xeee0 <_msg_MSGU>
     30e:	00 00 00 
     310:	b8 ee 04    	goto      0xeeb8 <_msg_ACK_CLASS>
     312:	00 00 00 
     314:	d6 ef 04    	goto      0xefd6 <_msg_CS1>
     316:	00 00 00 
     318:	cc ee 04    	goto      0xeecc <_msg_ACK_ID>
     31a:	00 00 00 
     31c:	a6 ef 04    	goto      0xefa6 <_udb_background_callback_triggered>
     31e:	00 00 00 

00000320 <__T2Interrupt>:
_FAS( APLK_OFF ) ;

/* Scheduler */
void __attribute__((__interrupt__,__auto_psv__)) _T2Interrupt(void)
{
     320:	36 00 f8    	push      0x36
     322:	80 9f be    	mov.d     w0, [w15++]
     324:	82 9f be    	mov.d     w2, [w15++]
     326:	84 9f be    	mov.d     w4, [w15++]
     328:	86 9f be    	mov.d     w6, [w15++]
     32a:	32 00 f8    	push      0x32
     32c:	34 00 f8    	push      0x34
     32e:	10 00 20    	mov.w     #0x1, w0
     330:	a0 01 88    	mov.w     w0, 0x34
     332:	00 20 20    	mov.w     #0x200, w0
     334:	90 01 88    	mov.w     w0, 0x32
     336:	00 00 00    	nop       
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
     338:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
     33a:	13 e1 a8    	bset.b    0x113, #0x7

0000033c <.LBB2>:

  {
    extern volatile uint_T BusyFlagRecursion __attribute__ ((near)) ;
    struct {
      unsigned int Flags0 : 1;
      unsigned int Flags1 : 1;
      unsigned int Flags2 : 1;
      unsigned int Flags3 : 1;
      unsigned int Flags4 : 1;
      unsigned int Flags5 : 1;
      unsigned int Flags6 : 1;
      unsigned int Flags7 : 1;
      unsigned int Flags8 : 1;
      unsigned int Flags9 : 1;
      unsigned int Flags10 : 1;
    } static volatile Overrun;

    struct {
      unsigned int Flags0 : 1;
      unsigned int Flags1 : 1;
      unsigned int Flags2 : 1;
      unsigned int Flags3 : 1;
      unsigned int Flags4 : 1;
      unsigned int Flags5 : 1;
      unsigned int Flags6 : 1;
      unsigned int Flags7 : 1;
      unsigned int Flags8 : 1;
      unsigned int Flags9 : 1;
      unsigned int Flags10 : 1;
    } static volatile event;

    static int_T taskCounter[11] = { 0, 0, 0, 0, 18, 16, 14, 12, 0, 0, 0 };

    _T2IF = 0;                         /* Re-enable interrupt */
     33c:	00 e8 a9    	bclr.b    0x800, #0x7

    /* Set busy flag */
    __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic increment of BusyFlagRecursion */
     33e:	52 30 ec    	inc.w     0x1052
    LATAbits.LATA6 = 1;
     340:	04 ce a8    	bset.b    0xe04, #0x6

    /* Check subrate overrun, set rates that need to run this time step*/
    if (taskCounter[1] == 0) {         /* task dropped on overload */
     342:	e0 23 82    	mov.w     0x447c, w0
     344:	00 00 e0    	cp0.w     w0
     346:	09 00 3a    	bra       NZ, 0x35a <.L2>
      event.Flags1 = 1U;
     348:	90 24 82    	mov.w     0x4492, w0
     34a:	00 10 a0    	bset.w    w0, #0x1
     34c:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags1) {
     34e:	a0 24 82    	mov.w     0x4494, w0
     350:	00 18 a3    	btst.z    w0, #0x1
     352:	03 00 32    	bra       Z, 0x35a <.L2>
        MCHP_MCU_Overload.b.task1 = 1U;/* Set overload bit for tid 1 */
     354:	80 24 82    	mov.w     0x4490, w0
     356:	00 10 a0    	bset.w    w0, #0x1
     358:	80 24 8a    	mov.w     w0, 0x4490

0000035a <.L2>:
      }
    }

    if (taskCounter[2] == 0) {         /* task dropped on overload */
     35a:	f0 23 82    	mov.w     0x447e, w0
     35c:	00 00 e0    	cp0.w     w0
     35e:	09 00 3a    	bra       NZ, 0x372 <.L3>
      event.Flags2 = 1U;
     360:	90 24 82    	mov.w     0x4492, w0
     362:	00 20 a0    	bset.w    w0, #0x2
     364:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags2) {
     366:	a0 24 82    	mov.w     0x4494, w0
     368:	00 28 a3    	btst.z    w0, #0x2
     36a:	03 00 32    	bra       Z, 0x372 <.L3>
        MCHP_MCU_Overload.b.task2 = 1U;/* Set overload bit for tid 2 */
     36c:	80 24 82    	mov.w     0x4490, w0
     36e:	00 20 a0    	bset.w    w0, #0x2
     370:	80 24 8a    	mov.w     w0, 0x4490

00000372 <.L3>:
      }
    }

    if (taskCounter[3] == 0) {         /* task dropped on overload */
     372:	00 24 82    	mov.w     0x4480, w0
     374:	00 00 e0    	cp0.w     w0
     376:	09 00 3a    	bra       NZ, 0x38a <.L4>
      event.Flags3 = 1U;
     378:	90 24 82    	mov.w     0x4492, w0
     37a:	00 30 a0    	bset.w    w0, #0x3
     37c:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags3) {
     37e:	a0 24 82    	mov.w     0x4494, w0
     380:	00 38 a3    	btst.z    w0, #0x3
     382:	03 00 32    	bra       Z, 0x38a <.L4>
        MCHP_MCU_Overload.b.task3 = 1U;/* Set overload bit for tid 3 */
     384:	80 24 82    	mov.w     0x4490, w0
     386:	00 30 a0    	bset.w    w0, #0x3
     388:	80 24 8a    	mov.w     w0, 0x4490

0000038a <.L4>:
      }
    }

    if (taskCounter[4] == 0) {         /* task dropped on overload */
     38a:	10 24 82    	mov.w     0x4482, w0
     38c:	00 00 e0    	cp0.w     w0
     38e:	09 00 3a    	bra       NZ, 0x3a2 <.L5>
      event.Flags4 = 1U;
     390:	90 24 82    	mov.w     0x4492, w0
     392:	00 40 a0    	bset.w    w0, #0x4
     394:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags4) {
     396:	a0 24 82    	mov.w     0x4494, w0
     398:	00 48 a3    	btst.z    w0, #0x4
     39a:	03 00 32    	bra       Z, 0x3a2 <.L5>
        MCHP_MCU_Overload.b.task4 = 1U;/* Set overload bit for tid 4 */
     39c:	80 24 82    	mov.w     0x4490, w0
     39e:	00 40 a0    	bset.w    w0, #0x4
     3a0:	80 24 8a    	mov.w     w0, 0x4490

000003a2 <.L5>:
      }
    }

    if (taskCounter[5] == 0) {         /* task dropped on overload */
     3a2:	20 24 82    	mov.w     0x4484, w0
     3a4:	00 00 e0    	cp0.w     w0
     3a6:	09 00 3a    	bra       NZ, 0x3ba <.L6>
      event.Flags5 = 1U;
     3a8:	90 24 82    	mov.w     0x4492, w0
     3aa:	00 50 a0    	bset.w    w0, #0x5
     3ac:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags5) {
     3ae:	a0 24 82    	mov.w     0x4494, w0
     3b0:	00 58 a3    	btst.z    w0, #0x5
     3b2:	03 00 32    	bra       Z, 0x3ba <.L6>
        MCHP_MCU_Overload.b.task5 = 1U;/* Set overload bit for tid 5 */
     3b4:	80 24 82    	mov.w     0x4490, w0
     3b6:	00 50 a0    	bset.w    w0, #0x5
     3b8:	80 24 8a    	mov.w     w0, 0x4490

000003ba <.L6>:
      }
    }

    if (taskCounter[6] == 0) {         /* task dropped on overload */
     3ba:	30 24 82    	mov.w     0x4486, w0
     3bc:	00 00 e0    	cp0.w     w0
     3be:	09 00 3a    	bra       NZ, 0x3d2 <.L7>
      event.Flags6 = 1U;
     3c0:	90 24 82    	mov.w     0x4492, w0
     3c2:	00 60 a0    	bset.w    w0, #0x6
     3c4:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags6) {
     3c6:	a0 24 82    	mov.w     0x4494, w0
     3c8:	00 68 a3    	btst.z    w0, #0x6
     3ca:	03 00 32    	bra       Z, 0x3d2 <.L7>
        MCHP_MCU_Overload.b.task6 = 1U;/* Set overload bit for tid 6 */
     3cc:	80 24 82    	mov.w     0x4490, w0
     3ce:	00 60 a0    	bset.w    w0, #0x6
     3d0:	80 24 8a    	mov.w     w0, 0x4490

000003d2 <.L7>:
      }
    }

    if (taskCounter[7] == 0) {         /* task dropped on overload */
     3d2:	40 24 82    	mov.w     0x4488, w0
     3d4:	00 00 e0    	cp0.w     w0
     3d6:	09 00 3a    	bra       NZ, 0x3ea <.L8>
      event.Flags7 = 1U;
     3d8:	90 24 82    	mov.w     0x4492, w0
     3da:	00 70 a0    	bset.w    w0, #0x7
     3dc:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags7) {
     3de:	a0 24 82    	mov.w     0x4494, w0
     3e0:	00 78 a3    	btst.z    w0, #0x7
     3e2:	03 00 32    	bra       Z, 0x3ea <.L8>
        MCHP_MCU_Overload.b.task7 = 1U;/* Set overload bit for tid 7 */
     3e4:	80 24 82    	mov.w     0x4490, w0
     3e6:	00 70 a0    	bset.w    w0, #0x7
     3e8:	80 24 8a    	mov.w     w0, 0x4490

000003ea <.L8>:
      }
    }

    if (taskCounter[8] == 0) {         /* task dropped on overload */
     3ea:	50 24 82    	mov.w     0x448a, w0
     3ec:	00 00 e0    	cp0.w     w0
     3ee:	09 00 3a    	bra       NZ, 0x402 <.L9>
      event.Flags8 = 1U;
     3f0:	90 24 82    	mov.w     0x4492, w0
     3f2:	00 80 a0    	bset.w    w0, #0x8
     3f4:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags8) {
     3f6:	a0 24 82    	mov.w     0x4494, w0
     3f8:	00 88 a3    	btst.z    w0, #0x8
     3fa:	03 00 32    	bra       Z, 0x402 <.L9>
        MCHP_MCU_Overload.b.task8 = 1U;/* Set overload bit for tid 8 */
     3fc:	80 24 82    	mov.w     0x4490, w0
     3fe:	00 80 a0    	bset.w    w0, #0x8
     400:	80 24 8a    	mov.w     w0, 0x4490

00000402 <.L9>:
      }
    }

    if (taskCounter[9] == 0) {         /* task dropped on overload */
     402:	60 24 82    	mov.w     0x448c, w0
     404:	00 00 e0    	cp0.w     w0
     406:	09 00 3a    	bra       NZ, 0x41a <.L10>
      event.Flags9 = 1U;
     408:	90 24 82    	mov.w     0x4492, w0
     40a:	00 90 a0    	bset.w    w0, #0x9
     40c:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags9) {
     40e:	a0 24 82    	mov.w     0x4494, w0
     410:	00 98 a3    	btst.z    w0, #0x9
     412:	03 00 32    	bra       Z, 0x41a <.L10>
        MCHP_MCU_Overload.b.task9 = 1U;/* Set overload bit for tid 9 */
     414:	80 24 82    	mov.w     0x4490, w0
     416:	00 90 a0    	bset.w    w0, #0x9
     418:	80 24 8a    	mov.w     w0, 0x4490

0000041a <.L10>:
      }
    }

    if (taskCounter[10] == 0) {        /* task dropped on overload */
     41a:	70 24 82    	mov.w     0x448e, w0
     41c:	00 00 e0    	cp0.w     w0
     41e:	09 00 3a    	bra       NZ, 0x432 <.L11>
      event.Flags10 = 1U;
     420:	90 24 82    	mov.w     0x4492, w0
     422:	00 a0 a0    	bset.w    w0, #0xa
     424:	90 24 8a    	mov.w     w0, 0x4492
      if (Overrun.Flags10) {
     426:	a0 24 82    	mov.w     0x4494, w0
     428:	00 a8 a3    	btst.z    w0, #0xa
     42a:	03 00 32    	bra       Z, 0x432 <.L11>
        MCHP_MCU_Overload.b.task10 = 1U;/* Set overload bit for tid 10 */
     42c:	80 24 82    	mov.w     0x4490, w0
     42e:	00 a0 a0    	bset.w    w0, #0xa
     430:	80 24 8a    	mov.w     w0, 0x4490

00000432 <.L11>:
      }
    }

    /* Update task internal counters */
    taskCounter[1]++;
     432:	c1 47 24    	mov.w     #0x447c, w1
     434:	11 00 e8    	inc.w     [w1], w0
     436:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[1] == 5) {
     438:	e5 0f 50    	sub.w     w0, #0x5, [w15]
     43a:	02 00 3a    	bra       NZ, 0x440 <.L12>
      taskCounter[1]= 0;
     43c:	01 00 78    	mov.w     w1, w0
     43e:	00 08 eb    	clr.w     [w0]

00000440 <.L12>:
    }

    taskCounter[2]++;
     440:	e1 47 24    	mov.w     #0x447e, w1
     442:	11 00 e8    	inc.w     [w1], w0
     444:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[2] == 10) {
     446:	ea 0f 50    	sub.w     w0, #0xa, [w15]
     448:	02 00 3a    	bra       NZ, 0x44e <.L13>
      taskCounter[2]= 0;
     44a:	01 00 78    	mov.w     w1, w0
     44c:	00 08 eb    	clr.w     [w0]

0000044e <.L13>:
    }

    taskCounter[3]++;
     44e:	01 48 24    	mov.w     #0x4480, w1
     450:	11 00 e8    	inc.w     [w1], w0
     452:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[3] == 20) {
     454:	f4 0f 50    	sub.w     w0, #0x14, [w15]
     456:	02 00 3a    	bra       NZ, 0x45c <.L14>
      taskCounter[3]= 0;
     458:	01 00 78    	mov.w     w1, w0
     45a:	00 08 eb    	clr.w     [w0]

0000045c <.L14>:
    }

    taskCounter[4]++;
     45c:	21 48 24    	mov.w     #0x4482, w1
     45e:	11 00 e8    	inc.w     [w1], w0
     460:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[4] == 20) {
     462:	f4 0f 50    	sub.w     w0, #0x14, [w15]
     464:	02 00 3a    	bra       NZ, 0x46a <.L15>
      taskCounter[4]= 0;
     466:	01 00 78    	mov.w     w1, w0
     468:	00 08 eb    	clr.w     [w0]

0000046a <.L15>:
    }

    taskCounter[5]++;
     46a:	41 48 24    	mov.w     #0x4484, w1
     46c:	11 00 e8    	inc.w     [w1], w0
     46e:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[5] == 20) {
     470:	f4 0f 50    	sub.w     w0, #0x14, [w15]
     472:	02 00 3a    	bra       NZ, 0x478 <.L16>
      taskCounter[5]= 0;
     474:	01 00 78    	mov.w     w1, w0
     476:	00 08 eb    	clr.w     [w0]

00000478 <.L16>:
    }

    taskCounter[6]++;
     478:	61 48 24    	mov.w     #0x4486, w1
     47a:	11 00 e8    	inc.w     [w1], w0
     47c:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[6] == 20) {
     47e:	f4 0f 50    	sub.w     w0, #0x14, [w15]
     480:	02 00 3a    	bra       NZ, 0x486 <.L17> <.Lframe0>
      taskCounter[6]= 0;
     482:	01 00 78    	mov.w     w1, w0
     484:	00 08 eb    	clr.w     [w0]

00000486 <.L17>:
    }

    taskCounter[7]++;
     486:	81 48 24    	mov.w     #0x4488, w1
     488:	11 00 e8    	inc.w     [w1], w0
     48a:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[7] == 20) {
     48c:	f4 0f 50    	sub.w     w0, #0x14, [w15]
     48e:	02 00 3a    	bra       NZ, 0x494 <.L18>
      taskCounter[7]= 0;
     490:	01 00 78    	mov.w     w1, w0
     492:	00 08 eb    	clr.w     [w0]

00000494 <.L18>:
    }

    taskCounter[8]++;
     494:	a1 48 24    	mov.w     #0x448a, w1
     496:	11 00 e8    	inc.w     [w1], w0
     498:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[8] == 25) {
     49a:	f9 0f 50    	sub.w     w0, #0x19, [w15]
     49c:	02 00 3a    	bra       NZ, 0x4a2 <.L19>
      taskCounter[8]= 0;
     49e:	01 00 78    	mov.w     w1, w0
     4a0:	00 08 eb    	clr.w     [w0]

000004a2 <.L19>:
    }

    taskCounter[9]++;
     4a2:	c1 48 24    	mov.w     #0x448c, w1
     4a4:	11 00 e8    	inc.w     [w1], w0
     4a6:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[9] == 50) {
     4a8:	21 03 20    	mov.w     #0x32, w1
     4aa:	81 0f 50    	sub.w     w0, w1, [w15]
     4ac:	02 00 3a    	bra       NZ, 0x4b2 <.L20>
      taskCounter[9]= 0;
     4ae:	c0 48 24    	mov.w     #0x448c, w0
     4b0:	00 08 eb    	clr.w     [w0]

000004b2 <.L20>:
    }

    taskCounter[10]++;
     4b2:	e1 48 24    	mov.w     #0x448e, w1
     4b4:	11 00 e8    	inc.w     [w1], w0
     4b6:	80 08 78    	mov.w     w0, [w1]
    if (taskCounter[10] == 100) {
     4b8:	41 06 20    	mov.w     #0x64, w1
     4ba:	81 0f 50    	sub.w     w0, w1, [w15]
     4bc:	02 00 3a    	bra       NZ, 0x4c2 <.L21> <.LBB3>
      taskCounter[10]= 0;
     4be:	e0 48 24    	mov.w     #0x448e, w0
     4c0:	00 08 eb    	clr.w     [w0]

000004c2 <.L21>:
    }

    /* Step the model for base rate */
    /* Start profiling task 0 */
    {
      uint16_T Tmp_TMR;
      Tmp_TMR = TMR3;
     4c2:	50 08 80    	mov.w     0x10a, w0
      MCHP_MCULoadResult[0] = Tmp_TMR - MCHP_MCULoadPreviousTimerValue[0];
     4c4:	b1 82 80    	mov.w     0x1056, w1
     4c6:	81 00 50    	sub.w     w0, w1, w1
     4c8:	a1 82 88    	mov.w     w1, 0x1054

000004ca <.L0>:
      MCHP_MCULoadPreviousTimerValue[0] = Tmp_TMR;
     4ca:	b0 82 88    	mov.w     w0, 0x1056

000004cc <.L0>:
    }

    AUAV_V3_TestSensors_step0();
     4cc:	ce 50 02    	call      0x50ce <_AUAV_V3_TestSensors_step0>
     4ce:	00 00 00 

    /* Get model outputs here */
    _T2IF = 0;                         /* Re-enable interrupt */
     4d0:	00 e8 a9    	bclr.b    0x800, #0x7

    /* Stop profiling task 0 */
    if (_T2IF ) {
     4d2:	00 e8 ab    	btst.b    0x800, #0x7
     4d4:	06 00 32    	bra       Z, 0x4e2 <.L22>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     4d6:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     4d8:	50 30 ed    	dec.w     0x1050
      MCHP_MCU_Overload.b.task0 = 1U;  /* Set overload bit for tid 0 */
     4da:	80 24 82    	mov.w     0x4490, w0
     4dc:	00 00 a0    	bset.w    w0, #0x0
     4de:	80 24 8a    	mov.w     w0, 0x4490
      return;                          /* Will re-enter into the interrupt */
     4e0:	f2 00 37    	bra       0x6c6 <.L1>

000004e2 <.L22>:
    }

    /* Re-Enable Interrupt. IPL value is 2 at this point */
    _IPL0 = 1;                         /* Set IPL to 1 (interrupt priority is 2) */
     4e2:	42 a0 a8    	bset.b    0x42, #0x5
    _IPL1 = 0;
     4e4:	42 c0 a9    	bclr.b    0x42, #0x6

    /* Step the model for any subrate */
    /* Handle Task 1 */
    if (Overrun.Flags1) {
     4e6:	a0 24 82    	mov.w     0x4494, w0
     4e8:	00 18 a3    	btst.z    w0, #0x1
     4ea:	03 00 32    	bra       Z, 0x4f2 <.L24> <.Ldebug_abbrev0>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     4ec:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     4ee:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     4f0:	ea 00 37    	bra       0x6c6 <.L1>

000004f2 <.L24>:
    }

    if (event.Flags1) {
     4f2:	90 24 82    	mov.w     0x4492, w0
     4f4:	00 18 a3    	btst.z    w0, #0x1
     4f6:	0e 00 32    	bra       Z, 0x514 <.L25>
      Overrun.Flags1 = 1;
     4f8:	a0 24 82    	mov.w     0x4494, w0
     4fa:	00 10 a0    	bset.w    w0, #0x1
     4fc:	a0 24 8a    	mov.w     w0, 0x4494

000004fe <.L0>:
      do {
        /* Start profiling task 1 */
        event.Flags1 = 0U;
     4fe:	90 24 82    	mov.w     0x4492, w0
     500:	00 10 a1    	bclr.w    w0, #0x1
     502:	90 24 8a    	mov.w     w0, 0x4492

00000504 <.L0>:
        AUAV_V3_TestSensors_step1();
     504:	96 8e 02    	call      0x8e96 <_AUAV_V3_TestSensors_step1>
     506:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 1 */

        /* Stop profiling task 1 */
      } while (event.Flags1);
     508:	90 24 82    	mov.w     0x4492, w0
     50a:	00 18 a3    	btst.z    w0, #0x1
     50c:	f8 ff 3a    	bra       NZ, 0x4fe <.L0> <.L26>

      Overrun.Flags1 = 0U;
     50e:	a0 24 82    	mov.w     0x4494, w0
     510:	00 10 a1    	bclr.w    w0, #0x1
     512:	a0 24 8a    	mov.w     w0, 0x4494

00000514 <.L25>:
    }

    /* Handle Task 2 */
    if (Overrun.Flags2) {
     514:	a0 24 82    	mov.w     0x4494, w0
     516:	00 28 a3    	btst.z    w0, #0x2
     518:	03 00 32    	bra       Z, 0x520 <.L27>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     51a:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     51c:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     51e:	d3 00 37    	bra       0x6c6 <.L1>

00000520 <.L27>:
    }

    if (event.Flags2) {
     520:	90 24 82    	mov.w     0x4492, w0
     522:	00 28 a3    	btst.z    w0, #0x2
     524:	0e 00 32    	bra       Z, 0x542 <.L28>
      Overrun.Flags2 = 1;
     526:	a0 24 82    	mov.w     0x4494, w0
     528:	00 20 a0    	bset.w    w0, #0x2
     52a:	a0 24 8a    	mov.w     w0, 0x4494

0000052c <.L0>:
      do {
        /* Start profiling task 2 */
        event.Flags2 = 0U;
     52c:	90 24 82    	mov.w     0x4492, w0
     52e:	00 20 a1    	bclr.w    w0, #0x2
     530:	90 24 8a    	mov.w     w0, 0x4492

00000532 <.L0>:
        AUAV_V3_TestSensors_step2();
     532:	9c 8e 02    	call      0x8e9c <_AUAV_V3_TestSensors_step2>
     534:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 2 */

        /* Stop profiling task 2 */
      } while (event.Flags2);
     536:	90 24 82    	mov.w     0x4492, w0
     538:	00 28 a3    	btst.z    w0, #0x2
     53a:	f8 ff 3a    	bra       NZ, 0x52c <.L0> <.L29>

      Overrun.Flags2 = 0U;
     53c:	a0 24 82    	mov.w     0x4494, w0
     53e:	00 20 a1    	bclr.w    w0, #0x2
     540:	a0 24 8a    	mov.w     w0, 0x4494

00000542 <.L28>:
    }

    /* Handle Task 3 */
    if (Overrun.Flags3) {
     542:	a0 24 82    	mov.w     0x4494, w0
     544:	00 38 a3    	btst.z    w0, #0x3
     546:	03 00 32    	bra       Z, 0x54e <.L30>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     548:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     54a:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     54c:	bc 00 37    	bra       0x6c6 <.L1>

0000054e <.L30>:
    }

    if (event.Flags3) {
     54e:	90 24 82    	mov.w     0x4492, w0
     550:	00 38 a3    	btst.z    w0, #0x3
     552:	0e 00 32    	bra       Z, 0x570 <.L31> <.LASF54>
      Overrun.Flags3 = 1;
     554:	a0 24 82    	mov.w     0x4494, w0
     556:	00 30 a0    	bset.w    w0, #0x3
     558:	a0 24 8a    	mov.w     w0, 0x4494

0000055a <.L0>:
      do {
        /* Start profiling task 3 */
        event.Flags3 = 0U;
     55a:	90 24 82    	mov.w     0x4492, w0
     55c:	00 30 a1    	bclr.w    w0, #0x3
     55e:	90 24 8a    	mov.w     w0, 0x4492

00000560 <.L0>:
        AUAV_V3_TestSensors_step3();
     560:	a6 8e 02    	call      0x8ea6 <_AUAV_V3_TestSensors_step3>
     562:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 3 */

        /* Stop profiling task 3 */
      } while (event.Flags3);
     564:	90 24 82    	mov.w     0x4492, w0
     566:	00 38 a3    	btst.z    w0, #0x3
     568:	f8 ff 3a    	bra       NZ, 0x55a <.L0> <.L32>

      Overrun.Flags3 = 0U;
     56a:	a0 24 82    	mov.w     0x4494, w0
     56c:	00 30 a1    	bclr.w    w0, #0x3
     56e:	a0 24 8a    	mov.w     w0, 0x4494

00000570 <.L31>:
    }

    /* Handle Task 4 */
    if (Overrun.Flags4) {
     570:	a0 24 82    	mov.w     0x4494, w0
     572:	00 48 a3    	btst.z    w0, #0x4
     574:	03 00 32    	bra       Z, 0x57c <.L33>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     576:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     578:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     57a:	a5 00 37    	bra       0x6c6 <.L1>

0000057c <.L33>:
    }

    if (event.Flags4) {
     57c:	90 24 82    	mov.w     0x4492, w0
     57e:	00 48 a3    	btst.z    w0, #0x4
     580:	0e 00 32    	bra       Z, 0x59e <.L34>
      Overrun.Flags4 = 1;
     582:	a0 24 82    	mov.w     0x4494, w0
     584:	00 40 a0    	bset.w    w0, #0x4
     586:	a0 24 8a    	mov.w     w0, 0x4494

00000588 <.L0>:
      do {
        /* Start profiling task 4 */
        event.Flags4 = 0U;
     588:	90 24 82    	mov.w     0x4492, w0
     58a:	00 40 a1    	bclr.w    w0, #0x4
     58c:	90 24 8a    	mov.w     w0, 0x4492

0000058e <.L0>:
        AUAV_V3_TestSensors_step4();
     58e:	b0 8e 02    	call      0x8eb0 <_AUAV_V3_TestSensors_step4>
     590:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 4 */

        /* Stop profiling task 4 */
      } while (event.Flags4);
     592:	90 24 82    	mov.w     0x4492, w0
     594:	00 48 a3    	btst.z    w0, #0x4
     596:	f8 ff 3a    	bra       NZ, 0x588 <.L0> <.L35>

      Overrun.Flags4 = 0U;
     598:	a0 24 82    	mov.w     0x4494, w0
     59a:	00 40 a1    	bclr.w    w0, #0x4
     59c:	a0 24 8a    	mov.w     w0, 0x4494

0000059e <.L34>:
    }

    /* Handle Task 5 */
    if (Overrun.Flags5) {
     59e:	a0 24 82    	mov.w     0x4494, w0
     5a0:	00 58 a3    	btst.z    w0, #0x5
     5a2:	03 00 32    	bra       Z, 0x5aa <.L36>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     5a4:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     5a6:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     5a8:	8e 00 37    	bra       0x6c6 <.L1>

000005aa <.L36>:
    }

    if (event.Flags5) {
     5aa:	90 24 82    	mov.w     0x4492, w0
     5ac:	00 58 a3    	btst.z    w0, #0x5
     5ae:	0e 00 32    	bra       Z, 0x5cc <.L37>
      Overrun.Flags5 = 1;
     5b0:	a0 24 82    	mov.w     0x4494, w0
     5b2:	00 50 a0    	bset.w    w0, #0x5
     5b4:	a0 24 8a    	mov.w     w0, 0x4494

000005b6 <.L0>:
      do {
        /* Start profiling task 5 */
        event.Flags5 = 0U;
     5b6:	90 24 82    	mov.w     0x4492, w0
     5b8:	00 50 a1    	bclr.w    w0, #0x5
     5ba:	90 24 8a    	mov.w     w0, 0x4492

000005bc <.L0>:
        AUAV_V3_TestSensors_step5();
     5bc:	b6 8e 02    	call      0x8eb6 <_AUAV_V3_TestSensors_step5>
     5be:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 5 */

        /* Stop profiling task 5 */
      } while (event.Flags5);
     5c0:	90 24 82    	mov.w     0x4492, w0
     5c2:	00 58 a3    	btst.z    w0, #0x5
     5c4:	f8 ff 3a    	bra       NZ, 0x5b6 <.L0> <.L38>

      Overrun.Flags5 = 0U;
     5c6:	a0 24 82    	mov.w     0x4494, w0
     5c8:	00 50 a1    	bclr.w    w0, #0x5
     5ca:	a0 24 8a    	mov.w     w0, 0x4494

000005cc <.L37>:
    }

    /* Handle Task 6 */
    if (Overrun.Flags6) {
     5cc:	a0 24 82    	mov.w     0x4494, w0
     5ce:	00 68 a3    	btst.z    w0, #0x6
     5d0:	03 00 32    	bra       Z, 0x5d8 <.L39>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     5d2:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     5d4:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     5d6:	77 00 37    	bra       0x6c6 <.L1>

000005d8 <.L39>:
    }

    if (event.Flags6) {
     5d8:	90 24 82    	mov.w     0x4492, w0
     5da:	00 68 a3    	btst.z    w0, #0x6
     5dc:	0e 00 32    	bra       Z, 0x5fa <.L40>
      Overrun.Flags6 = 1;
     5de:	a0 24 82    	mov.w     0x4494, w0
     5e0:	00 60 a0    	bset.w    w0, #0x6
     5e2:	a0 24 8a    	mov.w     w0, 0x4494

000005e4 <.L0>:
      do {
        /* Start profiling task 6 */
        event.Flags6 = 0U;
     5e4:	90 24 82    	mov.w     0x4492, w0
     5e6:	00 60 a1    	bclr.w    w0, #0x6
     5e8:	90 24 8a    	mov.w     w0, 0x4492

000005ea <.L0>:
        AUAV_V3_TestSensors_step6();
     5ea:	bc 8e 02    	call      0x8ebc <_AUAV_V3_TestSensors_step6>
     5ec:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 6 */

        /* Stop profiling task 6 */
      } while (event.Flags6);
     5ee:	90 24 82    	mov.w     0x4492, w0
     5f0:	00 68 a3    	btst.z    w0, #0x6
     5f2:	f8 ff 3a    	bra       NZ, 0x5e4 <.L0> <.L41>

      Overrun.Flags6 = 0U;
     5f4:	a0 24 82    	mov.w     0x4494, w0
     5f6:	00 60 a1    	bclr.w    w0, #0x6
     5f8:	a0 24 8a    	mov.w     w0, 0x4494

000005fa <.L40>:
    }

    /* Handle Task 7 */
    if (Overrun.Flags7) {
     5fa:	a0 24 82    	mov.w     0x4494, w0
     5fc:	00 78 a3    	btst.z    w0, #0x7
     5fe:	03 00 32    	bra       Z, 0x606 <.L42> <.LASF116>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     600:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     602:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     604:	60 00 37    	bra       0x6c6 <.L1>

00000606 <.L42>:
    }

    if (event.Flags7) {
     606:	90 24 82    	mov.w     0x4492, w0
     608:	00 78 a3    	btst.z    w0, #0x7
     60a:	0e 00 32    	bra       Z, 0x628 <.L43>
      Overrun.Flags7 = 1;
     60c:	a0 24 82    	mov.w     0x4494, w0
     60e:	00 70 a0    	bset.w    w0, #0x7
     610:	a0 24 8a    	mov.w     w0, 0x4494

00000612 <.L0>:
      do {
        /* Start profiling task 7 */
        event.Flags7 = 0U;
     612:	90 24 82    	mov.w     0x4492, w0
     614:	00 70 a1    	bclr.w    w0, #0x7
     616:	90 24 8a    	mov.w     w0, 0x4492

00000618 <.L0>:
        AUAV_V3_TestSensors_step7();
     618:	c2 8e 02    	call      0x8ec2 <_AUAV_V3_TestSensors_step7>
     61a:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 7 */

        /* Stop profiling task 7 */
      } while (event.Flags7);
     61c:	90 24 82    	mov.w     0x4492, w0
     61e:	00 78 a3    	btst.z    w0, #0x7
     620:	f8 ff 3a    	bra       NZ, 0x612 <.L0> <.L44>

      Overrun.Flags7 = 0U;
     622:	a0 24 82    	mov.w     0x4494, w0
     624:	00 70 a1    	bclr.w    w0, #0x7
     626:	a0 24 8a    	mov.w     w0, 0x4494

00000628 <.L43>:
    }

    /* Handle Task 8 */
    if (Overrun.Flags8) {
     628:	a0 24 82    	mov.w     0x4494, w0
     62a:	00 88 a3    	btst.z    w0, #0x8
     62c:	03 00 32    	bra       Z, 0x634 <.L45>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     62e:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     630:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     632:	49 00 37    	bra       0x6c6 <.L1>

00000634 <.L45>:
    }

    if (event.Flags8) {
     634:	90 24 82    	mov.w     0x4492, w0
     636:	00 88 a3    	btst.z    w0, #0x8
     638:	0e 00 32    	bra       Z, 0x656 <.L46>
      Overrun.Flags8 = 1;
     63a:	a0 24 82    	mov.w     0x4494, w0
     63c:	00 80 a0    	bset.w    w0, #0x8
     63e:	a0 24 8a    	mov.w     w0, 0x4494

00000640 <.L0>:
      do {
        /* Start profiling task 8 */
        event.Flags8 = 0U;
     640:	90 24 82    	mov.w     0x4492, w0
     642:	00 80 a1    	bclr.w    w0, #0x8
     644:	90 24 8a    	mov.w     w0, 0x4492

00000646 <.L0>:
        AUAV_V3_TestSensors_step8();
     646:	c8 8e 02    	call      0x8ec8 <_AUAV_V3_TestSensors_step8>
     648:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 8 */

        /* Stop profiling task 8 */
      } while (event.Flags8);
     64a:	90 24 82    	mov.w     0x4492, w0
     64c:	00 88 a3    	btst.z    w0, #0x8
     64e:	f8 ff 3a    	bra       NZ, 0x640 <.L0> <.L47>

      Overrun.Flags8 = 0U;
     650:	a0 24 82    	mov.w     0x4494, w0
     652:	00 80 a1    	bclr.w    w0, #0x8
     654:	a0 24 8a    	mov.w     w0, 0x4494

00000656 <.L46>:
    }

    /* Handle Task 9 */
    if (Overrun.Flags9) {
     656:	a0 24 82    	mov.w     0x4494, w0
     658:	00 98 a3    	btst.z    w0, #0x9
     65a:	03 00 32    	bra       Z, 0x662 <.L48>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     65c:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     65e:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     660:	32 00 37    	bra       0x6c6 <.L1>

00000662 <.L48>:
    }

    if (event.Flags9) {
     662:	90 24 82    	mov.w     0x4492, w0
     664:	00 98 a3    	btst.z    w0, #0x9
     666:	0e 00 32    	bra       Z, 0x684 <.L49>
      Overrun.Flags9 = 1;
     668:	a0 24 82    	mov.w     0x4494, w0
     66a:	00 90 a0    	bset.w    w0, #0x9
     66c:	a0 24 8a    	mov.w     w0, 0x4494

0000066e <.L0>:
      do {
        /* Start profiling task 9 */
        event.Flags9 = 0U;
     66e:	90 24 82    	mov.w     0x4492, w0
     670:	00 90 a1    	bclr.w    w0, #0x9
     672:	90 24 8a    	mov.w     w0, 0x4492

00000674 <.L0>:
        AUAV_V3_TestSensors_step9();
     674:	ce 8e 02    	call      0x8ece <_AUAV_V3_TestSensors_step9>
     676:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 9 */

        /* Stop profiling task 9 */
      } while (event.Flags9);
     678:	90 24 82    	mov.w     0x4492, w0
     67a:	00 98 a3    	btst.z    w0, #0x9
     67c:	f8 ff 3a    	bra       NZ, 0x66e <.L0> <.L50> <.LASF9>

      Overrun.Flags9 = 0U;
     67e:	a0 24 82    	mov.w     0x4494, w0
     680:	00 90 a1    	bclr.w    w0, #0x9
     682:	a0 24 8a    	mov.w     w0, 0x4494

00000684 <.L49>:
    }

    /* Handle Task 10 */
    if (Overrun.Flags10) {
     684:	a0 24 82    	mov.w     0x4494, w0
     686:	00 a8 a3    	btst.z    w0, #0xa
     688:	03 00 32    	bra       Z, 0x690 <.L51>
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     68a:	52 30 ed    	dec.w     0x1052

      /* ensure atomic mcuFlagRecursion--; The value cannot reach 0 here, do not stop the timer */
      __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     68c:	50 30 ed    	dec.w     0x1050
      return;                          /* Priority to higher rate steps interrupted */
     68e:	1b 00 37    	bra       0x6c6 <.L1>

00000690 <.L51>:
    }

    if (event.Flags10) {
     690:	90 24 82    	mov.w     0x4492, w0
     692:	00 a8 a3    	btst.z    w0, #0xa
     694:	0e 00 32    	bra       Z, 0x6b2 <.L52>
      Overrun.Flags10 = 1;
     696:	a0 24 82    	mov.w     0x4494, w0
     698:	00 a0 a0    	bset.w    w0, #0xa
     69a:	a0 24 8a    	mov.w     w0, 0x4494

0000069c <.L0>:
      do {
        /* Start profiling task 10 */
        event.Flags10 = 0U;
     69c:	90 24 82    	mov.w     0x4492, w0
     69e:	00 a0 a1    	bclr.w    w0, #0xa
     6a0:	90 24 8a    	mov.w     w0, 0x4492

000006a2 <.L0>:
        AUAV_V3_TestSensors_step10();
     6a2:	2c 8f 02    	call      0x8f2c <_AUAV_V3_TestSensors_step10>
     6a4:	00 00 00 

        /* Get model outputs here */
        ;                              /* Execute task tid 10 */

        /* Stop profiling task 10 */
      } while (event.Flags10);
     6a6:	90 24 82    	mov.w     0x4492, w0
     6a8:	00 a8 a3    	btst.z    w0, #0xa
     6aa:	f8 ff 3a    	bra       NZ, 0x69c <.L0> <.L53>

      Overrun.Flags10 = 0U;
     6ac:	a0 24 82    	mov.w     0x4494, w0
     6ae:	00 a0 a1    	bclr.w    w0, #0xa
     6b0:	a0 24 8a    	mov.w     w0, 0x4494

000006b2 <.L52>:
    }

    /* Disable Interrupt. IPL value is 1 at this point */
    _IPL1 = 1;                         /* Set IPL to 2 (interrupt priority was 1) */
     6b2:	42 c0 a8    	bset.b    0x42, #0x6
    _IPL0 = 0;
     6b4:	42 a0 a9    	bclr.b    0x42, #0x5

    /* Release busy flag */
    __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (BusyFlagRecursion) );/* ensure atomic decrement of BusyFlagRecursion */
     6b6:	52 30 ed    	dec.w     0x1052
    if (BusyFlagRecursion == 0)
     6b8:	52 10 e2    	cp0.w     0x1052
     6ba:	01 00 3a    	bra       NZ, 0x6be <.L54> <.LBE2>
      LATAbits.LATA6 = 0;
     6bc:	04 ce a9    	bclr.b    0xe04, #0x6

000006be <.L54>:
  }

  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     6be:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
     6c0:	50 10 e2    	cp0.w     0x1050
     6c2:	01 00 3a    	bra       NZ, 0x6c6 <.L1>
    T3CONbits.TON = 0;
     6c4:	13 e1 a9    	bclr.b    0x113, #0x7

000006c6 <.L1>:
  }
}
     6c6:	34 00 f9    	pop       0x34
     6c8:	32 00 f9    	pop       0x32
     6ca:	4f 03 be    	mov.d     [--w15], w6
     6cc:	4f 02 be    	mov.d     [--w15], w4
     6ce:	4f 01 be    	mov.d     [--w15], w2
     6d0:	4f 00 be    	mov.d     [--w15], w0
     6d2:	36 00 f9    	pop       0x36
     6d4:	00 40 06    	retfie    

000006d6 <_main>:

int main()
{
  /* Initialize model */
  /* Start Clock Switching */
  if ((OSCCONbits.COSC & 1) && !(OSCCONbits.COSC & 4))/* check not already in PLL mode (0?1) */
     6d6:	43 87 ab    	btst.b    0x743, #0x4
     6d8:	16 00 32    	bra       Z, 0x706 <.L66>
     6da:	43 c7 ab    	btst.b    0x743, #0x6
     6dc:	14 00 3a    	bra       NZ, 0x706 <.L66>
  {
    __builtin_write_OSCCONH(0);        /* Clock Switch to non PLL mode */
     6de:	a1 09 20    	mov.w     #0x9a, w1
     6e0:	00 01 eb    	clr.w     w2
     6e2:	80 07 20    	mov.w     #0x78, w0
     6e4:	33 74 20    	mov.w     #0x743, w3
     6e6:	80 49 78    	mov.b     w0, [w3]
     6e8:	81 49 78    	mov.b     w1, [w3]
     6ea:	82 49 78    	mov.b     w2, [w3]
    __builtin_write_OSCCONL(0x01);     /* Start clock switching */
     6ec:	71 05 20    	mov.w     #0x57, w1
     6ee:	12 00 20    	mov.w     #0x1, w2
     6f0:	60 04 20    	mov.w     #0x46, w0
     6f2:	23 74 20    	mov.w     #0x742, w3
     6f4:	80 49 78    	mov.b     w0, [w3]
     6f6:	81 49 78    	mov.b     w1, [w3]
     6f8:	82 49 78    	mov.b     w2, [w3]
	...
    __asm__ volatile("nop\n"
                     "nop");
    while (OSCCONbits.COSC != 0) ;
     6fe:	00 00 27    	mov.w     #0x7000, w0

00000700 <.L67>:
     700:	12 3a 80    	mov.w     0x742, w2
     702:	82 00 60    	and.w     w0, w2, w1
     704:	fd ff 3a    	bra       NZ, 0x700 <.L67>

00000706 <.L66>:
  }

  PLLFBD = 0xF3;                       /* configure Oscillator PLL : PLLDIV */
     706:	30 0f 20    	mov.w     #0xf3, w0
     708:	30 3a 88    	mov.w     w0, 0x746
  CLKDIV = 0x05;                       /* configure Oscillator PLL : FRCDIV ; PLLPOST ; PLLPRE */
     70a:	51 00 20    	mov.w     #0x5, w1
     70c:	21 3a 88    	mov.w     w1, 0x744
  __builtin_write_OSCCONH(3);          /* Clock Switch to desired configuration */
     70e:	a2 09 20    	mov.w     #0x9a, w2
     710:	33 00 20    	mov.w     #0x3, w3
     712:	80 07 20    	mov.w     #0x78, w0
     714:	34 74 20    	mov.w     #0x743, w4
     716:	00 4a 78    	mov.b     w0, [w4]
     718:	02 4a 78    	mov.b     w2, [w4]
     71a:	03 4a 78    	mov.b     w3, [w4]
  __builtin_write_OSCCONL(0x01);       /* Start clock switching */
     71c:	72 05 20    	mov.w     #0x57, w2
     71e:	13 00 20    	mov.w     #0x1, w3
     720:	60 04 20    	mov.w     #0x46, w0
     722:	24 74 20    	mov.w     #0x742, w4
     724:	00 4a 78    	mov.b     w0, [w4]
     726:	02 4a 78    	mov.b     w2, [w4]
     728:	03 4a 78    	mov.b     w3, [w4]

  /* Configure Pins as Analog or Digital */
  ANSELA = 0x0680;
     72a:	00 68 20    	mov.w     #0x680, w0
     72c:	70 70 88    	mov.w     w0, 0xe0e
  ANSELB = 0xFFC3;
     72e:	30 fc 2f    	mov.w     #0xffc3, w0
     730:	f0 70 88    	mov.w     w0, 0xe1e
  ANSELD = 0x40;
     732:	77 01 51    	sub.w     w2, #0x17, w2
     734:	f2 71 88    	mov.w     w2, 0xe3e
  ANSELE = 0x0382;
     736:	22 38 20    	mov.w     #0x382, w2
     738:	72 72 88    	mov.w     w2, 0xe4e

  /* Configure Remappables Pins */
  RPINR7 = 0x4840;
     73a:	02 84 24    	mov.w     #0x4840, w2
     73c:	72 35 88    	mov.w     w2, 0x6ae
  RPINR8 = 0x1F4B;
     73e:	b2 f4 21    	mov.w     #0x1f4b, w2
     740:	82 35 88    	mov.w     w2, 0x6b0
  RPINR9 = 0x1E15;
     742:	62 13 b1    	sub.w     #0x136, w2
     744:	92 35 88    	mov.w     w2, 0x6b2
  RPINR10 = 0x1014;
     746:	42 01 21    	mov.w     #0x1014, w2
     748:	a2 35 88    	mov.w     w2, 0x6b4
  RPINR20 = 0x53;
     74a:	32 05 20    	mov.w     #0x53, w2
     74c:	42 36 88    	mov.w     w2, 0x6c8
  RPOR3 = 0x1300;
     74e:	02 30 21    	mov.w     #0x1300, w2
     750:	32 34 88    	mov.w     w2, 0x686
  RPOR4 = 0x1100;
     752:	02 20 b1    	sub.w     #0x200, w2
     754:	42 34 88    	mov.w     w2, 0x688
  RPOR5 = 0x05;
     756:	51 34 88    	mov.w     w1, 0x68a
  RPOR6 = 0x1D;
     758:	d1 01 20    	mov.w     #0x1d, w1
     75a:	61 34 88    	mov.w     w1, 0x68c
  RPOR8 = 0x0100;
     75c:	01 10 20    	mov.w     #0x100, w1
     75e:	81 34 88    	mov.w     w1, 0x690
  RPOR12 = 0x1000;
     760:	01 00 21    	mov.w     #0x1000, w1
     762:	c1 34 88    	mov.w     w1, 0x698
  RPOR14 = 0x1200;
     764:	01 20 b0    	add.w     #0x200, w1
     766:	e1 34 88    	mov.w     w1, 0x69c
  RPOR15 = 0x0600;
     768:	01 60 20    	mov.w     #0x600, w1
     76a:	f1 34 88    	mov.w     w1, 0x69e

  /* Configure Digitals I/O directions */
  TRISA = 0xFFBF;
     76c:	f1 fb 2f    	mov.w     #0xffbf, w1
     76e:	01 70 88    	mov.w     w1, 0xe00
  TRISB = 0xFFC3;
     770:	80 70 88    	mov.w     w0, 0xe10
  TRISD = 0xFF7F;
     772:	f0 f7 2f    	mov.w     #0xff7f, w0
     774:	80 71 88    	mov.w     w0, 0xe30
  TRISE = 0xFFCA;
     776:	a0 fc 2f    	mov.w     #0xffca, w0
     778:	00 72 88    	mov.w     w0, 0xe40
  TRISF = 0xFFF7;
     77a:	70 ff 2f    	mov.w     #0xfff7, w0
     77c:	80 72 88    	mov.w     w0, 0xe50
  TRISG = 0x5FFE;
     77e:	e0 ff 25    	mov.w     #0x5ffe, w0
     780:	00 73 88    	mov.w     w0, 0xe60

  /* Finish clock switching procedure */
  while (OSCCONbits.COSC != 3) ;       /* Wait for Oscillator Stabilisation */
     782:	01 00 27    	mov.w     #0x7000, w1
     784:	00 00 23    	mov.w     #0x3000, w0

00000786 <.L68>:
     786:	13 3a 80    	mov.w     0x742, w3
     788:	03 81 60    	and.w     w1, w3, w2
     78a:	80 0f 51    	sub.w     w2, w0, [w15]
     78c:	fc ff 3a    	bra       NZ, 0x786 <.L68>

0000078e <.L0>:
  while (OSCCONbits.LOCK != 1) ;       /* Wait for PLL Stabilisation */
     78e:	00 02 20    	mov.w     #0x20, w0

00000790 <.L71>:
     790:	12 3a 80    	mov.w     0x742, w2
     792:	82 00 60    	and.w     w0, w2, w1
     794:	fd ff 32    	bra       Z, 0x790 <.L71>

00000796 <.L0>:

  /* Initialize model */
  AUAV_V3_TestSensors_initialize();
     796:	32 8f 02    	call      0x8f32 <_AUAV_V3_TestSensors_initialize>
     798:	00 00 00 

  /* Configure Timers */
  /* --- TIMER 1 --- */
  PR1 = 0xFFFF;                        /* Period */
     79a:	80 80 eb    	setm.w    w1
     79c:	11 08 88    	mov.w     w1, 0x102
  T1CON = 0x8010;
     79e:	00 01 28    	mov.w     #0x8010, w0
     7a0:	20 08 88    	mov.w     w0, 0x104

  /* --- TIMER 2 --- This timer is enabled at end of configuration functions. */
  _T2IP = 2;                           /* Set timer Interrupt Priority */
     7a2:	10 42 80    	mov.w     0x842, w0
     7a4:	00 c0 a1    	bclr.w    w0, #0xc
     7a6:	00 d0 a0    	bset.w    w0, #0xd
     7a8:	00 e0 a1    	bclr.w    w0, #0xe
     7aa:	10 42 88    	mov.w     w0, 0x842
  _T2IF = 0;                           /* Reset pending Interrupt */
     7ac:	00 e8 a9    	bclr.b    0x800, #0x7
  _T2IE = 1;                           /* Enable Timer Interrupt. */
     7ae:	20 e8 a8    	bset.b    0x820, #0x7
  PR2 = 0x2AB8;                        /* Period */
     7b0:	80 ab 22    	mov.w     #0x2ab8, w0
     7b2:	60 08 88    	mov.w     w0, 0x10c

  /* --- TIMER 3 --- */
  PR3 = 0xFFFF;                        /* Period */
     7b4:	71 08 88    	mov.w     w1, 0x10e
  T3CON = 0x20;
     7b6:	00 02 20    	mov.w     #0x20, w0
     7b8:	90 08 88    	mov.w     w0, 0x112

  /* Enable Time-step */
  TMR2 = 0x2AB7;
     7ba:	70 ab 22    	mov.w     #0x2ab7, w0
     7bc:	30 08 88    	mov.w     w0, 0x106
  T2CON = 0x8020;                      /* Timer 2 is the source trigger for the model Time-step */
     7be:	00 02 28    	mov.w     #0x8020, w0
     7c0:	80 08 88    	mov.w     w0, 0x110

000007c2 <.L70>:
     7c2:	ff ff 37    	bra       .

000007c4 <__MI2C2Interrupt>:

/* I2C - Interrupt: <S1>/BUS I2C Initialize BMP180 Read T, Convert P @ 100Hz */
/* Implement I2C 2 Interrupts */
void __attribute__((__interrupt__,__auto_psv__)) _MI2C2Interrupt(void) /* MI2C2 ISR */
{
     7c4:	80 9f be    	mov.d     w0, [w15++]
     7c6:	82 9f be    	mov.d     w2, [w15++]
     7c8:	84 9f be    	mov.d     w4, [w15++]
     7ca:	86 9f be    	mov.d     w6, [w15++]
     7cc:	88 1f 78    	mov.w     w8, [w15++]
     7ce:	32 00 f8    	push      0x32
     7d0:	34 00 f8    	push      0x34
     7d2:	10 00 20    	mov.w     #0x1, w0
     7d4:	a0 01 88    	mov.w     w0, 0x34
     7d6:	00 20 20    	mov.w     #0x200, w0
     7d8:	90 01 88    	mov.w     w0, 0x32
     7da:	00 00 00    	nop       
  boolean_T Continue;
  _MI2C2IF = 0;
     7dc:	06 48 a9    	bclr.b    0x806, #0x2
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
     7de:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
     7e0:	13 e1 a8    	bset.b    0x113, #0x7
     7e2:	c4 1d 82    	mov.w     0x43b8, w4

  /* Declaration of Variables */
  do {
    Continue = 0;                      /* By default, execute one sequence only */
    switch (MCHP_I2C2_State)
     7e4:	22 07 20    	mov.w     #0x72, w2
     7e6:	03 00 20    	mov.w     #0x0, w3
    {
     case 0:                           /* Idle */
      /* Check if the next sequence is already in the queue. If so, start it */
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
      if (Continue) {
        MCHP_I2C2_State = MCHP_I2C2_Queue.buffer[MCHP_I2C2_Queue.tail];
        if (MCHP_I2C2_Queue.tail >= 5) /* There are 5 I2C2 blocks, max idx for queue is 5 */
          MCHP_I2C2_Queue.tail = 0;
        else
          MCHP_I2C2_Queue.tail++;
      }
      break;

     case 1:                           /* Problem: try Reset of I2C BUS : Repeated Start sequence and Stop */
      TRISAbits.TRISA3 = 1;            /* Set I2C Port as Port Input (better for Fj chips)*/
      TRISAbits.TRISA2 = 1;
      I2C2CONbits.I2CEN = 1;           /* Re-Enable I2C*/
      I2C2STAT &= 65526;               /* Reset I2C State */
      I2C2CONbits.RSEN = 1;            /* I2C: Restart */
      MCHP_I2C2_State++;
      break;

     case 2:                           /* Problem: try Reset of I2C BUS : Stop sequence*/
      I2C2STAT &= 65526;               /* Reset I2C Receive Overflow and I2C Collision during Write or Master operation  */
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 3:
      I2C2STAT &= 65526;               /* Reset I2C Receive Overflow and I2C Collision during Write or Master operation  */
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* Any pending sequence ? */
      break;

     case 4:                           /* Start a new I2C Sequence */
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 5:
      I2C2TRN = 0xEE;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 6:
      I2C2TRN = 0xF6;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 7:
      I2C2CONbits.RSEN = 1;            /* I2C: REPEATED START */
      MCHP_I2C2_State++;
      break;

     case 8:
      I2C2TRN = 0xEF;                  /* I2C : Address Repeat */
      MCHP_I2C2_State++;
      break;

     case 9:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 10:
      I2C22_Buff8[0] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 11:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 12:
      I2C22_Buff8[1] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 1;           /* set to NACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 13:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 14:
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 15:
      I2C2TRN = 0xEE;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 16:
      I2C2TRN = 0xF4;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 17:
      I2C2TRN = 0x34;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 18:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 19:
      MCHP_I2C22_Request = 0;          /* This I2C sequence could be Re-Enabled */
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
      break;

     case 20:                          /* Start a new I2C Sequence */
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 21:
      I2C2TRN = 0xEE;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 22:
      I2C2TRN = 0xF6;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 23:
      I2C2CONbits.RSEN = 1;            /* I2C: REPEATED START */
      MCHP_I2C2_State++;
      break;

     case 24:
      I2C2TRN = 0xEF;                  /* I2C : Address Repeat */
      MCHP_I2C2_State++;
      break;

     case 25:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 26:
      I2C23_Buff8[0] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 27:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 28:
      I2C23_Buff8[1] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 1;           /* set to NACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 29:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 30:
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 31:
      I2C2TRN = 0xEE;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 32:
      I2C2TRN = 0xF4;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 33:
      I2C2TRN = 0x2E;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 34:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 35:
      MCHP_I2C23_Request = 0;          /* This I2C sequence could be Re-Enabled */
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
      break;

     case 36:                          /* Start a new I2C Sequence */
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 37:
      I2C2TRN = 0xEE;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 38:
      I2C2TRN = 0xAA;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 39:
      I2C2CONbits.RSEN = 1;            /* I2C: REPEATED START */
      MCHP_I2C2_State++;
      break;

     case 40:
      I2C2TRN = 0xEF;                  /* I2C : Address Repeat */
      MCHP_I2C2_State++;
      break;

     case 41:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 42:
      I2C21_Buff8[0] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 43:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 44:
      I2C21_Buff8[1] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 45:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 46:
      I2C21_Buff8[2] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 47:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 48:
      I2C21_Buff8[3] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 49:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 50:
      I2C21_Buff8[4] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 51:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 52:
      I2C21_Buff8[5] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 53:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 54:
      I2C21_Buff8[6] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 55:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 56:
      I2C21_Buff8[7] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 57:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 58:
      I2C21_Buff8[8] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 59:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 60:
      I2C21_Buff8[9] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 61:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 62:
      I2C21_Buff8[10] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 63:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 64:
      I2C21_Buff8[11] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 65:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 66:
      I2C21_Buff8[12] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 67:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 68:
      I2C21_Buff8[13] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 69:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 70:
      I2C21_Buff8[14] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 71:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 72:
      I2C21_Buff8[15] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 73:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 74:
      I2C21_Buff8[16] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 75:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 76:
      I2C21_Buff8[17] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 77:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 78:
      I2C21_Buff8[18] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 79:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 80:
      I2C21_Buff8[19] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 81:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 82:
      I2C21_Buff8[20] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 83:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 84:
      I2C21_Buff8[21] = I2C2RCV;       /* I2C : Read data */
      I2C2CONbits.ACKDT = 1;           /* set to NACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 85:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 86:
      MCHP_I2C21_Request = 0;          /* This I2C sequence could be Re-Enabled */
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
      break;

     case 87:                          /* Start a new I2C Sequence */
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 88:
      I2C2TRN = 0x3C;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 89:
      I2C2TRN = 0x03;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 90:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 91:
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 92:
      I2C2TRN = 0x3D;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 93:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 94:
      I2C24_Buff8[0] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 95:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 96:
      I2C24_Buff8[1] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 97:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 98:
      I2C24_Buff8[2] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 99:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 100:
      I2C24_Buff8[3] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 101:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 102:
      I2C24_Buff8[4] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 0;           /* set to ACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 103:
      I2C2CONbits.RCEN = 1;            /* I2C: Receive  */
      MCHP_I2C2_State++;
      break;

     case 104:
      I2C24_Buff8[5] = I2C2RCV;        /* I2C : Read data */
      I2C2CONbits.ACKDT = 1;           /* set to NACK */
      I2C2CONbits.ACKEN = 1;           /* Start Acknowledge sequence */
      MCHP_I2C2_State++;
      break;

     case 105:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 106:
      MCHP_I2C24_Request = 0;          /* This I2C sequence could be Re-Enabled */
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
      break;

     case 107:                         /* Start a new I2C Sequence */
      I2C2CONbits.SEN = 1;             /* I2C: START  */
      MCHP_I2C2_State++;
      break;

     case 108:
      I2C2TRN = 0x3C;                  /* Send I2C Address : A7 A6 A5 A4 A3 A2 A1 A0 RW */
      MCHP_I2C2_State++;
      break;

     case 109:
      I2C2TRN = 0x00;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 110:
      I2C2TRN = 0x78;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 111:
      I2C2TRN = 0x00;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 112:
      I2C2TRN = 0x00;                  /* I2C : Write data */
      MCHP_I2C2_State++;
      break;

     case 113:
      I2C2CONbits.PEN = 1;             /* I2C: STOP */
      MCHP_I2C2_State++;
      break;

     case 114:
      MCHP_I2C25_Request = 0;          /* This I2C sequence could be Re-Enabled */
     7e8:	80 02 eb    	clr.w     w5
      MCHP_I2C2_State = 0;
      Continue = (MCHP_I2C2_Queue.head != MCHP_I2C2_Queue.tail);/* One next sequence queued, start it now */
     7ea:	a6 3b 24    	mov.w     #0x43ba, w6
     7ec:	67 ff 2f    	mov.w     #0xfff6, w7
     7ee:	6e 04 53    	sub.w     w6, #0xe, w8

000007f0 <.L122>:
     7f0:	00 1d 82    	mov.w     0x43a0, w0
     7f2:	80 00 eb    	clr.w     w1
     7f4:	82 0f 50    	sub.w     w0, w2, [w15]
     7f6:	83 8f 58    	subb.w    w1, w3, [w15]
     7f8:	d7 03 3e    	bra       GTU, 0xfa8 <.L2>
     7fa:	00 06 01    	.pword 0x010600
     7fc:	72 00 37    	bra       0x8e2 <.L3>
     7fe:	80 00 37    	bra       0x900 <.L4>
     800:	8a 00 37    	bra       0x916 <.L5>
     802:	91 00 37    	bra       0x926 <.L6>
     804:	99 00 37    	bra       0x938 <.L7> <.LASF96>
     806:	9e 00 37    	bra       0x944 <.L8>
     808:	a4 00 37    	bra       0x952 <.L9> <.LASF60>
     80a:	aa 00 37    	bra       0x960 <.L10>
     80c:	af 00 37    	bra       0x96c <.L11>
     80e:	b5 00 37    	bra       0x97a <.L12>
     810:	ba 00 37    	bra       0x986 <.L13>
     812:	c3 00 37    	bra       0x99a <.L14>
     814:	c8 00 37    	bra       0x9a6 <.L15>
     816:	d1 00 37    	bra       0x9ba <.L16>
     818:	d6 00 37    	bra       0x9c6 <.L17>
     81a:	db 00 37    	bra       0x9d2 <.L18>
     81c:	e1 00 37    	bra       0x9e0 <.L19>
     81e:	e7 00 37    	bra       0x9ee <.L20>
     820:	ed 00 37    	bra       0x9fc <.L21>
     822:	f2 00 37    	bra       0xa08 <.L22>
     824:	f9 00 37    	bra       0xa18 <.L23>
     826:	fe 00 37    	bra       0xa24 <.L24> <.LASF81>
     828:	04 01 37    	bra       0xa32 <.L25>
     82a:	0a 01 37    	bra       0xa40 <.L26>
     82c:	0f 01 37    	bra       0xa4c <.L27>
     82e:	15 01 37    	bra       0xa5a <.L28>
     830:	1a 01 37    	bra       0xa66 <.L29>
     832:	23 01 37    	bra       0xa7a <.L30>
     834:	28 01 37    	bra       0xa86 <.L31>
     836:	31 01 37    	bra       0xa9a <.L32>
     838:	36 01 37    	bra       0xaa6 <.L33>
     83a:	3b 01 37    	bra       0xab2 <.L34>
     83c:	41 01 37    	bra       0xac0 <.L35>
     83e:	47 01 37    	bra       0xace <.L36>
     840:	4d 01 37    	bra       0xadc <.L37>
     842:	52 01 37    	bra       0xae8 <.L38>
     844:	59 01 37    	bra       0xaf8 <.L39>
     846:	5e 01 37    	bra       0xb04 <.L40>
     848:	64 01 37    	bra       0xb12 <.L41>
     84a:	6a 01 37    	bra       0xb20 <.L42> <.LASF149>
     84c:	6f 01 37    	bra       0xb2c <.L43>
     84e:	75 01 37    	bra       0xb3a <.L44>
     850:	7a 01 37    	bra       0xb46 <.L45>
     852:	83 01 37    	bra       0xb5a <.L46>
     854:	88 01 37    	bra       0xb66 <.L47>
     856:	91 01 37    	bra       0xb7a <.L48>
     858:	96 01 37    	bra       0xb86 <.L49>
     85a:	9f 01 37    	bra       0xb9a <.L50>
     85c:	a4 01 37    	bra       0xba6 <.L51>
     85e:	ad 01 37    	bra       0xbba <.L52>
     860:	b2 01 37    	bra       0xbc6 <.L53>
     862:	bb 01 37    	bra       0xbda <.L54>
     864:	c0 01 37    	bra       0xbe6 <.L55>
     866:	c9 01 37    	bra       0xbfa <.L56>
     868:	ce 01 37    	bra       0xc06 <.L57> <.LASF0>
     86a:	d7 01 37    	bra       0xc1a <.L58>
     86c:	dc 01 37    	bra       0xc26 <.L59>
     86e:	e5 01 37    	bra       0xc3a <.L60>
     870:	ea 01 37    	bra       0xc46 <.L61> <.LASF6>
     872:	f3 01 37    	bra       0xc5a <.L62>
     874:	f8 01 37    	bra       0xc66 <.L63>
     876:	01 02 37    	bra       0xc7a <.L64>
     878:	06 02 37    	bra       0xc86 <.L65> <.LASF51>
     87a:	0f 02 37    	bra       0xc9a <.L66>
     87c:	14 02 37    	bra       0xca6 <.L67>
     87e:	1d 02 37    	bra       0xcba <.L68>
     880:	22 02 37    	bra       0xcc6 <.L69>
     882:	2b 02 37    	bra       0xcda <.L70>
     884:	30 02 37    	bra       0xce6 <.L71>
     886:	39 02 37    	bra       0xcfa <.L72> <.Ldebug_abbrev0>
     888:	3e 02 37    	bra       0xd06 <.L73>
     88a:	47 02 37    	bra       0xd1a <.L74>
     88c:	4c 02 37    	bra       0xd26 <.L75>
     88e:	55 02 37    	bra       0xd3a <.L76>
     890:	5a 02 37    	bra       0xd46 <.L77>
     892:	63 02 37    	bra       0xd5a <.L78>
     894:	68 02 37    	bra       0xd66 <.L79>
     896:	71 02 37    	bra       0xd7a <.L80>
     898:	76 02 37    	bra       0xd86 <.L81>
     89a:	7f 02 37    	bra       0xd9a <.L82>
     89c:	84 02 37    	bra       0xda6 <.L83>
     89e:	8d 02 37    	bra       0xdba <.L84>
     8a0:	92 02 37    	bra       0xdc6 <.L85>
     8a2:	9b 02 37    	bra       0xdda <.L86> <.LASF19>
     8a4:	a0 02 37    	bra       0xde6 <.L87>
     8a6:	a9 02 37    	bra       0xdfa <.L88>
     8a8:	ae 02 37    	bra       0xe06 <.L89>
     8aa:	b5 02 37    	bra       0xe16 <.L90>
     8ac:	ba 02 37    	bra       0xe22 <.L91>
     8ae:	c0 02 37    	bra       0xe30 <.L92>
     8b0:	c6 02 37    	bra       0xe3e <.L93>
     8b2:	cb 02 37    	bra       0xe4a <.L94>
     8b4:	d0 02 37    	bra       0xe56 <.L95>
     8b6:	d6 02 37    	bra       0xe64 <.L96>
     8b8:	db 02 37    	bra       0xe70 <.L97>
     8ba:	e4 02 37    	bra       0xe84 <.L98>
     8bc:	e9 02 37    	bra       0xe90 <.L99>
     8be:	f2 02 37    	bra       0xea4 <.L100>
     8c0:	f7 02 37    	bra       0xeb0 <.L101>
     8c2:	00 03 37    	bra       0xec4 <.L102>
     8c4:	05 03 37    	bra       0xed0 <.L103>
     8c6:	0e 03 37    	bra       0xee4 <.L104> <.LASF40>
     8c8:	13 03 37    	bra       0xef0 <.L105>
     8ca:	1c 03 37    	bra       0xf04 <.L106>
     8cc:	21 03 37    	bra       0xf10 <.L107>
     8ce:	2a 03 37    	bra       0xf24 <.L108>
     8d0:	2f 03 37    	bra       0xf30 <.L109>
     8d2:	36 03 37    	bra       0xf40 <.L110>
     8d4:	3b 03 37    	bra       0xf4c <.L111>
     8d6:	41 03 37    	bra       0xf5a <.L112>
     8d8:	46 03 37    	bra       0xf66 <.L113>
     8da:	4c 03 37    	bra       0xf74 <.L114>
     8dc:	51 03 37    	bra       0xf80 <.L115>
     8de:	56 03 37    	bra       0xf8c <.L116>
     8e0:	5b 03 37    	bra       0xf98 <.L117>

000008e2 <.L3>:
     8e2:	16 00 6a    	xor.w     w4, [w6], w0
     8e4:	00 f0 a7    	btsc.w    w0, #0xf
     8e6:	00 00 ea    	neg.w     w0, w0
     8e8:	00 00 ea    	neg.w     w0, w0
     8ea:	4f 00 de    	lsr.w     w0, #0xf, w0
     8ec:	00 04 e0    	cp0.b     w0
     8ee:	69 03 32    	bra       Z, 0xfc2 <.L119>
     8f0:	84 00 42    	add.w     w4, w4, w1
     8f2:	81 00 44    	add.w     w8, w1, w1
     8f4:	91 00 78    	mov.w     [w1], w1
     8f6:	01 1d 8a    	mov.w     w1, 0x43a0
     8f8:	e4 0f 52    	sub.w     w4, #0x4, [w15]
     8fa:	5a 03 3e    	bra       GTU, 0xfb0 <.L125> <.LASF17>
     8fc:	04 02 e8    	inc.w     w4, w4
     8fe:	59 03 37    	bra       0xfb2 <.L120>

00000900 <.L4>:
     900:	c4 1d 8a    	mov.w     w4, 0x43b8
     902:	00 6e a8    	bset.b    0xe00, #0x3
     904:	00 4e a8    	bset.b    0xe00, #0x2
     906:	17 e2 a8    	bset.b    0x217, #0x7
     908:	60 ff 2f    	mov.w     #0xfff6, w0
     90a:	18 22 b6    	and.w     0x218
     90c:	16 22 a8    	bset.b    0x216, #0x1
     90e:	00 1d 82    	mov.w     0x43a0, w0
     910:	00 00 e8    	inc.w     w0, w0
     912:	00 1d 8a    	mov.w     w0, 0x43a0
     914:	51 03 37    	bra       0xfb8 <.L124>

00000916 <.L5>:
     916:	c4 1d 8a    	mov.w     w4, 0x43b8
     918:	60 ff 2f    	mov.w     #0xfff6, w0
     91a:	18 22 b6    	and.w     0x218
     91c:	16 42 a8    	bset.b    0x216, #0x2
     91e:	00 1d 82    	mov.w     0x43a0, w0
     920:	00 00 e8    	inc.w     w0, w0
     922:	00 1d 8a    	mov.w     w0, 0x43a0
     924:	49 03 37    	bra       0xfb8 <.L124>

00000926 <.L6>:
     926:	80 21 20    	mov.w     #0x218, w0
     928:	10 88 63    	and.w     w7, [w0], [w0]
     92a:	05 1d 8a    	mov.w     w5, 0x43a0
     92c:	16 00 6a    	xor.w     w4, [w6], w0
     92e:	00 f0 a7    	btsc.w    w0, #0xf
     930:	00 00 ea    	neg.w     w0, w0
     932:	00 00 ea    	neg.w     w0, w0
     934:	4f 00 de    	lsr.w     w0, #0xf, w0
     936:	3d 03 37    	bra       0xfb2 <.L120>

00000938 <.L7>:
     938:	c4 1d 8a    	mov.w     w4, 0x43b8
     93a:	16 02 a8    	bset.b    0x216, #0x0
     93c:	00 1d 82    	mov.w     0x43a0, w0
     93e:	00 00 e8    	inc.w     w0, w0
     940:	00 1d 8a    	mov.w     w0, 0x43a0
     942:	3a 03 37    	bra       0xfb8 <.L124>

00000944 <.L8>:
     944:	c4 1d 8a    	mov.w     w4, 0x43b8
     946:	e0 0e 20    	mov.w     #0xee, w0
     948:	90 10 88    	mov.w     w0, 0x212
     94a:	00 1d 82    	mov.w     0x43a0, w0
     94c:	00 00 e8    	inc.w     w0, w0
     94e:	00 1d 8a    	mov.w     w0, 0x43a0
     950:	33 03 37    	bra       0xfb8 <.L124>

00000952 <.L9>:
     952:	c4 1d 8a    	mov.w     w4, 0x43b8
     954:	60 0f 20    	mov.w     #0xf6, w0
     956:	90 10 88    	mov.w     w0, 0x212
     958:	00 1d 82    	mov.w     0x43a0, w0
     95a:	00 00 e8    	inc.w     w0, w0
     95c:	00 1d 8a    	mov.w     w0, 0x43a0
     95e:	2c 03 37    	bra       0xfb8 <.L124>

00000960 <.L10>:
     960:	c4 1d 8a    	mov.w     w4, 0x43b8
     962:	16 22 a8    	bset.b    0x216, #0x1
     964:	00 1d 82    	mov.w     0x43a0, w0
     966:	00 00 e8    	inc.w     w0, w0
     968:	00 1d 8a    	mov.w     w0, 0x43a0
     96a:	26 03 37    	bra       0xfb8 <.L124>

0000096c <.L11>:
     96c:	c4 1d 8a    	mov.w     w4, 0x43b8
     96e:	f0 0e 20    	mov.w     #0xef, w0
     970:	90 10 88    	mov.w     w0, 0x212
     972:	00 1d 82    	mov.w     0x43a0, w0
     974:	00 00 e8    	inc.w     w0, w0
     976:	00 1d 8a    	mov.w     w0, 0x43a0
     978:	1f 03 37    	bra       0xfb8 <.L124>

0000097a <.L12>:
     97a:	c4 1d 8a    	mov.w     w4, 0x43b8
     97c:	16 62 a8    	bset.b    0x216, #0x3
     97e:	00 1d 82    	mov.w     0x43a0, w0
     980:	00 00 e8    	inc.w     w0, w0
     982:	00 1d 8a    	mov.w     w0, 0x43a0
     984:	19 03 37    	bra       0xfb8 <.L124>

00000986 <.L13>:
     986:	c4 1d 8a    	mov.w     w4, 0x43b8
     988:	81 10 80    	mov.w     0x210, w1
     98a:	c0 3b 24    	mov.w     #0x43bc, w0
     98c:	01 48 78    	mov.b     w1, [w0]
     98e:	16 a2 a9    	bclr.b    0x216, #0x5
     990:	16 82 a8    	bset.b    0x216, #0x4
     992:	00 1d 82    	mov.w     0x43a0, w0
     994:	00 00 e8    	inc.w     w0, w0
     996:	00 1d 8a    	mov.w     w0, 0x43a0
     998:	0f 03 37    	bra       0xfb8 <.L124>

0000099a <.L14>:
     99a:	c4 1d 8a    	mov.w     w4, 0x43b8
     99c:	16 62 a8    	bset.b    0x216, #0x3
     99e:	00 1d 82    	mov.w     0x43a0, w0
     9a0:	00 00 e8    	inc.w     w0, w0
     9a2:	00 1d 8a    	mov.w     w0, 0x43a0
     9a4:	09 03 37    	bra       0xfb8 <.L124>

000009a6 <.L15>:
     9a6:	c4 1d 8a    	mov.w     w4, 0x43b8
     9a8:	81 10 80    	mov.w     0x210, w1
     9aa:	d0 3b 24    	mov.w     #0x43bd, w0
     9ac:	01 48 78    	mov.b     w1, [w0]
     9ae:	16 a2 a8    	bset.b    0x216, #0x5
     9b0:	16 82 a8    	bset.b    0x216, #0x4
     9b2:	00 1d 82    	mov.w     0x43a0, w0
     9b4:	00 00 e8    	inc.w     w0, w0
     9b6:	00 1d 8a    	mov.w     w0, 0x43a0
     9b8:	ff 02 37    	bra       0xfb8 <.L124>

000009ba <.L16>:
     9ba:	c4 1d 8a    	mov.w     w4, 0x43b8
     9bc:	16 42 a8    	bset.b    0x216, #0x2
     9be:	00 1d 82    	mov.w     0x43a0, w0
     9c0:	00 00 e8    	inc.w     w0, w0
     9c2:	00 1d 8a    	mov.w     w0, 0x43a0
     9c4:	f9 02 37    	bra       0xfb8 <.L124>

000009c6 <.L17>:
     9c6:	c4 1d 8a    	mov.w     w4, 0x43b8
     9c8:	16 02 a8    	bset.b    0x216, #0x0
     9ca:	00 1d 82    	mov.w     0x43a0, w0
     9cc:	00 00 e8    	inc.w     w0, w0
     9ce:	00 1d 8a    	mov.w     w0, 0x43a0
     9d0:	f3 02 37    	bra       0xfb8 <.L124>

000009d2 <.L18>:
     9d2:	c4 1d 8a    	mov.w     w4, 0x43b8
     9d4:	e0 0e 20    	mov.w     #0xee, w0
     9d6:	90 10 88    	mov.w     w0, 0x212
     9d8:	00 1d 82    	mov.w     0x43a0, w0
     9da:	00 00 e8    	inc.w     w0, w0
     9dc:	00 1d 8a    	mov.w     w0, 0x43a0
     9de:	ec 02 37    	bra       0xfb8 <.L124>

000009e0 <.L19>:
     9e0:	c4 1d 8a    	mov.w     w4, 0x43b8
     9e2:	40 0f 20    	mov.w     #0xf4, w0
     9e4:	90 10 88    	mov.w     w0, 0x212
     9e6:	00 1d 82    	mov.w     0x43a0, w0
     9e8:	00 00 e8    	inc.w     w0, w0
     9ea:	00 1d 8a    	mov.w     w0, 0x43a0
     9ec:	e5 02 37    	bra       0xfb8 <.L124>

000009ee <.L20>:
     9ee:	c4 1d 8a    	mov.w     w4, 0x43b8
     9f0:	40 03 20    	mov.w     #0x34, w0
     9f2:	90 10 88    	mov.w     w0, 0x212
     9f4:	00 1d 82    	mov.w     0x43a0, w0
     9f6:	00 00 e8    	inc.w     w0, w0
     9f8:	00 1d 8a    	mov.w     w0, 0x43a0
     9fa:	de 02 37    	bra       0xfb8 <.L124>

000009fc <.L21>:
     9fc:	c4 1d 8a    	mov.w     w4, 0x43b8
     9fe:	16 42 a8    	bset.b    0x216, #0x2
     a00:	00 1d 82    	mov.w     0x43a0, w0
     a02:	00 00 e8    	inc.w     w0, w0
     a04:	00 1d 8a    	mov.w     w0, 0x43a0
     a06:	d8 02 37    	bra       0xfb8 <.L124>

00000a08 <.L22>:
     a08:	15 1d 8a    	mov.w     w5, 0x43a2
     a0a:	05 1d 8a    	mov.w     w5, 0x43a0
     a0c:	16 00 6a    	xor.w     w4, [w6], w0
     a0e:	00 f0 a7    	btsc.w    w0, #0xf
     a10:	00 00 ea    	neg.w     w0, w0
     a12:	00 00 ea    	neg.w     w0, w0
     a14:	4f 00 de    	lsr.w     w0, #0xf, w0
     a16:	cd 02 37    	bra       0xfb2 <.L120>

00000a18 <.L23>:
     a18:	c4 1d 8a    	mov.w     w4, 0x43b8
     a1a:	16 02 a8    	bset.b    0x216, #0x0
     a1c:	00 1d 82    	mov.w     0x43a0, w0
     a1e:	00 00 e8    	inc.w     w0, w0
     a20:	00 1d 8a    	mov.w     w0, 0x43a0
     a22:	ca 02 37    	bra       0xfb8 <.L124>

00000a24 <.L24>:
     a24:	c4 1d 8a    	mov.w     w4, 0x43b8
     a26:	e0 0e 20    	mov.w     #0xee, w0
     a28:	90 10 88    	mov.w     w0, 0x212
     a2a:	00 1d 82    	mov.w     0x43a0, w0
     a2c:	00 00 e8    	inc.w     w0, w0
     a2e:	00 1d 8a    	mov.w     w0, 0x43a0
     a30:	c3 02 37    	bra       0xfb8 <.L124>

00000a32 <.L25>:
     a32:	c4 1d 8a    	mov.w     w4, 0x43b8
     a34:	60 0f 20    	mov.w     #0xf6, w0
     a36:	90 10 88    	mov.w     w0, 0x212
     a38:	00 1d 82    	mov.w     0x43a0, w0
     a3a:	00 00 e8    	inc.w     w0, w0
     a3c:	00 1d 8a    	mov.w     w0, 0x43a0
     a3e:	bc 02 37    	bra       0xfb8 <.L124>

00000a40 <.L26>:
     a40:	c4 1d 8a    	mov.w     w4, 0x43b8
     a42:	16 22 a8    	bset.b    0x216, #0x1
     a44:	00 1d 82    	mov.w     0x43a0, w0
     a46:	00 00 e8    	inc.w     w0, w0
     a48:	00 1d 8a    	mov.w     w0, 0x43a0
     a4a:	b6 02 37    	bra       0xfb8 <.L124>

00000a4c <.L27>:
     a4c:	c4 1d 8a    	mov.w     w4, 0x43b8
     a4e:	f0 0e 20    	mov.w     #0xef, w0
     a50:	90 10 88    	mov.w     w0, 0x212
     a52:	00 1d 82    	mov.w     0x43a0, w0
     a54:	00 00 e8    	inc.w     w0, w0
     a56:	00 1d 8a    	mov.w     w0, 0x43a0
     a58:	af 02 37    	bra       0xfb8 <.L124>

00000a5a <.L28>:
     a5a:	c4 1d 8a    	mov.w     w4, 0x43b8
     a5c:	16 62 a8    	bset.b    0x216, #0x3
     a5e:	00 1d 82    	mov.w     0x43a0, w0
     a60:	00 00 e8    	inc.w     w0, w0
     a62:	00 1d 8a    	mov.w     w0, 0x43a0
     a64:	a9 02 37    	bra       0xfb8 <.L124>

00000a66 <.L29>:
     a66:	c4 1d 8a    	mov.w     w4, 0x43b8
     a68:	81 10 80    	mov.w     0x210, w1
     a6a:	e0 3b 24    	mov.w     #0x43be, w0
     a6c:	01 48 78    	mov.b     w1, [w0]
     a6e:	16 a2 a9    	bclr.b    0x216, #0x5
     a70:	16 82 a8    	bset.b    0x216, #0x4
     a72:	00 1d 82    	mov.w     0x43a0, w0
     a74:	00 00 e8    	inc.w     w0, w0
     a76:	00 1d 8a    	mov.w     w0, 0x43a0
     a78:	9f 02 37    	bra       0xfb8 <.L124>

00000a7a <.L30>:
     a7a:	c4 1d 8a    	mov.w     w4, 0x43b8
     a7c:	16 62 a8    	bset.b    0x216, #0x3
     a7e:	00 1d 82    	mov.w     0x43a0, w0
     a80:	00 00 e8    	inc.w     w0, w0
     a82:	00 1d 8a    	mov.w     w0, 0x43a0
     a84:	99 02 37    	bra       0xfb8 <.L124>

00000a86 <.L31>:
     a86:	c4 1d 8a    	mov.w     w4, 0x43b8
     a88:	81 10 80    	mov.w     0x210, w1
     a8a:	f0 3b 24    	mov.w     #0x43bf, w0
     a8c:	01 48 78    	mov.b     w1, [w0]
     a8e:	16 a2 a8    	bset.b    0x216, #0x5
     a90:	16 82 a8    	bset.b    0x216, #0x4
     a92:	00 1d 82    	mov.w     0x43a0, w0
     a94:	00 00 e8    	inc.w     w0, w0
     a96:	00 1d 8a    	mov.w     w0, 0x43a0
     a98:	8f 02 37    	bra       0xfb8 <.L124>

00000a9a <.L32>:
     a9a:	c4 1d 8a    	mov.w     w4, 0x43b8
     a9c:	16 42 a8    	bset.b    0x216, #0x2
     a9e:	00 1d 82    	mov.w     0x43a0, w0
     aa0:	00 00 e8    	inc.w     w0, w0
     aa2:	00 1d 8a    	mov.w     w0, 0x43a0
     aa4:	89 02 37    	bra       0xfb8 <.L124>

00000aa6 <.L33>:
     aa6:	c4 1d 8a    	mov.w     w4, 0x43b8
     aa8:	16 02 a8    	bset.b    0x216, #0x0
     aaa:	00 1d 82    	mov.w     0x43a0, w0
     aac:	00 00 e8    	inc.w     w0, w0
     aae:	00 1d 8a    	mov.w     w0, 0x43a0
     ab0:	83 02 37    	bra       0xfb8 <.L124>

00000ab2 <.L34>:
     ab2:	c4 1d 8a    	mov.w     w4, 0x43b8
     ab4:	e0 0e 20    	mov.w     #0xee, w0
     ab6:	90 10 88    	mov.w     w0, 0x212
     ab8:	00 1d 82    	mov.w     0x43a0, w0
     aba:	00 00 e8    	inc.w     w0, w0
     abc:	00 1d 8a    	mov.w     w0, 0x43a0
     abe:	7c 02 37    	bra       0xfb8 <.L124>

00000ac0 <.L35>:
     ac0:	c4 1d 8a    	mov.w     w4, 0x43b8
     ac2:	40 0f 20    	mov.w     #0xf4, w0
     ac4:	90 10 88    	mov.w     w0, 0x212
     ac6:	00 1d 82    	mov.w     0x43a0, w0
     ac8:	00 00 e8    	inc.w     w0, w0
     aca:	00 1d 8a    	mov.w     w0, 0x43a0
     acc:	75 02 37    	bra       0xfb8 <.L124>

00000ace <.L36>:
     ace:	c4 1d 8a    	mov.w     w4, 0x43b8
     ad0:	e0 02 20    	mov.w     #0x2e, w0
     ad2:	90 10 88    	mov.w     w0, 0x212
     ad4:	00 1d 82    	mov.w     0x43a0, w0
     ad6:	00 00 e8    	inc.w     w0, w0
     ad8:	00 1d 8a    	mov.w     w0, 0x43a0
     ada:	6e 02 37    	bra       0xfb8 <.L124>

00000adc <.L37>:
     adc:	c4 1d 8a    	mov.w     w4, 0x43b8
     ade:	16 42 a8    	bset.b    0x216, #0x2
     ae0:	00 1d 82    	mov.w     0x43a0, w0
     ae2:	00 00 e8    	inc.w     w0, w0
     ae4:	00 1d 8a    	mov.w     w0, 0x43a0
     ae6:	68 02 37    	bra       0xfb8 <.L124>

00000ae8 <.L38>:
     ae8:	25 1d 8a    	mov.w     w5, 0x43a4
     aea:	05 1d 8a    	mov.w     w5, 0x43a0
     aec:	16 00 6a    	xor.w     w4, [w6], w0
     aee:	00 f0 a7    	btsc.w    w0, #0xf
     af0:	00 00 ea    	neg.w     w0, w0
     af2:	00 00 ea    	neg.w     w0, w0
     af4:	4f 00 de    	lsr.w     w0, #0xf, w0
     af6:	5d 02 37    	bra       0xfb2 <.L120>

00000af8 <.L39>:
     af8:	c4 1d 8a    	mov.w     w4, 0x43b8
     afa:	16 02 a8    	bset.b    0x216, #0x0
     afc:	00 1d 82    	mov.w     0x43a0, w0
     afe:	00 00 e8    	inc.w     w0, w0
     b00:	00 1d 8a    	mov.w     w0, 0x43a0
     b02:	5a 02 37    	bra       0xfb8 <.L124>

00000b04 <.L40>:
     b04:	c4 1d 8a    	mov.w     w4, 0x43b8
     b06:	e0 0e 20    	mov.w     #0xee, w0
     b08:	90 10 88    	mov.w     w0, 0x212
     b0a:	00 1d 82    	mov.w     0x43a0, w0
     b0c:	00 00 e8    	inc.w     w0, w0
     b0e:	00 1d 8a    	mov.w     w0, 0x43a0
     b10:	53 02 37    	bra       0xfb8 <.L124>

00000b12 <.L41>:
     b12:	c4 1d 8a    	mov.w     w4, 0x43b8
     b14:	a0 0a 20    	mov.w     #0xaa, w0
     b16:	90 10 88    	mov.w     w0, 0x212
     b18:	00 1d 82    	mov.w     0x43a0, w0
     b1a:	00 00 e8    	inc.w     w0, w0
     b1c:	00 1d 8a    	mov.w     w0, 0x43a0
     b1e:	4c 02 37    	bra       0xfb8 <.L124>

00000b20 <.L42>:
     b20:	c4 1d 8a    	mov.w     w4, 0x43b8
     b22:	16 22 a8    	bset.b    0x216, #0x1
     b24:	00 1d 82    	mov.w     0x43a0, w0
     b26:	00 00 e8    	inc.w     w0, w0
     b28:	00 1d 8a    	mov.w     w0, 0x43a0
     b2a:	46 02 37    	bra       0xfb8 <.L124>

00000b2c <.L43>:
     b2c:	c4 1d 8a    	mov.w     w4, 0x43b8
     b2e:	f0 0e 20    	mov.w     #0xef, w0
     b30:	90 10 88    	mov.w     w0, 0x212
     b32:	00 1d 82    	mov.w     0x43a0, w0
     b34:	00 00 e8    	inc.w     w0, w0
     b36:	00 1d 8a    	mov.w     w0, 0x43a0
     b38:	3f 02 37    	bra       0xfb8 <.L124>

00000b3a <.L44>:
     b3a:	c4 1d 8a    	mov.w     w4, 0x43b8
     b3c:	16 62 a8    	bset.b    0x216, #0x3
     b3e:	00 1d 82    	mov.w     0x43a0, w0
     b40:	00 00 e8    	inc.w     w0, w0
     b42:	00 1d 8a    	mov.w     w0, 0x43a0
     b44:	39 02 37    	bra       0xfb8 <.L124>

00000b46 <.L45>:
     b46:	c4 1d 8a    	mov.w     w4, 0x43b8
     b48:	81 10 80    	mov.w     0x210, w1
     b4a:	00 3c 24    	mov.w     #0x43c0, w0
     b4c:	01 48 78    	mov.b     w1, [w0]
     b4e:	16 a2 a9    	bclr.b    0x216, #0x5
     b50:	16 82 a8    	bset.b    0x216, #0x4
     b52:	00 1d 82    	mov.w     0x43a0, w0
     b54:	00 00 e8    	inc.w     w0, w0
     b56:	00 1d 8a    	mov.w     w0, 0x43a0
     b58:	2f 02 37    	bra       0xfb8 <.L124>

00000b5a <.L46>:
     b5a:	c4 1d 8a    	mov.w     w4, 0x43b8
     b5c:	16 62 a8    	bset.b    0x216, #0x3
     b5e:	00 1d 82    	mov.w     0x43a0, w0
     b60:	00 00 e8    	inc.w     w0, w0
     b62:	00 1d 8a    	mov.w     w0, 0x43a0
     b64:	29 02 37    	bra       0xfb8 <.L124>

00000b66 <.L47>:
     b66:	c4 1d 8a    	mov.w     w4, 0x43b8
     b68:	81 10 80    	mov.w     0x210, w1
     b6a:	10 3c 24    	mov.w     #0x43c1, w0
     b6c:	01 48 78    	mov.b     w1, [w0]
     b6e:	16 a2 a9    	bclr.b    0x216, #0x5
     b70:	16 82 a8    	bset.b    0x216, #0x4
     b72:	00 1d 82    	mov.w     0x43a0, w0
     b74:	00 00 e8    	inc.w     w0, w0
     b76:	00 1d 8a    	mov.w     w0, 0x43a0
     b78:	1f 02 37    	bra       0xfb8 <.L124>

00000b7a <.L48>:
     b7a:	c4 1d 8a    	mov.w     w4, 0x43b8
     b7c:	16 62 a8    	bset.b    0x216, #0x3
     b7e:	00 1d 82    	mov.w     0x43a0, w0
     b80:	00 00 e8    	inc.w     w0, w0
     b82:	00 1d 8a    	mov.w     w0, 0x43a0
     b84:	19 02 37    	bra       0xfb8 <.L124>

00000b86 <.L49>:
     b86:	c4 1d 8a    	mov.w     w4, 0x43b8
     b88:	81 10 80    	mov.w     0x210, w1
     b8a:	20 3c 24    	mov.w     #0x43c2, w0
     b8c:	01 48 78    	mov.b     w1, [w0]
     b8e:	16 a2 a9    	bclr.b    0x216, #0x5
     b90:	16 82 a8    	bset.b    0x216, #0x4
     b92:	00 1d 82    	mov.w     0x43a0, w0
     b94:	00 00 e8    	inc.w     w0, w0
     b96:	00 1d 8a    	mov.w     w0, 0x43a0
     b98:	0f 02 37    	bra       0xfb8 <.L124>

00000b9a <.L50>:
     b9a:	c4 1d 8a    	mov.w     w4, 0x43b8
     b9c:	16 62 a8    	bset.b    0x216, #0x3
     b9e:	00 1d 82    	mov.w     0x43a0, w0
     ba0:	00 00 e8    	inc.w     w0, w0
     ba2:	00 1d 8a    	mov.w     w0, 0x43a0
     ba4:	09 02 37    	bra       0xfb8 <.L124>

00000ba6 <.L51>:
     ba6:	c4 1d 8a    	mov.w     w4, 0x43b8
     ba8:	81 10 80    	mov.w     0x210, w1
     baa:	30 3c 24    	mov.w     #0x43c3, w0
     bac:	01 48 78    	mov.b     w1, [w0]
     bae:	16 a2 a9    	bclr.b    0x216, #0x5
     bb0:	16 82 a8    	bset.b    0x216, #0x4
     bb2:	00 1d 82    	mov.w     0x43a0, w0
     bb4:	00 00 e8    	inc.w     w0, w0
     bb6:	00 1d 8a    	mov.w     w0, 0x43a0
     bb8:	ff 01 37    	bra       0xfb8 <.L124>

00000bba <.L52>:
     bba:	c4 1d 8a    	mov.w     w4, 0x43b8
     bbc:	16 62 a8    	bset.b    0x216, #0x3
     bbe:	00 1d 82    	mov.w     0x43a0, w0
     bc0:	00 00 e8    	inc.w     w0, w0
     bc2:	00 1d 8a    	mov.w     w0, 0x43a0
     bc4:	f9 01 37    	bra       0xfb8 <.L124>

00000bc6 <.L53>:
     bc6:	c4 1d 8a    	mov.w     w4, 0x43b8
     bc8:	81 10 80    	mov.w     0x210, w1
     bca:	40 3c 24    	mov.w     #0x43c4, w0
     bcc:	01 48 78    	mov.b     w1, [w0]
     bce:	16 a2 a9    	bclr.b    0x216, #0x5
     bd0:	16 82 a8    	bset.b    0x216, #0x4
     bd2:	00 1d 82    	mov.w     0x43a0, w0
     bd4:	00 00 e8    	inc.w     w0, w0
     bd6:	00 1d 8a    	mov.w     w0, 0x43a0
     bd8:	ef 01 37    	bra       0xfb8 <.L124>

00000bda <.L54>:
     bda:	c4 1d 8a    	mov.w     w4, 0x43b8
     bdc:	16 62 a8    	bset.b    0x216, #0x3
     bde:	00 1d 82    	mov.w     0x43a0, w0
     be0:	00 00 e8    	inc.w     w0, w0
     be2:	00 1d 8a    	mov.w     w0, 0x43a0
     be4:	e9 01 37    	bra       0xfb8 <.L124>

00000be6 <.L55>:
     be6:	c4 1d 8a    	mov.w     w4, 0x43b8
     be8:	81 10 80    	mov.w     0x210, w1
     bea:	50 3c 24    	mov.w     #0x43c5, w0
     bec:	01 48 78    	mov.b     w1, [w0]
     bee:	16 a2 a9    	bclr.b    0x216, #0x5
     bf0:	16 82 a8    	bset.b    0x216, #0x4
     bf2:	00 1d 82    	mov.w     0x43a0, w0
     bf4:	00 00 e8    	inc.w     w0, w0
     bf6:	00 1d 8a    	mov.w     w0, 0x43a0
     bf8:	df 01 37    	bra       0xfb8 <.L124>

00000bfa <.L56>:
     bfa:	c4 1d 8a    	mov.w     w4, 0x43b8
     bfc:	16 62 a8    	bset.b    0x216, #0x3
     bfe:	00 1d 82    	mov.w     0x43a0, w0
     c00:	00 00 e8    	inc.w     w0, w0
     c02:	00 1d 8a    	mov.w     w0, 0x43a0
     c04:	d9 01 37    	bra       0xfb8 <.L124>

00000c06 <.L57>:
     c06:	c4 1d 8a    	mov.w     w4, 0x43b8
     c08:	81 10 80    	mov.w     0x210, w1
     c0a:	60 3c 24    	mov.w     #0x43c6, w0
     c0c:	01 48 78    	mov.b     w1, [w0]
     c0e:	16 a2 a9    	bclr.b    0x216, #0x5
     c10:	16 82 a8    	bset.b    0x216, #0x4
     c12:	00 1d 82    	mov.w     0x43a0, w0
     c14:	00 00 e8    	inc.w     w0, w0
     c16:	00 1d 8a    	mov.w     w0, 0x43a0
     c18:	cf 01 37    	bra       0xfb8 <.L124>

00000c1a <.L58>:
     c1a:	c4 1d 8a    	mov.w     w4, 0x43b8
     c1c:	16 62 a8    	bset.b    0x216, #0x3
     c1e:	00 1d 82    	mov.w     0x43a0, w0
     c20:	00 00 e8    	inc.w     w0, w0
     c22:	00 1d 8a    	mov.w     w0, 0x43a0
     c24:	c9 01 37    	bra       0xfb8 <.L124>

00000c26 <.L59>:
     c26:	c4 1d 8a    	mov.w     w4, 0x43b8
     c28:	81 10 80    	mov.w     0x210, w1
     c2a:	70 3c 24    	mov.w     #0x43c7, w0
     c2c:	01 48 78    	mov.b     w1, [w0]
     c2e:	16 a2 a9    	bclr.b    0x216, #0x5
     c30:	16 82 a8    	bset.b    0x216, #0x4
     c32:	00 1d 82    	mov.w     0x43a0, w0
     c34:	00 00 e8    	inc.w     w0, w0
     c36:	00 1d 8a    	mov.w     w0, 0x43a0
     c38:	bf 01 37    	bra       0xfb8 <.L124>

00000c3a <.L60>:
     c3a:	c4 1d 8a    	mov.w     w4, 0x43b8
     c3c:	16 62 a8    	bset.b    0x216, #0x3
     c3e:	00 1d 82    	mov.w     0x43a0, w0
     c40:	00 00 e8    	inc.w     w0, w0
     c42:	00 1d 8a    	mov.w     w0, 0x43a0
     c44:	b9 01 37    	bra       0xfb8 <.L124>

00000c46 <.L61>:
     c46:	c4 1d 8a    	mov.w     w4, 0x43b8
     c48:	81 10 80    	mov.w     0x210, w1
     c4a:	80 3c 24    	mov.w     #0x43c8, w0
     c4c:	01 48 78    	mov.b     w1, [w0]
     c4e:	16 a2 a9    	bclr.b    0x216, #0x5
     c50:	16 82 a8    	bset.b    0x216, #0x4
     c52:	00 1d 82    	mov.w     0x43a0, w0
     c54:	00 00 e8    	inc.w     w0, w0
     c56:	00 1d 8a    	mov.w     w0, 0x43a0
     c58:	af 01 37    	bra       0xfb8 <.L124>

00000c5a <.L62>:
     c5a:	c4 1d 8a    	mov.w     w4, 0x43b8
     c5c:	16 62 a8    	bset.b    0x216, #0x3
     c5e:	00 1d 82    	mov.w     0x43a0, w0
     c60:	00 00 e8    	inc.w     w0, w0
     c62:	00 1d 8a    	mov.w     w0, 0x43a0
     c64:	a9 01 37    	bra       0xfb8 <.L124>

00000c66 <.L63>:
     c66:	c4 1d 8a    	mov.w     w4, 0x43b8
     c68:	81 10 80    	mov.w     0x210, w1
     c6a:	90 3c 24    	mov.w     #0x43c9, w0
     c6c:	01 48 78    	mov.b     w1, [w0]
     c6e:	16 a2 a9    	bclr.b    0x216, #0x5
     c70:	16 82 a8    	bset.b    0x216, #0x4
     c72:	00 1d 82    	mov.w     0x43a0, w0
     c74:	00 00 e8    	inc.w     w0, w0
     c76:	00 1d 8a    	mov.w     w0, 0x43a0
     c78:	9f 01 37    	bra       0xfb8 <.L124>

00000c7a <.L64>:
     c7a:	c4 1d 8a    	mov.w     w4, 0x43b8
     c7c:	16 62 a8    	bset.b    0x216, #0x3
     c7e:	00 1d 82    	mov.w     0x43a0, w0
     c80:	00 00 e8    	inc.w     w0, w0
     c82:	00 1d 8a    	mov.w     w0, 0x43a0
     c84:	99 01 37    	bra       0xfb8 <.L124>

00000c86 <.L65>:
     c86:	c4 1d 8a    	mov.w     w4, 0x43b8
     c88:	81 10 80    	mov.w     0x210, w1
     c8a:	a0 3c 24    	mov.w     #0x43ca, w0
     c8c:	01 48 78    	mov.b     w1, [w0]
     c8e:	16 a2 a9    	bclr.b    0x216, #0x5
     c90:	16 82 a8    	bset.b    0x216, #0x4
     c92:	00 1d 82    	mov.w     0x43a0, w0
     c94:	00 00 e8    	inc.w     w0, w0
     c96:	00 1d 8a    	mov.w     w0, 0x43a0
     c98:	8f 01 37    	bra       0xfb8 <.L124>

00000c9a <.L66>:
     c9a:	c4 1d 8a    	mov.w     w4, 0x43b8
     c9c:	16 62 a8    	bset.b    0x216, #0x3
     c9e:	00 1d 82    	mov.w     0x43a0, w0
     ca0:	00 00 e8    	inc.w     w0, w0
     ca2:	00 1d 8a    	mov.w     w0, 0x43a0
     ca4:	89 01 37    	bra       0xfb8 <.L124>

00000ca6 <.L67>:
     ca6:	c4 1d 8a    	mov.w     w4, 0x43b8
     ca8:	81 10 80    	mov.w     0x210, w1
     caa:	b0 3c 24    	mov.w     #0x43cb, w0
     cac:	01 48 78    	mov.b     w1, [w0]
     cae:	16 a2 a9    	bclr.b    0x216, #0x5
     cb0:	16 82 a8    	bset.b    0x216, #0x4
     cb2:	00 1d 82    	mov.w     0x43a0, w0
     cb4:	00 00 e8    	inc.w     w0, w0
     cb6:	00 1d 8a    	mov.w     w0, 0x43a0
     cb8:	7f 01 37    	bra       0xfb8 <.L124>

00000cba <.L68>:
     cba:	c4 1d 8a    	mov.w     w4, 0x43b8
     cbc:	16 62 a8    	bset.b    0x216, #0x3
     cbe:	00 1d 82    	mov.w     0x43a0, w0
     cc0:	00 00 e8    	inc.w     w0, w0
     cc2:	00 1d 8a    	mov.w     w0, 0x43a0
     cc4:	79 01 37    	bra       0xfb8 <.L124>

00000cc6 <.L69>:
     cc6:	c4 1d 8a    	mov.w     w4, 0x43b8
     cc8:	81 10 80    	mov.w     0x210, w1
     cca:	c0 3c 24    	mov.w     #0x43cc, w0
     ccc:	01 48 78    	mov.b     w1, [w0]
     cce:	16 a2 a9    	bclr.b    0x216, #0x5
     cd0:	16 82 a8    	bset.b    0x216, #0x4
     cd2:	00 1d 82    	mov.w     0x43a0, w0
     cd4:	00 00 e8    	inc.w     w0, w0
     cd6:	00 1d 8a    	mov.w     w0, 0x43a0
     cd8:	6f 01 37    	bra       0xfb8 <.L124>

00000cda <.L70>:
     cda:	c4 1d 8a    	mov.w     w4, 0x43b8
     cdc:	16 62 a8    	bset.b    0x216, #0x3
     cde:	00 1d 82    	mov.w     0x43a0, w0
     ce0:	00 00 e8    	inc.w     w0, w0
     ce2:	00 1d 8a    	mov.w     w0, 0x43a0
     ce4:	69 01 37    	bra       0xfb8 <.L124>

00000ce6 <.L71>:
     ce6:	c4 1d 8a    	mov.w     w4, 0x43b8
     ce8:	81 10 80    	mov.w     0x210, w1
     cea:	d0 3c 24    	mov.w     #0x43cd, w0
     cec:	01 48 78    	mov.b     w1, [w0]
     cee:	16 a2 a9    	bclr.b    0x216, #0x5
     cf0:	16 82 a8    	bset.b    0x216, #0x4
     cf2:	00 1d 82    	mov.w     0x43a0, w0
     cf4:	00 00 e8    	inc.w     w0, w0
     cf6:	00 1d 8a    	mov.w     w0, 0x43a0
     cf8:	5f 01 37    	bra       0xfb8 <.L124>

00000cfa <.L72>:
     cfa:	c4 1d 8a    	mov.w     w4, 0x43b8
     cfc:	16 62 a8    	bset.b    0x216, #0x3
     cfe:	00 1d 82    	mov.w     0x43a0, w0
     d00:	00 00 e8    	inc.w     w0, w0
     d02:	00 1d 8a    	mov.w     w0, 0x43a0
     d04:	59 01 37    	bra       0xfb8 <.L124>

00000d06 <.L73>:
     d06:	c4 1d 8a    	mov.w     w4, 0x43b8
     d08:	81 10 80    	mov.w     0x210, w1
     d0a:	e0 3c 24    	mov.w     #0x43ce, w0
     d0c:	01 48 78    	mov.b     w1, [w0]
     d0e:	16 a2 a9    	bclr.b    0x216, #0x5
     d10:	16 82 a8    	bset.b    0x216, #0x4
     d12:	00 1d 82    	mov.w     0x43a0, w0
     d14:	00 00 e8    	inc.w     w0, w0
     d16:	00 1d 8a    	mov.w     w0, 0x43a0
     d18:	4f 01 37    	bra       0xfb8 <.L124>

00000d1a <.L74>:
     d1a:	c4 1d 8a    	mov.w     w4, 0x43b8
     d1c:	16 62 a8    	bset.b    0x216, #0x3
     d1e:	00 1d 82    	mov.w     0x43a0, w0
     d20:	00 00 e8    	inc.w     w0, w0
     d22:	00 1d 8a    	mov.w     w0, 0x43a0
     d24:	49 01 37    	bra       0xfb8 <.L124>

00000d26 <.L75>:
     d26:	c4 1d 8a    	mov.w     w4, 0x43b8
     d28:	81 10 80    	mov.w     0x210, w1
     d2a:	f0 3c 24    	mov.w     #0x43cf, w0
     d2c:	01 48 78    	mov.b     w1, [w0]
     d2e:	16 a2 a9    	bclr.b    0x216, #0x5
     d30:	16 82 a8    	bset.b    0x216, #0x4
     d32:	00 1d 82    	mov.w     0x43a0, w0
     d34:	00 00 e8    	inc.w     w0, w0
     d36:	00 1d 8a    	mov.w     w0, 0x43a0
     d38:	3f 01 37    	bra       0xfb8 <.L124>

00000d3a <.L76>:
     d3a:	c4 1d 8a    	mov.w     w4, 0x43b8
     d3c:	16 62 a8    	bset.b    0x216, #0x3
     d3e:	00 1d 82    	mov.w     0x43a0, w0
     d40:	00 00 e8    	inc.w     w0, w0
     d42:	00 1d 8a    	mov.w     w0, 0x43a0
     d44:	39 01 37    	bra       0xfb8 <.L124>

00000d46 <.L77>:
     d46:	c4 1d 8a    	mov.w     w4, 0x43b8
     d48:	81 10 80    	mov.w     0x210, w1
     d4a:	00 3d 24    	mov.w     #0x43d0, w0
     d4c:	01 48 78    	mov.b     w1, [w0]
     d4e:	16 a2 a9    	bclr.b    0x216, #0x5
     d50:	16 82 a8    	bset.b    0x216, #0x4
     d52:	00 1d 82    	mov.w     0x43a0, w0
     d54:	00 00 e8    	inc.w     w0, w0
     d56:	00 1d 8a    	mov.w     w0, 0x43a0
     d58:	2f 01 37    	bra       0xfb8 <.L124>

00000d5a <.L78>:
     d5a:	c4 1d 8a    	mov.w     w4, 0x43b8
     d5c:	16 62 a8    	bset.b    0x216, #0x3
     d5e:	00 1d 82    	mov.w     0x43a0, w0
     d60:	00 00 e8    	inc.w     w0, w0
     d62:	00 1d 8a    	mov.w     w0, 0x43a0
     d64:	29 01 37    	bra       0xfb8 <.L124>

00000d66 <.L79>:
     d66:	c4 1d 8a    	mov.w     w4, 0x43b8
     d68:	81 10 80    	mov.w     0x210, w1
     d6a:	10 3d 24    	mov.w     #0x43d1, w0
     d6c:	01 48 78    	mov.b     w1, [w0]
     d6e:	16 a2 a9    	bclr.b    0x216, #0x5
     d70:	16 82 a8    	bset.b    0x216, #0x4
     d72:	00 1d 82    	mov.w     0x43a0, w0
     d74:	00 00 e8    	inc.w     w0, w0
     d76:	00 1d 8a    	mov.w     w0, 0x43a0
     d78:	1f 01 37    	bra       0xfb8 <.L124>

00000d7a <.L80>:
     d7a:	c4 1d 8a    	mov.w     w4, 0x43b8
     d7c:	16 62 a8    	bset.b    0x216, #0x3
     d7e:	00 1d 82    	mov.w     0x43a0, w0
     d80:	00 00 e8    	inc.w     w0, w0
     d82:	00 1d 8a    	mov.w     w0, 0x43a0
     d84:	19 01 37    	bra       0xfb8 <.L124>

00000d86 <.L81>:
     d86:	c4 1d 8a    	mov.w     w4, 0x43b8
     d88:	81 10 80    	mov.w     0x210, w1
     d8a:	20 3d 24    	mov.w     #0x43d2, w0
     d8c:	01 48 78    	mov.b     w1, [w0]
     d8e:	16 a2 a9    	bclr.b    0x216, #0x5
     d90:	16 82 a8    	bset.b    0x216, #0x4
     d92:	00 1d 82    	mov.w     0x43a0, w0
     d94:	00 00 e8    	inc.w     w0, w0
     d96:	00 1d 8a    	mov.w     w0, 0x43a0
     d98:	0f 01 37    	bra       0xfb8 <.L124>

00000d9a <.L82>:
     d9a:	c4 1d 8a    	mov.w     w4, 0x43b8
     d9c:	16 62 a8    	bset.b    0x216, #0x3
     d9e:	00 1d 82    	mov.w     0x43a0, w0
     da0:	00 00 e8    	inc.w     w0, w0
     da2:	00 1d 8a    	mov.w     w0, 0x43a0
     da4:	09 01 37    	bra       0xfb8 <.L124>

00000da6 <.L83>:
     da6:	c4 1d 8a    	mov.w     w4, 0x43b8
     da8:	81 10 80    	mov.w     0x210, w1
     daa:	30 3d 24    	mov.w     #0x43d3, w0
     dac:	01 48 78    	mov.b     w1, [w0]
     dae:	16 a2 a9    	bclr.b    0x216, #0x5
     db0:	16 82 a8    	bset.b    0x216, #0x4
     db2:	00 1d 82    	mov.w     0x43a0, w0
     db4:	00 00 e8    	inc.w     w0, w0
     db6:	00 1d 8a    	mov.w     w0, 0x43a0
     db8:	ff 00 37    	bra       0xfb8 <.L124>

00000dba <.L84>:
     dba:	c4 1d 8a    	mov.w     w4, 0x43b8
     dbc:	16 62 a8    	bset.b    0x216, #0x3
     dbe:	00 1d 82    	mov.w     0x43a0, w0
     dc0:	00 00 e8    	inc.w     w0, w0
     dc2:	00 1d 8a    	mov.w     w0, 0x43a0
     dc4:	f9 00 37    	bra       0xfb8 <.L124>

00000dc6 <.L85>:
     dc6:	c4 1d 8a    	mov.w     w4, 0x43b8
     dc8:	81 10 80    	mov.w     0x210, w1
     dca:	40 3d 24    	mov.w     #0x43d4, w0
     dcc:	01 48 78    	mov.b     w1, [w0]
     dce:	16 a2 a9    	bclr.b    0x216, #0x5
     dd0:	16 82 a8    	bset.b    0x216, #0x4
     dd2:	00 1d 82    	mov.w     0x43a0, w0
     dd4:	00 00 e8    	inc.w     w0, w0
     dd6:	00 1d 8a    	mov.w     w0, 0x43a0
     dd8:	ef 00 37    	bra       0xfb8 <.L124>

00000dda <.L86>:
     dda:	c4 1d 8a    	mov.w     w4, 0x43b8
     ddc:	16 62 a8    	bset.b    0x216, #0x3
     dde:	00 1d 82    	mov.w     0x43a0, w0
     de0:	00 00 e8    	inc.w     w0, w0
     de2:	00 1d 8a    	mov.w     w0, 0x43a0
     de4:	e9 00 37    	bra       0xfb8 <.L124>

00000de6 <.L87>:
     de6:	c4 1d 8a    	mov.w     w4, 0x43b8
     de8:	81 10 80    	mov.w     0x210, w1
     dea:	50 3d 24    	mov.w     #0x43d5, w0
     dec:	01 48 78    	mov.b     w1, [w0]
     dee:	16 a2 a8    	bset.b    0x216, #0x5
     df0:	16 82 a8    	bset.b    0x216, #0x4
     df2:	00 1d 82    	mov.w     0x43a0, w0
     df4:	00 00 e8    	inc.w     w0, w0
     df6:	00 1d 8a    	mov.w     w0, 0x43a0
     df8:	df 00 37    	bra       0xfb8 <.L124>

00000dfa <.L88>:
     dfa:	c4 1d 8a    	mov.w     w4, 0x43b8
     dfc:	16 42 a8    	bset.b    0x216, #0x2
     dfe:	00 1d 82    	mov.w     0x43a0, w0
     e00:	00 00 e8    	inc.w     w0, w0
     e02:	00 1d 8a    	mov.w     w0, 0x43a0
     e04:	d9 00 37    	bra       0xfb8 <.L124>

00000e06 <.L89>:
     e06:	35 1d 8a    	mov.w     w5, 0x43a6
     e08:	05 1d 8a    	mov.w     w5, 0x43a0
     e0a:	16 00 6a    	xor.w     w4, [w6], w0
     e0c:	00 f0 a7    	btsc.w    w0, #0xf
     e0e:	00 00 ea    	neg.w     w0, w0
     e10:	00 00 ea    	neg.w     w0, w0
     e12:	4f 00 de    	lsr.w     w0, #0xf, w0
     e14:	ce 00 37    	bra       0xfb2 <.L120>

00000e16 <.L90>:
     e16:	c4 1d 8a    	mov.w     w4, 0x43b8
     e18:	16 02 a8    	bset.b    0x216, #0x0
     e1a:	00 1d 82    	mov.w     0x43a0, w0
     e1c:	00 00 e8    	inc.w     w0, w0
     e1e:	00 1d 8a    	mov.w     w0, 0x43a0
     e20:	cb 00 37    	bra       0xfb8 <.L124>

00000e22 <.L91>:
     e22:	c4 1d 8a    	mov.w     w4, 0x43b8
     e24:	c0 03 20    	mov.w     #0x3c, w0
     e26:	90 10 88    	mov.w     w0, 0x212
     e28:	00 1d 82    	mov.w     0x43a0, w0
     e2a:	00 00 e8    	inc.w     w0, w0
     e2c:	00 1d 8a    	mov.w     w0, 0x43a0
     e2e:	c4 00 37    	bra       0xfb8 <.L124>

00000e30 <.L92>:
     e30:	c4 1d 8a    	mov.w     w4, 0x43b8
     e32:	30 00 20    	mov.w     #0x3, w0
     e34:	90 10 88    	mov.w     w0, 0x212
     e36:	00 1d 82    	mov.w     0x43a0, w0
     e38:	00 00 e8    	inc.w     w0, w0
     e3a:	00 1d 8a    	mov.w     w0, 0x43a0
     e3c:	bd 00 37    	bra       0xfb8 <.L124>

00000e3e <.L93>:
     e3e:	c4 1d 8a    	mov.w     w4, 0x43b8
     e40:	16 42 a8    	bset.b    0x216, #0x2
     e42:	00 1d 82    	mov.w     0x43a0, w0
     e44:	00 00 e8    	inc.w     w0, w0
     e46:	00 1d 8a    	mov.w     w0, 0x43a0
     e48:	b7 00 37    	bra       0xfb8 <.L124>

00000e4a <.L94>:
     e4a:	c4 1d 8a    	mov.w     w4, 0x43b8
     e4c:	16 02 a8    	bset.b    0x216, #0x0
     e4e:	00 1d 82    	mov.w     0x43a0, w0
     e50:	00 00 e8    	inc.w     w0, w0
     e52:	00 1d 8a    	mov.w     w0, 0x43a0
     e54:	b1 00 37    	bra       0xfb8 <.L124>

00000e56 <.L95>:
     e56:	c4 1d 8a    	mov.w     w4, 0x43b8
     e58:	d0 03 20    	mov.w     #0x3d, w0
     e5a:	90 10 88    	mov.w     w0, 0x212
     e5c:	00 1d 82    	mov.w     0x43a0, w0
     e5e:	00 00 e8    	inc.w     w0, w0
     e60:	00 1d 8a    	mov.w     w0, 0x43a0
     e62:	aa 00 37    	bra       0xfb8 <.L124>

00000e64 <.L96>:
     e64:	c4 1d 8a    	mov.w     w4, 0x43b8
     e66:	16 62 a8    	bset.b    0x216, #0x3
     e68:	00 1d 82    	mov.w     0x43a0, w0
     e6a:	00 00 e8    	inc.w     w0, w0
     e6c:	00 1d 8a    	mov.w     w0, 0x43a0
     e6e:	a4 00 37    	bra       0xfb8 <.L124>

00000e70 <.L97>:
     e70:	c4 1d 8a    	mov.w     w4, 0x43b8
     e72:	81 10 80    	mov.w     0x210, w1
     e74:	60 3d 24    	mov.w     #0x43d6, w0
     e76:	01 48 78    	mov.b     w1, [w0]
     e78:	16 a2 a9    	bclr.b    0x216, #0x5
     e7a:	16 82 a8    	bset.b    0x216, #0x4
     e7c:	00 1d 82    	mov.w     0x43a0, w0
     e7e:	00 00 e8    	inc.w     w0, w0
     e80:	00 1d 8a    	mov.w     w0, 0x43a0
     e82:	9a 00 37    	bra       0xfb8 <.L124>

00000e84 <.L98>:
     e84:	c4 1d 8a    	mov.w     w4, 0x43b8
     e86:	16 62 a8    	bset.b    0x216, #0x3
     e88:	00 1d 82    	mov.w     0x43a0, w0
     e8a:	00 00 e8    	inc.w     w0, w0
     e8c:	00 1d 8a    	mov.w     w0, 0x43a0
     e8e:	94 00 37    	bra       0xfb8 <.L124>

00000e90 <.L99>:
     e90:	c4 1d 8a    	mov.w     w4, 0x43b8
     e92:	81 10 80    	mov.w     0x210, w1
     e94:	70 3d 24    	mov.w     #0x43d7, w0
     e96:	01 48 78    	mov.b     w1, [w0]
     e98:	16 a2 a9    	bclr.b    0x216, #0x5
     e9a:	16 82 a8    	bset.b    0x216, #0x4
     e9c:	00 1d 82    	mov.w     0x43a0, w0
     e9e:	00 00 e8    	inc.w     w0, w0
     ea0:	00 1d 8a    	mov.w     w0, 0x43a0
     ea2:	8a 00 37    	bra       0xfb8 <.L124>

00000ea4 <.L100>:
     ea4:	c4 1d 8a    	mov.w     w4, 0x43b8
     ea6:	16 62 a8    	bset.b    0x216, #0x3
     ea8:	00 1d 82    	mov.w     0x43a0, w0
     eaa:	00 00 e8    	inc.w     w0, w0
     eac:	00 1d 8a    	mov.w     w0, 0x43a0
     eae:	84 00 37    	bra       0xfb8 <.L124>

00000eb0 <.L101>:
     eb0:	c4 1d 8a    	mov.w     w4, 0x43b8
     eb2:	81 10 80    	mov.w     0x210, w1
     eb4:	80 3d 24    	mov.w     #0x43d8, w0
     eb6:	01 48 78    	mov.b     w1, [w0]
     eb8:	16 a2 a9    	bclr.b    0x216, #0x5
     eba:	16 82 a8    	bset.b    0x216, #0x4
     ebc:	00 1d 82    	mov.w     0x43a0, w0
     ebe:	00 00 e8    	inc.w     w0, w0
     ec0:	00 1d 8a    	mov.w     w0, 0x43a0
     ec2:	7a 00 37    	bra       0xfb8 <.L124>

00000ec4 <.L102>:
     ec4:	c4 1d 8a    	mov.w     w4, 0x43b8
     ec6:	16 62 a8    	bset.b    0x216, #0x3
     ec8:	00 1d 82    	mov.w     0x43a0, w0
     eca:	00 00 e8    	inc.w     w0, w0
     ecc:	00 1d 8a    	mov.w     w0, 0x43a0
     ece:	74 00 37    	bra       0xfb8 <.L124>

00000ed0 <.L103>:
     ed0:	c4 1d 8a    	mov.w     w4, 0x43b8
     ed2:	81 10 80    	mov.w     0x210, w1
     ed4:	90 3d 24    	mov.w     #0x43d9, w0
     ed6:	01 48 78    	mov.b     w1, [w0]
     ed8:	16 a2 a9    	bclr.b    0x216, #0x5
     eda:	16 82 a8    	bset.b    0x216, #0x4
     edc:	00 1d 82    	mov.w     0x43a0, w0
     ede:	00 00 e8    	inc.w     w0, w0
     ee0:	00 1d 8a    	mov.w     w0, 0x43a0
     ee2:	6a 00 37    	bra       0xfb8 <.L124>

00000ee4 <.L104>:
     ee4:	c4 1d 8a    	mov.w     w4, 0x43b8
     ee6:	16 62 a8    	bset.b    0x216, #0x3
     ee8:	00 1d 82    	mov.w     0x43a0, w0
     eea:	00 00 e8    	inc.w     w0, w0
     eec:	00 1d 8a    	mov.w     w0, 0x43a0
     eee:	64 00 37    	bra       0xfb8 <.L124>

00000ef0 <.L105>:
     ef0:	c4 1d 8a    	mov.w     w4, 0x43b8
     ef2:	81 10 80    	mov.w     0x210, w1
     ef4:	a0 3d 24    	mov.w     #0x43da, w0
     ef6:	01 48 78    	mov.b     w1, [w0]
     ef8:	16 a2 a9    	bclr.b    0x216, #0x5
     efa:	16 82 a8    	bset.b    0x216, #0x4
     efc:	00 1d 82    	mov.w     0x43a0, w0
     efe:	00 00 e8    	inc.w     w0, w0
     f00:	00 1d 8a    	mov.w     w0, 0x43a0
     f02:	5a 00 37    	bra       0xfb8 <.L124>

00000f04 <.L106>:
     f04:	c4 1d 8a    	mov.w     w4, 0x43b8
     f06:	16 62 a8    	bset.b    0x216, #0x3
     f08:	00 1d 82    	mov.w     0x43a0, w0
     f0a:	00 00 e8    	inc.w     w0, w0
     f0c:	00 1d 8a    	mov.w     w0, 0x43a0
     f0e:	54 00 37    	bra       0xfb8 <.L124>

00000f10 <.L107>:
     f10:	c4 1d 8a    	mov.w     w4, 0x43b8
     f12:	81 10 80    	mov.w     0x210, w1
     f14:	b0 3d 24    	mov.w     #0x43db, w0
     f16:	01 48 78    	mov.b     w1, [w0]
     f18:	16 a2 a8    	bset.b    0x216, #0x5
     f1a:	16 82 a8    	bset.b    0x216, #0x4
     f1c:	00 1d 82    	mov.w     0x43a0, w0
     f1e:	00 00 e8    	inc.w     w0, w0
     f20:	00 1d 8a    	mov.w     w0, 0x43a0
     f22:	4a 00 37    	bra       0xfb8 <.L124>

00000f24 <.L108>:
     f24:	c4 1d 8a    	mov.w     w4, 0x43b8
     f26:	16 42 a8    	bset.b    0x216, #0x2
     f28:	00 1d 82    	mov.w     0x43a0, w0
     f2a:	00 00 e8    	inc.w     w0, w0
     f2c:	00 1d 8a    	mov.w     w0, 0x43a0
     f2e:	44 00 37    	bra       0xfb8 <.L124>

00000f30 <.L109>:
     f30:	45 1d 8a    	mov.w     w5, 0x43a8
     f32:	05 1d 8a    	mov.w     w5, 0x43a0
     f34:	16 00 6a    	xor.w     w4, [w6], w0
     f36:	00 f0 a7    	btsc.w    w0, #0xf
     f38:	00 00 ea    	neg.w     w0, w0
     f3a:	00 00 ea    	neg.w     w0, w0
     f3c:	4f 00 de    	lsr.w     w0, #0xf, w0
     f3e:	39 00 37    	bra       0xfb2 <.L120>

00000f40 <.L110>:
     f40:	c4 1d 8a    	mov.w     w4, 0x43b8
     f42:	16 02 a8    	bset.b    0x216, #0x0
     f44:	00 1d 82    	mov.w     0x43a0, w0
     f46:	00 00 e8    	inc.w     w0, w0
     f48:	00 1d 8a    	mov.w     w0, 0x43a0
     f4a:	36 00 37    	bra       0xfb8 <.L124>

00000f4c <.L111>:
     f4c:	c4 1d 8a    	mov.w     w4, 0x43b8
     f4e:	c0 03 20    	mov.w     #0x3c, w0
     f50:	90 10 88    	mov.w     w0, 0x212
     f52:	00 1d 82    	mov.w     0x43a0, w0
     f54:	00 00 e8    	inc.w     w0, w0
     f56:	00 1d 8a    	mov.w     w0, 0x43a0
     f58:	2f 00 37    	bra       0xfb8 <.L124>

00000f5a <.L112>:
     f5a:	c4 1d 8a    	mov.w     w4, 0x43b8
     f5c:	12 22 ef    	clr.w     0x212
     f5e:	00 1d 82    	mov.w     0x43a0, w0
     f60:	00 00 e8    	inc.w     w0, w0
     f62:	00 1d 8a    	mov.w     w0, 0x43a0
     f64:	29 00 37    	bra       0xfb8 <.L124>

00000f66 <.L113>:
     f66:	c4 1d 8a    	mov.w     w4, 0x43b8
     f68:	80 07 20    	mov.w     #0x78, w0
     f6a:	90 10 88    	mov.w     w0, 0x212
     f6c:	00 1d 82    	mov.w     0x43a0, w0
     f6e:	00 00 e8    	inc.w     w0, w0
     f70:	00 1d 8a    	mov.w     w0, 0x43a0
     f72:	22 00 37    	bra       0xfb8 <.L124>

00000f74 <.L114>:
     f74:	c4 1d 8a    	mov.w     w4, 0x43b8
     f76:	12 22 ef    	clr.w     0x212
     f78:	00 1d 82    	mov.w     0x43a0, w0
     f7a:	00 00 e8    	inc.w     w0, w0
     f7c:	00 1d 8a    	mov.w     w0, 0x43a0
     f7e:	1c 00 37    	bra       0xfb8 <.L124>

00000f80 <.L115>:
     f80:	c4 1d 8a    	mov.w     w4, 0x43b8
     f82:	12 22 ef    	clr.w     0x212
     f84:	00 1d 82    	mov.w     0x43a0, w0
     f86:	00 00 e8    	inc.w     w0, w0
     f88:	00 1d 8a    	mov.w     w0, 0x43a0
     f8a:	16 00 37    	bra       0xfb8 <.L124>

00000f8c <.L116>:
     f8c:	c4 1d 8a    	mov.w     w4, 0x43b8
     f8e:	16 42 a8    	bset.b    0x216, #0x2

00000f90 <.L0>:
     f90:	00 1d 82    	mov.w     0x43a0, w0
     f92:	00 00 e8    	inc.w     w0, w0
     f94:	00 1d 8a    	mov.w     w0, 0x43a0

00000f96 <.L0>:
     f96:	10 00 37    	bra       0xfb8 <.L124>

00000f98 <.L117>:
     f98:	55 1d 8a    	mov.w     w5, 0x43aa
     f9a:	05 1d 8a    	mov.w     w5, 0x43a0
     f9c:	16 00 6a    	xor.w     w4, [w6], w0
     f9e:	00 f0 a7    	btsc.w    w0, #0xf
     fa0:	00 00 ea    	neg.w     w0, w0
     fa2:	00 00 ea    	neg.w     w0, w0
     fa4:	4f 00 de    	lsr.w     w0, #0xf, w0
      break;
     fa6:	05 00 37    	bra       0xfb2 <.L120>

00000fa8 <.L2>:
     fa8:	c4 1d 8a    	mov.w     w4, 0x43b8

     default:                          /* Sequence finished */
      MCHP_I2C2_State = 0;             /* Should never happend */
     faa:	00 00 eb    	clr.w     w0
     fac:	00 1d 8a    	mov.w     w0, 0x43a0
      break;
     fae:	04 00 37    	bra       0xfb8 <.L124>

00000fb0 <.L125>:
     fb0:	05 02 78    	mov.w     w5, w4

00000fb2 <.L120>:
    }                                  /* End of switch case sequence*/
  } while (Continue == 1);             /* end do-While */
     fb2:	e1 4f 50    	sub.b     w0, #0x1, [w15]
     fb4:	1d fc 32    	bra       Z, 0x7f0 <.L122>
     fb6:	c4 1d 8a    	mov.w     w4, 0x43b8

00000fb8 <.L124>:

  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
     fb8:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
     fba:	50 10 e2    	cp0.w     0x1050
     fbc:	04 00 3a    	bra       NZ, 0xfc6 <.L1>
    T3CONbits.TON = 0;
     fbe:	13 e1 a9    	bclr.b    0x113, #0x7
     fc0:	02 00 37    	bra       0xfc6 <.L1>

00000fc2 <.L119>:
  }
}                                      /* Enf of interrupt */
     fc2:	c4 1d 8a    	mov.w     w4, 0x43b8
     fc4:	f9 ff 37    	bra       0xfb8 <.L124>

00000fc6 <.L1>:
     fc6:	34 00 f9    	pop       0x34
     fc8:	32 00 f9    	pop       0x32
     fca:	4f 04 78    	mov.w     [--w15], w8
     fcc:	4f 03 be    	mov.d     [--w15], w6
     fce:	4f 02 be    	mov.d     [--w15], w4
     fd0:	4f 01 be    	mov.d     [--w15], w2
     fd2:	4f 00 be    	mov.d     [--w15], w0
     fd4:	00 40 06    	retfie    

00000fd6 <__IC1Interrupt>:
volatile uint16_T MCHP_ic8up;

/* Implement Input Capture Interrupts if required */
void __attribute__((__interrupt__,__auto_psv__)) _IC1Interrupt(void)
{
     fd6:	80 9f be    	mov.d     w0, [w15++]
     fd8:	32 00 f8    	push      0x32
     fda:	34 00 f8    	push      0x34
     fdc:	10 00 20    	mov.w     #0x1, w0
     fde:	a0 01 88    	mov.w     w0, 0x34
     fe0:	00 20 20    	mov.w     #0x200, w0
     fe2:	90 01 88    	mov.w     w0, 0x32
     fe4:	00 00 00    	nop       
  static uint16_T IC1BUF_Old;
  uint16_T IC1BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
     fe6:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
     fe8:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC1CON1bits.ICBNE == 1)
     fea:	40 61 ab    	btst.b    0x140, #0x3
     fec:	03 00 32    	bra       Z, 0xff4 <.L2> <.LASF41>

00000fee <.L7>:
    IC1BUF_New = IC1BUF;               /* take the last value */
     fee:	20 0a 80    	mov.w     0x144, w0
     ff0:	40 61 ab    	btst.b    0x140, #0x3
     ff2:	fd ff 3a    	bra       NZ, 0xfee <.L7>

00000ff4 <.L2>:
  if (IC1CON1 & 1)                     /* This is a rising edge */
     ff4:	40 01 ab    	btst.b    0x140, #0x0
     ff6:	02 00 32    	bra       Z, 0xffc <.L4>
  {
    IC1CON1 &= 0xFFFE;                 /* detect next falling edge */
     ff8:	40 01 a9    	bclr.b    0x140, #0x0
     ffa:	04 00 37    	bra       0x1004 <.L5>

00000ffc <.L4>:
  } else                               /* falling edge */
  {
    IC1CON1 |= 1;                      /* detect next rising edge */
     ffc:	40 01 a8    	bset.b    0x140, #0x0
    MCHP_ic1up = IC1BUF_New - IC1BUF_Old;/* Compute Up time */
     ffe:	21 22 82    	mov.w     0x4444, w1
    1000:	81 00 50    	sub.w     w0, w1, w1
    1002:	31 21 8a    	mov.w     w1, 0x4426

00001004 <.L5>:
  }

  IC1BUF_Old = IC1BUF_New;
    1004:	20 22 8a    	mov.w     w0, 0x4444
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1006:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1008:	50 10 e2    	cp0.w     0x1050
    100a:	01 00 3a    	bra       NZ, 0x100e <.L6>
    T3CONbits.TON = 0;
    100c:	13 e1 a9    	bclr.b    0x113, #0x7

0000100e <.L6>:
  }

  _IC1IF = 0;
    100e:	00 28 a9    	bclr.b    0x800, #0x1
}
    1010:	34 00 f9    	pop       0x34
    1012:	32 00 f9    	pop       0x32
    1014:	4f 00 be    	mov.d     [--w15], w0
    1016:	00 40 06    	retfie    

00001018 <__IC2Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC2Interrupt(void)
{
    1018:	80 9f be    	mov.d     w0, [w15++]
    101a:	32 00 f8    	push      0x32
    101c:	34 00 f8    	push      0x34
    101e:	10 00 20    	mov.w     #0x1, w0
    1020:	a0 01 88    	mov.w     w0, 0x34
    1022:	00 20 20    	mov.w     #0x200, w0
    1024:	90 01 88    	mov.w     w0, 0x32
    1026:	00 00 00    	nop       
  static uint16_T IC2BUF_Old;
  uint16_T IC2BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    1028:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    102a:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC2CON1bits.ICBNE == 1)
    102c:	48 61 ab    	btst.b    0x148, #0x3
    102e:	03 00 32    	bra       Z, 0x1036 <.L10>

00001030 <.L15>:
    IC2BUF_New = IC2BUF;               /* take the last value */
    1030:	60 0a 80    	mov.w     0x14c, w0
    1032:	48 61 ab    	btst.b    0x148, #0x3
    1034:	fd ff 3a    	bra       NZ, 0x1030 <.L15>

00001036 <.L10>:
  if (IC2CON1 & 1)                     /* This is a rising edge */
    1036:	48 01 ab    	btst.b    0x148, #0x0
    1038:	02 00 32    	bra       Z, 0x103e <.L12>
  {
    IC2CON1 &= 0xFFFE;                 /* detect next falling edge */
    103a:	48 01 a9    	bclr.b    0x148, #0x0
    103c:	04 00 37    	bra       0x1046 <.L13>

0000103e <.L12>:
  } else                               /* falling edge */
  {
    IC2CON1 |= 1;                      /* detect next rising edge */
    103e:	48 01 a8    	bset.b    0x148, #0x0
    MCHP_ic2up = IC2BUF_New - IC2BUF_Old;/* Compute Up time */
    1040:	11 22 82    	mov.w     0x4442, w1
    1042:	81 00 50    	sub.w     w0, w1, w1
    1044:	41 21 8a    	mov.w     w1, 0x4428

00001046 <.L13>:
  }

  IC2BUF_Old = IC2BUF_New;
    1046:	10 22 8a    	mov.w     w0, 0x4442
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1048:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    104a:	50 10 e2    	cp0.w     0x1050
    104c:	01 00 3a    	bra       NZ, 0x1050 <.L14> <_mcuFlagRecursion>
    T3CONbits.TON = 0;
    104e:	13 e1 a9    	bclr.b    0x113, #0x7

00001050 <.L14>:
  }

  _IC2IF = 0;
    1050:	00 a8 a9    	bclr.b    0x800, #0x5
}
    1052:	34 00 f9    	pop       0x34
    1054:	32 00 f9    	pop       0x32
    1056:	4f 00 be    	mov.d     [--w15], w0
    1058:	00 40 06    	retfie    

0000105a <__IC3Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC3Interrupt(void)
{
    105a:	80 9f be    	mov.d     w0, [w15++]
    105c:	32 00 f8    	push      0x32
    105e:	34 00 f8    	push      0x34
    1060:	10 00 20    	mov.w     #0x1, w0
    1062:	a0 01 88    	mov.w     w0, 0x34
    1064:	00 20 20    	mov.w     #0x200, w0
    1066:	90 01 88    	mov.w     w0, 0x32
    1068:	00 00 00    	nop       
  static uint16_T IC3BUF_Old;
  uint16_T IC3BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    106a:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    106c:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC3CON1bits.ICBNE == 1)
    106e:	50 61 ab    	btst.b    0x150, #0x3
    1070:	03 00 32    	bra       Z, 0x1078 <.L18> <_mlAirData>

00001072 <.L23>:
    IC3BUF_New = IC3BUF;               /* take the last value */
    1072:	a0 0a 80    	mov.w     0x154, w0
    1074:	50 61 ab    	btst.b    0x150, #0x3
    1076:	fd ff 3a    	bra       NZ, 0x1072 <.L23>

00001078 <.L18>:
  if (IC3CON1 & 1)                     /* This is a rising edge */
    1078:	50 01 ab    	btst.b    0x150, #0x0
    107a:	02 00 32    	bra       Z, 0x1080 <.L20>
  {
    IC3CON1 &= 0xFFFE;                 /* detect next falling edge */
    107c:	50 01 a9    	bclr.b    0x150, #0x0
    107e:	04 00 37    	bra       0x1088 <.L21>

00001080 <.L20>:
  } else                               /* falling edge */
  {
    IC3CON1 |= 1;                      /* detect next rising edge */
    1080:	50 01 a8    	bset.b    0x150, #0x0
    MCHP_ic3up = IC3BUF_New - IC3BUF_Old;/* Compute Up time */
    1082:	01 22 82    	mov.w     0x4440, w1
    1084:	81 00 50    	sub.w     w0, w1, w1
    1086:	51 21 8a    	mov.w     w1, 0x442a

00001088 <.L21>:
  }

  IC3BUF_Old = IC3BUF_New;
    1088:	00 22 8a    	mov.w     w0, 0x4440
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    108a:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    108c:	50 10 e2    	cp0.w     0x1050
    108e:	01 00 3a    	bra       NZ, 0x1092 <.L22>
    T3CONbits.TON = 0;
    1090:	13 e1 a9    	bclr.b    0x113, #0x7

00001092 <.L22>:
  }

  _IC3IF = 0;
    1092:	04 a8 a9    	bclr.b    0x804, #0x5
}
    1094:	34 00 f9    	pop       0x34
    1096:	32 00 f9    	pop       0x32
    1098:	4f 00 be    	mov.d     [--w15], w0
    109a:	00 40 06    	retfie    

0000109c <__IC4Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC4Interrupt(void)
{
    109c:	80 9f be    	mov.d     w0, [w15++]
    109e:	32 00 f8    	push      0x32
    10a0:	34 00 f8    	push      0x34
    10a2:	10 00 20    	mov.w     #0x1, w0
    10a4:	a0 01 88    	mov.w     w0, 0x34
    10a6:	00 20 20    	mov.w     #0x200, w0
    10a8:	90 01 88    	mov.w     w0, 0x32
    10aa:	00 00 00    	nop       
  static uint16_T IC4BUF_Old;
  uint16_T IC4BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    10ac:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    10ae:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC4CON1bits.ICBNE == 1)
    10b0:	58 61 ab    	btst.b    0x158, #0x3
    10b2:	03 00 32    	bra       Z, 0x10ba <.L26>

000010b4 <.L31>:
    IC4BUF_New = IC4BUF;               /* take the last value */
    10b4:	e0 0a 80    	mov.w     0x15c, w0
    10b6:	58 61 ab    	btst.b    0x158, #0x3
    10b8:	fd ff 3a    	bra       NZ, 0x10b4 <.L31>

000010ba <.L26>:
  if (IC4CON1 & 1)                     /* This is a rising edge */
    10ba:	58 01 ab    	btst.b    0x158, #0x0
    10bc:	02 00 32    	bra       Z, 0x10c2 <.L28>
  {
    IC4CON1 &= 0xFFFE;                 /* detect next falling edge */
    10be:	58 01 a9    	bclr.b    0x158, #0x0
    10c0:	04 00 37    	bra       0x10ca <.L29>

000010c2 <.L28>:
  } else                               /* falling edge */
  {
    IC4CON1 |= 1;                      /* detect next rising edge */
    10c2:	58 01 a8    	bset.b    0x158, #0x0
    MCHP_ic4up = IC4BUF_New - IC4BUF_Old;/* Compute Up time */
    10c4:	f1 21 82    	mov.w     0x443e, w1
    10c6:	81 00 50    	sub.w     w0, w1, w1
    10c8:	61 21 8a    	mov.w     w1, 0x442c

000010ca <.L29>:
  }

  IC4BUF_Old = IC4BUF_New;
    10ca:	f0 21 8a    	mov.w     w0, 0x443e
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    10cc:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    10ce:	50 10 e2    	cp0.w     0x1050
    10d0:	01 00 3a    	bra       NZ, 0x10d4 <.L30>
    T3CONbits.TON = 0;
    10d2:	13 e1 a9    	bclr.b    0x113, #0x7

000010d4 <.L30>:
  }

  _IC4IF = 0;
    10d4:	04 c8 a9    	bclr.b    0x804, #0x6
}
    10d6:	34 00 f9    	pop       0x34
    10d8:	32 00 f9    	pop       0x32
    10da:	4f 00 be    	mov.d     [--w15], w0
    10dc:	00 40 06    	retfie    

000010de <__IC5Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC5Interrupt(void)
{
    10de:	80 9f be    	mov.d     w0, [w15++]
    10e0:	32 00 f8    	push      0x32
    10e2:	34 00 f8    	push      0x34
    10e4:	10 00 20    	mov.w     #0x1, w0
    10e6:	a0 01 88    	mov.w     w0, 0x34
    10e8:	00 20 20    	mov.w     #0x200, w0
    10ea:	90 01 88    	mov.w     w0, 0x32
    10ec:	00 00 00    	nop       
  static uint16_T IC5BUF_Old;
  uint16_T IC5BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    10ee:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    10f0:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC5CON1bits.ICBNE == 1)
    10f2:	60 61 ab    	btst.b    0x160, #0x3
    10f4:	03 00 32    	bra       Z, 0x10fc <.L34>

000010f6 <.L39>:
    IC5BUF_New = IC5BUF;               /* take the last value */
    10f6:	20 0b 80    	mov.w     0x164, w0
    10f8:	60 61 ab    	btst.b    0x160, #0x3
    10fa:	fd ff 3a    	bra       NZ, 0x10f6 <.L39> <.LASF11>

000010fc <.L34>:
  if (IC5CON1 & 1)                     /* This is a rising edge */
    10fc:	60 01 ab    	btst.b    0x160, #0x0
    10fe:	02 00 32    	bra       Z, 0x1104 <.L36>
  {
    IC5CON1 &= 0xFFFE;                 /* detect next falling edge */
    1100:	60 01 a9    	bclr.b    0x160, #0x0
    1102:	04 00 37    	bra       0x110c <.L37>

00001104 <.L36>:
  } else                               /* falling edge */
  {
    IC5CON1 |= 1;                      /* detect next rising edge */
    1104:	60 01 a8    	bset.b    0x160, #0x0
    MCHP_ic5up = IC5BUF_New - IC5BUF_Old;/* Compute Up time */
    1106:	e1 21 82    	mov.w     0x443c, w1
    1108:	81 00 50    	sub.w     w0, w1, w1
    110a:	71 21 8a    	mov.w     w1, 0x442e

0000110c <.L37>:
  }

  IC5BUF_Old = IC5BUF_New;
    110c:	e0 21 8a    	mov.w     w0, 0x443c
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    110e:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1110:	50 10 e2    	cp0.w     0x1050
    1112:	01 00 3a    	bra       NZ, 0x1116 <.L38>
    T3CONbits.TON = 0;
    1114:	13 e1 a9    	bclr.b    0x113, #0x7

00001116 <.L38>:
  }

  _IC5IF = 0;
    1116:	04 e8 a9    	bclr.b    0x804, #0x7
}
    1118:	34 00 f9    	pop       0x34
    111a:	32 00 f9    	pop       0x32
    111c:	4f 00 be    	mov.d     [--w15], w0
    111e:	00 40 06    	retfie    

00001120 <__IC6Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC6Interrupt(void)
{
    1120:	80 9f be    	mov.d     w0, [w15++]
    1122:	32 00 f8    	push      0x32
    1124:	34 00 f8    	push      0x34
    1126:	10 00 20    	mov.w     #0x1, w0
    1128:	a0 01 88    	mov.w     w0, 0x34
    112a:	00 20 20    	mov.w     #0x200, w0
    112c:	90 01 88    	mov.w     w0, 0x32
    112e:	00 00 00    	nop       
  static uint16_T IC6BUF_Old;
  uint16_T IC6BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    1130:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    1132:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC6CON1bits.ICBNE == 1)
    1134:	68 61 ab    	btst.b    0x168, #0x3
    1136:	03 00 32    	bra       Z, 0x113e <.L42>

00001138 <.L47>:
    IC6BUF_New = IC6BUF;               /* take the last value */
    1138:	60 0b 80    	mov.w     0x16c, w0
    113a:	68 61 ab    	btst.b    0x168, #0x3
    113c:	fd ff 3a    	bra       NZ, 0x1138 <.L47> <_mlWpValues>

0000113e <.L42>:
  if (IC6CON1 & 1)                     /* This is a rising edge */
    113e:	68 01 ab    	btst.b    0x168, #0x0
    1140:	02 00 32    	bra       Z, 0x1146 <.L44>
  {
    IC6CON1 &= 0xFFFE;                 /* detect next falling edge */
    1142:	68 01 a9    	bclr.b    0x168, #0x0
    1144:	04 00 37    	bra       0x114e <.L45>

00001146 <.L44>:
  } else                               /* falling edge */
  {
    IC6CON1 |= 1;                      /* detect next rising edge */
    1146:	68 01 a8    	bset.b    0x168, #0x0
    MCHP_ic6up = IC6BUF_New - IC6BUF_Old;/* Compute Up time */
    1148:	d1 21 82    	mov.w     0x443a, w1
    114a:	81 00 50    	sub.w     w0, w1, w1
    114c:	81 21 8a    	mov.w     w1, 0x4430

0000114e <.L45>:
  }

  IC6BUF_Old = IC6BUF_New;
    114e:	d0 21 8a    	mov.w     w0, 0x443a
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1150:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1152:	50 10 e2    	cp0.w     0x1050
    1154:	01 00 3a    	bra       NZ, 0x1158 <.L46>
    T3CONbits.TON = 0;
    1156:	13 e1 a9    	bclr.b    0x113, #0x7

00001158 <.L46>:
  }

  _IC6IF = 0;
    1158:	05 08 a9    	bclr.b    0x805, #0x0
}
    115a:	34 00 f9    	pop       0x34
    115c:	32 00 f9    	pop       0x32
    115e:	4f 00 be    	mov.d     [--w15], w0
    1160:	00 40 06    	retfie    

00001162 <__IC7Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC7Interrupt(void)
{
    1162:	80 9f be    	mov.d     w0, [w15++]
    1164:	32 00 f8    	push      0x32
    1166:	34 00 f8    	push      0x34
    1168:	10 00 20    	mov.w     #0x1, w0
    116a:	a0 01 88    	mov.w     w0, 0x34
    116c:	00 20 20    	mov.w     #0x200, w0
    116e:	90 01 88    	mov.w     w0, 0x32
    1170:	00 00 00    	nop       
  static uint16_T IC7BUF_Old;
  uint16_T IC7BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    1172:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    1174:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC7CON1bits.ICBNE == 1)
    1176:	70 61 ab    	btst.b    0x170, #0x3
    1178:	03 00 32    	bra       Z, 0x1180 <.L50>

0000117a <.L55>:
    IC7BUF_New = IC7BUF;               /* take the last value */
    117a:	a0 0b 80    	mov.w     0x174, w0
    117c:	70 61 ab    	btst.b    0x170, #0x3
    117e:	fd ff 3a    	bra       NZ, 0x117a <.L55>

00001180 <.L50>:
  if (IC7CON1 & 1)                     /* This is a rising edge */
    1180:	70 01 ab    	btst.b    0x170, #0x0
    1182:	02 00 32    	bra       Z, 0x1188 <.L52>
  {
    IC7CON1 &= 0xFFFE;                 /* detect next falling edge */
    1184:	70 01 a9    	bclr.b    0x170, #0x0
    1186:	04 00 37    	bra       0x1190 <.L53>

00001188 <.L52>:
  } else                               /* falling edge */
  {
    IC7CON1 |= 1;                      /* detect next rising edge */
    1188:	70 01 a8    	bset.b    0x170, #0x0
    MCHP_ic7up = IC7BUF_New - IC7BUF_Old;/* Compute Up time */
    118a:	c1 21 82    	mov.w     0x4438, w1
    118c:	81 00 50    	sub.w     w0, w1, w1
    118e:	91 21 8a    	mov.w     w1, 0x4432

00001190 <.L53>:
  }

  IC7BUF_Old = IC7BUF_New;
    1190:	c0 21 8a    	mov.w     w0, 0x4438
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1192:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1194:	50 10 e2    	cp0.w     0x1050
    1196:	01 00 3a    	bra       NZ, 0x119a <.L54>
    T3CONbits.TON = 0;
    1198:	13 e1 a9    	bclr.b    0x113, #0x7

0000119a <.L54>:
  }

  _IC7IF = 0;
    119a:	02 c8 a9    	bclr.b    0x802, #0x6
}
    119c:	34 00 f9    	pop       0x34
    119e:	32 00 f9    	pop       0x32
    11a0:	4f 00 be    	mov.d     [--w15], w0
    11a2:	00 40 06    	retfie    

000011a4 <__IC8Interrupt>:

void __attribute__((__interrupt__,__auto_psv__)) _IC8Interrupt(void)
{
    11a4:	80 9f be    	mov.d     w0, [w15++]
    11a6:	32 00 f8    	push      0x32
    11a8:	34 00 f8    	push      0x34
    11aa:	10 00 20    	mov.w     #0x1, w0
    11ac:	a0 01 88    	mov.w     w0, 0x34
    11ae:	00 20 20    	mov.w     #0x200, w0
    11b0:	90 01 88    	mov.w     w0, 0x32
    11b2:	00 00 00    	nop       
  static uint16_T IC8BUF_Old;
  uint16_T IC8BUF_New;
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    11b4:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    11b6:	13 e1 a8    	bset.b    0x113, #0x7
  while (IC8CON1bits.ICBNE == 1)
    11b8:	78 61 ab    	btst.b    0x178, #0x3
    11ba:	03 00 32    	bra       Z, 0x11c2 <.L58>

000011bc <.L63>:
    IC8BUF_New = IC8BUF;               /* take the last value */
    11bc:	e0 0b 80    	mov.w     0x17c, w0
    11be:	78 61 ab    	btst.b    0x178, #0x3
    11c0:	fd ff 3a    	bra       NZ, 0x11bc <.L63>

000011c2 <.L58>:
  if (IC8CON1 & 1)                     /* This is a rising edge */
    11c2:	78 01 ab    	btst.b    0x178, #0x0
    11c4:	02 00 32    	bra       Z, 0x11ca <.L60> <.LASF13>
  {
    IC8CON1 &= 0xFFFE;                 /* detect next falling edge */
    11c6:	78 01 a9    	bclr.b    0x178, #0x0
    11c8:	04 00 37    	bra       0x11d2 <.L61>

000011ca <.L60>:
  } else                               /* falling edge */
  {
    IC8CON1 |= 1;                      /* detect next rising edge */
    11ca:	78 01 a8    	bset.b    0x178, #0x0
    MCHP_ic8up = IC8BUF_New - IC8BUF_Old;/* Compute Up time */
    11cc:	b1 21 82    	mov.w     0x4436, w1
    11ce:	81 00 50    	sub.w     w0, w1, w1
    11d0:	a1 21 8a    	mov.w     w1, 0x4434

000011d2 <.L61>:
  }

  IC8BUF_Old = IC8BUF_New;
    11d2:	b0 21 8a    	mov.w     w0, 0x4436
  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    11d4:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    11d6:	50 10 e2    	cp0.w     0x1050
    11d8:	01 00 3a    	bra       NZ, 0x11dc <.L62> <.L0> <.L0> <.Ldebug_line0>
    T3CONbits.TON = 0;
    11da:	13 e1 a9    	bclr.b    0x113, #0x7

000011dc <.L62>:
  }

  _IC8IF = 0;
    11dc:	02 e8 a9    	bclr.b    0x802, #0x7
}
    11de:	34 00 f9    	pop       0x34
    11e0:	32 00 f9    	pop       0x32
    11e2:	4f 00 be    	mov.d     [--w15], w0
    11e4:	00 40 06    	retfie    

000011e6 <__SPI1Interrupt>:

/* Implement SPI 1 Interrupts */
void __attribute__((__interrupt__,__shadow__,__auto_psv__)) _SPI1Interrupt(void)
  /* SPI1 ISR */
{
    11e6:	00 a0 fe    	push.s    
    11e8:	36 00 f8    	push      0x36
    11ea:	84 9f be    	mov.d     w4, [w15++]
    11ec:	86 9f be    	mov.d     w6, [w15++]
    11ee:	88 9f be    	mov.d     w8, [w15++]
    11f0:	8a 9f be    	mov.d     w10, [w15++]
    11f2:	8c 9f be    	mov.d     w12, [w15++]
    11f4:	32 00 f8    	push      0x32
    11f6:	34 00 f8    	push      0x34
    11f8:	14 00 20    	mov.w     #0x1, w4
    11fa:	a4 01 88    	mov.w     w4, 0x34
    11fc:	04 20 20    	mov.w     #0x200, w4
    11fe:	94 01 88    	mov.w     w4, 0x32
    1200:	00 00 00    	nop       
  boolean_T Continue;
  _SPI1IF = 0;
    1202:	01 48 a9    	bclr.b    0x801, #0x2
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    1204:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    1206:	13 e1 a8    	bset.b    0x113, #0x7
    1208:	81 22 82    	mov.w     0x4450, w1

  /* Declaration of Variables */
  uint16_T tmp;
  do {
    Continue = 0;                      /* By default, execute one sequence only */
    switch (MCHP_SPI1_State)
    {
     case 0:                           /* Idle */
      /* Check if the next sequence is already in the queue. If so, start it */
      Continue = (MCHP_SPI1_Queue.head != MCHP_SPI1_Queue.tail);/* One next sequence queued, start it now */
      if (Continue) {
        MCHP_SPI1_State = MCHP_SPI1_Queue.buffer[MCHP_SPI1_Queue.tail];
        if (MCHP_SPI1_Queue.tail >= 2) /* There are 2 SPI1 blocks, max idx for queue is 2 */
          MCHP_SPI1_Queue.tail = 0;
        else
          MCHP_SPI1_Queue.tail++;
      }
      break;

     case 1:                           /* Start a new SPI Sequence */
      LATEbits.LATE4 = 0;              /* switch RE4 to 0 */

      /* Write only Sequence */
      SPI1BUF = 0xBA00;

      /* Read only Sequence */
      SPI1BUF = 0x0000;
      SPI1BUF = 0x0000;
      SPI1BUF = 0x0000;

      /* Read only Sequence */
      SPI1BUF = 0x0000;

      /* Read only Sequence */
      SPI1BUF = 0x0000;
      SPI1BUF = 0x0000;
      SPI1BUF = 0x0000;
      MCHP_SPI1_State++;
      break;

     case 2:
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */
      tmp = SPI1BUF;
      SPI11_Buff16[0] = SPI1BUF;
      SPI11_Buff16[1] = SPI1BUF;
      SPI11_Buff16[2] = SPI1BUF;
      SPI11_Buff16[3] = SPI1BUF;
      SPI11_Buff16[4] = SPI1BUF;
      SPI11_Buff16[5] = SPI1BUF;
      SPI11_Buff16[6] = SPI1BUF;
      MCHP_SPI11_Request = 0;          /* This SPI sequence could be Re-Enabled */
      MCHP_SPI1_State = 0;             /* End of SPI Sequence. SPI Interrupt should be started for new sequence */
      Continue = (MCHP_SPI1_Queue.head != MCHP_SPI1_Queue.tail);/* One next sequence queued, start it now */
      break;

     case 3:                           /* Start a new SPI Sequence */
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */

      /* Delay */
      __delay32(700000);               /* Delay  */
      LATEbits.LATE4 = 0;              /* switch RE4 to 0 */

      /* Write only Sequence */
      SPI1BUF = 0x6A80;
      MCHP_SPI1_State++;
      break;

     case 4:
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */

      /* Delay */
      __delay32(4200000);              /* Delay  */
      LATEbits.LATE4 = 0;              /* switch RE4 to 0 */

      /* Write only Sequence */
      tmp = SPI1BUF;
      SPI1BUF = 0x6B01;
      MCHP_SPI1_State++;
      break;

     case 5:
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */

      /* Delay */
      __delay32(700000);               /* Delay  */
      LATEbits.LATE4 = 0;              /* switch RE4 to 0 */

      /* Write only Sequence */
      tmp = SPI1BUF;
      SPI1BUF = 0x1B08;
      MCHP_SPI1_State++;
      break;

     case 6:
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */

      /* Delay */
      __delay32(700000);               /* Delay  */
      LATEbits.LATE4 = 0;              /* switch RE4 to 0 */

      /* Write only Sequence */
      tmp = SPI1BUF;
      SPI1BUF = 0x6A10;
      MCHP_SPI1_State++;
      break;

     case 7:
      LATEbits.LATE4 = 1;              /* switch RE4 to 1 */
      tmp = SPI1BUF;
      MCHP_SPI12_Request = 0;          /* This SPI sequence could be Re-Enabled */
    120a:	9b 44 24    	mov.w     #0x4449, w11
      MCHP_SPI1_State = 0;             /* End of SPI Sequence. SPI Interrupt should be started for new sequence */
      Continue = (MCHP_SPI1_Queue.head != MCHP_SPI1_Queue.tail);/* One next sequence queued, start it now */
    120c:	22 45 24    	mov.w     #0x4452, w2
    120e:	4a 45 24    	mov.w     #0x4454, w10
    1210:	8a 84 e8    	inc2.w    w10, w9
    1212:	09 84 e8    	inc2.w    w9, w8
    1214:	88 83 e8    	inc2.w    w8, w7
    1216:	07 83 e8    	inc2.w    w7, w6
    1218:	86 82 e8    	inc2.w    w6, w5
    121a:	05 82 e8    	inc2.w    w5, w4
    121c:	83 44 24    	mov.w     #0x4448, w3

0000121e <.L15>:
    121e:	30 22 82    	mov.w     0x4446, w0
    1220:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    1222:	45 00 32    	bra       Z, 0x12ae <.L6>
    1224:	04 00 3e    	bra       GTU, 0x122e <.L11>
    1226:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    1228:	1a 00 32    	bra       Z, 0x125e <.L4>
    122a:	28 00 3e    	bra       GTU, 0x127c <.L5>
    122c:	08 00 37    	bra       0x123e <.L22>

0000122e <.L11>:
    122e:	e5 0f 50    	sub.w     w0, #0x5, [w15]
    1230:	59 00 32    	bra       Z, 0x12e4 <.L8>
    1232:	4a 00 39    	bra       NC, 0x12c8 <.L7>
    1234:	e6 0f 50    	sub.w     w0, #0x6, [w15]
    1236:	64 00 32    	bra       Z, 0x1300 <.L9>
    1238:	e7 0f 50    	sub.w     w0, #0x7, [w15]
    123a:	7b 00 3a    	bra       NZ, 0x1332 <.L21>
    123c:	6f 00 37    	bra       0x131c <.L23>

0000123e <.L22>:
    123e:	12 80 68    	xor.w     w1, [w2], w0
    1240:	00 f0 a7    	btsc.w    w0, #0xf
    1242:	00 00 ea    	neg.w     w0, w0
    1244:	00 00 ea    	neg.w     w0, w0
    1246:	4f 00 de    	lsr.w     w0, #0xf, w0
    1248:	00 04 e0    	cp0.b     w0
    124a:	80 00 32    	bra       Z, 0x134c <.L12>
    124c:	01 86 40    	add.w     w1, w1, w12
    124e:	ad 44 24    	mov.w     #0x444a, w13
    1250:	0c 86 46    	add.w     w13, w12, w12
    1252:	1c 06 78    	mov.w     [w12], w12
    1254:	3c 22 8a    	mov.w     w12, 0x4446
    1256:	e1 8f 50    	sub.w     w1, #0x1, [w15]
    1258:	70 00 3e    	bra       GTU, 0x133a <.L18>
    125a:	81 00 e8    	inc.w     w1, w1
    125c:	6f 00 37    	bra       0x133c <.L13>

0000125e <.L4>:
    125e:	81 22 8a    	mov.w     w1, 0x4450
    1260:	44 8e a9    	bclr.b    0xe44, #0x4
    1262:	00 a0 2b    	mov.w     #0xba00, w0
    1264:	40 12 88    	mov.w     w0, 0x248
    1266:	48 22 ef    	clr.w     0x248
    1268:	48 22 ef    	clr.w     0x248
    126a:	48 22 ef    	clr.w     0x248
    126c:	48 22 ef    	clr.w     0x248
    126e:	48 22 ef    	clr.w     0x248
    1270:	48 22 ef    	clr.w     0x248
    1272:	48 22 ef    	clr.w     0x248
    1274:	30 22 82    	mov.w     0x4446, w0
    1276:	00 00 e8    	inc.w     w0, w0
    1278:	30 22 8a    	mov.w     w0, 0x4446
    127a:	63 00 37    	bra       0x1342 <.L17> <.LASF0>

0000127c <.L5>:
    127c:	44 8e a8    	bset.b    0xe44, #0x4
    127e:	40 12 80    	mov.w     0x248, w0
    1280:	40 12 80    	mov.w     0x248, w0
    1282:	00 0d 78    	mov.w     w0, [w10]
    1284:	40 12 80    	mov.w     0x248, w0
    1286:	80 0c 78    	mov.w     w0, [w9]
    1288:	40 12 80    	mov.w     0x248, w0
    128a:	00 0c 78    	mov.w     w0, [w8]
    128c:	40 12 80    	mov.w     0x248, w0
    128e:	80 0b 78    	mov.w     w0, [w7]
    1290:	40 12 80    	mov.w     0x248, w0
    1292:	00 0b 78    	mov.w     w0, [w6]
    1294:	40 12 80    	mov.w     0x248, w0
    1296:	80 0a 78    	mov.w     w0, [w5]
    1298:	40 12 80    	mov.w     0x248, w0
    129a:	00 0a 78    	mov.w     w0, [w4]
    129c:	80 49 eb    	clr.b     [w3]
    129e:	00 00 eb    	clr.w     w0
    12a0:	30 22 8a    	mov.w     w0, 0x4446
    12a2:	12 80 68    	xor.w     w1, [w2], w0
    12a4:	00 f0 a7    	btsc.w    w0, #0xf
    12a6:	00 00 ea    	neg.w     w0, w0
    12a8:	00 00 ea    	neg.w     w0, w0
    12aa:	4f 00 de    	lsr.w     w0, #0xf, w0
    12ac:	47 00 37    	bra       0x133c <.L13>

000012ae <.L6>:
    12ae:	81 22 8a    	mov.w     w1, 0x4450
    12b0:	44 8e a8    	bset.b    0xe44, #0x4

000012b2 <.L0>:
    12b2:	00 e6 2a    	mov.w     #0xae60, w0
    12b4:	a1 00 20    	mov.w     #0xa, w1
    12b6:	38 12 02    	call      0x11238 <L0>
    12b8:	01 00 00 

000012ba <.L0>:
    12ba:	44 8e a9    	bclr.b    0xe44, #0x4
    12bc:	00 a8 26    	mov.w     #0x6a80, w0
    12be:	40 12 88    	mov.w     w0, 0x248
    12c0:	30 22 82    	mov.w     0x4446, w0
    12c2:	00 00 e8    	inc.w     w0, w0
    12c4:	30 22 8a    	mov.w     w0, 0x4446
    12c6:	3d 00 37    	bra       0x1342 <.L17> <.LASF0>

000012c8 <.L7>:
    12c8:	81 22 8a    	mov.w     w1, 0x4450
    12ca:	44 8e a8    	bset.b    0xe44, #0x4

000012cc <.L0>:
    12cc:	00 64 21    	mov.w     #0x1640, w0
    12ce:	01 04 20    	mov.w     #0x40, w1
    12d0:	38 12 02    	call      0x11238 <L0>
    12d2:	01 00 00 

000012d4 <.L0>:
    12d4:	44 8e a9    	bclr.b    0xe44, #0x4
    12d6:	40 12 80    	mov.w     0x248, w0
    12d8:	10 b0 26    	mov.w     #0x6b01, w0
    12da:	40 12 88    	mov.w     w0, 0x248
    12dc:	30 22 82    	mov.w     0x4446, w0
    12de:	00 00 e8    	inc.w     w0, w0
    12e0:	30 22 8a    	mov.w     w0, 0x4446
    12e2:	2f 00 37    	bra       0x1342 <.L17> <.LASF0>

000012e4 <.L8>:
    12e4:	81 22 8a    	mov.w     w1, 0x4450
    12e6:	44 8e a8    	bset.b    0xe44, #0x4

000012e8 <.L0>:
    12e8:	00 e6 2a    	mov.w     #0xae60, w0
    12ea:	a1 00 20    	mov.w     #0xa, w1
    12ec:	38 12 02    	call      0x11238 <L0>
    12ee:	01 00 00 

000012f0 <.L0>:
    12f0:	44 8e a9    	bclr.b    0xe44, #0x4
    12f2:	40 12 80    	mov.w     0x248, w0
    12f4:	80 b0 21    	mov.w     #0x1b08, w0
    12f6:	40 12 88    	mov.w     w0, 0x248
    12f8:	30 22 82    	mov.w     0x4446, w0
    12fa:	00 00 e8    	inc.w     w0, w0
    12fc:	30 22 8a    	mov.w     w0, 0x4446
    12fe:	21 00 37    	bra       0x1342 <.L17> <.LASF0>

00001300 <.L9>:
    1300:	81 22 8a    	mov.w     w1, 0x4450
    1302:	44 8e a8    	bset.b    0xe44, #0x4

00001304 <.L0>:
    1304:	00 e6 2a    	mov.w     #0xae60, w0
    1306:	a1 00 20    	mov.w     #0xa, w1
    1308:	38 12 02    	call      0x11238 <L0>
    130a:	01 00 00 

0000130c <.L0>:
    130c:	44 8e a9    	bclr.b    0xe44, #0x4
    130e:	40 12 80    	mov.w     0x248, w0
    1310:	00 a1 26    	mov.w     #0x6a10, w0
    1312:	40 12 88    	mov.w     w0, 0x248
    1314:	30 22 82    	mov.w     0x4446, w0
    1316:	00 00 e8    	inc.w     w0, w0
    1318:	30 22 8a    	mov.w     w0, 0x4446
    131a:	13 00 37    	bra       0x1342 <.L17> <.LASF0>

0000131c <.L23>:
    131c:	44 8e a8    	bset.b    0xe44, #0x4
    131e:	40 12 80    	mov.w     0x248, w0
    1320:	80 4d eb    	clr.b     [w11]
    1322:	00 00 eb    	clr.w     w0
    1324:	30 22 8a    	mov.w     w0, 0x4446
    1326:	12 80 68    	xor.w     w1, [w2], w0
    1328:	00 f0 a7    	btsc.w    w0, #0xf
    132a:	00 00 ea    	neg.w     w0, w0
    132c:	00 00 ea    	neg.w     w0, w0
    132e:	4f 00 de    	lsr.w     w0, #0xf, w0
      break;
    1330:	05 00 37    	bra       0x133c <.L13>

00001332 <.L21>:
    1332:	81 22 8a    	mov.w     w1, 0x4450

     default:                          /* Sequence finished */
      MCHP_SPI1_State = 0;             /* Should never happend */
    1334:	00 00 eb    	clr.w     w0
    1336:	30 22 8a    	mov.w     w0, 0x4446
      break;
    1338:	04 00 37    	bra       0x1342 <.L17> <.LASF0>

0000133a <.L18>:
    133a:	80 00 eb    	clr.w     w1

0000133c <.L13>:
    }                                  /* End of switch case sequence*/
  } while (Continue == 1);             /* end do-While */
    133c:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    133e:	6f ff 32    	bra       Z, 0x121e <.L15>
    1340:	81 22 8a    	mov.w     w1, 0x4450

00001342 <.L17>:

  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1342:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1344:	50 10 e2    	cp0.w     0x1050
    1346:	04 00 3a    	bra       NZ, 0x1350 <.L1>
    T3CONbits.TON = 0;
    1348:	13 e1 a9    	bclr.b    0x113, #0x7
    134a:	02 00 37    	bra       0x1350 <.L1>

0000134c <.L12>:
  }
}                                      /* Enf of interrupt */
    134c:	81 22 8a    	mov.w     w1, 0x4450
    134e:	f9 ff 37    	bra       0x1342 <.L17> <.LASF0>

00001350 <.L1>:
    1350:	34 00 f9    	pop       0x34
    1352:	32 00 f9    	pop       0x32
    1354:	4f 06 be    	mov.d     [--w15], w12
    1356:	4f 05 be    	mov.d     [--w15], w10
    1358:	4f 04 be    	mov.d     [--w15], w8
    135a:	4f 03 be    	mov.d     [--w15], w6
    135c:	4f 02 be    	mov.d     [--w15], w4
    135e:	36 00 f9    	pop       0x36
    1360:	00 80 fe    	pop.s     
    1362:	00 40 06    	retfie    

00001364 <__U1TXInterrupt>:

/* Declare UART1 Tx Circular Buffer Structure */
MCHP_UART1_TxStr MCHP_UART1_Tx;
void __attribute__((__interrupt__,__auto_psv__)) _U1TXInterrupt(void)
{
    1364:	80 9f be    	mov.d     w0, [w15++]
    1366:	82 9f be    	mov.d     w2, [w15++]
    1368:	84 9f be    	mov.d     w4, [w15++]
    136a:	86 1f 78    	mov.w     w6, [w15++]
    136c:	32 00 f8    	push      0x32
    136e:	34 00 f8    	push      0x34
    1370:	10 00 20    	mov.w     #0x1, w0
    1372:	a0 01 88    	mov.w     w0, 0x34
    1374:	00 20 20    	mov.w     #0x200, w0
    1376:	90 01 88    	mov.w     w0, 0x32
    1378:	00 00 00    	nop       
  _U1TXIF = 0;                         /*  */
    137a:	01 88 a9    	bclr.b    0x801, #0x4
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    137c:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    137e:	13 e1 a8    	bset.b    0x113, #0x7
  while ((U1STAbits.UTXBF == 0) && (MCHP_UART1_Tx.tail != MCHP_UART1_Tx.head) )/* while UxTXREG buffer is not full */
    1380:	23 22 ab    	btst.b    0x223, #0x1
    1382:	13 00 3a    	bra       NZ, 0x13aa <.L2>
    1384:	52 e3 81    	mov.w     0x3c6a, w2
    1386:	60 e3 81    	mov.w     0x3c6c, w0
    1388:	80 0f 51    	sub.w     w2, w0, [w15]
    138a:	0f 00 32    	bra       Z, 0x13aa <.L2>
  {
    U1TXREG = MCHP_UART1_Tx.buffer[MCHP_UART1_Tx.head];
    138c:	c0 c6 23    	mov.w     #0x3c6c, w0
    138e:	e5 df 2f    	mov.w     #0xfdfe, w5
    1390:	80 82 42    	add.w     w5, w0, w5
    MCHP_UART1_Tx.head = (MCHP_UART1_Tx.head + 1) & (Tx_BUFF_SIZE_Uart1-1);
    1392:	f4 1f 20    	mov.w     #0x1ff, w4
    1394:	03 20 20    	mov.w     #0x200, w3

00001396 <.L5>:
    1396:	90 80 42    	add.w     w5, [w0], w1
    1398:	91 80 fb    	ze        [w1], w1
    139a:	21 11 88    	mov.w     w1, 0x224
    139c:	90 00 e8    	inc.w     [w0], w1
    139e:	04 88 60    	and.w     w1, w4, [w0]
    13a0:	16 11 80    	mov.w     0x222, w6
    13a2:	86 80 61    	and.w     w3, w6, w1
    13a4:	02 00 3a    	bra       NZ, 0x13aa <.L2>
    13a6:	90 0f 11    	subr.w    w2, [w0], [w15]
    13a8:	f6 ff 3a    	bra       NZ, 0x1396 <.L5>

000013aa <.L2>:
  }

  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    13aa:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    13ac:	50 10 e2    	cp0.w     0x1050
    13ae:	01 00 3a    	bra       NZ, 0x13b2 <.L1>
    T3CONbits.TON = 0;
    13b0:	13 e1 a9    	bclr.b    0x113, #0x7

000013b2 <.L1>:
  }
}
    13b2:	34 00 f9    	pop       0x34
    13b4:	32 00 f9    	pop       0x32
    13b6:	4f 03 78    	mov.w     [--w15], w6
    13b8:	4f 02 be    	mov.d     [--w15], w4
    13ba:	4f 01 be    	mov.d     [--w15], w2
    13bc:	4f 00 be    	mov.d     [--w15], w0
    13be:	00 40 06    	retfie    

000013c0 <__U4TXInterrupt>:

/* Declare UART4 Tx Circular Buffer Structure */
MCHP_UART4_TxStr MCHP_UART4_Tx;
void __attribute__((__interrupt__,__auto_psv__)) _U4TXInterrupt(void)
{
    13c0:	80 9f be    	mov.d     w0, [w15++]
    13c2:	82 9f be    	mov.d     w2, [w15++]
    13c4:	84 9f be    	mov.d     w4, [w15++]
    13c6:	86 1f 78    	mov.w     w6, [w15++]
    13c8:	32 00 f8    	push      0x32
    13ca:	34 00 f8    	push      0x34
    13cc:	10 00 20    	mov.w     #0x1, w0
    13ce:	a0 01 88    	mov.w     w0, 0x34
    13d0:	00 20 20    	mov.w     #0x200, w0
    13d2:	90 01 88    	mov.w     w0, 0x32
    13d4:	00 00 00    	nop       
  _U4TXIF = 0;                         /*  */
    13d6:	0b 28 a9    	bclr.b    0x80b, #0x1
  __asm__ volatile ("INC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic increment of mcuFlagRecursion */
    13d8:	50 30 ec    	inc.w     0x1050
  T3CONbits.TON = 1;
    13da:	13 e1 a8    	bset.b    0x113, #0x7
  while ((U4STAbits.UTXBF == 0) && (MCHP_UART4_Tx.tail != MCHP_UART4_Tx.head) )/* while UxTXREG buffer is not full */
    13dc:	b3 22 ab    	btst.b    0x2b3, #0x1
    13de:	13 00 3a    	bra       NZ, 0x1406 <.L2>
    13e0:	72 f3 81    	mov.w     0x3e6e, w2
    13e2:	80 f3 81    	mov.w     0x3e70, w0
    13e4:	80 0f 51    	sub.w     w2, w0, [w15]
    13e6:	0f 00 32    	bra       Z, 0x1406 <.L2>
  {
    U4TXREG = MCHP_UART4_Tx.buffer[MCHP_UART4_Tx.head];
    13e8:	00 e7 23    	mov.w     #0x3e70, w0
    13ea:	e5 df 2f    	mov.w     #0xfdfe, w5
    13ec:	80 82 42    	add.w     w5, w0, w5
    MCHP_UART4_Tx.head = (MCHP_UART4_Tx.head + 1) & (Tx_BUFF_SIZE_Uart4-1);
    13ee:	f4 1f 20    	mov.w     #0x1ff, w4
    13f0:	03 20 20    	mov.w     #0x200, w3

000013f2 <.L5>:
    13f2:	90 80 42    	add.w     w5, [w0], w1
    13f4:	91 80 fb    	ze        [w1], w1
    13f6:	a1 15 88    	mov.w     w1, 0x2b4
    13f8:	90 00 e8    	inc.w     [w0], w1
    13fa:	04 88 60    	and.w     w1, w4, [w0]
    13fc:	96 15 80    	mov.w     0x2b2, w6
    13fe:	86 80 61    	and.w     w3, w6, w1
    1400:	02 00 3a    	bra       NZ, 0x1406 <.L2>
    1402:	90 0f 11    	subr.w    w2, [w0], [w15]
    1404:	f6 ff 3a    	bra       NZ, 0x13f2 <.L5>

00001406 <.L2>:
  }

  __asm__ volatile ("DEC %[MyVar]" : [MyVar] "+m" (mcuFlagRecursion) );/* ensure atomic decrement of mcuFlagRecursion */
    1406:	50 30 ed    	dec.w     0x1050
  if (mcuFlagRecursion == 0) {
    1408:	50 10 e2    	cp0.w     0x1050
    140a:	01 00 3a    	bra       NZ, 0x140e <.L1>
    T3CONbits.TON = 0;
    140c:	13 e1 a9    	bclr.b    0x113, #0x7

0000140e <.L1>:
  }
}
    140e:	34 00 f9    	pop       0x34
    1410:	32 00 f9    	pop       0x32
    1412:	4f 03 78    	mov.w     [--w15], w6
    1414:	4f 02 be    	mov.d     [--w15], w4
    1416:	4f 01 be    	mov.d     [--w15], w2
    1418:	4f 00 be    	mov.d     [--w15], w0
    141a:	00 40 06    	retfie    

0000141c <__DefaultInterrupt>:
    141c:	00 40 da    	.pword 0xda4000
    141e:	00 00 fe    	reset     

00001420 <_isspace>:
    1420:	69 00 e1    	.pword 0xe10069
    1422:	04 00 35    	bra       LT, 0x142c <nomatch>
    1424:	6d 00 e1    	.pword 0xe1006d
    1426:	03 00 34    	bra       LE, 0x142e <match> <.LASF4>
    1428:	00 02 b1    	sub.w     #0x20, w0
    142a:	01 00 32    	bra       Z, 0x142e <match> <.LASF4>

0000142c <nomatch>:
    142c:	00 00 05    	retlw.w   #0x0, w0

0000142e <match>:
    142e:	10 00 05    	retlw.w   #0x1, w0

00001430 <_write>:
    1430:	0a 00 fa    	lnk       #0xa
    1432:	e2 0f 50    	sub.w     w0, #0x2, [w15]
    1434:	20 00 3e    	bra       GTU, 0x1476 <.L3>
    1436:	30 25 82    	mov.w     0x44a6, w0
    1438:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    143a:	06 00 32    	bra       Z, 0x1448 <.L11>
    143c:	80 23 20    	mov.w     #0x238, w0
    143e:	45 23 20    	mov.w     #0x234, w5
    1440:	23 23 20    	mov.w     #0x232, w3
    1442:	04 23 20    	mov.w     #0x230, w4
    1444:	00 00 e0    	cp0.w     w0
    1446:	04 00 3a    	bra       NZ, 0x1450 <.L5>

00001448 <.L11>:
    1448:	80 22 20    	mov.w     #0x228, w0
    144a:	45 22 20    	mov.w     #0x224, w5
    144c:	23 22 20    	mov.w     #0x222, w3
    144e:	04 22 20    	mov.w     #0x220, w4

00001450 <.L5>:
    1450:	06 00 28    	mov.w     #0x8000, w6
    1452:	14 03 63    	and.w     w6, [w4], w6
    1454:	03 00 3a    	bra       NZ, 0x145c <.L6>
    1456:	06 08 78    	mov.w     w6, [w0]
    1458:	00 00 28    	mov.w     #0x8000, w0
    145a:	14 0a 70    	ior.w     w0, [w4], [w4]

0000145c <.L6>:
    145c:	13 a8 a3    	btst.z    [w3], #0xa
    145e:	01 00 3a    	bra       NZ, 0x1462 <.L7>
    1460:	13 a0 a0    	bset.w    [w3], #0xa

00001462 <.L7>:
    1462:	02 00 78    	mov.w     w2, w0
    1464:	05 00 37    	bra       0x1470 <.L8>

00001466 <.L9>:
    1466:	13 88 a3    	btst.z    [w3], #0x8
    1468:	fe ff 32    	bra       Z, 0x1466 <.L9>
    146a:	31 02 fb    	se        [w1++], w4
    146c:	84 0a 78    	mov.w     w4, [w5]
    146e:	00 00 e9    	dec.w     w0, w0

00001470 <.L8>:
    1470:	00 00 e0    	cp0.w     w0
    1472:	f9 ff 3a    	bra       NZ, 0x1466 <.L9>
    1474:	08 00 37    	bra       0x1486 <.L10> <.LASF3>

00001476 <.L3>:
    1476:	33 00 20    	mov.w     #0x3, w3
    1478:	b3 bf 9f    	mov.w     w3, [w15-10]
    147a:	c0 bf 9f    	mov.w     w0, [w15-8]
    147c:	d1 bf 9f    	mov.w     w1, [w15-6]
    147e:	e2 bf 9f    	mov.w     w2, [w15-4]
    1480:	6a 80 57    	sub.w     w15, #0xa, w0
    1482:	e8 0e 07    	rcall     0x3254 <_dowrite> <L0>
    1484:	6f b9 97    	mov.w     [w15-4], w2

00001486 <.L10>:
    1486:	02 00 78    	mov.w     w2, w0
    1488:	00 80 fa    	ulnk      
    148a:	00 00 06    	return    

0000148c <_acosf>:
    148c:	32 00 20    	mov.w     #0x3, w2
    148e:	5e 00 37    	bra       0x154c <__asinacosf>

00001490 <___subsf3>:
    1490:	03 f0 a2    	btg.w     w3, #0xf

00001492 <___addsf3>:
    1492:	88 9f be    	mov.d     w8, [w15++]
    1494:	8a 9f be    	mov.d     w10, [w15++]
    1496:	8c 1f 78    	mov.w     w12, [w15++]
    1498:	d4 02 07    	rcall     0x1a42 <__funpack2>
    149a:	db 02 33    	bra       N, 0x1a52 <__fPropagateNaN>
    149c:	64 50 e1    	.pword 0xe15064
    149e:	4f 00 32    	bra       Z, 0x153e <aisinfinite>

000014a0 <checkspecialb>:
    14a0:	64 20 e1    	.pword 0xe12064
    14a2:	52 00 32    	bra       Z, 0x1548 <return2>
    14a4:	03 82 6c    	xor.w     w9, w3, w4
    14a6:	07 00 3b    	bra       NN, 0x14b6 <getsign>
    14a8:	09 05 d0    	sl.w      w9, w10
    14aa:	03 06 d0    	sl.w      w3, w12
    14ac:	82 0f 54    	sub.w     w8, w2, [w15]
    14ae:	0c 06 5d    	subb.w    w10, w12, w12
    14b0:	02 00 39    	bra       NC, 0x14b6 <getsign>
    14b2:	02 00 32    	bra       Z, 0x14b8 <gotsign>
    14b4:	89 01 78    	mov.w     w9, w3

000014b6 <getsign>:
    14b6:	03 06 78    	mov.w     w3, w12

000014b8 <gotsign>:
    14b8:	85 82 55    	sub.w     w11, w5, w5
    14ba:	04 00 3d    	bra       GE, 0x14c4 <expcanonical> <.LASF5>
    14bc:	00 03 fd    	exch      w0, w6
    14be:	81 03 fd    	exch      w1, w7
    14c0:	85 02 ea    	neg.w     w5, w5
    14c2:	8b 85 42    	add.w     w5, w11, w11

000014c4 <expcanonical>:
    14c4:	84 0f 72    	ior.w     w4, w4, [w15]
    14c6:	02 00 3b    	bra       NN, 0x14cc <nonegate>
    14c8:	60 00 10    	subr.w    w0, #0x0, w0
    14ca:	e0 80 18    	subbr.w   w1, #0x0, w1

000014cc <nonegate>:
    14cc:	60 11 b8    	mul.uu    w2, #0x0, w2
    14ce:	00 05 eb    	clr.w     w10
    14d0:	7a 28 e1    	.pword 0xe1287a
    14d2:	0a 00 39    	bra       NC, 0x14e8 <aligniter>
    14d4:	06 00 78    	mov.w     w6, w0
    14d6:	c7 5d dd    	sl.w      w11, #0x7, w11
    14d8:	f7 07 b2    	and.w     #0x7f, w7
    14da:	87 80 75    	ior.w     w11, w7, w1
    14dc:	2d 00 37    	bra       0x1538 <signoff>

000014de <align>:
    14de:	82 81 71    	ior.w     w3, w2, w3
    14e0:	0a 01 78    	mov.w     w10, w2
    14e2:	61 05 60    	and.w     w0, #0x1, w10
    14e4:	81 80 d1    	asr.w     w1, w1
    14e6:	00 80 d3    	rrc.w     w0, w0

000014e8 <aligniter>:
    14e8:	85 02 e9    	dec.w     w5, w5
    14ea:	f9 ff 3b    	bra       NN, 0x14de <align>

000014ec <aligned>:
    14ec:	06 04 40    	add.w     w0, w6, w8
    14ee:	87 84 48    	addc.w    w1, w7, w9
    14f0:	02 00 3b    	bra       NN, 0x14f6 <normalizesum>
    14f2:	60 04 14    	subr.w    w8, #0x0, w8
    14f4:	e0 84 1c    	subbr.w   w9, #0x0, w9

000014f6 <normalizesum>:
    14f6:	09 88 a3    	btst.z    w9, #0x8
    14f8:	07 00 32    	bra       Z, 0x1508 <checknormal>
    14fa:	8a 81 71    	ior.w     w3, w10, w3
    14fc:	82 81 71    	ior.w     w3, w2, w3
    14fe:	61 01 64    	and.w     w8, #0x1, w2
    1500:	89 04 d1    	lsr.w     w9, w9
    1502:	08 84 d3    	rrc.w     w8, w8
    1504:	8b 05 e8    	inc.w     w11, w11
    1506:	17 00 37    	bra       0x1536 <round>

00001508 <checknormal>:
    1508:	09 78 a3    	btst.z    w9, #0x7
    150a:	13 00 3a    	bra       NZ, 0x1532 <discardguard>

0000150c <underflow>:
    150c:	0b 00 e0    	cp0.w     w11
    150e:	13 00 34    	bra       LE, 0x1536 <round>
    1510:	8b 05 e9    	dec.w     w11, w11
    1512:	08 04 44    	add.w     w8, w8, w8
    1514:	89 84 4c    	addc.w    w9, w9, w9
    1516:	0a 44 74    	ior.b     w8, w10, w8
    1518:	09 78 a3    	btst.z    w9, #0x7
    151a:	0d 00 3a    	bra       NZ, 0x1536 <round>

0000151c <normalizeloop>:
    151c:	0b 00 e0    	cp0.w     w11
    151e:	07 00 34    	bra       LE, 0x152e <normalizeexit>
    1520:	8b 05 e9    	dec.w     w11, w11
    1522:	08 04 44    	add.w     w8, w8, w8
    1524:	89 84 4c    	addc.w    w9, w9, w9
    1526:	01 00 3a    	bra       NZ, 0x152a <normalizetest>
    1528:	0b 00 20    	mov.w     #0x0, w11

0000152a <normalizetest>:
    152a:	09 78 a3    	btst.z    w9, #0x7
    152c:	f7 ff 32    	bra       Z, 0x151c <normalizeloop>

0000152e <normalizeexit>:
    152e:	00 01 eb    	clr.w     w2
    1530:	02 00 37    	bra       0x1536 <round>

00001532 <discardguard>:
    1532:	82 81 71    	ior.w     w3, w2, w3
    1534:	0a 01 78    	mov.w     w10, w2

00001536 <round>:
    1536:	4a 02 07    	rcall     0x19cc <__fpack>

00001538 <signoff>:
    1538:	0c f0 a7    	btsc.w    w12, #0xf
    153a:	01 f0 a0    	bset.w    w1, #0xf
    153c:	93 02 37    	bra       0x1a64 <__fbopExit>

0000153e <aisinfinite>:
    153e:	64 20 e1    	.pword 0xe12064
    1540:	02 00 3a    	bra       NZ, 0x1546 <return8>
    1542:	83 8f 6c    	xor.w     w9, w3, [w15]
    1544:	93 02 33    	bra       N, 0x1a6c <__fbopReturnNaN>

00001546 <return8>:
    1546:	08 01 be    	mov.d     w8, w2

00001548 <return2>:
    1548:	02 00 be    	mov.d     w2, w0
    154a:	8c 02 37    	bra       0x1a64 <__fbopExit>

0000154c <__asinacosf>:
    154c:	88 9f be    	mov.d     w8, [w15++]
    154e:	8a 9f be    	mov.d     w10, [w15++]
    1550:	8c 9f be    	mov.d     w12, [w15++]
    1552:	02 06 78    	mov.w     w2, w12
    1554:	01 f0 a7    	btsc.w    w1, #0xf
    1556:	0c f0 a0    	bset.w    w12, #0xf
    1558:	00 04 be    	mov.d     w0, w8
    155a:	5e 02 07    	rcall     0x1a18 <__funpack> <.LASF94>
    155c:	08 00 be    	mov.d     w8, w0
    155e:	64 20 e1    	.pword 0xe12064
    1560:	07 00 39    	bra       NC, 0x1570 <finite>
    1562:	02 00 3a    	bra       NZ, 0x1568 <isNaN>

00001564 <returnNaN>:
    1564:	f1 ff 27    	mov.w     #0x7fff, w1
    1566:	f0 ff 2f    	mov.w     #0xffff, w0

00001568 <isNaN>:
    1568:	01 60 a0    	bset.w    w1, #0x6

0000156a <domainerr>:
    156a:	12 02 20    	mov.w     #0x21, w2
    156c:	c2 82 88    	mov.w     w2, 0x1058
    156e:	51 00 37    	bra       0x1612 <return0> <.Ldebug_abbrev0>

00001570 <finite>:
    1570:	09 f0 a1    	bclr.w    w9, #0xf
    1572:	08 00 be    	mov.d     w8, w0
    1574:	02 00 20    	mov.w     #0x0, w2
    1576:	03 f8 23    	mov.w     #0x3f80, w3
    1578:	8b 01 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    157a:	f4 ff 3c    	bra       GT, 0x1564 <returnNaN>
    157c:	08 00 be    	mov.d     w8, w0
    157e:	02 00 20    	mov.w     #0x0, w2
    1580:	03 98 23    	mov.w     #0x3980, w3
    1582:	84 01 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1584:	08 00 be    	mov.d     w8, w0
    1586:	30 00 35    	bra       LT, 0x15e8 <translate>
    1588:	02 00 20    	mov.w     #0x0, w2
    158a:	03 f0 23    	mov.w     #0x3f00, w3
    158c:	81 01 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    158e:	05 00 3c    	bra       GT, 0x159a <argreduce>
    1590:	08 00 be    	mov.d     w8, w0
    1592:	08 01 be    	mov.d     w8, w2
    1594:	90 02 07    	rcall     0x1ab6 <___mulsf3>
    1596:	00 05 be    	mov.d     w0, w10
    1598:	0e 00 37    	bra       0x15b6 <rapprox>

0000159a <argreduce>:
    159a:	0c 10 a2    	btg.w     w12, #0x1
    159c:	00 00 20    	mov.w     #0x0, w0
    159e:	01 f8 23    	mov.w     #0x3f80, w1
    15a0:	08 01 be    	mov.d     w8, w2
    15a2:	76 ff 07    	rcall     0x1490 <___subsf3>
    15a4:	02 00 20    	mov.w     #0x0, w2
    15a6:	03 f0 23    	mov.w     #0x3f00, w3
    15a8:	86 02 07    	rcall     0x1ab6 <___mulsf3>
    15aa:	00 05 be    	mov.d     w0, w10
    15ac:	06 04 07    	rcall     0x1dba <_sqrtf>
    15ae:	02 00 20    	mov.w     #0x0, w2
    15b0:	03 00 2c    	mov.w     #0xc000, w3
    15b2:	81 02 07    	rcall     0x1ab6 <___mulsf3>
    15b4:	00 04 be    	mov.d     w0, w8

000015b6 <rapprox>:
    15b6:	0a 00 be    	mov.d     w10, w0
    15b8:	b2 d0 28    	mov.w     #0x8d0b, w2
    15ba:	13 0b 2c    	mov.w     #0xc0b1, w3
    15bc:	6a ff 07    	rcall     0x1492 <___addsf3>
    15be:	0a 01 be    	mov.d     w10, w2
    15c0:	7a 02 07    	rcall     0x1ab6 <___mulsf3>
    15c2:	02 0f 25    	mov.w     #0x50f0, w2
    15c4:	33 0b 24    	mov.w     #0x40b3, w3
    15c6:	65 ff 07    	rcall     0x1492 <___addsf3>
    15c8:	80 9f be    	mov.d     w0, [w15++]
    15ca:	0a 00 be    	mov.d     w10, w0
    15cc:	52 06 22    	mov.w     #0x2065, w2
    15ce:	13 f0 2b    	mov.w     #0xbf01, w3
    15d0:	72 02 07    	rcall     0x1ab6 <___mulsf3>
    15d2:	b2 66 21    	mov.w     #0x166b, w2
    15d4:	f3 f6 23    	mov.w     #0x3f6f, w3
    15d6:	5d ff 07    	rcall     0x1492 <___addsf3>
    15d8:	0a 01 be    	mov.d     w10, w2
    15da:	6d 02 07    	rcall     0x1ab6 <___mulsf3>
    15dc:	4f 01 be    	mov.d     [--w15], w2
    15de:	a3 00 07    	rcall     0x1726 <___divsf3>
    15e0:	08 01 be    	mov.d     w8, w2
    15e2:	69 02 07    	rcall     0x1ab6 <___mulsf3>
    15e4:	08 01 be    	mov.d     w8, w2
    15e6:	55 ff 07    	rcall     0x1492 <___addsf3>

000015e8 <translate>:
    15e8:	0c 00 a7    	btsc.w    w12, #0x0
    15ea:	07 00 37    	bra       0x15fa <arccosine>
    15ec:	b2 fd 20    	mov.w     #0xfdb, w2
    15ee:	93 fc 23    	mov.w     #0x3fc9, w3
    15f0:	0c 10 a7    	btsc.w    w12, #0x1
    15f2:	4f ff 07    	rcall     0x1492 <___addsf3>
    15f4:	0c f0 a7    	btsc.w    w12, #0xf
    15f6:	01 f0 a2    	btg.w     w1, #0xf
    15f8:	0c 00 37    	bra       0x1612 <return0> <.Ldebug_abbrev0>

000015fa <arccosine>:
    15fa:	0c f0 a7    	btsc.w    w12, #0xf
    15fc:	02 00 37    	bra       0x1602 <arccosxneg>
    15fe:	01 f0 a2    	btg.w     w1, #0xf
    1600:	04 00 37    	bra       0x160a <addpiover2> <.LASF92>

00001602 <arccosxneg>:
    1602:	b2 fd 20    	mov.w     #0xfdb, w2
    1604:	93 04 24    	mov.w     #0x4049, w3
    1606:	0c 10 a6    	btss.w    w12, #0x1
    1608:	03 00 37    	bra       0x1610 <addandexit>

0000160a <addpiover2>:
    160a:	b2 fd 20    	mov.w     #0xfdb, w2
    160c:	93 fc 23    	mov.w     #0x3fc9, w3
    160e:	0c 10 a7    	btsc.w    w12, #0x1

00001610 <addandexit>:
    1610:	40 ff 07    	rcall     0x1492 <___addsf3>

00001612 <return0>:
    1612:	4f 06 be    	mov.d     [--w15], w12
    1614:	4f 05 be    	mov.d     [--w15], w10
    1616:	4f 04 be    	mov.d     [--w15], w8
    1618:	00 00 06    	return    

0000161a <_asinf>:
    161a:	00 01 eb    	clr.w     w2
    161c:	97 ff 37    	bra       0x154c <__asinacosf>

0000161e <_atan2f>:
    161e:	88 9f be    	mov.d     w8, [w15++]
    1620:	8a 9f be    	mov.d     w10, [w15++]
    1622:	8c 1f 78    	mov.w     w12, [w15++]
    1624:	0e 02 07    	rcall     0x1a42 <__funpack2>
    1626:	10 02 20    	mov.w     #0x21, w0
    1628:	02 00 3b    	bra       NN, 0x162e <checkinfinities>
    162a:	c0 82 88    	mov.w     w0, 0x1058
    162c:	12 02 37    	bra       0x1a52 <__fPropagateNaN>

0000162e <checkinfinities>:
    162e:	8a 00 62    	and.w     w4, w10, w1
    1630:	64 08 e1    	.pword 0xe10864
    1632:	02 00 3a    	bra       NZ, 0x1638 <checkzeros>

00001634 <domainerror>:
    1634:	c0 82 88    	mov.w     w0, 0x1058
    1636:	1a 02 37    	bra       0x1a6c <__fbopReturnNaN>

00001638 <checkzeros>:
    1638:	61 08 e1    	.pword 0xe10861
    163a:	fc ff 32    	bra       Z, 0x1634 <domainerror> <.LASF95>

0000163c <finitenonzero>:
    163c:	08 00 be    	mov.d     w8, w0
    163e:	03 04 78    	mov.w     w3, w8
    1640:	72 00 07    	rcall     0x1726 <___divsf3>
    1642:	01 f0 a1    	bclr.w    w1, #0xf
    1644:	09 00 07    	rcall     0x1658 <_atanf>
    1646:	08 f0 a6    	btss.w    w8, #0xf
    1648:	04 00 37    	bra       0x1652 <checksignv>
    164a:	00 01 be    	mov.d     w0, w2
    164c:	91 04 24    	mov.w     #0x4049, w1
    164e:	b0 fd 20    	mov.w     #0xfdb, w0
    1650:	1f ff 07    	rcall     0x1490 <___subsf3>

00001652 <checksignv>:
    1652:	09 f0 a7    	btsc.w    w9, #0xf
    1654:	01 f0 a2    	btg.w     w1, #0xf

00001656 <return0>:
    1656:	06 02 37    	bra       0x1a64 <__fbopExit>

00001658 <_atanf>:
    1658:	88 9f be    	mov.d     w8, [w15++]
    165a:	8a 9f be    	mov.d     w10, [w15++]
    165c:	8c 9f be    	mov.d     w12, [w15++]
    165e:	00 04 be    	mov.d     w0, w8
    1660:	db 01 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1662:	08 00 be    	mov.d     w8, w0
    1664:	89 06 78    	mov.w     w9, w13
    1666:	64 20 e1    	.pword 0xe12064
    1668:	08 00 39    	bra       NC, 0x167a <finite>
    166a:	04 00 32    	bra       Z, 0x1674 <isInf>
    166c:	01 60 a0    	bset.w    w1, #0x6

0000166e <domainerr>:
    166e:	12 02 20    	mov.w     #0x21, w2
    1670:	c2 82 88    	mov.w     w2, 0x1058
    1672:	53 00 37    	bra       0x171a <return0>

00001674 <isInf>:
    1674:	91 fc 23    	mov.w     #0x3fc9, w1
    1676:	b0 fd 20    	mov.w     #0xfdb, w0
    1678:	4e 00 37    	bra       0x1716 <signresult> <.LASF34>

0000167a <finite>:
    167a:	00 06 eb    	clr.w     w12
    167c:	09 f0 a1    	bclr.w    w9, #0xf
    167e:	03 f8 23    	mov.w     #0x3f80, w3
    1680:	02 00 20    	mov.w     #0x0, w2
    1682:	08 00 be    	mov.d     w8, w0
    1684:	03 01 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1686:	06 00 34    	bra       LE, 0x1694 <reduce1>
    1688:	01 f8 23    	mov.w     #0x3f80, w1
    168a:	00 00 20    	mov.w     #0x0, w0
    168c:	08 01 be    	mov.d     w8, w2
    168e:	4b 00 07    	rcall     0x1726 <___divsf3>
    1690:	00 04 be    	mov.d     w0, w8
    1692:	2c 00 20    	mov.w     #0x2, w12

00001694 <reduce1>:
    1694:	08 00 be    	mov.d     w8, w0
    1696:	93 e8 23    	mov.w     #0x3e89, w3
    1698:	32 0a 23    	mov.w     #0x30a3, w2
    169a:	f8 00 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    169c:	12 00 34    	bra       LE, 0x16c2 <reduced>
    169e:	08 01 be    	mov.d     w8, w2
    16a0:	d1 fd 23    	mov.w     #0x3fdd, w1
    16a2:	70 3d 2b    	mov.w     #0xb3d7, w0
    16a4:	f6 fe 07    	rcall     0x1492 <___addsf3>
    16a6:	00 05 be    	mov.d     w0, w10
    16a8:	b3 f3 23    	mov.w     #0x3f3b, w3
    16aa:	f2 7a 26    	mov.w     #0x67af, w2
    16ac:	08 00 be    	mov.d     w8, w0
    16ae:	03 02 07    	rcall     0x1ab6 <___mulsf3>
    16b0:	03 f8 23    	mov.w     #0x3f80, w3
    16b2:	02 00 20    	mov.w     #0x0, w2
    16b4:	ed fe 07    	rcall     0x1490 <___subsf3>
    16b6:	08 01 be    	mov.d     w8, w2
    16b8:	ec fe 07    	rcall     0x1492 <___addsf3>
    16ba:	0a 01 be    	mov.d     w10, w2
    16bc:	34 00 07    	rcall     0x1726 <___divsf3>
    16be:	00 04 be    	mov.d     w0, w8
    16c0:	0c 06 e8    	inc.w     w12, w12

000016c2 <reduced>:
    16c2:	08 00 be    	mov.d     w8, w0
    16c4:	01 f0 a1    	bclr.w    w1, #0xf
    16c6:	02 00 20    	mov.w     #0x0, w2
    16c8:	03 98 23    	mov.w     #0x3980, w3
    16ca:	e0 00 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    16cc:	08 00 be    	mov.d     w8, w0
    16ce:	16 00 35    	bra       LT, 0x16fc <translate> <.Lframe0>
    16d0:	08 01 be    	mov.d     w8, w2
    16d2:	f1 01 07    	rcall     0x1ab6 <___mulsf3>
    16d4:	00 05 be    	mov.d     w0, w10
    16d6:	32 cd 2c    	mov.w     #0xccd3, w2
    16d8:	43 fb 23    	mov.w     #0x3fb4, w3
    16da:	db fe 07    	rcall     0x1492 <___addsf3>
    16dc:	80 9f be    	mov.d     w0, [w15++]
    16de:	12 69 28    	mov.w     #0x8691, w2
    16e0:	03 d5 2b    	mov.w     #0xbd50, w3
    16e2:	0a 00 be    	mov.d     w10, w0
    16e4:	e8 01 07    	rcall     0x1ab6 <___mulsf3>
    16e6:	62 0f 21    	mov.w     #0x10f6, w2
    16e8:	13 ef 2b    	mov.w     #0xbef1, w3
    16ea:	d3 fe 07    	rcall     0x1492 <___addsf3>
    16ec:	0a 01 be    	mov.d     w10, w2
    16ee:	e3 01 07    	rcall     0x1ab6 <___mulsf3>
    16f0:	4f 01 be    	mov.d     [--w15], w2
    16f2:	19 00 07    	rcall     0x1726 <___divsf3>
    16f4:	08 01 be    	mov.d     w8, w2
    16f6:	df 01 07    	rcall     0x1ab6 <___mulsf3>
    16f8:	08 01 be    	mov.d     w8, w2
    16fa:	cb fe 07    	rcall     0x1492 <___addsf3>

000016fc <translate>:
    16fc:	0c 00 e0    	cp0.w     w12
    16fe:	0b 00 32    	bra       Z, 0x1716 <signresult> <.LASF34>
    1700:	0c 10 a7    	btsc.w    w12, #0x1
    1702:	01 f0 a2    	btg.w     w1, #0xf
    1704:	b2 fd 20    	mov.w     #0xfdb, w2
    1706:	93 fc 23    	mov.w     #0x3fc9, w3
    1708:	62 60 e1    	.pword 0xe16062
    170a:	04 00 32    	bra       Z, 0x1714 <dotranslate>
    170c:	22 a9 20    	mov.w     #0xa92, w2
    170e:	63 f0 23    	mov.w     #0x3f06, w3
    1710:	0c 10 a7    	btsc.w    w12, #0x1
    1712:	63 f8 23    	mov.w     #0x3f86, w3

00001714 <dotranslate>:
    1714:	be fe 07    	rcall     0x1492 <___addsf3>

00001716 <signresult>:
    1716:	0d f0 a7    	btsc.w    w13, #0xf
    1718:	01 f0 a2    	btg.w     w1, #0xf

0000171a <return0>:
    171a:	4f 06 be    	mov.d     [--w15], w12
    171c:	4f 05 be    	mov.d     [--w15], w10
    171e:	4f 04 be    	mov.d     [--w15], w8
    1720:	00 00 06    	return    

00001722 <_cosf>:
    1722:	00 81 eb    	setm.w    w2
    1724:	df 02 37    	bra       0x1ce4 <__sincosf>

00001726 <___divsf3>:
    1726:	88 9f be    	mov.d     w8, [w15++]
    1728:	8a 9f be    	mov.d     w10, [w15++]
    172a:	8c 1f 78    	mov.w     w12, [w15++]
    172c:	8a 01 07    	rcall     0x1a42 <__funpack2>
    172e:	91 01 33    	bra       N, 0x1a52 <__fPropagateNaN>
    1730:	03 86 6c    	xor.w     w9, w3, w12
    1732:	64 50 e1    	.pword 0xe15064
    1734:	2e 00 32    	bra       Z, 0x1792 <aisinfinite>
    1736:	64 20 e1    	.pword 0xe12064
    1738:	33 00 32    	bra       Z, 0x17a0 <returnZero>
    173a:	61 50 e1    	.pword 0xe15061
    173c:	2f 00 32    	bra       Z, 0x179c <aiszero>
    173e:	61 20 e1    	.pword 0xe12061
    1740:	31 00 32    	bra       Z, 0x17a4 <returnInf>

00001742 <finitenonzero>:
    1742:	85 85 55    	sub.w     w11, w5, w11
    1744:	eb 07 b0    	add.w     #0x7e, w11
    1746:	09 00 20    	mov.w     #0x0, w9
    1748:	08 04 20    	mov.w     #0x40, w8
    174a:	05 00 37    	bra       0x1756 <diventry>

0000174c <divnext>:
    174c:	08 04 44    	add.w     w8, w8, w8
    174e:	89 84 4c    	addc.w    w9, w9, w9
    1750:	0a 00 31    	bra       C, 0x1766 <divdone> <formsticky>

00001752 <divloop>:
    1752:	06 03 43    	add.w     w6, w6, w6
    1754:	87 83 4b    	addc.w    w7, w7, w7

00001756 <diventry>:
    1756:	00 01 53    	sub.w     w6, w0, w2
    1758:	81 81 5b    	subb.w    w7, w1, w3
    175a:	f8 ff 33    	bra       N, 0x174c <divnext>
    175c:	02 03 be    	mov.d     w2, w6
    175e:	08 00 a0    	bset.w    w8, #0x0
    1760:	08 04 44    	add.w     w8, w8, w8
    1762:	89 84 4c    	addc.w    w9, w9, w9
    1764:	f6 ff 39    	bra       NC, 0x1752 <divloop>

00001766 <divdone>:
    1766:	c6 39 dd    	sl.w      w7, #0x6, w3
    1768:	83 01 73    	ior.w     w6, w3, w3
    176a:	01 00 32    	bra       Z, 0x176e <stickyok>
    176c:	13 00 20    	mov.w     #0x1, w3

0000176e <stickyok>:
    176e:	89 04 d1    	lsr.w     w9, w9
    1770:	08 84 d3    	rrc.w     w8, w8
    1772:	09 98 a3    	btst.z    w9, #0x9
    1774:	05 00 32    	bra       Z, 0x1780 <guardused>
    1776:	08 00 a7    	btsc.w    w8, #0x0
    1778:	03 00 a0    	bset.w    w3, #0x0
    177a:	89 04 d1    	lsr.w     w9, w9
    177c:	08 84 d3    	rrc.w     w8, w8
    177e:	8b 05 e8    	inc.w     w11, w11

00001780 <guardused>:
    1780:	89 04 d1    	lsr.w     w9, w9
    1782:	08 84 d3    	rrc.w     w8, w8
    1784:	00 01 eb    	clr.w     w2
    1786:	02 81 d2    	rlc.w     w2, w2
    1788:	21 01 07    	rcall     0x19cc <__fpack>

0000178a <return0>:
    178a:	01 f0 a1    	bclr.w    w1, #0xf
    178c:	0c f0 a7    	btsc.w    w12, #0xf
    178e:	01 f0 a0    	bset.w    w1, #0xf
    1790:	69 01 37    	bra       0x1a64 <__fbopExit>

00001792 <aisinfinite>:
    1792:	64 20 e1    	.pword 0xe12064
    1794:	6b 01 32    	bra       Z, 0x1a6c <__fbopReturnNaN>

00001796 <return8>:
    1796:	08 01 be    	mov.d     w8, w2

00001798 <return2>:
    1798:	02 00 be    	mov.d     w2, w0
    179a:	f7 ff 37    	bra       0x178a <return0>

0000179c <aiszero>:
    179c:	61 20 e1    	.pword 0xe12061
    179e:	66 01 32    	bra       Z, 0x1a6c <__fbopReturnNaN>

000017a0 <returnZero>:
    17a0:	60 00 b8    	mul.uu    w0, #0x0, w0
    17a2:	f3 ff 37    	bra       0x178a <return0>

000017a4 <returnInf>:
    17a4:	00 00 20    	mov.w     #0x0, w0
    17a6:	01 f8 27    	mov.w     #0x7f80, w1
    17a8:	f0 ff 37    	bra       0x178a <return0>

000017aa <___divsi3>:
    17aa:	83 9f 68    	xor.w     w1, w3, [w15++]
    17ac:	01 00 e0    	cp0.w     w1
    17ae:	02 00 3d    	bra       GE, 0x17b4 <divtestb>
    17b0:	60 00 10    	subr.w    w0, #0x0, w0
    17b2:	e0 80 18    	subbr.w   w1, #0x0, w1

000017b4 <divtestb>:
    17b4:	03 00 e0    	cp0.w     w3
    17b6:	02 00 3d    	bra       GE, 0x17bc <calcquot>
    17b8:	60 01 11    	subr.w    w2, #0x0, w2
    17ba:	e0 81 19    	subbr.w   w3, #0x0, w3

000017bc <calcquot>:
    17bc:	bb 03 07    	rcall     0x1f34 <___udivsi3>
    17be:	4f 00 e0    	cp0.w     [--w15]
    17c0:	02 00 3b    	bra       NN, 0x17c6 <returnq> <.LASF25>
    17c2:	60 00 10    	subr.w    w0, #0x0, w0
    17c4:	e0 80 18    	subbr.w   w1, #0x0, w1

000017c6 <returnq>:
    17c6:	00 00 06    	return    

000017c8 <_expf>:
    17c8:	88 9f be    	mov.d     w8, [w15++]
    17ca:	8a 9f be    	mov.d     w10, [w15++]
    17cc:	8c 9f be    	mov.d     w12, [w15++]
    17ce:	00 04 be    	mov.d     w0, w8
    17d0:	23 01 07    	rcall     0x1a18 <__funpack> <.LASF94>
    17d2:	08 00 be    	mov.d     w8, w0
    17d4:	64 20 e1    	.pword 0xe12064
    17d6:	48 00 3e    	bra       GTU, 0x1868 <return0>
    17d8:	55 00 32    	bra       Z, 0x1884 <xIsInf>
    17da:	72 21 27    	mov.w     #0x7217, w2
    17dc:	13 2b 24    	mov.w     #0x42b1, w3
    17de:	58 00 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    17e0:	47 00 3c    	bra       GT, 0x1870 <overflow>
    17e2:	08 00 be    	mov.d     w8, w0
    17e4:	c2 ec 28    	mov.w     #0x8ecc, w2
    17e6:	e3 2c 2c    	mov.w     #0xc2ce, w3
    17e8:	51 00 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    17ea:	47 00 35    	bra       LT, 0x187a <underflow>
    17ec:	08 00 be    	mov.d     w8, w0
    17ee:	01 f0 a1    	bclr.w    w1, #0xf
    17f0:	02 00 20    	mov.w     #0x0, w2
    17f2:	03 38 23    	mov.w     #0x3380, w3
    17f4:	4b 00 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    17f6:	43 00 35    	bra       LT, 0x187e <tinyarg>
    17f8:	08 00 be    	mov.d     w8, w0
    17fa:	b2 a3 2a    	mov.w     #0xaa3b, w2
    17fc:	83 fb 23    	mov.w     #0x3fb8, w3
    17fe:	5b 01 07    	rcall     0x1ab6 <___mulsf3>
    1800:	02 00 20    	mov.w     #0x0, w2
    1802:	03 f0 23    	mov.w     #0x3f00, w3
    1804:	01 f0 a7    	btsc.w    w1, #0xf
    1806:	03 f0 a0    	bset.w    w3, #0xf
    1808:	44 fe 07    	rcall     0x1492 <___addsf3>
    180a:	44 00 07    	rcall     0x1894 <___fixsfsi> <.LASF17>
    180c:	00 05 be    	mov.d     w0, w10
    180e:	7e 00 07    	rcall     0x190c <___floatsisf>
    1810:	01 f0 a2    	btg.w     w1, #0xf
    1812:	00 06 be    	mov.d     w0, w12
    1814:	02 00 28    	mov.w     #0x8000, w2
    1816:	13 f3 23    	mov.w     #0x3f31, w3
    1818:	4e 01 07    	rcall     0x1ab6 <___mulsf3>
    181a:	08 01 be    	mov.d     w8, w2
    181c:	3a fe 07    	rcall     0x1492 <___addsf3>
    181e:	80 9f be    	mov.d     w0, [w15++]
    1820:	0c 00 be    	mov.d     w12, w0
    1822:	32 08 28    	mov.w     #0x8083, w2
    1824:	e3 95 2b    	mov.w     #0xb95e, w3
    1826:	47 01 07    	rcall     0x1ab6 <___mulsf3>
    1828:	4f 01 be    	mov.d     [--w15], w2
    182a:	33 fe 07    	rcall     0x1492 <___addsf3>
    182c:	00 06 be    	mov.d     w0, w12
    182e:	00 01 be    	mov.d     w0, w2
    1830:	42 01 07    	rcall     0x1ab6 <___mulsf3>
    1832:	80 9f be    	mov.d     w0, [w15++]
    1834:	42 41 25    	mov.w     #0x5414, w2
    1836:	83 b8 23    	mov.w     #0x3b88, w3
    1838:	3e 01 07    	rcall     0x1ab6 <___mulsf3>
    183a:	02 00 20    	mov.w     #0x0, w2
    183c:	03 e8 23    	mov.w     #0x3e80, w3
    183e:	29 fe 07    	rcall     0x1492 <___addsf3>
    1840:	0c 01 be    	mov.d     w12, w2
    1842:	39 01 07    	rcall     0x1ab6 <___mulsf3>
    1844:	00 06 be    	mov.d     w0, w12
    1846:	4f 00 be    	mov.d     [--w15], w0
    1848:	f2 f9 2b    	mov.w     #0xbf9f, w2
    184a:	c3 d4 23    	mov.w     #0x3d4c, w3
    184c:	34 01 07    	rcall     0x1ab6 <___mulsf3>
    184e:	02 00 20    	mov.w     #0x0, w2
    1850:	03 f0 23    	mov.w     #0x3f00, w3
    1852:	1f fe 07    	rcall     0x1492 <___addsf3>
    1854:	0c 01 be    	mov.d     w12, w2
    1856:	1c fe 07    	rcall     0x1490 <___subsf3>
    1858:	00 01 be    	mov.d     w0, w2
    185a:	0c 00 be    	mov.d     w12, w0
    185c:	64 ff 07    	rcall     0x1726 <___divsf3>
    185e:	02 00 20    	mov.w     #0x0, w2
    1860:	03 f0 23    	mov.w     #0x3f00, w3
    1862:	17 fe 07    	rcall     0x1492 <___addsf3>
    1864:	61 01 45    	add.w     w10, #0x1, w2
    1866:	05 01 07    	rcall     0x1a72 <_ldexpf>

00001868 <return0>:
    1868:	4f 06 be    	mov.d     [--w15], w12
    186a:	4f 05 be    	mov.d     [--w15], w10
    186c:	4f 04 be    	mov.d     [--w15], w8
    186e:	00 00 06    	return    

00001870 <overflow>:
    1870:	01 f8 27    	mov.w     #0x7f80, w1
    1872:	00 00 20    	mov.w     #0x0, w0

00001874 <rangeerr>:
    1874:	22 02 20    	mov.w     #0x22, w2
    1876:	c2 82 88    	mov.w     w2, 0x1058
    1878:	f7 ff 37    	bra       0x1868 <return0>

0000187a <underflow>:
    187a:	60 00 b8    	mul.uu    w0, #0x0, w0
    187c:	fb ff 37    	bra       0x1874 <rangeerr>

0000187e <tinyarg>:
    187e:	01 f8 23    	mov.w     #0x3f80, w1
    1880:	00 00 20    	mov.w     #0x0, w0
    1882:	f2 ff 37    	bra       0x1868 <return0>

00001884 <xIsInf>:
    1884:	09 f8 a3    	btst.z    w9, #0xf
    1886:	f0 ff 32    	bra       Z, 0x1868 <return0>
    1888:	60 00 b8    	mul.uu    w0, #0x0, w0
    188a:	ee ff 37    	bra       0x1868 <return0>

0000188c <___eqsf2>:
    188c:	14 00 20    	mov.w     #0x1, w4
    188e:	d9 03 37    	bra       0x2042 <__fcompare>

00001890 <___gesf2>:
    1890:	f4 ff 2f    	mov.w     #0xffff, w4
    1892:	d7 03 37    	bra       0x2042 <__fcompare>

00001894 <___fixsfsi>:
    1894:	00 01 be    	mov.d     w0, w2
    1896:	c0 00 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1898:	04 70 a7    	btsc.w    w4, #0x7
    189a:	03 f0 a1    	bclr.w    w3, #0xf
    189c:	65 09 b1    	sub.w     #0x96, w5
    189e:	16 00 32    	bra       Z, 0x18cc <setsign>
    18a0:	0d 00 35    	bra       LT, 0x18bc <shiftright>
    18a2:	68 28 e1    	.pword 0xe12868
    18a4:	06 00 35    	bra       LT, 0x18b2 <shiftleft>
    18a6:	f0 ff 2f    	mov.w     #0xffff, w0
    18a8:	f1 ff 27    	mov.w     #0x7fff, w1
    18aa:	03 00 e0    	cp0.w     w3
    18ac:	13 00 3b    	bra       NN, 0x18d4 <exit>
    18ae:	01 00 28    	mov.w     #0x8000, w1
    18b0:	00 00 05    	retlw.w   #0x0, w0

000018b2 <shiftleft>:
    18b2:	00 00 40    	add.w     w0, w0, w0
    18b4:	81 80 48    	addc.w    w1, w1, w1
    18b6:	85 02 e9    	dec.w     w5, w5
    18b8:	fc ff 3a    	bra       NZ, 0x18b2 <shiftleft>
    18ba:	08 00 37    	bra       0x18cc <setsign>

000018bc <shiftright>:
    18bc:	f8 8f 42    	add.w     w5, #0x18, [w15]
    18be:	02 00 3c    	bra       GT, 0x18c4 <shiftrightloop>
    18c0:	80 00 eb    	clr.w     w1
    18c2:	00 00 05    	retlw.w   #0x0, w0

000018c4 <shiftrightloop>:
    18c4:	81 00 d1    	lsr.w     w1, w1
    18c6:	00 80 d3    	rrc.w     w0, w0
    18c8:	85 02 e8    	inc.w     w5, w5
    18ca:	fc ff 3a    	bra       NZ, 0x18c4 <shiftrightloop>

000018cc <setsign>:
    18cc:	03 00 e0    	cp0.w     w3
    18ce:	02 00 3b    	bra       NN, 0x18d4 <exit>
    18d0:	60 00 10    	subr.w    w0, #0x0, w0
    18d2:	e0 80 18    	subbr.w   w1, #0x0, w1

000018d4 <exit>:
    18d4:	00 00 06    	return    

000018d6 <___fixunssfsi>:
    18d6:	00 01 be    	mov.d     w0, w2
    18d8:	9f 00 07    	rcall     0x1a18 <__funpack> <.LASF94>
    18da:	04 70 a7    	btsc.w    w4, #0x7
    18dc:	03 f0 a1    	bclr.w    w3, #0xf
    18de:	03 f8 a3    	btst.z    w3, #0xf
    18e0:	13 00 3a    	bra       NZ, 0x1908 <returnzero>
    18e2:	65 09 b1    	sub.w     #0x96, w5
    18e4:	10 00 32    	bra       Z, 0x1906 <exit>
    18e6:	09 00 35    	bra       LT, 0x18fa <shiftright>
    18e8:	69 28 e1    	.pword 0xe12869
    18ea:	02 00 35    	bra       LT, 0x18f0 <shiftleft>
    18ec:	01 00 28    	mov.w     #0x8000, w1
    18ee:	00 00 05    	retlw.w   #0x0, w0

000018f0 <shiftleft>:
    18f0:	00 00 40    	add.w     w0, w0, w0
    18f2:	81 80 48    	addc.w    w1, w1, w1
    18f4:	85 02 e9    	dec.w     w5, w5
    18f6:	fc ff 3a    	bra       NZ, 0x18f0 <shiftleft>
    18f8:	00 00 06    	return    

000018fa <shiftright>:
    18fa:	f8 8f 42    	add.w     w5, #0x18, [w15]
    18fc:	05 00 35    	bra       LT, 0x1908 <returnzero>

000018fe <shiftrightloop>:
    18fe:	81 00 d1    	lsr.w     w1, w1
    1900:	00 80 d3    	rrc.w     w0, w0
    1902:	85 02 e8    	inc.w     w5, w5
    1904:	fc ff 3a    	bra       NZ, 0x18fe <shiftrightloop>

00001906 <exit>:
    1906:	00 00 06    	return    

00001908 <returnzero>:
    1908:	80 00 eb    	clr.w     w1
    190a:	00 00 05    	retlw.w   #0x0, w0

0000190c <___floatsisf>:
    190c:	4f 89 de    	asr.w     w1, #0xf, w2
    190e:	82 01 78    	mov.w     w2, w3
    1910:	b3 03 37    	bra       0x2078 <___floatdisf>

00001912 <___floatunsisf>:
    1912:	60 11 b8    	mul.uu    w2, #0x0, w2
    1914:	c1 03 37    	bra       0x2098 <___floatundisf>

00001916 <_floorf>:
    1916:	00 01 eb    	clr.w     w2
    1918:	6d 03 07    	rcall     0x1ff4 <__fchop>
    191a:	04 00 32    	bra       Z, 0x1924 <exit>
    191c:	02 00 20    	mov.w     #0x0, w2
    191e:	03 f8 23    	mov.w     #0x3f80, w3
    1920:	01 f0 a7    	btsc.w    w1, #0xf
    1922:	b6 fd 07    	rcall     0x1490 <___subsf3>

00001924 <exit>:
    1924:	00 00 06    	return    

00001926 <_fmodf>:
    1926:	04 00 20    	mov.w     #0x0, w4
    1928:	00 00 37    	bra       0x192a <__fmodrem>

0000192a <__fmodrem>:
    192a:	88 9f be    	mov.d     w8, [w15++]
    192c:	8a 9f be    	mov.d     w10, [w15++]
    192e:	8c 1f 78    	mov.w     w12, [w15++]
    1930:	4f 26 dd    	sl.w      w4, #0xf, w12
    1932:	87 00 07    	rcall     0x1a42 <__funpack2>
    1934:	8e 00 33    	bra       N, 0x1a52 <__fPropagateNaN>
    1936:	61 20 e1    	.pword 0xe12061
    1938:	43 00 32    	bra       Z, 0x19c0 <domainerr>

0000193a <checkxinf>:
    193a:	62 50 e1    	.pword 0xe15062
    193c:	41 00 3e    	bra       GTU, 0x19c0 <domainerr>
    193e:	3e 00 39    	bra       NC, 0x19bc <return8>
    1940:	64 20 e1    	.pword 0xe12064
    1942:	3c 00 32    	bra       Z, 0x19bc <return8>
    1944:	05 82 55    	sub.w     w11, w5, w4
    1946:	0f 00 3b    	bra       NN, 0x1966 <rementry>
    1948:	04 02 e8    	inc.w     w4, w4
    194a:	38 00 3a    	bra       NZ, 0x19bc <return8>
    194c:	80 0f 53    	sub.w     w6, w0, [w15]
    194e:	81 8f 5b    	subb.w    w7, w1, [w15]
    1950:	35 00 34    	bra       LE, 0x19bc <return8>
    1952:	08 00 be    	mov.d     w8, w0
    1954:	03 f0 a1    	bclr.w    w3, #0xf
    1956:	01 f0 a6    	btss.w    w1, #0xf
    1958:	03 f0 a0    	bset.w    w3, #0xf
    195a:	0c f0 a7    	btsc.w    w12, #0xf
    195c:	9a fd 07    	rcall     0x1492 <___addsf3>
    195e:	82 00 37    	bra       0x1a64 <__fbopExit>

00001960 <remloop>:
    1960:	06 03 43    	add.w     w6, w6, w6
    1962:	87 83 4b    	addc.w    w7, w7, w7
    1964:	0c 46 46    	add.b     w12, w12, w12

00001966 <rementry>:
    1966:	00 05 53    	sub.w     w6, w0, w10
    1968:	81 85 5b    	subb.w    w7, w1, w11
    196a:	02 00 33    	bra       N, 0x1970 <remnext>
    196c:	0a 03 be    	mov.d     w10, w6
    196e:	0c 00 a0    	bset.w    w12, #0x0

00001970 <remnext>:
    1970:	04 02 e9    	dec.w     w4, w4
    1972:	f6 ff 3b    	bra       NN, 0x1960 <remloop>
    1974:	85 05 78    	mov.w     w5, w11
    1976:	06 02 43    	add.w     w6, w6, w4
    1978:	87 82 4b    	addc.w    w7, w7, w5
    197a:	04 00 3a    	bra       NZ, 0x1984 <checkmag>
    197c:	60 00 b8    	mul.uu    w0, #0x0, w0
    197e:	09 f0 a7    	btsc.w    w9, #0xf
    1980:	01 f0 a0    	bset.w    w1, #0xf
    1982:	70 00 37    	bra       0x1a64 <__fbopExit>

00001984 <checkmag>:
    1984:	00 02 52    	sub.w     w4, w0, w4
    1986:	81 82 5a    	subb.w    w5, w1, w5

00001988 <normrem>:
    1988:	07 04 e0    	cp0.b     w7
    198a:	04 00 33    	bra       N, 0x1994 <normout>
    198c:	06 03 43    	add.w     w6, w6, w6
    198e:	87 83 4b    	addc.w    w7, w7, w7
    1990:	8b 05 e9    	dec.w     w11, w11
    1992:	fa ff 37    	bra       0x1988 <normrem>

00001994 <normout>:
    1994:	09 05 78    	mov.w     w9, w10
    1996:	06 04 be    	mov.d     w6, w8
    1998:	02 03 be    	mov.d     w2, w6
    199a:	60 11 b8    	mul.uu    w2, #0x0, w2
    199c:	17 00 07    	rcall     0x19cc <__fpack>
    199e:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    19a0:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    19a2:	07 00 35    	bra       LT, 0x19b2 <setsign>
    19a4:	02 00 3c    	bra       GT, 0x19aa <adjustrem> <.LASF9>
    19a6:	0c 08 a3    	btst.z    w12, #0x0
    19a8:	04 00 32    	bra       Z, 0x19b2 <setsign>

000019aa <adjustrem>:
    19aa:	06 01 be    	mov.d     w6, w2
    19ac:	03 f0 a0    	bset.w    w3, #0xf
    19ae:	0c f0 a7    	btsc.w    w12, #0xf
    19b0:	70 fd 07    	rcall     0x1492 <___addsf3>

000019b2 <setsign>:
    19b2:	0a 85 68    	xor.w     w1, w10, w10
    19b4:	01 f0 a1    	bclr.w    w1, #0xf
    19b6:	0a f0 a7    	btsc.w    w10, #0xf
    19b8:	01 f0 a0    	bset.w    w1, #0xf
    19ba:	54 00 37    	bra       0x1a64 <__fbopExit>

000019bc <return8>:
    19bc:	08 00 be    	mov.d     w8, w0
    19be:	52 00 37    	bra       0x1a64 <__fbopExit>

000019c0 <domainerr>:
    19c0:	10 02 20    	mov.w     #0x21, w0
    19c2:	0c f0 a6    	btss.w    w12, #0xf
    19c4:	c0 82 88    	mov.w     w0, 0x1058
    19c6:	52 00 37    	bra       0x1a6c <__fbopReturnNaN>

000019c8 <___nesf2>:
    19c8:	04 00 20    	mov.w     #0x0, w4
    19ca:	3b 03 37    	bra       0x2042 <__fcompare>

000019cc <__fpack>:
    19cc:	81 00 20    	mov.w     #0x8, w1
    19ce:	61 80 55    	sub.w     w11, #0x1, w0
    19d0:	0b 00 3d    	bra       GE, 0x19e8 <notsubnormal>
    19d2:	0b 00 20    	mov.w     #0x0, w11
    19d4:	61 fe 2f    	mov.w     #0xffe6, w1
    19d6:	01 00 e1    	cp.w      w0, w1
    19d8:	1d 00 34    	bra       LE, 0x1a14 <zerosig>

000019da <subnormal>:
    19da:	82 81 71    	ior.w     w3, w2, w3
    19dc:	61 01 64    	and.w     w8, #0x1, w2
    19de:	89 04 d1    	lsr.w     w9, w9
    19e0:	08 84 d3    	rrc.w     w8, w8
    19e2:	00 00 e8    	inc.w     w0, w0
    19e4:	fa ff 3a    	bra       NZ, 0x19da <subnormal>
    19e6:	71 00 20    	mov.w     #0x7, w1

000019e8 <notsubnormal>:
    19e8:	61 00 64    	and.w     w8, #0x1, w0
    19ea:	03 00 70    	ior.w     w0, w3, w0
    19ec:	02 00 60    	and.w     w0, w2, w0
    19ee:	09 00 32    	bra       Z, 0x1a02 <packupandgo>
    19f0:	61 04 44    	add.w     w8, #0x1, w8
    19f2:	e0 84 4c    	addc.w    w9, #0x0, w9
    19f4:	09 88 a5    	btst.z    w9, w1
    19f6:	05 00 32    	bra       Z, 0x1a02 <packupandgo>
    19f8:	8b 05 e8    	inc.w     w11, w11
    19fa:	68 08 e1    	.pword 0xe10868
    19fc:	02 00 3a    	bra       NZ, 0x1a02 <packupandgo>
    19fe:	89 04 d1    	lsr.w     w9, w9
    1a00:	08 84 d3    	rrc.w     w8, w8

00001a02 <packupandgo>:
    1a02:	f2 0f 20    	mov.w     #0xff, w2
    1a04:	02 58 e1    	cp.w      w11, w2
    1a06:	05 00 3d    	bra       GE, 0x1a12 <overflow>
    1a08:	c7 5d dd    	sl.w      w11, #0x7, w11
    1a0a:	f9 07 b2    	and.w     #0x7f, w9
    1a0c:	89 80 75    	ior.w     w11, w9, w1
    1a0e:	08 00 78    	mov.w     w8, w0
    1a10:	00 00 06    	return    

00001a12 <overflow>:
    1a12:	0b f8 27    	mov.w     #0x7f80, w11

00001a14 <zerosig>:
    1a14:	8b 00 78    	mov.w     w11, w1
    1a16:	00 00 05    	retlw.w   #0x0, w0

00001a18 <__funpack>:
    1a18:	c7 0a de    	lsr.w     w1, #0x7, w5
    1a1a:	f1 07 b2    	and.w     #0x7f, w1
    1a1c:	f5 0f b2    	and.w     #0xff, w5
    1a1e:	08 00 32    	bra       Z, 0x1a30 <zeroorsub>
    1a20:	e1 cf 42    	add.b     w5, #0x1, [w15]
    1a22:	02 00 32    	bra       Z, 0x1a28 <nanorinf>

00001a24 <finitereturn>:
    1a24:	01 70 a0    	bset.w    w1, #0x7
    1a26:	24 00 05    	retlw.w   #0x2, w4

00001a28 <nanorinf>:
    1a28:	81 0f 70    	ior.w     w0, w1, [w15]
    1a2a:	01 00 32    	bra       Z, 0x1a2e <infinite>
    1a2c:	04 08 05    	retlw.w   #0x80, w4

00001a2e <infinite>:
    1a2e:	44 00 05    	retlw.w   #0x4, w4

00001a30 <zeroorsub>:
    1a30:	81 0f 70    	ior.w     w0, w1, [w15]
    1a32:	02 00 3a    	bra       NZ, 0x1a38 <subnormal>
    1a34:	14 00 05    	retlw.w   #0x1, w4

00001a36 <normalize>:
    1a36:	85 02 e9    	dec.w     w5, w5

00001a38 <subnormal>:
    1a38:	00 00 40    	add.w     w0, w0, w0
    1a3a:	81 c0 48    	addc.b    w1, w1, w1
    1a3c:	fc ff 3b    	bra       NN, 0x1a36 <normalize>
    1a3e:	01 70 a0    	bset.w    w1, #0x7
    1a40:	24 00 05    	retlw.w   #0x2, w4

00001a42 <__funpack2>:
    1a42:	00 04 be    	mov.d     w0, w8
    1a44:	e9 ff 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1a46:	00 03 be    	mov.d     w0, w6
    1a48:	04 05 be    	mov.d     w4, w10
    1a4a:	02 00 be    	mov.d     w2, w0
    1a4c:	e5 ff 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1a4e:	84 4f 75    	ior.b     w10, w4, [w15]
    1a50:	00 00 06    	return    

00001a52 <__fPropagateNaN>:
    1a52:	02 00 be    	mov.d     w2, w0
    1a54:	64 50 e1    	.pword 0xe15064
    1a56:	05 00 36    	bra       LEU, 0x1a62 <return0> <.LASF24>
    1a58:	64 20 e1    	.pword 0xe12064
    1a5a:	02 00 36    	bra       LEU, 0x1a60 <return8>
    1a5c:	09 68 a3    	btst.z    w9, #0x6
    1a5e:	01 00 3a    	bra       NZ, 0x1a62 <return0> <.LASF24>

00001a60 <return8>:
    1a60:	08 00 be    	mov.d     w8, w0

00001a62 <return0>:
    1a62:	01 60 a0    	bset.w    w1, #0x6

00001a64 <__fbopExit>:
    1a64:	4f 06 78    	mov.w     [--w15], w12
    1a66:	4f 05 be    	mov.d     [--w15], w10
    1a68:	4f 04 be    	mov.d     [--w15], w8
    1a6a:	00 00 06    	return    

00001a6c <__fbopReturnNaN>:
    1a6c:	f0 ff 2f    	mov.w     #0xffff, w0
    1a6e:	f1 ff 27    	mov.w     #0x7fff, w1
    1a70:	f9 ff 37    	bra       0x1a64 <__fbopExit>

00001a72 <_ldexpf>:
    1a72:	00 03 be    	mov.d     w0, w6
    1a74:	d1 ff 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1a76:	62 20 e1    	.pword 0xe12062
    1a78:	02 00 32    	bra       Z, 0x1a7e <finite>
    1a7a:	06 00 be    	mov.d     w6, w0
    1a7c:	00 00 06    	return    

00001a7e <finite>:
    1a7e:	85 02 41    	add.w     w2, w5, w5
    1a80:	e3 0f 20    	mov.w     #0xfe, w3
    1a82:	03 28 e1    	cp.w      w5, w3
    1a84:	05 00 3c    	bra       GT, 0x1a90 <overflow> <.LASF56>
    1a86:	a3 fe 2f    	mov.w     #0xffea, w3
    1a88:	03 28 e1    	cp.w      w5, w3
    1a8a:	07 00 3d    	bra       GE, 0x1a9a <nounderflow>
    1a8c:	05 00 20    	mov.w     #0x0, w5
    1a8e:	01 00 37    	bra       0x1a92 <packupandgozero>

00001a90 <overflow>:
    1a90:	f5 0f 20    	mov.w     #0xff, w5

00001a92 <packupandgozero>:
    1a92:	20 02 20    	mov.w     #0x22, w0
    1a94:	c0 82 88    	mov.w     w0, 0x1058
    1a96:	60 00 b8    	mul.uu    w0, #0x0, w0
    1a98:	08 00 37    	bra       0x1aaa <packupandgo>

00001a9a <nounderflow>:
    1a9a:	13 00 20    	mov.w     #0x1, w3
    1a9c:	83 81 52    	sub.w     w5, w3, w3
    1a9e:	05 00 3d    	bra       GE, 0x1aaa <packupandgo>

00001aa0 <reduce>:
    1aa0:	81 00 d1    	lsr.w     w1, w1
    1aa2:	00 80 d3    	rrc.w     w0, w0
    1aa4:	83 01 e8    	inc.w     w3, w3
    1aa6:	fc ff 3a    	bra       NZ, 0x1aa0 <reduce>
    1aa8:	05 00 20    	mov.w     #0x0, w5

00001aaa <packupandgo>:
    1aaa:	c7 2a dd    	sl.w      w5, #0x7, w5
    1aac:	f1 07 b2    	and.w     #0x7f, w1
    1aae:	85 80 70    	ior.w     w1, w5, w1
    1ab0:	07 f0 a7    	btsc.w    w7, #0xf
    1ab2:	01 f0 a0    	bset.w    w1, #0xf
    1ab4:	00 00 06    	return    

00001ab6 <___mulsf3>:
    1ab6:	88 9f be    	mov.d     w8, [w15++]
    1ab8:	8a 9f be    	mov.d     w10, [w15++]
    1aba:	8c 1f 78    	mov.w     w12, [w15++]
    1abc:	c2 ff 07    	rcall     0x1a42 <__funpack2>
    1abe:	c9 ff 33    	bra       N, 0x1a52 <__fPropagateNaN>
    1ac0:	03 86 6c    	xor.w     w9, w3, w12
    1ac2:	64 50 e1    	.pword 0xe15064
    1ac4:	24 00 32    	bra       Z, 0x1b0e <aisinfinite>
    1ac6:	64 20 e1    	.pword 0xe12064
    1ac8:	27 00 32    	bra       Z, 0x1b18 <bisinfinite>
    1aca:	61 50 e1    	.pword 0xe15061
    1acc:	22 00 32    	bra       Z, 0x1b12 <return8>
    1ace:	61 20 e1    	.pword 0xe12061
    1ad0:	21 00 32    	bra       Z, 0x1b14 <return2>
    1ad2:	8b 85 42    	add.w     w5, w11, w11
    1ad4:	eb 07 b1    	sub.w     #0x7e, w11
    1ad6:	01 34 b8    	mul.uu    w6, w1, w8
    1ad8:	00 3a b8    	mul.uu    w7, w0, w4
    1ada:	08 04 42    	add.w     w4, w8, w8
    1adc:	89 84 4a    	addc.w    w5, w9, w9
    1ade:	01 3a b8    	mul.uu    w7, w1, w4
    1ae0:	00 30 b8    	mul.uu    w6, w0, w0
    1ae2:	88 80 40    	add.w     w1, w8, w1
    1ae4:	09 01 4a    	addc.w    w4, w9, w2
    1ae6:	04 00 33    	bra       N, 0x1af0 <formsticky>
    1ae8:	00 00 40    	add.w     w0, w0, w0
    1aea:	81 80 48    	addc.w    w1, w1, w1
    1aec:	02 01 49    	addc.w    w2, w2, w2
    1aee:	8b 05 e9    	dec.w     w11, w11

00001af0 <formsticky>:
    1af0:	c9 09 dd    	sl.w      w1, #0x9, w3
    1af2:	83 01 70    	ior.w     w0, w3, w3
    1af4:	01 00 32    	bra       Z, 0x1af8 <formRandSig>
    1af6:	13 00 20    	mov.w     #0x1, w3

00001af8 <formRandSig>:
    1af8:	c8 14 de    	lsr.w     w2, #0x8, w9
    1afa:	48 14 dd    	sl.w      w2, #0x8, w8
    1afc:	47 09 de    	lsr.w     w1, #0x7, w2
    1afe:	12 00 b2    	and.w     #0x1, w2
    1b00:	c8 08 de    	lsr.w     w1, #0x8, w1
    1b02:	08 84 70    	ior.w     w1, w8, w8
    1b04:	63 ff 07    	rcall     0x19cc <__fpack>

00001b06 <return0>:
    1b06:	01 f0 a1    	bclr.w    w1, #0xf
    1b08:	0c f0 a7    	btsc.w    w12, #0xf
    1b0a:	01 f0 a0    	bset.w    w1, #0xf
    1b0c:	ab ff 37    	bra       0x1a64 <__fbopExit>

00001b0e <aisinfinite>:
    1b0e:	61 20 e1    	.pword 0xe12061
    1b10:	ad ff 32    	bra       Z, 0x1a6c <__fbopReturnNaN>

00001b12 <return8>:
    1b12:	08 01 be    	mov.d     w8, w2

00001b14 <return2>:
    1b14:	02 00 be    	mov.d     w2, w0
    1b16:	f7 ff 37    	bra       0x1b06 <return0>

00001b18 <bisinfinite>:
    1b18:	61 50 e1    	.pword 0xe15061
    1b1a:	fc ff 3a    	bra       NZ, 0x1b14 <return2>
    1b1c:	a7 ff 37    	bra       0x1a6c <__fbopReturnNaN>

00001b1e <_powf>:
    1b1e:	0c 00 fa    	lnk       #0xc
    1b20:	88 9f be    	mov.d     w8, [w15++]
    1b22:	8a 9f be    	mov.d     w10, [w15++]
    1b24:	8c 9f be    	mov.d     w12, [w15++]
    1b26:	8d ff 07    	rcall     0x1a42 <__funpack2>
    1b28:	02 06 be    	mov.d     w2, w12
    1b2a:	84 05 78    	mov.w     w4, w11
    1b2c:	02 00 be    	mov.d     w2, w0
    1b2e:	02 00 20    	mov.w     #0x0, w2
    1b30:	61 02 07    	rcall     0x1ff4 <__fchop>
    1b32:	05 00 3a    	bra       NZ, 0x1b3e <endintchk> <.LASF5>
    1b34:	8b 02 b3    	ior.w     #0x28, w11
    1b36:	12 00 20    	mov.w     #0x1, w2
    1b38:	5d 02 07    	rcall     0x1ff4 <__fchop>
    1b3a:	01 00 3a    	bra       NZ, 0x1b3e <endintchk> <.LASF5>
    1b3c:	f8 85 6d    	xor.w     w11, #0x18, w11

00001b3e <endintchk>:
    1b3e:	0c 01 be    	mov.d     w12, w2
    1b40:	c6 00 07    	rcall     0x1cce <compareone>
    1b42:	08 00 be    	mov.d     w8, w0
    1b44:	9b 00 32    	bra       Z, 0x1c7c <return0>
    1b46:	0b 08 a3    	btst.z    w11, #0x0
    1b48:	9e 00 3a    	bra       NZ, 0x1c86 <returnone>
    1b4a:	0d f0 a7    	btsc.w    w13, #0xf
    1b4c:	0b e0 a0    	bset.w    w11, #0xe
    1b4e:	09 f0 a7    	btsc.w    w9, #0xf
    1b50:	0b f0 a0    	bset.w    w11, #0xf
    1b52:	09 f0 a1    	bclr.w    w9, #0xf
    1b54:	08 01 be    	mov.d     w8, w2
    1b56:	bb 00 07    	rcall     0x1cce <compareone>
    1b58:	0b f0 a6    	btss.w    w11, #0xf
    1b5a:	95 00 32    	bra       Z, 0x1c86 <returnone>
    1b5c:	01 00 3c    	bra       GT, 0x1b60 <checkNaN>
    1b5e:	0b d0 a0    	bset.w    w11, #0xd

00001b60 <checkNaN>:
    1b60:	8a cf 75    	ior.b     w11, w10, [w15]
    1b62:	b2 00 33    	bra       N, 0x1cc8 <returnNaN>
    1b64:	60 00 b8    	mul.uu    w0, #0x0, w0
    1b66:	62 50 e1    	.pword 0xe15062
    1b68:	99 00 39    	bra       NC, 0x1c9c <xIsZero>
    1b6a:	a1 00 3e    	bra       GTU, 0x1cae <xIsInfinite>
    1b6c:	0b 28 a3    	btst.z    w11, #0x2
    1b6e:	a2 00 3a    	bra       NZ, 0x1cb4 <yIsInfinite>
    1b70:	0b f8 a3    	btst.z    w11, #0xf
    1b72:	06 00 32    	bra       Z, 0x1b80 <finiteargs> <.LASF14>
    1b74:	0b 58 a3    	btst.z    w11, #0x5
    1b76:	a7 00 32    	bra       Z, 0x1cc6 <complexpow>
    1b78:	08 01 be    	mov.d     w8, w2
    1b7a:	a9 00 07    	rcall     0x1cce <compareone>
    1b7c:	08 00 be    	mov.d     w8, w0
    1b7e:	94 00 32    	bra       Z, 0x1ca8 <negifyodd>

00001b80 <finiteargs>:
    1b80:	08 00 be    	mov.d     w8, w0
    1b82:	eb 01 07    	rcall     0x1f5a <__frexpf>
    1b84:	00 04 be    	mov.d     w0, w8
    1b86:	05 05 78    	mov.w     w5, w10
    1b88:	0b f0 a7    	btsc.w    w11, #0xf
    1b8a:	0b 30 a6    	btss.w    w11, #0x3
    1b8c:	0b f0 a1    	bclr.w    w11, #0xf
    1b8e:	5b 07 98    	mov.w     w11, [w14+10]
    1b90:	32 4f 20    	mov.w     #0x4f3, w2
    1b92:	53 f3 23    	mov.w     #0x3f35, w3
    1b94:	7b fe 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1b96:	05 00 3d    	bra       GE, 0x1ba2 <finrange>
    1b98:	08 00 be    	mov.d     w8, w0
    1b9a:	12 00 20    	mov.w     #0x1, w2
    1b9c:	6a ff 07    	rcall     0x1a72 <_ldexpf>
    1b9e:	00 04 be    	mov.d     w0, w8
    1ba0:	0a 05 e9    	dec.w     w10, w10

00001ba2 <finrange>:
    1ba2:	4a 07 98    	mov.w     w10, [w14+8]
    1ba4:	61 50 b9    	mul.su    w10, #0x1, w0
    1ba6:	b2 fe 07    	rcall     0x190c <___floatsisf>
    1ba8:	00 8f be    	mov.d     w0, [w14]
    1baa:	0c 01 be    	mov.d     w12, w2
    1bac:	84 ff 07    	rcall     0x1ab6 <___mulsf3>
    1bae:	72 fe 07    	rcall     0x1894 <___fixsfsi> <.LASF17>
    1bb0:	30 07 98    	mov.w     w0, [w14+6]
    1bb2:	01 00 e0    	cp0.w     w1
    1bb4:	02 00 3d    	bra       GE, 0x1bba <npos>
    1bb6:	60 00 10    	subr.w    w0, #0x0, w0
    1bb8:	e0 80 18    	subbr.w   w1, #0x0, w1

00001bba <npos>:
    1bba:	f2 ff 27    	mov.w     #0x7fff, w2
    1bbc:	82 0f 50    	sub.w     w0, w2, [w15]
    1bbe:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    1bc0:	64 00 3e    	bra       GTU, 0x1c8a <powrangeerror>
    1bc2:	0c 00 be    	mov.d     w12, w0
    1bc4:	67 fe 07    	rcall     0x1894 <___fixsfsi> <.LASF17>
    1bc6:	20 07 98    	mov.w     w0, [w14+4]
    1bc8:	f2 07 20    	mov.w     #0x7f, w2
    1bca:	82 0f 50    	sub.w     w0, w2, [w15]
    1bcc:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    1bce:	05 00 3c    	bra       GT, 0x1bda <mrangeerr>
    1bd0:	12 f8 2f    	mov.w     #0xff81, w2
    1bd2:	f3 ff 2f    	mov.w     #0xffff, w3
    1bd4:	82 0f 50    	sub.w     w0, w2, [w15]
    1bd6:	83 8f 58    	subb.w    w1, w3, [w15]
    1bd8:	09 00 3d    	bra       GE, 0x1bec <minrange>

00001bda <mrangeerr>:
    1bda:	0a 00 e0    	cp0.w     w10
    1bdc:	03 00 32    	bra       Z, 0x1be4 <setwm>
    1bde:	01 00 3c    	bra       GT, 0x1be2 <setn>
    1be0:	02 01 ea    	neg.w     w2, w2

00001be2 <setn>:
    1be2:	02 05 78    	mov.w     w2, w10

00001be4 <setwm>:
    1be4:	60 00 b8    	mul.uu    w0, #0x0, w0
    1be6:	20 07 98    	mov.w     w0, [w14+4]
    1be8:	3a 07 98    	mov.w     w10, [w14+6]
    1bea:	19 00 37    	bra       0x1c1e <common>

00001bec <minrange>:
    1bec:	3e 00 90    	mov.w     [w14+6], w0
    1bee:	61 00 b9    	mul.su    w0, #0x1, w0
    1bf0:	8d fe 07    	rcall     0x190c <___floatsisf>
    1bf2:	80 9f be    	mov.d     w0, [w15++]
    1bf4:	0c 00 be    	mov.d     w12, w0
    1bf6:	41 09 dd    	sl.w      w1, #0x1, w2
    1bf8:	48 11 de    	lsr.w     w2, #0x8, w2
    1bfa:	72 08 b1    	sub.w     #0x87, w2
    1bfc:	fb 01 07    	rcall     0x1ff4 <__fchop>
    1bfe:	00 05 be    	mov.d     w0, w10
    1c00:	1e 01 be    	mov.d     [w14], w2
    1c02:	59 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c04:	4f 01 be    	mov.d     [--w15], w2
    1c06:	44 fc 07    	rcall     0x1490 <___subsf3>
    1c08:	80 9f be    	mov.d     w0, [w15++]
    1c0a:	0c 00 be    	mov.d     w12, w0
    1c0c:	0a 01 be    	mov.d     w10, w2
    1c0e:	40 fc 07    	rcall     0x1490 <___subsf3>
    1c10:	1e 01 be    	mov.d     [w14], w2
    1c12:	51 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c14:	4f 01 be    	mov.d     [--w15], w2
    1c16:	3d fc 07    	rcall     0x1492 <___addsf3>
    1c18:	82 21 27    	mov.w     #0x7218, w2
    1c1a:	13 f3 23    	mov.w     #0x3f31, w3
    1c1c:	4c ff 07    	rcall     0x1ab6 <___mulsf3>

00001c1e <common>:
    1c1e:	00 05 be    	mov.d     w0, w10
    1c20:	2e 00 90    	mov.w     [w14+4], w0
    1c22:	61 00 b9    	mul.su    w0, #0x1, w0
    1c24:	73 fe 07    	rcall     0x190c <___floatsisf>
    1c26:	01 f0 a2    	btg.w     w1, #0xf
    1c28:	0c 01 be    	mov.d     w12, w2
    1c2a:	33 fc 07    	rcall     0x1492 <___addsf3>
    1c2c:	00 06 be    	mov.d     w0, w12
    1c2e:	08 00 be    	mov.d     w8, w0
    1c30:	62 02 07    	rcall     0x20f6 <_logf>
    1c32:	0c 01 be    	mov.d     w12, w2
    1c34:	40 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c36:	0a 01 be    	mov.d     w10, w2
    1c38:	2c fc 07    	rcall     0x1492 <___addsf3>
    1c3a:	80 9f be    	mov.d     w0, [w15++]
    1c3c:	4a 00 07    	rcall     0x1cd2 <loadone>
    1c3e:	2e 05 90    	mov.w     [w14+4], w10
    1c40:	0a f0 a7    	btsc.w    w10, #0xf
    1c42:	0a 05 ea    	neg.w     w10, w10
    1c44:	05 00 37    	bra       0x1c50 <scalebeg>

00001c46 <scalez>:
    1c46:	08 00 be    	mov.d     w8, w0
    1c48:	08 01 be    	mov.d     w8, w2
    1c4a:	35 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c4c:	00 04 be    	mov.d     w0, w8
    1c4e:	0c 00 be    	mov.d     w12, w0

00001c50 <scalebeg>:
    1c50:	08 01 be    	mov.d     w8, w2
    1c52:	0a 00 a7    	btsc.w    w10, #0x0
    1c54:	30 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c56:	00 06 be    	mov.d     w0, w12
    1c58:	0a 05 d1    	lsr.w     w10, w10
    1c5a:	f5 ff 3a    	bra       NZ, 0x1c46 <scalez> <.LASF27>

00001c5c <zscaled>:
    1c5c:	5e 01 90    	mov.w     [w14+10], w2
    1c5e:	02 e0 a6    	btss.w    w2, #0xe
    1c60:	03 00 37    	bra       0x1c68 <zcomputed>
    1c62:	00 01 be    	mov.d     w0, w2
    1c64:	36 00 07    	rcall     0x1cd2 <loadone>
    1c66:	5f fd 07    	rcall     0x1726 <___divsf3>

00001c68 <zcomputed>:
    1c68:	00 04 be    	mov.d     w0, w8
    1c6a:	4f 00 be    	mov.d     [--w15], w0
    1c6c:	ad fd 07    	rcall     0x17c8 <_expf>
    1c6e:	08 01 be    	mov.d     w8, w2
    1c70:	22 ff 07    	rcall     0x1ab6 <___mulsf3>
    1c72:	3e 01 90    	mov.w     [w14+6], w2
    1c74:	fe fe 07    	rcall     0x1a72 <_ldexpf>
    1c76:	de 05 90    	mov.w     [w14+10], w11

00001c78 <signresult>:
    1c78:	0b f0 a7    	btsc.w    w11, #0xf
    1c7a:	01 f0 a2    	btg.w     w1, #0xf

00001c7c <return0>:
    1c7c:	4f 06 be    	mov.d     [--w15], w12
    1c7e:	4f 05 be    	mov.d     [--w15], w10
    1c80:	4f 04 be    	mov.d     [--w15], w8
    1c82:	00 80 fa    	ulnk      
    1c84:	00 00 06    	return    

00001c86 <returnone>:
    1c86:	25 00 07    	rcall     0x1cd2 <loadone>
    1c88:	f9 ff 37    	bra       0x1c7c <return0>

00001c8a <powrangeerror>:
    1c8a:	27 00 07    	rcall     0x1cda <rangeerror>
    1c8c:	60 00 b8    	mul.uu    w0, #0x0, w0
    1c8e:	0b d0 a7    	btsc.w    w11, #0xd
    1c90:	0b c0 a0    	bset.w    w11, #0xc
    1c92:	0b e0 a7    	btsc.w    w11, #0xe
    1c94:	0b c0 a2    	btg.w     w11, #0xc
    1c96:	0b c0 a7    	btsc.w    w11, #0xc
    1c98:	01 f8 27    	mov.w     #0x7f80, w1
    1c9a:	f0 ff 37    	bra       0x1c7c <return0>

00001c9c <xIsZero>:
    1c9c:	0d f8 a3    	btst.z    w13, #0xf
    1c9e:	02 00 32    	bra       Z, 0x1ca4 <negifodd>
    1ca0:	1e 00 07    	rcall     0x1cde <domainerror>

00001ca2 <infnegifodd>:
    1ca2:	19 00 07    	rcall     0x1cd6 <loadinfinity> <.LASF33>

00001ca4 <negifodd>:
    1ca4:	0b f8 a3    	btst.z    w11, #0xf
    1ca6:	ea ff 32    	bra       Z, 0x1c7c <return0>

00001ca8 <negifyodd>:
    1ca8:	0b 30 a7    	btsc.w    w11, #0x3
    1caa:	01 f0 a2    	btg.w     w1, #0xf
    1cac:	e7 ff 37    	bra       0x1c7c <return0>

00001cae <xIsInfinite>:
    1cae:	0d f8 a3    	btst.z    w13, #0xf
    1cb0:	f9 ff 3a    	bra       NZ, 0x1ca4 <negifodd>
    1cb2:	f7 ff 37    	bra       0x1ca2 <infnegifodd>

00001cb4 <yIsInfinite>:
    1cb4:	08 01 be    	mov.d     w8, w2
    1cb6:	0b 00 07    	rcall     0x1cce <compareone>
    1cb8:	e6 ff 32    	bra       Z, 0x1c86 <returnone>
    1cba:	01 00 3c    	bra       GT, 0x1cbe <flessthanone>
    1cbc:	0d f0 a2    	btg.w     w13, #0xf

00001cbe <flessthanone>:
    1cbe:	60 00 b8    	mul.uu    w0, #0x0, w0
    1cc0:	0d f0 a7    	btsc.w    w13, #0xf
    1cc2:	09 00 07    	rcall     0x1cd6 <loadinfinity> <.LASF33>
    1cc4:	db ff 37    	bra       0x1c7c <return0>

00001cc6 <complexpow>:
    1cc6:	0b 00 07    	rcall     0x1cde <domainerror>

00001cc8 <returnNaN>:
    1cc8:	f1 ff 27    	mov.w     #0x7fff, w1
    1cca:	f0 ff 2f    	mov.w     #0xffff, w0
    1ccc:	d7 ff 37    	bra       0x1c7c <return0>

00001cce <compareone>:
    1cce:	01 00 07    	rcall     0x1cd2 <loadone>
    1cd0:	dd fd 37    	bra       0x188c <___eqsf2> <___lesf2> <___ltsf2>

00001cd2 <loadone>:
    1cd2:	01 f8 23    	mov.w     #0x3f80, w1
    1cd4:	00 00 05    	retlw.w   #0x0, w0

00001cd6 <loadinfinity>:
    1cd6:	01 f8 27    	mov.w     #0x7f80, w1
    1cd8:	00 00 05    	retlw.w   #0x0, w0

00001cda <rangeerror>:
    1cda:	20 02 20    	mov.w     #0x22, w0
    1cdc:	01 00 37    	bra       0x1ce0 <seterrno> <.LASF41>

00001cde <domainerror>:
    1cde:	10 02 20    	mov.w     #0x21, w0

00001ce0 <seterrno>:
    1ce0:	c0 82 88    	mov.w     w0, 0x1058
    1ce2:	00 00 06    	return    

00001ce4 <__sincosf>:
    1ce4:	88 9f be    	mov.d     w8, [w15++]
    1ce6:	8a 9f be    	mov.d     w10, [w15++]
    1ce8:	8c 9f be    	mov.d     w12, [w15++]
    1cea:	82 05 78    	mov.w     w2, w11
    1cec:	00 04 be    	mov.d     w0, w8
    1cee:	94 fe 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1cf0:	08 00 be    	mov.d     w8, w0
    1cf2:	64 20 e1    	.pword 0xe12064
    1cf4:	07 00 39    	bra       NC, 0x1d04 <finite>
    1cf6:	02 00 3a    	bra       NZ, 0x1cfc <isNaN>
    1cf8:	f1 ff 27    	mov.w     #0x7fff, w1
    1cfa:	f0 ff 2f    	mov.w     #0xffff, w0

00001cfc <isNaN>:
    1cfc:	01 60 a0    	bset.w    w1, #0x6

00001cfe <domainerr>:
    1cfe:	12 02 20    	mov.w     #0x21, w2
    1d00:	c2 82 88    	mov.w     w2, 0x1058
    1d02:	55 00 37    	bra       0x1dae <return0>

00001d04 <finite>:
    1d04:	61 20 e1    	.pword 0xe12061
    1d06:	03 00 3a    	bra       NZ, 0x1d0e <nonzero>
    1d08:	0b 00 a7    	btsc.w    w11, #0x0
    1d0a:	01 f8 23    	mov.w     #0x3f80, w1
    1d0c:	50 00 37    	bra       0x1dae <return0>

00001d0e <nonzero>:
    1d0e:	01 f0 a1    	bclr.w    w1, #0xf
    1d10:	02 00 21    	mov.w     #0x1000, w2
    1d12:	93 64 24    	mov.w     #0x4649, w3
    1d14:	bb fd 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1d16:	08 00 be    	mov.d     w8, w0
    1d18:	04 00 35    	bra       LT, 0x1d22 <inrange>
    1d1a:	b2 fd 20    	mov.w     #0xfdb, w2
    1d1c:	93 0c 24    	mov.w     #0x40c9, w3
    1d1e:	03 fe 07    	rcall     0x1926 <_fmodf>
    1d20:	00 04 be    	mov.d     w0, w8

00001d22 <inrange>:
    1d22:	00 05 eb    	clr.w     w10
    1d24:	0b 00 a6    	btss.w    w11, #0x0
    1d26:	4f 0d de    	lsr.w     w1, #0xf, w10
    1d28:	01 f0 a1    	bclr.w    w1, #0xf
    1d2a:	00 04 be    	mov.d     w0, w8
    1d2c:	32 98 2f    	mov.w     #0xf983, w2
    1d2e:	23 ea 23    	mov.w     #0x3ea2, w3
    1d30:	c2 fe 07    	rcall     0x1ab6 <___mulsf3>
    1d32:	00 01 eb    	clr.w     w2
    1d34:	03 f0 23    	mov.w     #0x3f00, w3
    1d36:	0b 00 a7    	btsc.w    w11, #0x0
    1d38:	03 f8 23    	mov.w     #0x3f80, w3
    1d3a:	ab fb 07    	rcall     0x1492 <___addsf3>
    1d3c:	ab fd 07    	rcall     0x1894 <___fixsfsi> <.LASF17>
    1d3e:	00 00 a7    	btsc.w    w0, #0x0
    1d40:	0a 00 a2    	btg.w     w10, #0x0
    1d42:	e4 fd 07    	rcall     0x190c <___floatsisf>
    1d44:	0b 00 e0    	cp0.w     w11
    1d46:	03 00 32    	bra       Z, 0x1d4e <common> <.LASF23>
    1d48:	02 00 20    	mov.w     #0x0, w2
    1d4a:	03 f0 23    	mov.w     #0x3f00, w3
    1d4c:	a1 fb 07    	rcall     0x1490 <___subsf3>

00001d4e <common>:
    1d4e:	01 f0 a2    	btg.w     w1, #0xf
    1d50:	00 06 be    	mov.d     w0, w12
    1d52:	02 00 20    	mov.w     #0x0, w2
    1d54:	93 04 24    	mov.w     #0x4049, w3
    1d56:	af fe 07    	rcall     0x1ab6 <___mulsf3>
    1d58:	08 01 be    	mov.d     w8, w2
    1d5a:	9b fb 07    	rcall     0x1492 <___addsf3>
    1d5c:	80 9f be    	mov.d     w0, [w15++]
    1d5e:	0c 00 be    	mov.d     w12, w0
    1d60:	22 a2 2a    	mov.w     #0xaa22, w2
    1d62:	d3 a7 23    	mov.w     #0x3a7d, w3
    1d64:	a8 fe 07    	rcall     0x1ab6 <___mulsf3>
    1d66:	4f 01 be    	mov.d     [--w15], w2
    1d68:	94 fb 07    	rcall     0x1492 <___addsf3>
    1d6a:	00 04 be    	mov.d     w0, w8
    1d6c:	01 f0 a1    	bclr.w    w1, #0xf
    1d6e:	02 00 20    	mov.w     #0x0, w2
    1d70:	03 98 23    	mov.w     #0x3980, w3
    1d72:	8c fd 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1d74:	08 00 be    	mov.d     w8, w0
    1d76:	19 00 35    	bra       LT, 0x1daa <signresult>
    1d78:	00 01 be    	mov.d     w0, w2
    1d7a:	9d fe 07    	rcall     0x1ab6 <___mulsf3>
    1d7c:	00 06 be    	mov.d     w0, w12
    1d7e:	b2 c5 29    	mov.w     #0x9c5b, w2
    1d80:	e3 62 23    	mov.w     #0x362e, w3
    1d82:	99 fe 07    	rcall     0x1ab6 <___mulsf3>
    1d84:	22 22 2b    	mov.w     #0xb222, w2
    1d86:	f3 94 2b    	mov.w     #0xb94f, w3
    1d88:	84 fb 07    	rcall     0x1492 <___addsf3>
    1d8a:	0c 01 be    	mov.d     w12, w2
    1d8c:	94 fe 07    	rcall     0x1ab6 <___mulsf3>
    1d8e:	e2 73 28    	mov.w     #0x873e, w2
    1d90:	83 c0 23    	mov.w     #0x3c08, w3
    1d92:	7f fb 07    	rcall     0x1492 <___addsf3>
    1d94:	0c 01 be    	mov.d     w12, w2
    1d96:	8f fe 07    	rcall     0x1ab6 <___mulsf3>
    1d98:	42 aa 2a    	mov.w     #0xaaa4, w2
    1d9a:	a3 e2 2b    	mov.w     #0xbe2a, w3
    1d9c:	7a fb 07    	rcall     0x1492 <___addsf3>
    1d9e:	0c 01 be    	mov.d     w12, w2
    1da0:	8a fe 07    	rcall     0x1ab6 <___mulsf3>
    1da2:	08 01 be    	mov.d     w8, w2
    1da4:	88 fe 07    	rcall     0x1ab6 <___mulsf3>
    1da6:	08 01 be    	mov.d     w8, w2
    1da8:	74 fb 07    	rcall     0x1492 <___addsf3>

00001daa <signresult>:
    1daa:	0a 00 a7    	btsc.w    w10, #0x0
    1dac:	01 f0 a2    	btg.w     w1, #0xf

00001dae <return0>:
    1dae:	4f 06 be    	mov.d     [--w15], w12
    1db0:	4f 05 be    	mov.d     [--w15], w10
    1db2:	4f 04 be    	mov.d     [--w15], w8
    1db4:	00 00 06    	return    

00001db6 <_sinf>:
    1db6:	00 01 eb    	clr.w     w2
    1db8:	95 ff 37    	bra       0x1ce4 <__sincosf>

00001dba <_sqrtf>:
    1dba:	88 9f be    	mov.d     w8, [w15++]
    1dbc:	8a 9f be    	mov.d     w10, [w15++]
    1dbe:	8c 1f 78    	mov.w     w12, [w15++]
    1dc0:	00 04 be    	mov.d     w0, w8
    1dc2:	2a fe 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1dc4:	04 78 a3    	btst.z    w4, #0x7
    1dc6:	26 00 3a    	bra       NZ, 0x1e14 <xisNaN>
    1dc8:	61 20 e1    	.pword 0xe12061
    1dca:	25 00 32    	bra       Z, 0x1e16 <return8>
    1dcc:	09 f8 a3    	btst.z    w9, #0xf
    1dce:	25 00 3a    	bra       NZ, 0x1e1a <domainerr>
    1dd0:	64 20 e1    	.pword 0xe12064
    1dd2:	21 00 32    	bra       Z, 0x1e16 <return8>
    1dd4:	f5 07 b1    	sub.w     #0x7f, w5
    1dd6:	05 08 a3    	btst.z    w5, #0x0
    1dd8:	02 00 32    	bra       Z, 0x1dde <ncanonical>
    1dda:	00 00 40    	add.w     w0, w0, w0
    1ddc:	81 80 48    	addc.w    w1, w1, w1

00001dde <ncanonical>:
    1dde:	60 44 b8    	mul.uu    w8, #0x0, w8
    1de0:	03 10 20    	mov.w     #0x100, w3
    1de2:	02 00 20    	mov.w     #0x0, w2

00001de4 <qloop>:
    1de4:	00 00 40    	add.w     w0, w0, w0
    1de6:	81 80 48    	addc.w    w1, w1, w1
    1de8:	08 05 44    	add.w     w8, w8, w10
    1dea:	89 85 4c    	addc.w    w9, w9, w11
    1dec:	0a 05 41    	add.w     w2, w10, w10
    1dee:	8b 85 49    	addc.w    w3, w11, w11
    1df0:	0a 05 50    	sub.w     w0, w10, w10
    1df2:	8b 85 58    	subb.w    w1, w11, w11
    1df4:	03 00 33    	bra       N, 0x1dfc <qnext>
    1df6:	0a 00 be    	mov.d     w10, w0
    1df8:	02 04 74    	ior.w     w8, w2, w8
    1dfa:	83 84 74    	ior.w     w9, w3, w9

00001dfc <qnext>:
    1dfc:	83 01 d1    	lsr.w     w3, w3
    1dfe:	02 81 d3    	rrc.w     w2, w2
    1e00:	83 0f 71    	ior.w     w2, w3, [w15]
    1e02:	f0 ff 3a    	bra       NZ, 0x1de4 <qloop>
    1e04:	89 04 d1    	lsr.w     w9, w9
    1e06:	08 84 d3    	rrc.w     w8, w8
    1e08:	60 01 49    	addc.w    w2, #0x0, w2
    1e0a:	82 01 78    	mov.w     w2, w3
    1e0c:	c1 ad de    	asr.w     w5, #0x1, w11
    1e0e:	fb 07 b0    	add.w     #0x7f, w11
    1e10:	dd fd 07    	rcall     0x19cc <__fpack>
    1e12:	28 fe 37    	bra       0x1a64 <__fbopExit>

00001e14 <xisNaN>:
    1e14:	09 60 a0    	bset.w    w9, #0x6

00001e16 <return8>:
    1e16:	08 00 be    	mov.d     w8, w0
    1e18:	25 fe 37    	bra       0x1a64 <__fbopExit>

00001e1a <domainerr>:
    1e1a:	12 02 20    	mov.w     #0x21, w2
    1e1c:	c2 82 88    	mov.w     w2, 0x1058
    1e1e:	f0 ff 2f    	mov.w     #0xffff, w0
    1e20:	f1 ff 27    	mov.w     #0x7fff, w1
    1e22:	20 fe 37    	bra       0x1a64 <__fbopExit>

00001e24 <_tanf>:
    1e24:	88 9f be    	mov.d     w8, [w15++]
    1e26:	8a 9f be    	mov.d     w10, [w15++]
    1e28:	00 04 be    	mov.d     w0, w8
    1e2a:	f6 fd 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1e2c:	08 00 be    	mov.d     w8, w0
    1e2e:	64 20 e1    	.pword 0xe12064
    1e30:	07 00 39    	bra       NC, 0x1e40 <finite>
    1e32:	02 00 3a    	bra       NZ, 0x1e38 <isNaN>
    1e34:	f1 ff 27    	mov.w     #0x7fff, w1
    1e36:	f0 ff 2f    	mov.w     #0xffff, w0

00001e38 <isNaN>:
    1e38:	01 60 a0    	bset.w    w1, #0x6

00001e3a <domainerr>:
    1e3a:	12 02 20    	mov.w     #0x21, w2
    1e3c:	c2 82 88    	mov.w     w2, 0x1058
    1e3e:	4c 00 37    	bra       0x1ed8 <return0>

00001e40 <finite>:
    1e40:	01 f0 a1    	bclr.w    w1, #0xf
    1e42:	02 80 20    	mov.w     #0x800, w2
    1e44:	93 5c 24    	mov.w     #0x45c9, w3
    1e46:	22 fd 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    1e48:	08 00 be    	mov.d     w8, w0
    1e4a:	04 00 35    	bra       LT, 0x1e54 <argreduction>
    1e4c:	b2 fd 20    	mov.w     #0xfdb, w2
    1e4e:	93 04 24    	mov.w     #0x4049, w3
    1e50:	6a fd 07    	rcall     0x1926 <_fmodf>
    1e52:	00 04 be    	mov.d     w0, w8

00001e54 <argreduction>:
    1e54:	32 98 2f    	mov.w     #0xf983, w2
    1e56:	23 f2 23    	mov.w     #0x3f22, w3
    1e58:	2e fe 07    	rcall     0x1ab6 <___mulsf3>
    1e5a:	02 00 20    	mov.w     #0x0, w2
    1e5c:	03 f0 23    	mov.w     #0x3f00, w3
    1e5e:	01 f0 a7    	btsc.w    w1, #0xf
    1e60:	03 f0 a0    	bset.w    w3, #0xf
    1e62:	17 fb 07    	rcall     0x1492 <___addsf3>
    1e64:	17 fd 07    	rcall     0x1894 <___fixsfsi> <.LASF17>
    1e66:	80 1f 78    	mov.w     w0, [w15++]
    1e68:	51 fd 07    	rcall     0x190c <___floatsisf>
    1e6a:	01 f0 a2    	btg.w     w1, #0xf
    1e6c:	00 05 be    	mov.d     w0, w10
    1e6e:	02 00 20    	mov.w     #0x0, w2
    1e70:	93 fc 23    	mov.w     #0x3fc9, w3
    1e72:	21 fe 07    	rcall     0x1ab6 <___mulsf3>
    1e74:	08 01 be    	mov.d     w8, w2
    1e76:	0d fb 07    	rcall     0x1492 <___addsf3>
    1e78:	80 9f be    	mov.d     w0, [w15++]
    1e7a:	0a 00 be    	mov.d     w10, w0
    1e7c:	22 a2 2a    	mov.w     #0xaa22, w2
    1e7e:	d3 9f 23    	mov.w     #0x39fd, w3
    1e80:	1a fe 07    	rcall     0x1ab6 <___mulsf3>
    1e82:	4f 01 be    	mov.d     [--w15], w2
    1e84:	06 fb 07    	rcall     0x1492 <___addsf3>
    1e86:	00 04 be    	mov.d     w0, w8
    1e88:	01 f0 a1    	bclr.w    w1, #0xf
    1e8a:	02 00 20    	mov.w     #0x0, w2
    1e8c:	03 98 23    	mov.w     #0x3980, w3
    1e8e:	00 fd 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    1e90:	03 00 3d    	bra       GE, 0x1e98 <inrange>
    1e92:	00 00 20    	mov.w     #0x0, w0
    1e94:	01 f8 23    	mov.w     #0x3f80, w1
    1e96:	18 00 37    	bra       0x1ec8 <determineq>

00001e98 <inrange>:
    1e98:	08 00 be    	mov.d     w8, w0
    1e9a:	00 01 be    	mov.d     w0, w2
    1e9c:	0c fe 07    	rcall     0x1ab6 <___mulsf3>
    1e9e:	00 05 be    	mov.d     w0, w10
    1ea0:	82 3b 23    	mov.w     #0x33b8, w2
    1ea2:	43 dc 2b    	mov.w     #0xbdc4, w3
    1ea4:	08 fe 07    	rcall     0x1ab6 <___mulsf3>
    1ea6:	08 01 be    	mov.d     w8, w2
    1ea8:	06 fe 07    	rcall     0x1ab6 <___mulsf3>
    1eaa:	08 01 be    	mov.d     w8, w2
    1eac:	f2 fa 07    	rcall     0x1492 <___addsf3>
    1eae:	00 04 be    	mov.d     w0, w8
    1eb0:	0a 00 be    	mov.d     w10, w0
    1eb2:	52 37 23    	mov.w     #0x3375, w2
    1eb4:	f3 c1 23    	mov.w     #0x3c1f, w3
    1eb6:	ff fd 07    	rcall     0x1ab6 <___mulsf3>
    1eb8:	f2 7a 2b    	mov.w     #0xb7af, w2
    1eba:	b3 ed 2b    	mov.w     #0xbedb, w3
    1ebc:	ea fa 07    	rcall     0x1492 <___addsf3>
    1ebe:	0a 01 be    	mov.d     w10, w2
    1ec0:	fa fd 07    	rcall     0x1ab6 <___mulsf3>
    1ec2:	02 00 20    	mov.w     #0x0, w2
    1ec4:	03 f8 23    	mov.w     #0x3f80, w3
    1ec6:	e5 fa 07    	rcall     0x1492 <___addsf3>

00001ec8 <determineq>:
    1ec8:	4f 00 a6    	btss.w    [--w15], #0x0
    1eca:	03 00 37    	bra       0x1ed2 <neven>
    1ecc:	08 01 be    	mov.d     w8, w2
    1ece:	03 f0 a2    	btg.w     w3, #0xf
    1ed0:	02 00 37    	bra       0x1ed6 <ratio>

00001ed2 <neven>:
    1ed2:	00 01 be    	mov.d     w0, w2
    1ed4:	08 00 be    	mov.d     w8, w0

00001ed6 <ratio>:
    1ed6:	27 fc 07    	rcall     0x1726 <___divsf3>

00001ed8 <return0>:
    1ed8:	4f 05 be    	mov.d     [--w15], w10
    1eda:	4f 04 be    	mov.d     [--w15], w8
    1edc:	00 00 06    	return    

00001ede <___truncdfsf2>:
    1ede:	14 00 fa    	lnk       #0x14
    1ee0:	88 9f be    	mov.d     w8, [w15++]
    1ee2:	8a 9f be    	mov.d     w10, [w15++]
    1ee4:	8c 9f be    	mov.d     w12, [w15++]
    1ee6:	00 05 be    	mov.d     w0, w10
    1ee8:	02 06 be    	mov.d     w2, w12
    1eea:	68 00 47    	add.w     w14, #0x8, w0
    1eec:	0c 90 be    	mov.d     w12, [w0--]
    1eee:	0a 90 be    	mov.d     w10, [w0--]
    1ef0:	41 00 07    	rcall     0x1f74 <__dunpack>
    1ef2:	64 00 e1    	.pword 0xe10064
    1ef4:	1a 00 32    	bra       Z, 0x1f2a <xIsInf>
    1ef6:	16 00 3e    	bra       GTU, 0x1f24 <xIsNaN>
    1ef8:	61 00 e1    	.pword 0xe10061
    1efa:	1a 00 32    	bra       Z, 0x1f30 <xIsZero> <.LASF1>
    1efc:	6e 04 90    	mov.w     [w14+12], w8
    1efe:	fe 04 90    	mov.w     [w14+14], w9
    1f00:	0e 0b 90    	mov.w     [w14+16], w6
    1f02:	9e 0b 90    	mov.w     [w14+18], w7
    1f04:	60 11 b8    	mul.uu    w2, #0x0, w2
    1f06:	9e 05 90    	mov.w     [w14+2], w11
    1f08:	0b 38 b1    	sub.w     #0x380, w11
    1f0a:	d5 01 20    	mov.w     #0x1d, w5

00001f0c <align>:
    1f0c:	82 81 71    	ior.w     w3, w2, w3
    1f0e:	61 01 64    	and.w     w8, #0x1, w2
    1f10:	87 03 d1    	lsr.w     w7, w7
    1f12:	06 83 d3    	rrc.w     w6, w6
    1f14:	89 84 d3    	rrc.w     w9, w9
    1f16:	08 84 d3    	rrc.w     w8, w8
    1f18:	85 02 e9    	dec.w     w5, w5
    1f1a:	f8 ff 3a    	bra       NZ, 0x1f0c <align>
    1f1c:	57 fd 07    	rcall     0x19cc <__fpack>

00001f1e <signoff>:
    1f1e:	0d f0 a7    	btsc.w    w13, #0xf
    1f20:	01 f0 a0    	bset.w    w1, #0xf

00001f22 <exit>:
    1f22:	63 00 37    	bra       0x1fea <__dunpack2exit>

00001f24 <xIsNaN>:
    1f24:	f1 ff 27    	mov.w     #0x7fff, w1
    1f26:	f0 ff 2f    	mov.w     #0xffff, w0
    1f28:	60 00 37    	bra       0x1fea <__dunpack2exit>

00001f2a <xIsInf>:
    1f2a:	01 f8 27    	mov.w     #0x7f80, w1
    1f2c:	00 00 20    	mov.w     #0x0, w0
    1f2e:	f7 ff 37    	bra       0x1f1e <signoff>

00001f30 <xIsZero>:
    1f30:	60 00 b8    	mul.uu    w0, #0x0, w0
    1f32:	f5 ff 37    	bra       0x1f1e <signoff>

00001f34 <___udivsi3>:
    1f34:	60 22 b8    	mul.uu    w4, #0x0, w4
    1f36:	06 02 20    	mov.w     #0x20, w6

00001f38 <nextbit>:
    1f38:	00 00 d0    	sl.w      w0, w0
    1f3a:	81 80 d2    	rlc.w     w1, w1
    1f3c:	04 82 d2    	rlc.w     w4, w4
    1f3e:	85 82 d2    	rlc.w     w5, w5
    1f40:	00 00 a0    	bset.w    w0, #0x0
    1f42:	02 02 52    	sub.w     w4, w2, w4
    1f44:	83 82 5a    	subb.w    w5, w3, w5
    1f46:	03 00 31    	bra       C, 0x1f4e <iterate>
    1f48:	02 02 42    	add.w     w4, w2, w4
    1f4a:	83 82 4a    	addc.w    w5, w3, w5
    1f4c:	00 00 a1    	bclr.w    w0, #0x0

00001f4e <iterate>:
    1f4e:	06 03 e9    	dec.w     w6, w6
    1f50:	f3 ff 3a    	bra       NZ, 0x1f38 <nextbit>
    1f52:	00 00 06    	return    

00001f54 <___umodsi3>:
    1f54:	ef ff 07    	rcall     0x1f34 <___udivsi3>
    1f56:	04 00 be    	mov.d     w4, w0
    1f58:	00 00 06    	return    

00001f5a <__frexpf>:
    1f5a:	00 03 be    	mov.d     w0, w6
    1f5c:	5d fd 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1f5e:	62 20 e1    	.pword 0xe12062
    1f60:	02 00 32    	bra       Z, 0x1f66 <finite>
    1f62:	06 00 be    	mov.d     w6, w0
    1f64:	05 00 05    	retlw.w   #0x0, w5

00001f66 <finite>:
    1f66:	e5 07 b1    	sub.w     #0x7e, w5
    1f68:	f1 07 b2    	and.w     #0x7f, w1
    1f6a:	04 f0 23    	mov.w     #0x3f00, w4
    1f6c:	84 80 70    	ior.w     w1, w4, w1
    1f6e:	07 f0 a7    	btsc.w    w7, #0xf
    1f70:	01 f0 a0    	bset.w    w1, #0xf
    1f72:	24 00 05    	retlw.w   #0x2, w4

00001f74 <__dunpack>:
    1f74:	80 00 78    	mov.w     w0, w1
    1f76:	50 02 be    	mov.d     [++w0], w4
    1f78:	50 03 be    	mov.d     [++w0], w6
    1f7a:	44 39 de    	lsr.w     w7, #0x4, w2
    1f7c:	f7 00 b2    	and.w     #0xf, w7
    1f7e:	f3 7f 20    	mov.w     #0x7ff, w3
    1f80:	03 01 61    	and.w     w2, w3, w2
    1f82:	09 00 32    	bra       Z, 0x1f96 <zeroorsub>
    1f84:	02 18 e1    	cp.w      w3, w2
    1f86:	16 00 3a    	bra       NZ, 0x1fb4 <finitereturn> <.LASF35>
    1f88:	85 01 72    	ior.w     w4, w5, w3
    1f8a:	83 01 73    	ior.w     w6, w3, w3
    1f8c:	83 81 73    	ior.w     w7, w3, w3
    1f8e:	00 08 20    	mov.w     #0x80, w0
    1f90:	15 00 3a    	bra       NZ, 0x1fbc <exit>
    1f92:	40 00 20    	mov.w     #0x4, w0
    1f94:	13 00 37    	bra       0x1fbc <exit>

00001f96 <zeroorsub>:
    1f96:	85 01 72    	ior.w     w4, w5, w3
    1f98:	83 01 73    	ior.w     w6, w3, w3
    1f9a:	83 81 73    	ior.w     w7, w3, w3
    1f9c:	05 00 3a    	bra       NZ, 0x1fa8 <subnormal>
    1f9e:	04 a8 be    	mov.d     w4, [++w0]
    1fa0:	06 a8 be    	mov.d     w6, [++w0]
    1fa2:	10 00 20    	mov.w     #0x1, w0
    1fa4:	0b 00 37    	bra       0x1fbc <exit>

00001fa6 <normalize>:
    1fa6:	02 01 e9    	dec.w     w2, w2

00001fa8 <subnormal>:
    1fa8:	04 02 42    	add.w     w4, w4, w4
    1faa:	85 82 4a    	addc.w    w5, w5, w5
    1fac:	06 03 4b    	addc.w    w6, w6, w6
    1fae:	87 83 4b    	addc.w    w7, w7, w7
    1fb0:	07 48 a3    	btst.z    w7, #0x4
    1fb2:	f9 ff 32    	bra       Z, 0x1fa6 <normalize>

00001fb4 <finitereturn>:
    1fb4:	07 40 a0    	bset.w    w7, #0x4
    1fb6:	04 a8 be    	mov.d     w4, [++w0]
    1fb8:	06 a8 be    	mov.d     w6, [++w0]
    1fba:	20 00 20    	mov.w     #0x2, w0

00001fbc <exit>:
    1fbc:	80 00 98    	mov.w     w0, [w1+0]
    1fbe:	92 00 98    	mov.w     w2, [w1+2]
    1fc0:	00 00 06    	return    

00001fc2 <__dunpack2>:
    1fc2:	68 04 47    	add.w     w14, #0x8, w8
    1fc4:	02 94 be    	mov.d     w2, [w8--]
    1fc6:	00 94 be    	mov.d     w0, [w8--]
    1fc8:	fc 04 47    	add.w     w14, #0x1c, w9
    1fca:	86 94 be    	mov.d     w6, [w9--]
    1fcc:	84 94 be    	mov.d     w4, [w9--]
    1fce:	09 00 78    	mov.w     w9, w0
    1fd0:	d1 ff 07    	rcall     0x1f74 <__dunpack>
    1fd2:	08 00 78    	mov.w     w8, w0
    1fd4:	cf ff 07    	rcall     0x1f74 <__dunpack>
    1fd6:	99 00 78    	mov.w     [w9], w1
    1fd8:	81 4f 70    	ior.b     w0, w1, [w15]
    1fda:	0b 00 3b    	bra       NN, 0x1ff2 <exit>

00001fdc <aorbIsNaN>:
    1fdc:	08 00 be    	mov.d     w8, w0
    1fde:	e2 00 07    	rcall     0x21a4 <__dPropagateNaN>
    1fe0:	4f 00 b1    	sub.w     #0x4, w15
    1fe2:	03 00 37    	bra       0x1fea <__dunpack2exit>

00001fe4 <__dreturnNaN>:
    1fe4:	f3 ff 27    	mov.w     #0x7fff, w3
    1fe6:	f2 ff 2f    	mov.w     #0xffff, w2
    1fe8:	61 10 b9    	mul.su    w2, #0x1, w0

00001fea <__dunpack2exit>:
    1fea:	4f 06 be    	mov.d     [--w15], w12
    1fec:	4f 05 be    	mov.d     [--w15], w10
    1fee:	4f 04 be    	mov.d     [--w15], w8
    1ff0:	00 80 fa    	ulnk      

00001ff2 <exit>:
    1ff2:	00 00 06    	return    

00001ff4 <__fchop>:
    1ff4:	88 9f be    	mov.d     w8, [w15++]
    1ff6:	8a 9f be    	mov.d     w10, [w15++]
    1ff8:	00 03 be    	mov.d     w0, w6
    1ffa:	0e fd 07    	rcall     0x1a18 <__funpack> <.LASF94>
    1ffc:	85 05 78    	mov.w     w5, w11
    1ffe:	82 81 52    	sub.w     w5, w2, w3
    2000:	02 00 20    	mov.w     #0x0, w2
    2002:	62 20 e1    	.pword 0xe12062
    2004:	04 00 3a    	bra       NZ, 0x200e <return6>
    2006:	f3 07 b1    	sub.w     #0x7f, w3
    2008:	04 00 35    	bra       LT, 0x2012 <result0>
    200a:	77 18 e1    	.pword 0xe11877
    200c:	04 00 35    	bra       LT, 0x2016 <chop>

0000200e <return6>:
    200e:	06 00 be    	mov.d     w6, w0
    2010:	14 00 37    	bra       0x203a <return0>

00002012 <result0>:
    2012:	60 00 b8    	mul.uu    w0, #0x0, w0
    2014:	0f 00 37    	bra       0x2034 <signit>

00002016 <chop>:
    2016:	f5 0f 20    	mov.w     #0xff, w5
    2018:	fa ff 2f    	mov.w     #0xffff, w10

0000201a <shiftloop>:
    201a:	85 02 d1    	lsr.w     w5, w5
    201c:	0a 85 d3    	rrc.w     w10, w10
    201e:	83 01 e9    	dec.w     w3, w3
    2020:	fc ff 3b    	bra       NN, 0x201a <shiftloop>
    2022:	81 84 62    	and.w     w5, w1, w9
    2024:	00 04 65    	and.w     w10, w0, w8
    2026:	89 0f 74    	ior.w     w8, w9, [w15]
    2028:	f2 ff 32    	bra       Z, 0x200e <return6>
    202a:	85 82 ea    	com.w     w5, w5
    202c:	0a 85 ea    	com.w     w10, w10
    202e:	81 84 62    	and.w     w5, w1, w9
    2030:	00 04 65    	and.w     w10, w0, w8
    2032:	cc fc 07    	rcall     0x19cc <__fpack>

00002034 <signit>:
    2034:	07 f0 a7    	btsc.w    w7, #0xf
    2036:	01 f0 a0    	bset.w    w1, #0xf
    2038:	00 81 eb    	setm.w    w2

0000203a <return0>:
    203a:	02 00 e0    	cp0.w     w2
    203c:	4f 05 be    	mov.d     [--w15], w10
    203e:	4f 04 be    	mov.d     [--w15], w8
    2040:	00 00 06    	return    

00002042 <__fcompare>:
    2042:	88 9f be    	mov.d     w8, [w15++]
    2044:	8a 9f be    	mov.d     w10, [w15++]
    2046:	84 1f 78    	mov.w     w4, [w15++]
    2048:	fc fc 07    	rcall     0x1a42 <__funpack2>
    204a:	4f 00 78    	mov.w     [--w15], w0
    204c:	11 00 33    	bra       N, 0x2070 <exit>
    204e:	f0 ff 2f    	mov.w     #0xffff, w0
    2050:	83 8f 6c    	xor.w     w9, w3, [w15]
    2052:	06 00 3b    	bra       NN, 0x2060 <comparemag>
    2054:	04 05 65    	and.w     w10, w4, w10
    2056:	0a 00 a7    	btsc.w    w10, #0x0
    2058:	08 00 37    	bra       0x206a <returnEqual>
    205a:	09 f0 a6    	btss.w    w9, #0xf
    205c:	10 00 20    	mov.w     #0x1, w0
    205e:	08 00 37    	bra       0x2070 <exit>

00002060 <comparemag>:
    2060:	82 0f 54    	sub.w     w8, w2, [w15]
    2062:	83 8f 5c    	subb.w    w9, w3, [w15]
    2064:	03 00 39    	bra       NC, 0x206c <adjust>
    2066:	10 00 20    	mov.w     #0x1, w0
    2068:	01 00 3e    	bra       GTU, 0x206c <adjust>

0000206a <returnEqual>:
    206a:	00 00 20    	mov.w     #0x0, w0

0000206c <adjust>:
    206c:	09 f0 a7    	btsc.w    w9, #0xf
    206e:	00 00 ea    	neg.w     w0, w0

00002070 <exit>:
    2070:	4f 05 be    	mov.d     [--w15], w10
    2072:	4f 04 be    	mov.d     [--w15], w8
    2074:	00 00 e0    	cp0.w     w0
    2076:	00 00 06    	return    

00002078 <___floatdisf>:
    2078:	88 1f 78    	mov.w     w8, [w15++]
    207a:	03 04 78    	mov.w     w3, w8
    207c:	03 00 e0    	cp0.w     w3
    207e:	07 00 3d    	bra       GE, 0x208e <notspecial>

00002080 <negative>:
    2080:	60 00 10    	subr.w    w0, #0x0, w0
    2082:	e0 80 18    	subbr.w   w1, #0x0, w1
    2084:	60 01 19    	subbr.w   w2, #0x0, w2
    2086:	e0 81 19    	subbr.w   w3, #0x0, w3
    2088:	02 00 3b    	bra       NN, 0x208e <notspecial>
    208a:	01 f0 2d    	mov.w     #0xdf00, w1
    208c:	03 00 37    	bra       0x2094 <return0>

0000208e <notspecial>:
    208e:	04 00 07    	rcall     0x2098 <___floatundisf>
    2090:	08 f0 a7    	btsc.w    w8, #0xf
    2092:	01 f0 a0    	bset.w    w1, #0xf

00002094 <return0>:
    2094:	4f 04 78    	mov.w     [--w15], w8
    2096:	00 00 06    	return    

00002098 <___floatundisf>:
    2098:	88 9f be    	mov.d     w8, [w15++]
    209a:	8a 9f be    	mov.d     w10, [w15++]
    209c:	00 82 70    	ior.w     w1, w0, w4
    209e:	04 02 71    	ior.w     w2, w4, w4
    20a0:	04 82 71    	ior.w     w3, w4, w4
    20a2:	26 00 32    	bra       Z, 0x20f0 <return0>
    20a4:	00 04 be    	mov.d     w0, w8
    20a6:	02 00 be    	mov.d     w2, w0
    20a8:	60 11 b8    	mul.uu    w2, #0x0, w2
    20aa:	6b 09 20    	mov.w     #0x96, w11
    20ac:	95 02 20    	mov.w     #0x29, w5
    20ae:	01 82 cf    	ff1l      w1, w4
    20b0:	0a 00 39    	bra       NC, 0x20c6 <fixshift>
    20b2:	05 41 b1    	sub.b     #0x10, w5
    20b4:	00 82 cf    	ff1l      w0, w4
    20b6:	07 00 39    	bra       NC, 0x20c6 <fixshift>
    20b8:	05 41 b1    	sub.b     #0x10, w5
    20ba:	09 82 cf    	ff1l      w9, w4
    20bc:	04 00 39    	bra       NC, 0x20c6 <fixshift>
    20be:	05 41 b1    	sub.b     #0x10, w5
    20c0:	08 82 cf    	ff1l      w8, w4
    20c2:	01 00 39    	bra       NC, 0x20c6 <fixshift>
    20c4:	05 41 b1    	sub.b     #0x10, w5

000020c6 <fixshift>:
    20c6:	05 42 52    	sub.b     w4, w5, w4
    20c8:	12 00 32    	bra       Z, 0x20ee <round>
    20ca:	0a 00 3b    	bra       NN, 0x20e0 <shiftleft>

000020cc <shiftright>:
    20cc:	82 81 71    	ior.w     w3, w2, w3
    20ce:	61 01 64    	and.w     w8, #0x1, w2
    20d0:	81 00 d1    	lsr.w     w1, w1
    20d2:	00 80 d3    	rrc.w     w0, w0
    20d4:	89 84 d3    	rrc.w     w9, w9
    20d6:	08 84 d3    	rrc.w     w8, w8
    20d8:	8b 05 e8    	inc.w     w11, w11
    20da:	04 42 e8    	inc.b     w4, w4
    20dc:	f7 ff 3a    	bra       NZ, 0x20cc <shiftright>
    20de:	07 00 37    	bra       0x20ee <round>

000020e0 <shiftleft>:
    20e0:	08 04 44    	add.w     w8, w8, w8
    20e2:	89 84 4c    	addc.w    w9, w9, w9
    20e4:	00 00 48    	addc.w    w0, w0, w0
    20e6:	81 80 48    	addc.w    w1, w1, w1
    20e8:	8b 05 e9    	dec.w     w11, w11
    20ea:	04 42 e9    	dec.b     w4, w4
    20ec:	f9 ff 3a    	bra       NZ, 0x20e0 <shiftleft>

000020ee <round>:
    20ee:	6e fc 07    	rcall     0x19cc <__fpack>

000020f0 <return0>:
    20f0:	4f 05 be    	mov.d     [--w15], w10
    20f2:	4f 04 be    	mov.d     [--w15], w8
    20f4:	00 00 06    	return    

000020f6 <_logf>:
    20f6:	88 9f be    	mov.d     w8, [w15++]
    20f8:	8a 9f be    	mov.d     w10, [w15++]
    20fa:	8c 9f be    	mov.d     w12, [w15++]
    20fc:	2e ff 07    	rcall     0x1f5a <__frexpf>
    20fe:	85 04 78    	mov.w     w5, w9
    2100:	00 05 be    	mov.d     w0, w10
    2102:	64 20 e1    	.pword 0xe12064
    2104:	49 00 3e    	bra       GTU, 0x2198 <exit>
    2106:	62 20 e1    	.pword 0xe12062
    2108:	03 00 32    	bra       Z, 0x2110 <finite>
    210a:	09 00 35    	bra       LT, 0x211e <argiszero>
    210c:	0b f8 a3    	btst.z    w11, #0xf
    210e:	44 00 32    	bra       Z, 0x2198 <exit>

00002110 <finite>:
    2110:	0b f8 a3    	btst.z    w11, #0xf
    2112:	08 00 32    	bra       Z, 0x2124 <finitenonzero>
    2114:	10 02 20    	mov.w     #0x21, w0
    2116:	c0 82 88    	mov.w     w0, 0x1058
    2118:	f0 ff 2f    	mov.w     #0xffff, w0
    211a:	f1 ff 27    	mov.w     #0x7fff, w1
    211c:	3d 00 37    	bra       0x2198 <exit>

0000211e <argiszero>:
    211e:	01 f8 2f    	mov.w     #0xff80, w1
    2120:	00 00 20    	mov.w     #0x0, w0
    2122:	3a 00 37    	bra       0x2198 <exit>

00002124 <finitenonzero>:
    2124:	3d 00 07    	rcall     0x21a0 <loadhalf>
    2126:	b4 f9 07    	rcall     0x1490 <___subsf3>
    2128:	00 06 be    	mov.d     w0, w12
    212a:	0a 00 be    	mov.d     w10, w0
    212c:	32 4f 20    	mov.w     #0x4f3, w2
    212e:	53 f3 23    	mov.w     #0x3f35, w3
    2130:	af fb 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    2132:	06 00 34    	bra       LE, 0x2140 <lesqrt.5>
    2134:	0c 00 be    	mov.d     w12, w0
    2136:	34 00 07    	rcall     0x21a0 <loadhalf>
    2138:	ab f9 07    	rcall     0x1490 <___subsf3>
    213a:	00 06 be    	mov.d     w0, w12
    213c:	0a 00 be    	mov.d     w10, w0
    213e:	02 00 37    	bra       0x2144 <calczden>

00002140 <lesqrt.5>:
    2140:	89 04 e9    	dec.w     w9, w9
    2142:	0c 00 be    	mov.d     w12, w0

00002144 <calczden>:
    2144:	2d 00 07    	rcall     0x21a0 <loadhalf>
    2146:	b7 fc 07    	rcall     0x1ab6 <___mulsf3>
    2148:	2b 00 07    	rcall     0x21a0 <loadhalf>
    214a:	a3 f9 07    	rcall     0x1492 <___addsf3>
    214c:	00 01 be    	mov.d     w0, w2
    214e:	0c 00 be    	mov.d     w12, w0
    2150:	ea fa 07    	rcall     0x1726 <___divsf3>
    2152:	00 05 be    	mov.d     w0, w10
    2154:	00 01 be    	mov.d     w0, w2
    2156:	af fc 07    	rcall     0x1ab6 <___mulsf3>
    2158:	00 06 be    	mov.d     w0, w12
    215a:	a2 f3 23    	mov.w     #0x3f3a, w2
    215c:	43 0d 2c    	mov.w     #0xc0d4, w3
    215e:	99 f9 07    	rcall     0x1492 <___addsf3>
    2160:	80 9f be    	mov.d     w0, [w15++]
    2162:	0c 00 be    	mov.d     w12, w0
    2164:	d2 e3 27    	mov.w     #0x7e3d, w2
    2166:	d3 f0 2b    	mov.w     #0xbf0d, w3
    2168:	a6 fc 07    	rcall     0x1ab6 <___mulsf3>
    216a:	4f 01 be    	mov.d     [--w15], w2
    216c:	dc fa 07    	rcall     0x1726 <___divsf3>
    216e:	00 06 be    	mov.d     w0, w12
    2170:	0a 01 be    	mov.d     w10, w2
    2172:	a1 fc 07    	rcall     0x1ab6 <___mulsf3>
    2174:	0a 01 be    	mov.d     w10, w2
    2176:	8d f9 07    	rcall     0x1492 <___addsf3>
    2178:	00 06 be    	mov.d     w0, w12
    217a:	61 48 b9    	mul.su    w9, #0x1, w0
    217c:	c7 fb 07    	rcall     0x190c <___floatsisf>
    217e:	00 05 be    	mov.d     w0, w10
    2180:	32 08 28    	mov.w     #0x8083, w2
    2182:	e3 95 2b    	mov.w     #0xb95e, w3
    2184:	98 fc 07    	rcall     0x1ab6 <___mulsf3>
    2186:	0c 01 be    	mov.d     w12, w2
    2188:	84 f9 07    	rcall     0x1492 <___addsf3>
    218a:	00 06 be    	mov.d     w0, w12
    218c:	0a 00 be    	mov.d     w10, w0
    218e:	02 00 28    	mov.w     #0x8000, w2
    2190:	13 f3 23    	mov.w     #0x3f31, w3
    2192:	91 fc 07    	rcall     0x1ab6 <___mulsf3>
    2194:	0c 01 be    	mov.d     w12, w2
    2196:	7d f9 07    	rcall     0x1492 <___addsf3>

00002198 <exit>:
    2198:	4f 06 be    	mov.d     [--w15], w12
    219a:	4f 05 be    	mov.d     [--w15], w10
    219c:	4f 04 be    	mov.d     [--w15], w8
    219e:	00 00 06    	return    

000021a0 <loadhalf>:
    21a0:	03 f0 23    	mov.w     #0x3f00, w3
    21a2:	02 00 05    	retlw.w   #0x0, w2

000021a4 <__dPropagateNaN>:
    21a4:	e4 82 40    	add.w     w1, #0x4, w5
    21a6:	10 78 a3    	btst.z    [w0], #0x7
    21a8:	07 00 32    	bra       Z, 0x21b8 <returnb>
    21aa:	64 02 40    	add.w     w0, #0x4, w4
    21ac:	11 78 a3    	btst.z    [w1], #0x7
    21ae:	34 00 be    	mov.d     [w4++], w0
    21b0:	14 01 be    	mov.d     [w4], w2
    21b2:	04 00 32    	bra       Z, 0x21bc <returnab>
    21b4:	03 30 a7    	btsc.w    w3, #0x3
    21b6:	00 00 06    	return    

000021b8 <returnb>:
    21b8:	35 00 be    	mov.d     [w5++], w0
    21ba:	15 01 be    	mov.d     [w5], w2

000021bc <returnab>:
    21bc:	03 30 a0    	bset.w    w3, #0x3
    21be:	00 00 06    	return    

000021c0 <_strtof>:
    21c0:	88 9f be    	mov.d     w8, [w15++]
    21c2:	8a 9f be    	mov.d     w10, [w15++]
    21c4:	8c 9f be    	mov.d     w12, [w15++]
    21c6:	8e 1f 78    	mov.w     w14, [w15++]
    21c8:	01 06 78    	mov.w     w1, w12
    21ca:	0c 00 e0    	cp0.w     w12
    21cc:	01 00 32    	bra       Z, 0x21d0 <.L2>
    21ce:	00 0e 78    	mov.w     w0, [w12]

000021d0 <.L2>:
    21d0:	80 04 78    	mov.w     w0, w9

000021d2 <.L3>:
    21d2:	09 05 78    	mov.w     w9, w10
    21d4:	8a 04 78    	mov.w     w10, w9
    21d6:	b9 05 fb    	se        [w9++], w11
    21d8:	0b 00 78    	mov.w     w11, w0
    21da:	22 f9 07    	rcall     0x1420 <_isspace> <.Lframe0>
    21dc:	00 00 e0    	cp0.w     w0
    21de:	f9 ff 3a    	bra       NZ, 0x21d2 <.L3>
    21e0:	d0 02 20    	mov.w     #0x2d, w0
    21e2:	80 8f 55    	sub.w     w11, w0, [w15]
    21e4:	03 00 3a    	bra       NZ, 0x21ec <.L4>
    21e6:	09 05 78    	mov.w     w9, w10
    21e8:	18 c0 b3    	mov.b     #0x1, w8
    21ea:	05 00 37    	bra       0x21f6 <.L5> <.LASF2>

000021ec <.L4>:
    21ec:	00 44 eb    	clr.b     w8
    21ee:	b0 02 20    	mov.w     #0x2b, w0
    21f0:	80 8f 55    	sub.w     w11, w0, [w15]
    21f2:	01 00 3a    	bra       NZ, 0x21f6 <.L5> <.LASF2>
    21f4:	09 05 78    	mov.w     w9, w10

000021f6 <.L5>:
    21f6:	60 00 b8    	mul.uu    w0, #0x0, w0
    21f8:	80 04 eb    	clr.w     w9
    21fa:	00 07 eb    	clr.w     w14
    21fc:	01 00 37    	bra       0x2200 <.L6>

000021fe <.L8>:
    21fe:	0a 05 e8    	inc.w     w10, w10

00002200 <.L6>:
    2200:	0a 01 78    	mov.w     w10, w2
    2202:	08 48 a3    	btst.z    w8, #0x4
    2204:	05 00 3a    	bra       NZ, 0x2210 <.L7>
    2206:	e3 c2 b3    	mov.b     #0x2e, w3
    2208:	9a cf 11    	subr.b    w3, [w10], [w15]
    220a:	02 00 3a    	bra       NZ, 0x2210 <.L7>
    220c:	08 44 a0    	bset.b    w8, #0x4
    220e:	f7 ff 37    	bra       0x21fe <.L8>

00002210 <.L7>:
    2210:	9a 45 78    	mov.b     [w10], w11
    2212:	8b 01 fb    	se        w11, w3
    2214:	03 03 b1    	sub.w     #0x30, w3
    2216:	e9 8f 51    	sub.w     w3, #0x9, [w15]
    2218:	16 00 3e    	bra       GTU, 0x2246 <.L9>
    221a:	08 14 a0    	bset.b    w8, #0x1
    221c:	08 01 fb    	se        w8, w2
    221e:	e9 8f 54    	sub.w     w9, #0x9, [w15]
    2220:	0e 00 32    	bra       Z, 0x223e <.L10>
    2222:	02 48 a3    	btst.z    w2, #0x4
    2224:	01 00 32    	bra       Z, 0x2228 <.L11>
    2226:	0e 07 e9    	dec.w     w14, w14

00002228 <.L11>:
    2228:	89 04 e8    	inc.w     w9, w9
    222a:	a2 00 20    	mov.w     #0xa, w2
    222c:	03 00 20    	mov.w     #0x0, w3
    222e:	35 0a 07    	rcall     0x369a <___mulp32eds3> <___mulp32peds3> <___mulsi3>
    2230:	02 cd b3    	mov.b     #0xd0, w2
    2232:	02 c1 45    	add.b     w11, w2, w2
    2234:	02 81 fb    	ze        w2, w2
    2236:	80 01 eb    	clr.w     w3
    2238:	00 00 41    	add.w     w2, w0, w0
    223a:	81 80 49    	addc.w    w3, w1, w1
    223c:	e0 ff 37    	bra       0x21fe <.L8>

0000223e <.L10>:
    223e:	02 48 a3    	btst.z    w2, #0x4
    2240:	de ff 3a    	bra       NZ, 0x21fe <.L8>
    2242:	0e 07 e8    	inc.w     w14, w14
    2244:	dc ff 37    	bra       0x21fe <.L8>

00002246 <.L9>:
    2246:	53 c6 b3    	mov.b     #0x65, w3
    2248:	83 cf 55    	sub.b     w11, w3, [w15]
    224a:	04 00 32    	bra       Z, 0x2254 <.L13>
    224c:	80 04 eb    	clr.w     w9
    224e:	53 c4 b3    	mov.b     #0x45, w3
    2250:	83 cf 55    	sub.b     w11, w3, [w15]
    2252:	2d 00 3a    	bra       NZ, 0x22ae <.L14>

00002254 <.L13>:
    2254:	5a 41 78    	mov.b     [++w10], w2
    2256:	d3 c2 b3    	mov.b     #0x2d, w3
    2258:	83 4f 51    	sub.b     w2, w3, [w15]
    225a:	02 00 3a    	bra       NZ, 0x2260 <.L15>
    225c:	08 34 a0    	bset.b    w8, #0x3
    225e:	03 00 37    	bra       0x2266 <.L45>

00002260 <.L15>:
    2260:	b3 c2 b3    	mov.b     #0x2b, w3
    2262:	83 4f 51    	sub.b     w2, w3, [w15]
    2264:	01 00 3a    	bra       NZ, 0x2268 <.L17>

00002266 <.L45>:
    2266:	0a 05 e8    	inc.w     w10, w10

00002268 <.L17>:
    2268:	0a 01 78    	mov.w     w10, w2
    226a:	02 05 78    	mov.w     w2, w10
    226c:	3a 42 78    	mov.b     [w10++], w4
    226e:	03 c3 b3    	mov.b     #0x30, w3
    2270:	83 4f 52    	sub.b     w4, w3, [w15]
    2272:	fa ff 32    	bra       Z, 0x2268 <.L17>
    2274:	84 02 fb    	se        w4, w5
    2276:	05 03 b1    	sub.w     #0x30, w5
    2278:	80 04 eb    	clr.w     w9
    227a:	e9 8f 52    	sub.w     w5, #0x9, [w15]
    227c:	15 00 3e    	bra       GTU, 0x22a8 <.L18>
    227e:	83 44 52    	sub.b     w4, w3, w9
    2280:	89 84 fb    	ze        w9, w9
    2282:	0a 01 78    	mov.w     w10, w2
    2284:	12 42 78    	mov.b     [w2], w4
    2286:	84 02 fb    	se        w4, w5
    2288:	05 03 b1    	sub.w     #0x30, w5
    228a:	e9 8f 52    	sub.w     w5, #0x9, [w15]
    228c:	0d 00 3e    	bra       GTU, 0x22a8 <.L18>
    228e:	ea 4b b9    	.pword 0xb94bea
    2290:	83 44 52    	sub.b     w4, w3, w9
    2292:	89 84 fb    	ze        w9, w9
    2294:	86 84 44    	add.w     w9, w6, w9
    2296:	52 42 78    	mov.b     [++w2], w4
    2298:	84 02 fb    	se        w4, w5
    229a:	05 03 b1    	sub.w     #0x30, w5
    229c:	e9 8f 52    	sub.w     w5, #0x9, [w15]
    229e:	04 00 3e    	bra       GTU, 0x22a8 <.L18>
    22a0:	ea 4b b9    	.pword 0xb94bea
    22a2:	83 41 52    	sub.b     w4, w3, w3
    22a4:	83 81 fb    	ze        w3, w3
    22a6:	83 04 43    	add.w     w6, w3, w9

000022a8 <.L18>:
    22a8:	08 38 a3    	btst.z    w8, #0x3
    22aa:	01 00 32    	bra       Z, 0x22ae <.L14>
    22ac:	89 04 ea    	neg.w     w9, w9

000022ae <.L14>:
    22ae:	0c 00 e0    	cp0.w     w12
    22b0:	03 00 32    	bra       Z, 0x22b8 <.L19>
    22b2:	08 18 a3    	btst.z    w8, #0x1
    22b4:	01 00 32    	bra       Z, 0x22b8 <.L19>
    22b6:	02 0e 78    	mov.w     w2, [w12]

000022b8 <.L19>:
    22b8:	29 fb 07    	rcall     0x190c <___floatsisf>
    22ba:	00 05 be    	mov.d     w0, w10
    22bc:	00 06 be    	mov.d     w0, w12
    22be:	60 11 b8    	mul.uu    w2, #0x0, w2
    22c0:	e5 fa 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    22c2:	00 01 78    	mov.w     w0, w2
    22c4:	60 00 b8    	mul.uu    w0, #0x0, w0
    22c6:	02 00 e0    	cp0.w     w2
    22c8:	58 00 32    	bra       Z, 0x237a <.L20>
    22ca:	8e 84 44    	add.w     w9, w14, w9
    22cc:	32 f8 2f    	mov.w     #0xff83, w2
    22ce:	82 8f 54    	sub.w     w9, w2, [w15]
    22d0:	03 00 3d    	bra       GE, 0x22d8 <.L21>
    22d2:	22 02 20    	mov.w     #0x22, w2
    22d4:	c2 82 88    	mov.w     w2, 0x1058
    22d6:	51 00 37    	bra       0x237a <.L20>

000022d8 <.L21>:
    22d8:	00 08 20    	mov.w     #0x80, w0
    22da:	80 8f 54    	sub.w     w9, w0, [w15]
    22dc:	07 00 34    	bra       LE, 0x22ec <.L22>
    22de:	20 02 20    	mov.w     #0x22, w0
    22e0:	c0 82 88    	mov.w     w0, 0x1058
    22e2:	08 08 a3    	btst.z    w8, #0x0
    22e4:	45 00 32    	bra       Z, 0x2370 <.L40> <.Ldebug_abbrev0>
    22e6:	00 00 20    	mov.w     #0x0, w0
    22e8:	01 f8 2f    	mov.w     #0xff80, w1
    22ea:	47 00 37    	bra       0x237a <.L20>

000022ec <.L22>:
    22ec:	09 00 e0    	cp0.w     w9
    22ee:	1b 00 3d    	bra       GE, 0x2326 <.L23>
    22f0:	89 04 ea    	neg.w     w9, w9
    22f2:	06 00 37    	bra       0x2300 <.L24>

000022f4 <.L25>:
    22f4:	92 2f 20    	mov.w     #0x2f9, w2
    22f6:	53 01 25    	mov.w     #0x5015, w3
    22f8:	0a 00 be    	mov.d     w10, w0
    22fa:	15 fa 07    	rcall     0x1726 <___divsf3>
    22fc:	00 05 be    	mov.d     w0, w10
    22fe:	ea 84 54    	sub.w     w9, #0xa, w9

00002300 <.L24>:
    2300:	e9 8f 54    	sub.w     w9, #0x9, [w15]
    2302:	f8 ff 3c    	bra       GT, 0x22f4 <.L25>
    2304:	06 00 37    	bra       0x2312 <.L26>

00002306 <.L27>:
    2306:	02 00 20    	mov.w     #0x0, w2
    2308:	03 12 24    	mov.w     #0x4120, w3
    230a:	0a 00 be    	mov.d     w10, w0
    230c:	0c fa 07    	rcall     0x1726 <___divsf3>
    230e:	00 05 be    	mov.d     w0, w10
    2310:	89 04 e9    	dec.w     w9, w9

00002312 <.L26>:
    2312:	09 00 e0    	cp0.w     w9
    2314:	f8 ff 3a    	bra       NZ, 0x2306 <.L27>
    2316:	0a 06 be    	mov.d     w10, w12
    2318:	02 00 20    	mov.w     #0x0, w2
    231a:	03 08 20    	mov.w     #0x80, w3
    231c:	0a 00 be    	mov.d     w10, w0
    231e:	b6 fa 07    	rcall     0x188c <___eqsf2> <___lesf2> <___ltsf2>
    2320:	00 00 e0    	cp0.w     w0
    2322:	21 00 3d    	bra       GE, 0x2366 <.L28>
    2324:	1b 00 37    	bra       0x235c <.L48>

00002326 <.L23>:
    2326:	09 00 e0    	cp0.w     w9
    2328:	07 00 3a    	bra       NZ, 0x2338 <.L30> <.LASF38>
    232a:	1d 00 37    	bra       0x2366 <.L28>

0000232c <.L31>:
    232c:	92 2f 20    	mov.w     #0x2f9, w2
    232e:	53 01 25    	mov.w     #0x5015, w3
    2330:	0a 00 be    	mov.d     w10, w0
    2332:	c1 fb 07    	rcall     0x1ab6 <___mulsf3>
    2334:	00 05 be    	mov.d     w0, w10
    2336:	ea 84 54    	sub.w     w9, #0xa, w9

00002338 <.L30>:
    2338:	e9 cf 54    	sub.b     w9, #0x9, [w15]
    233a:	f8 ff 3e    	bra       GTU, 0x232c <.L31>
    233c:	06 00 37    	bra       0x234a <.L32>

0000233e <.L33>:
    233e:	02 00 20    	mov.w     #0x0, w2
    2340:	03 12 24    	mov.w     #0x4120, w3
    2342:	0a 00 be    	mov.d     w10, w0
    2344:	b8 fb 07    	rcall     0x1ab6 <___mulsf3>
    2346:	00 05 be    	mov.d     w0, w10
    2348:	89 04 e9    	dec.w     w9, w9

0000234a <.L32>:
    234a:	09 00 e0    	cp0.w     w9
    234c:	f8 ff 3a    	bra       NZ, 0x233e <.L33>
    234e:	0a 06 be    	mov.d     w10, w12
    2350:	f2 ff 2f    	mov.w     #0xffff, w2
    2352:	f3 f7 27    	mov.w     #0x7f7f, w3
    2354:	0a 00 be    	mov.d     w10, w0
    2356:	9c fa 07    	rcall     0x1890 <___gesf2> <___gtsf2>
    2358:	00 00 e0    	cp0.w     w0
    235a:	05 00 34    	bra       LE, 0x2366 <.L28>

0000235c <.L48>:
    235c:	08 08 a3    	btst.z    w8, #0x0
    235e:	0b 00 32    	bra       Z, 0x2376 <.L42>
    2360:	00 00 20    	mov.w     #0x0, w0
    2362:	01 08 28    	mov.w     #0x8080, w1
    2364:	0a 00 37    	bra       0x237a <.L20>

00002366 <.L28>:
    2366:	08 08 a3    	btst.z    w8, #0x0
    2368:	01 00 32    	bra       Z, 0x236c <.L35>
    236a:	0d f0 a2    	btg.w     w13, #0xf

0000236c <.L35>:
    236c:	0c 00 be    	mov.d     w12, w0
    236e:	05 00 37    	bra       0x237a <.L20>

00002370 <.L40>:
    2370:	00 00 20    	mov.w     #0x0, w0
    2372:	01 f8 27    	mov.w     #0x7f80, w1
    2374:	02 00 37    	bra       0x237a <.L20>

00002376 <.L42>:
    2376:	00 00 20    	mov.w     #0x0, w0
    2378:	01 08 20    	mov.w     #0x80, w1

0000237a <.L20>:
    237a:	4f 07 78    	mov.w     [--w15], w14
    237c:	4f 06 be    	mov.d     [--w15], w12
    237e:	4f 05 be    	mov.d     [--w15], w10
    2380:	4f 04 be    	mov.d     [--w15], w8
    2382:	00 00 06    	return    

00002384 <_strtod>:
    2384:	1d ff 37    	bra       0x21c0 <_strtof>

00002386 <_atof>:
    2386:	80 00 eb    	clr.w     w1
    2388:	1b ff 37    	bra       0x21c0 <_strtof>

0000238a <_atoi>:
    238a:	80 00 78    	mov.w     w0, w1
    238c:	01 00 78    	mov.w     w1, w0
    238e:	30 41 78    	mov.b     [w0++], w2
    2390:	03 c2 b3    	mov.b     #0x20, w3
    2392:	83 4f 51    	sub.b     w2, w3, [w15]
    2394:	fa ff 32    	bra       Z, 0x238a <_atoi> <L0> <.L11> <.LASF29>
    2396:	e9 4f 51    	sub.b     w2, #0x9, [w15]
    2398:	f8 ff 32    	bra       Z, 0x238a <_atoi> <L0> <.L11> <.LASF29>
    239a:	ed c1 41    	add.b     w3, #0xd, w3
    239c:	83 4f 51    	sub.b     w2, w3, [w15]
    239e:	03 00 3a    	bra       NZ, 0x23a6 <.L4> <.LASF18>
    23a0:	80 00 78    	mov.w     w0, w1
    23a2:	13 c0 b3    	mov.b     #0x1, w3
    23a4:	05 00 37    	bra       0x23b0 <.L5>

000023a6 <.L4>:
    23a6:	80 41 eb    	clr.b     w3
    23a8:	b4 c2 b3    	mov.b     #0x2b, w4
    23aa:	84 4f 51    	sub.b     w2, w4, [w15]
    23ac:	01 00 3a    	bra       NZ, 0x23b0 <.L5>
    23ae:	80 00 78    	mov.w     w0, w1

000023b0 <.L5>:
    23b0:	00 00 eb    	clr.w     w0
    23b2:	02 00 37    	bra       0x23b8 <.L6>

000023b4 <.L7>:
    23b4:	ea 00 b9    	.pword 0xb900ea
    23b6:	00 00 41    	add.w     w2, w0, w0

000023b8 <.L6>:
    23b8:	31 01 fb    	se        [w1++], w2
    23ba:	02 03 b1    	sub.w     #0x30, w2
    23bc:	e9 0f 51    	sub.w     w2, #0x9, [w15]
    23be:	fa ff 36    	bra       LEU, 0x23b4 <.L7>
    23c0:	03 04 e0    	cp0.b     w3
    23c2:	01 00 32    	bra       Z, 0x23c6 <.L8>
    23c4:	00 00 ea    	neg.w     w0, w0

000023c6 <.L8>:
    23c6:	00 00 06    	return    

000023c8 <_memcpy>:
    23c8:	80 01 78    	mov.w     w0, w3
    23ca:	02 00 37    	bra       0x23d0 <.L2>

000023cc <.L3>:
    23cc:	b1 59 78    	mov.b     [w1++], [w3++]
    23ce:	02 01 e9    	dec.w     w2, w2

000023d0 <.L2>:
    23d0:	02 00 e0    	cp0.w     w2
    23d2:	fc ff 3a    	bra       NZ, 0x23cc <.L3>
    23d4:	00 00 06    	return    

000023d6 <_memset>:
    23d6:	80 01 78    	mov.w     w0, w3
    23d8:	02 00 37    	bra       0x23de <.L2>

000023da <.L3>:
    23da:	81 59 78    	mov.b     w1, [w3++]
    23dc:	02 01 e9    	dec.w     w2, w2

000023de <.L2>:
    23de:	02 00 e0    	cp0.w     w2
    23e0:	fc ff 3a    	bra       NZ, 0x23da <.L3>
    23e2:	00 00 06    	return    

000023e4 <_strchr>:
    23e4:	00 01 78    	mov.w     w0, w2
    23e6:	02 00 78    	mov.w     w2, w0
    23e8:	b0 41 78    	mov.b     [w0++], w3
    23ea:	81 cf 51    	sub.b     w3, w1, [w15]
    23ec:	03 00 32    	bra       Z, 0x23f4 <.L2>
    23ee:	03 04 e0    	cp0.b     w3
    23f0:	f9 ff 3a    	bra       NZ, 0x23e4 <_strchr> <L0> <.L3>
    23f2:	00 01 eb    	clr.w     w2

000023f4 <.L2>:
    23f4:	02 00 78    	mov.w     w2, w0
    23f6:	00 00 06    	return    

000023f8 <_strlen>:
    23f8:	80 00 78    	mov.w     w0, w1

000023fa <.L2>:
    23fa:	31 04 e0    	cp0.b     [w1++]
    23fc:	fe ff 3a    	bra       NZ, 0x23fa <.L2>
    23fe:	00 80 ea    	com.w     w0, w0
    2400:	00 80 40    	add.w     w1, w0, w0
    2402:	00 00 06    	return    

00002404 <_strncpy>:
    2404:	80 01 78    	mov.w     w0, w3
    2406:	06 00 37    	bra       0x2414 <.L2>

00002408 <.L4>:
    2408:	02 01 e9    	dec.w     w2, w2
    240a:	b1 42 78    	mov.b     [w1++], w5
    240c:	85 59 78    	mov.b     w5, [w3++]
    240e:	03 02 78    	mov.w     w3, w4
    2410:	05 04 e0    	cp0.b     w5
    2412:	06 00 32    	bra       Z, 0x2420 <.L3>

00002414 <.L2>:
    2414:	03 02 78    	mov.w     w3, w4
    2416:	02 00 e0    	cp0.w     w2
    2418:	f7 ff 3a    	bra       NZ, 0x2408 <.L4>
    241a:	02 00 37    	bra       0x2420 <.L3>

0000241c <.L6>:
    241c:	00 5a eb    	clr.b     [w4++]
    241e:	02 01 e9    	dec.w     w2, w2

00002420 <.L3>:
    2420:	02 00 e0    	cp0.w     w2
    2422:	fc ff 3a    	bra       NZ, 0x241c <.L6>
    2424:	00 00 06    	return    

00002426 <__sprintf_cdfFnopsuxX>:
    2426:	0c 00 fa    	lnk       #0xc
    2428:	88 9f be    	mov.d     w8, [w15++]
    242a:	00 04 78    	mov.w     w0, w8
    242c:	f0 ff 27    	mov.w     #0x7fff, w0
    242e:	d0 bf 9f    	mov.w     w0, [w15-6]
    2430:	80 04 eb    	clr.w     w9
    2432:	99 bf 9f    	mov.w     w9, [w15-14]
    2434:	88 bf 9f    	mov.w     w8, [w15-16]
    2436:	a8 bf 9f    	mov.w     w8, [w15-12]
    2438:	20 0c 20    	mov.w     #0xc2, w0
    243a:	b0 bf 9f    	mov.w     w0, [w15-10]
    243c:	78 81 57    	sub.w     w15, #0x18, w2
    243e:	cf b0 97    	mov.w     [w15-24], w1
    2440:	70 80 57    	sub.w     w15, #0x10, w0
    2442:	cf 00 07    	rcall     0x25e2 <__vfprintf_cdfFnopsuxX> <__vfprintf_cdfFnopuxX> <__vfprintf_cdnopuxX> <L0>
    2444:	0f b8 97    	mov.w     [w15-16], w0
    2446:	09 48 78    	mov.b     w9, [w0]
    2448:	8f b8 97    	mov.w     [w15-16], w1
    244a:	08 80 50    	sub.w     w1, w8, w0
    244c:	4f 04 be    	mov.d     [--w15], w8
    244e:	00 80 fa    	ulnk      
    2450:	00 00 06    	return    

00002452 <_fround>:
    2452:	08 00 fa    	lnk       #0x8
    2454:	88 9f be    	mov.d     w8, [w15++]
    2456:	8a 9f be    	mov.d     w10, [w15++]
    2458:	00 84 fb    	ze        w0, w8
    245a:	d1 c6 b3    	mov.b     #0x6d, w1
    245c:	81 4f 50    	sub.b     w0, w1, [w15]
    245e:	34 00 36    	bra       LEU, 0x24c8 <.L2>
    2460:	4b 06 20    	mov.w     #0x64, w11
    2462:	11 00 09    	.pword 0x090011
    2464:	0b 84 d8    	div.uw    w8, w11
    2466:	81 05 78    	mov.w     w1, w11
    2468:	72 00 40    	add.w     w0, #0x12, w0
    246a:	43 00 dd    	sl.w      w0, #0x3, w0
    246c:	29 f2 23    	mov.w     #0x3f22, w9
    246e:	00 80 44    	add.w     w9, w0, w0
    2470:	60 22 b8    	mul.uu    w4, #0x0, w4
    2472:	06 00 20    	mov.w     #0x0, w6
    2474:	07 fe 23    	mov.w     #0x3fe0, w7
    2476:	50 01 be    	mov.d     [++w0], w2
    2478:	40 00 be    	mov.d     [--w0], w0
    247a:	98 08 07    	rcall     0x35ac <___muldf3>
    247c:	00 02 be    	mov.d     w0, w4
    247e:	02 03 be    	mov.d     w2, w6
    2480:	84 bf 9f    	mov.w     w4, [w15-16]
    2482:	95 bf 9f    	mov.w     w5, [w15-14]
    2484:	a6 bf 9f    	mov.w     w6, [w15-12]
    2486:	b7 bf 9f    	mov.w     w7, [w15-10]
    2488:	aa 00 20    	mov.w     #0xa, w10
    248a:	11 00 09    	.pword 0x090011
    248c:	8a 85 d8    	div.uw    w11, w10
    248e:	80 05 78    	mov.w     w0, w11
    2490:	e9 85 45    	add.w     w11, #0x9, w11
    2492:	c3 5d dd    	sl.w      w11, #0x3, w11
    2494:	8b 85 44    	add.w     w9, w11, w11
    2496:	3b 02 be    	mov.d     [w11++], w4
    2498:	2b 03 be    	mov.d     [w11--], w6
    249a:	0f b8 97    	mov.w     [w15-16], w0
    249c:	9f b8 97    	mov.w     [w15-14], w1
    249e:	2f b9 97    	mov.w     [w15-12], w2
    24a0:	bf b9 97    	mov.w     [w15-10], w3
    24a2:	84 08 07    	rcall     0x35ac <___muldf3>
    24a4:	00 02 be    	mov.d     w0, w4
    24a6:	02 03 be    	mov.d     w2, w6
    24a8:	84 bf 9f    	mov.w     w4, [w15-16]
    24aa:	95 bf 9f    	mov.w     w5, [w15-14]
    24ac:	a6 bf 9f    	mov.w     w6, [w15-12]
    24ae:	b7 bf 9f    	mov.w     w7, [w15-10]
    24b0:	11 00 09    	.pword 0x090011
    24b2:	0a 84 d8    	div.uw    w8, w10
    24b4:	01 04 78    	mov.w     w1, w8
    24b6:	43 44 dd    	sl.w      w8, #0x3, w8
    24b8:	88 84 44    	add.w     w9, w8, w9
    24ba:	39 02 be    	mov.d     [w9++], w4
    24bc:	29 03 be    	mov.d     [w9--], w6
    24be:	0f b8 97    	mov.w     [w15-16], w0
    24c0:	9f b8 97    	mov.w     [w15-14], w1
    24c2:	2f b9 97    	mov.w     [w15-12], w2
    24c4:	bf b9 97    	mov.w     [w15-10], w3
    24c6:	1d 00 37    	bra       0x2502 <.L5>

000024c8 <.L2>:
    24c8:	ea 4f 50    	sub.b     w0, #0xa, [w15]
    24ca:	13 00 36    	bra       LEU, 0x24f2 <.L4>
    24cc:	aa 00 20    	mov.w     #0xa, w10
    24ce:	11 00 09    	.pword 0x090011
    24d0:	0a 84 d8    	div.uw    w8, w10
    24d2:	01 05 78    	mov.w     w1, w10
    24d4:	69 04 40    	add.w     w0, #0x9, w8
    24d6:	43 44 dd    	sl.w      w8, #0x3, w8
    24d8:	29 f2 23    	mov.w     #0x3f22, w9
    24da:	08 84 44    	add.w     w9, w8, w8
    24dc:	60 22 b8    	mul.uu    w4, #0x0, w4
    24de:	06 00 20    	mov.w     #0x0, w6
    24e0:	07 fe 23    	mov.w     #0x3fe0, w7
    24e2:	38 00 be    	mov.d     [w8++], w0
    24e4:	28 01 be    	mov.d     [w8--], w2
    24e6:	62 08 07    	rcall     0x35ac <___muldf3>
    24e8:	43 55 dd    	sl.w      w10, #0x3, w10
    24ea:	8a 84 44    	add.w     w9, w10, w9
    24ec:	39 02 be    	mov.d     [w9++], w4
    24ee:	29 03 be    	mov.d     [w9--], w6
    24f0:	08 00 37    	bra       0x2502 <.L5>

000024f2 <.L4>:
    24f2:	43 44 dd    	sl.w      w8, #0x3, w8
    24f4:	20 f2 23    	mov.w     #0x3f22, w0
    24f6:	08 04 40    	add.w     w0, w8, w8
    24f8:	60 22 b8    	mul.uu    w4, #0x0, w4
    24fa:	06 00 20    	mov.w     #0x0, w6
    24fc:	07 fe 23    	mov.w     #0x3fe0, w7
    24fe:	38 00 be    	mov.d     [w8++], w0
    2500:	28 01 be    	mov.d     [w8--], w2

00002502 <.L5>:
    2502:	54 08 07    	rcall     0x35ac <___muldf3>
    2504:	4f 05 be    	mov.d     [--w15], w10
    2506:	4f 04 be    	mov.d     [--w15], w8
    2508:	00 80 fa    	ulnk      
    250a:	00 00 06    	return    

0000250c <_scale>:
    250c:	08 00 fa    	lnk       #0x8
    250e:	88 9f be    	mov.d     w8, [w15++]
    2510:	8a 9f be    	mov.d     w10, [w15++]
    2512:	d1 c6 b3    	mov.b     #0x6d, w1
    2514:	00 04 e0    	cp0.b     w0
    2516:	23 00 3d    	bra       GE, 0x255e <.L7>
    2518:	00 40 ea    	neg.b     w0, w0
    251a:	00 04 fb    	se        w0, w8
    251c:	81 4f 50    	sub.b     w0, w1, [w15]
    251e:	0a 00 34    	bra       LE, 0x2534 <.L8>
    2520:	42 06 20    	mov.w     #0x64, w2
    2522:	11 00 09    	.pword 0x090011
    2524:	02 04 d8    	div.sw    w8, w2
    2526:	a9 00 20    	mov.w     #0xa, w9
    2528:	11 00 09    	.pword 0x090011
    252a:	89 00 d8    	div.sw    w1, w9
    252c:	e9 00 40    	add.w     w0, #0x9, w1
    252e:	c3 08 dd    	sl.w      w1, #0x3, w1
    2530:	2a f2 23    	mov.w     #0x3f22, w10
    2532:	21 00 37    	bra       0x2576 <.L15>

00002534 <.L8>:
    2534:	ea 4f 50    	sub.b     w0, #0xa, [w15]
    2536:	10 00 34    	bra       LE, 0x2558 <.L10>
    2538:	a2 00 20    	mov.w     #0xa, w2
    253a:	11 00 09    	.pword 0x090011
    253c:	02 04 d8    	div.sw    w8, w2
    253e:	01 01 78    	mov.w     w1, w2
    2540:	69 00 40    	add.w     w0, #0x9, w0
    2542:	43 00 dd    	sl.w      w0, #0x3, w0
    2544:	21 f2 23    	mov.w     #0x3f22, w1

00002546 <.L16>:
    2546:	00 80 40    	add.w     w1, w0, w0
    2548:	43 11 dd    	sl.w      w2, #0x3, w2
    254a:	82 80 40    	add.w     w1, w2, w1
    254c:	31 02 be    	mov.d     [w1++], w4
    254e:	21 03 be    	mov.d     [w1--], w6
    2550:	50 01 be    	mov.d     [++w0], w2
    2552:	40 00 be    	mov.d     [--w0], w0

00002554 <.L13>:
    2554:	2b 08 07    	rcall     0x35ac <___muldf3>
    2556:	38 00 37    	bra       0x25c8 <.L9>

00002558 <.L10>:
    2558:	43 44 dd    	sl.w      w8, #0x3, w8
    255a:	20 f2 23    	mov.w     #0x3f22, w0
    255c:	32 00 37    	bra       0x25c2 <.L14>

0000255e <.L7>:
    255e:	00 04 fb    	se        w0, w8
    2560:	81 4f 50    	sub.b     w0, w1, [w15]
    2562:	23 00 34    	bra       LE, 0x25aa <.L11>
    2564:	42 06 20    	mov.w     #0x64, w2
    2566:	11 00 09    	.pword 0x090011
    2568:	02 04 d8    	div.sw    w8, w2
    256a:	a9 00 20    	mov.w     #0xa, w9
    256c:	11 00 09    	.pword 0x090011
    256e:	89 00 d8    	div.sw    w1, w9
    2570:	e9 00 40    	add.w     w0, #0x9, w1
    2572:	c3 08 dd    	sl.w      w1, #0x3, w1
    2574:	2a e7 23    	mov.w     #0x3e72, w10

00002576 <.L15>:
    2576:	81 00 45    	add.w     w10, w1, w1
    2578:	31 02 be    	mov.d     [w1++], w4
    257a:	21 03 be    	mov.d     [w1--], w6
    257c:	8b 09 20    	mov.w     #0x98, w11
    257e:	8a 85 45    	add.w     w11, w10, w11
    2580:	3b 00 be    	mov.d     [w11++], w0
    2582:	2b 01 be    	mov.d     [w11--], w2
    2584:	13 08 07    	rcall     0x35ac <___muldf3>
    2586:	00 02 be    	mov.d     w0, w4
    2588:	02 03 be    	mov.d     w2, w6
    258a:	84 bf 9f    	mov.w     w4, [w15-16]
    258c:	95 bf 9f    	mov.w     w5, [w15-14]
    258e:	a6 bf 9f    	mov.w     w6, [w15-12]
    2590:	b7 bf 9f    	mov.w     w7, [w15-10]
    2592:	11 00 09    	.pword 0x090011
    2594:	09 04 d8    	div.sw    w8, w9
    2596:	01 04 78    	mov.w     w1, w8
    2598:	43 44 dd    	sl.w      w8, #0x3, w8
    259a:	08 05 45    	add.w     w10, w8, w10
    259c:	3a 02 be    	mov.d     [w10++], w4
    259e:	2a 03 be    	mov.d     [w10--], w6
    25a0:	0f b8 97    	mov.w     [w15-16], w0
    25a2:	9f b8 97    	mov.w     [w15-14], w1
    25a4:	2f b9 97    	mov.w     [w15-12], w2
    25a6:	bf b9 97    	mov.w     [w15-10], w3
    25a8:	d5 ff 37    	bra       0x2554 <.L13>

000025aa <.L11>:
    25aa:	ea 4f 50    	sub.b     w0, #0xa, [w15]
    25ac:	08 00 34    	bra       LE, 0x25be <.L12>
    25ae:	a2 00 20    	mov.w     #0xa, w2
    25b0:	11 00 09    	.pword 0x090011
    25b2:	02 04 d8    	div.sw    w8, w2
    25b4:	01 01 78    	mov.w     w1, w2
    25b6:	69 00 40    	add.w     w0, #0x9, w0
    25b8:	43 00 dd    	sl.w      w0, #0x3, w0
    25ba:	21 e7 23    	mov.w     #0x3e72, w1
    25bc:	c4 ff 37    	bra       0x2546 <.L16>

000025be <.L12>:
    25be:	43 44 dd    	sl.w      w8, #0x3, w8
    25c0:	20 e7 23    	mov.w     #0x3e72, w0

000025c2 <.L14>:
    25c2:	08 04 40    	add.w     w0, w8, w8
    25c4:	38 00 be    	mov.d     [w8++], w0
    25c6:	28 01 be    	mov.d     [w8--], w2

000025c8 <.L9>:
    25c8:	4f 05 be    	mov.d     [--w15], w10
    25ca:	4f 04 be    	mov.d     [--w15], w8
    25cc:	00 80 fa    	ulnk      
    25ce:	00 00 06    	return    

000025d0 <_sputc>:
    25d0:	d0 01 90    	mov.w     [w0+10], w3
    25d2:	02 81 51    	sub.w     w3, w2, w2
    25d4:	42 40 a9    	bclr.b    0x42, #0x2
    25d6:	03 00 34    	bra       LE, 0x25de <.L18>
    25d8:	10 01 78    	mov.w     [w0], w2
    25da:	01 49 78    	mov.b     w1, [w2]
    25dc:	02 08 e8    	inc.w     w2, [w0]

000025de <.L18>:
    25de:	01 00 78    	mov.w     w1, w0
    25e0:	00 00 06    	return    

000025e2 <__vfprintf_cdfFnopsuxX>:
    25e2:	ef 03 b0    	add.w     #0x3e, w15
    25e4:	88 9f be    	mov.d     w8, [w15++]
    25e6:	8a 9f be    	mov.d     w10, [w15++]
    25e8:	8c 9f be    	mov.d     w12, [w15++]
    25ea:	8e 1f 78    	mov.w     w14, [w15++]
    25ec:	00 06 78    	mov.w     w0, w12
    25ee:	e1 9f 9f    	mov.w     w1, [w15-68]
    25f0:	82 af 9f    	mov.w     w2, [w15-48]
    25f2:	60 00 b8    	mul.uu    w0, #0x0, w0
    25f4:	60 11 b8    	mul.uu    w2, #0x0, w2
    25f6:	80 a7 9f    	mov.w     w0, [w15-64]
    25f8:	91 a7 9f    	mov.w     w1, [w15-62]
    25fa:	a2 a7 9f    	mov.w     w2, [w15-60]
    25fc:	b3 a7 9f    	mov.w     w3, [w15-58]
    25fe:	80 06 eb    	clr.w     w13
    2600:	9b 05 37    	bra       0x3138 <.L263>

00002602 <.L237>:
    2602:	ef 98 97    	mov.w     [w15-68], w1
    2604:	81 00 e8    	inc.w     w1, w1
    2606:	e1 9f 9f    	mov.w     w1, [w15-68]
    2608:	51 c2 b3    	mov.b     #0x25, w1
    260a:	81 4f 50    	sub.b     w0, w1, [w15]
    260c:	03 00 3a    	bra       NZ, 0x2614 <.L21>
    260e:	6f 99 97    	mov.w     [w15-68], w2
    2610:	00 07 eb    	clr.w     w14
    2612:	11 00 37    	bra       0x2636 <.L264> <.Lframe0>

00002614 <.L21>:
    2614:	bc 00 90    	mov.w     [w12+6], w1
    2616:	00 00 fb    	se        w0, w0
    2618:	01 68 a3    	btst.z    w1, #0x6
    261a:	07 00 32    	bra       Z, 0x262a <.L23>
    261c:	0d 01 78    	mov.w     w13, w2
    261e:	80 00 78    	mov.w     w0, w1
    2620:	0c 00 78    	mov.w     w12, w0
    2622:	d6 ff 07    	rcall     0x25d0 <_sputc> <L0>
    2624:	00 00 e0    	cp0.w     w0
    2626:	05 00 3a    	bra       NZ, 0x2632 <.L24>
    2628:	87 05 37    	bra       0x3138 <.L263>

0000262a <.L23>:
    262a:	8c 00 78    	mov.w     w12, w1
    262c:	91 05 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    262e:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2630:	83 05 32    	bra       Z, 0x3138 <.L263>

00002632 <.L24>:
    2632:	8d 06 e8    	inc.w     w13, w13
    2634:	81 05 37    	bra       0x3138 <.L263>

00002636 <.L264>:
    2636:	02 00 78    	mov.w     w2, w0
    2638:	b2 40 78    	mov.b     [w2++], w1
    263a:	d3 c2 b3    	mov.b     #0x2d, w3
    263c:	83 cf 50    	sub.b     w1, w3, [w15]
    263e:	0c 00 32    	bra       Z, 0x2658 <.L29>
    2640:	07 00 3c    	bra       GT, 0x2650 <.L31>
    2642:	ed c1 51    	sub.b     w3, #0xd, w3
    2644:	83 cf 50    	sub.b     w1, w3, [w15]
    2646:	0a 00 32    	bra       Z, 0x265c <.L27>
    2648:	eb c1 41    	add.b     w3, #0xb, w3
    264a:	83 cf 50    	sub.b     w1, w3, [w15]
    264c:	0d 00 3a    	bra       NZ, 0x2668 <.L26>
    264e:	08 00 37    	bra       0x2660 <.L295>

00002650 <.L31>:
    2650:	03 c3 b3    	mov.b     #0x30, w3
    2652:	83 cf 50    	sub.b     w1, w3, [w15]
    2654:	09 00 3a    	bra       NZ, 0x2668 <.L26>
    2656:	06 00 37    	bra       0x2664 <.L296>

00002658 <.L29>:
    2658:	0e 30 a0    	bset.w    w14, #0x3
    265a:	ed ff 37    	bra       0x2636 <.L264> <.Lframe0>

0000265c <.L27>:
    265c:	0e 00 a0    	bset.w    w14, #0x0
    265e:	eb ff 37    	bra       0x2636 <.L264> <.Lframe0>

00002660 <.L295>:
    2660:	0e 10 a0    	bset.w    w14, #0x1
    2662:	e9 ff 37    	bra       0x2636 <.L264> <.Lframe0>

00002664 <.L296>:
    2664:	0e 20 a0    	bset.w    w14, #0x2
    2666:	e7 ff 37    	bra       0x2636 <.L264> <.Lframe0>

00002668 <.L26>:
    2668:	0e 18 a3    	btst.z    w14, #0x1
    266a:	01 00 32    	bra       Z, 0x266e <.L33>
    266c:	0e 00 a1    	bclr.w    w14, #0x0

0000266e <.L33>:
    266e:	0e 38 a3    	btst.z    w14, #0x3
    2670:	01 00 32    	bra       Z, 0x2674 <.L34>
    2672:	0e 20 a1    	bclr.w    w14, #0x2

00002674 <.L34>:
    2674:	01 01 fb    	se        w1, w2
    2676:	02 03 b1    	sub.w     #0x30, w2
    2678:	e9 0f 51    	sub.w     w2, #0x9, [w15]
    267a:	0e 00 3e    	bra       GTU, 0x2698 <.L35>
    267c:	80 00 78    	mov.w     w0, w1
    267e:	00 01 eb    	clr.w     w2
    2680:	92 b7 9f    	mov.w     w2, [w15-30]

00002682 <.L36>:
    2682:	ea 11 b9    	.pword 0xb911ea
    2684:	31 00 fb    	se        [w1++], w0
    2686:	00 03 b1    	sub.w     #0x30, w0
    2688:	02 01 40    	add.w     w0, w2, w2
    268a:	01 00 78    	mov.w     w1, w0
    268c:	91 01 fb    	se        [w1], w3
    268e:	03 03 b1    	sub.w     #0x30, w3
    2690:	e9 8f 51    	sub.w     w3, #0x9, [w15]
    2692:	f7 ff 36    	bra       LEU, 0x2682 <.L36>
    2694:	92 b7 9f    	mov.w     w2, [w15-30]
    2696:	0a 00 37    	bra       0x26ac <.L37>

00002698 <.L35>:
    2698:	80 01 eb    	clr.w     w3
    269a:	93 b7 9f    	mov.w     w3, [w15-30]
    269c:	a2 c2 b3    	mov.b     #0x2a, w2
    269e:	82 cf 50    	sub.b     w1, w2, [w15]
    26a0:	05 00 3a    	bra       NZ, 0x26ac <.L37>
    26a2:	0f aa 97    	mov.w     [w15-48], w4
    26a4:	c4 02 78    	mov.w     [--w4], w5
    26a6:	84 af 9f    	mov.w     w4, [w15-48]
    26a8:	95 b7 9f    	mov.w     w5, [w15-30]
    26aa:	00 00 e8    	inc.w     w0, w0

000026ac <.L37>:
    26ac:	e1 c2 b3    	mov.b     #0x2e, w1
    26ae:	90 cf 10    	subr.b    w1, [w0], [w15]
    26b0:	17 00 3a    	bra       NZ, 0x26e0 <.L38>
    26b2:	0e e0 a0    	bset.w    w14, #0xe
    26b4:	e4 c0 50    	sub.b     w1, #0x4, w1
    26b6:	d0 cf 10    	subr.b    w1, [++w0], [w15]
    26b8:	03 00 32    	bra       Z, 0x26c0 <.L39>
    26ba:	80 00 78    	mov.w     w0, w1
    26bc:	80 01 eb    	clr.w     w3
    26be:	09 00 37    	bra       0x26d2 <.L40>

000026c0 <.L39>:
    26c0:	8f ab 97    	mov.w     [w15-48], w7
    26c2:	c7 00 78    	mov.w     [--w7], w1
    26c4:	87 af 9f    	mov.w     w7, [w15-48]
    26c6:	d1 af 9f    	mov.w     w1, [w15-38]
    26c8:	00 00 e8    	inc.w     w0, w0

000026ca <.L41>:
    26ca:	00 01 78    	mov.w     w0, w2
    26cc:	0d 00 37    	bra       0x26e8 <.L42>

000026ce <.L43>:
    26ce:	ea 18 b9    	.pword 0xb918ea
    26d0:	80 01 41    	add.w     w2, w0, w3

000026d2 <.L40>:
    26d2:	01 00 78    	mov.w     w1, w0
    26d4:	31 01 fb    	se        [w1++], w2
    26d6:	02 03 b1    	sub.w     #0x30, w2
    26d8:	e9 0f 51    	sub.w     w2, #0x9, [w15]
    26da:	f9 ff 36    	bra       LEU, 0x26ce <.L43> <.LASF1>
    26dc:	d3 af 9f    	mov.w     w3, [w15-38]
    26de:	f5 ff 37    	bra       0x26ca <.L41>

000026e0 <.L38>:
    26e0:	0e c0 a0    	bset.w    w14, #0xc
    26e2:	00 01 eb    	clr.w     w2
    26e4:	d2 af 9f    	mov.w     w2, [w15-38]
    26e6:	f1 ff 37    	bra       0x26ca <.L41>

000026e8 <.L42>:
    26e8:	82 01 78    	mov.w     w2, w3
    26ea:	33 40 78    	mov.b     [w3++], w0
    26ec:	03 01 78    	mov.w     w3, w2
    26ee:	c1 c6 b3    	mov.b     #0x6c, w1
    26f0:	81 4f 50    	sub.b     w0, w1, [w15]
    26f2:	2b 00 32    	bra       Z, 0x274a <.L50>
    26f4:	e3 9f 9f    	mov.w     w3, [w15-68]
    26f6:	14 00 3c    	bra       GT, 0x2720 <.L55>
    26f8:	e8 c0 50    	sub.b     w1, #0x8, w1
    26fa:	81 4f 50    	sub.b     w0, w1, [w15]
    26fc:	24 00 32    	bra       Z, 0x2746 <.L48>
    26fe:	09 00 3c    	bra       GT, 0x2712 <.L56>
    2700:	ec c0 50    	sub.b     w1, #0xc, w1
    2702:	81 4f 50    	sub.b     w0, w1, [w15]
    2704:	2e 00 32    	bra       Z, 0x2762 <.L46>
    2706:	eb c0 40    	add.b     w1, #0xb, w1
    2708:	81 4f 50    	sub.b     w0, w1, [w15]
    270a:	98 00 32    	bra       Z, 0x283c <.L47>
    270c:	00 04 e0    	cp0.b     w0
    270e:	19 05 32    	bra       Z, 0x3142 <.L45>
    2710:	b4 00 37    	bra       0x287a <.L44>

00002712 <.L56>:
    2712:	61 c6 b3    	mov.b     #0x66, w1
    2714:	81 4f 50    	sub.b     w0, w1, [w15]
    2716:	1f 00 32    	bra       Z, 0x2756 <.L49>
    2718:	e3 c0 40    	add.b     w1, #0x3, w1
    271a:	81 4f 50    	sub.b     w0, w1, [w15]
    271c:	ae 00 3a    	bra       NZ, 0x287a <.L44>
    271e:	13 00 37    	bra       0x2746 <.L48>

00002720 <.L55>:
    2720:	31 c7 b3    	mov.b     #0x73, w1
    2722:	81 4f 50    	sub.b     w0, w1, [w15]
    2724:	22 00 32    	bra       Z, 0x276a <.L52>
    2726:	07 00 3c    	bra       GT, 0x2736 <.L57>
    2728:	e4 c0 50    	sub.b     w1, #0x4, w1
    272a:	81 4f 50    	sub.b     w0, w1, [w15]
    272c:	17 00 32    	bra       Z, 0x275c <.L51>
    272e:	81 40 e8    	inc.b     w1, w1
    2730:	81 4f 50    	sub.b     w0, w1, [w15]
    2732:	a3 00 3a    	bra       NZ, 0x287a <.L44>
    2734:	16 00 37    	bra       0x2762 <.L46>

00002736 <.L57>:
    2736:	51 c7 b3    	mov.b     #0x75, w1
    2738:	81 4f 50    	sub.b     w0, w1, [w15]
    273a:	a4 00 32    	bra       Z, 0x2884 <.L53>
    273c:	e3 c0 40    	add.b     w1, #0x3, w1
    273e:	81 4f 50    	sub.b     w0, w1, [w15]
    2740:	9c 00 3a    	bra       NZ, 0x287a <.L44>
    2742:	e0 77 9f    	mov.b     w0, [w15-74]
    2744:	10 00 37    	bra       0x2766 <.L58>

00002746 <.L48>:
    2746:	e0 77 9f    	mov.b     w0, [w15-74]
    2748:	9f 00 37    	bra       0x2888 <.L59>

0000274a <.L50>:
    274a:	00 01 20    	mov.w     #0x10, w0
    274c:	0e 48 a3    	btst.z    w14, #0x4
    274e:	01 00 32    	bra       Z, 0x2752 <.L60>
    2750:	00 00 28    	mov.w     #0x8000, w0

00002752 <.L60>:
    2752:	0e 07 70    	ior.w     w0, w14, w14
    2754:	c9 ff 37    	bra       0x26e8 <.L42>

00002756 <.L49>:
    2756:	e0 77 9f    	mov.b     w0, [w15-74]
    2758:	0e a0 a0    	bset.w    w14, #0xa
    275a:	96 00 37    	bra       0x2888 <.L59>

0000275c <.L51>:
    275c:	e0 77 9f    	mov.b     w0, [w15-74]
    275e:	0e 60 a0    	bset.w    w14, #0x6
    2760:	93 00 37    	bra       0x2888 <.L59>

00002762 <.L46>:
    2762:	e0 77 9f    	mov.b     w0, [w15-74]
    2764:	0e 50 a0    	bset.w    w14, #0x5

00002766 <.L58>:
    2766:	0e 70 a0    	bset.w    w14, #0x7
    2768:	8f 00 37    	bra       0x2888 <.L59>

0000276a <.L52>:
    276a:	e0 77 9f    	mov.b     w0, [w15-74]
    276c:	8f a9 97    	mov.w     [w15-48], w3
    276e:	43 00 78    	mov.w     [--w3], w0
    2770:	83 af 9f    	mov.w     w3, [w15-48]
    2772:	00 04 78    	mov.w     w0, w8
    2774:	00 00 e0    	cp0.w     w0
    2776:	01 00 3a    	bra       NZ, 0x277a <.L61>
    2778:	48 ff 23    	mov.w     #0x3ff4, w8

0000277a <.L61>:
    277a:	08 01 78    	mov.w     w8, w2
    277c:	00 00 eb    	clr.w     w0
    277e:	01 00 37    	bra       0x2782 <.L62>

00002780 <.L63>:
    2780:	00 00 e8    	inc.w     w0, w0

00002782 <.L62>:
    2782:	80 00 41    	add.w     w2, w0, w1
    2784:	11 04 e0    	cp0.b     [w1]
    2786:	fc ff 3a    	bra       NZ, 0x2780 <.L63>
    2788:	80 04 78    	mov.w     w0, w9

0000278a <.L64>:
    278a:	5f aa 97    	mov.w     [w15-38], w4
    278c:	04 00 e0    	cp0.w     w4
    278e:	03 00 32    	bra       Z, 0x2796 <.L65>
    2790:	89 0f 52    	sub.w     w4, w9, [w15]
    2792:	01 00 31    	bra       C, 0x2796 <.L65>
    2794:	84 04 78    	mov.w     w4, w9

00002796 <.L65>:
    2796:	80 01 eb    	clr.w     w3
    2798:	9f b2 97    	mov.w     [w15-30], w5
    279a:	89 8f 52    	sub.w     w5, w9, [w15]
    279c:	01 00 36    	bra       LEU, 0x27a0 <.L66>
    279e:	89 81 52    	sub.w     w5, w9, w3

000027a0 <.L66>:
    27a0:	68 03 67    	and.w     w14, #0x8, w6
    27a2:	d6 af 9f    	mov.w     w6, [w15-38]
    27a4:	2c 00 3a    	bra       NZ, 0x27fe <.L267>
    27a6:	03 07 78    	mov.w     w3, w14
    27a8:	11 00 37    	bra       0x27cc <.L68>

000027aa <.L73>:
    27aa:	3c 00 90    	mov.w     [w12+6], w0
    27ac:	00 68 a3    	btst.z    w0, #0x6
    27ae:	07 00 32    	bra       Z, 0x27be <.L70>
    27b0:	0d 01 78    	mov.w     w13, w2
    27b2:	01 02 20    	mov.w     #0x20, w1
    27b4:	0c 00 78    	mov.w     w12, w0
    27b6:	0c ff 07    	rcall     0x25d0 <_sputc> <L0>
    27b8:	00 00 e0    	cp0.w     w0
    27ba:	06 00 3a    	bra       NZ, 0x27c8 <.L71>
    27bc:	06 00 37    	bra       0x27ca <.L72> <.LASF0>

000027be <.L70>:
    27be:	8c 00 78    	mov.w     w12, w1
    27c0:	00 02 20    	mov.w     #0x20, w0
    27c2:	c6 04 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    27c4:	e1 0f 40    	add.w     w0, #0x1, [w15]
    27c6:	01 00 32    	bra       Z, 0x27ca <.L72> <.LASF0>

000027c8 <.L71>:
    27c8:	8d 06 e8    	inc.w     w13, w13

000027ca <.L72>:
    27ca:	0e 07 e9    	dec.w     w14, w14

000027cc <.L68>:
    27cc:	0e 00 e0    	cp0.w     w14
    27ce:	ed ff 3a    	bra       NZ, 0x27aa <.L73>
    27d0:	80 81 eb    	setm.w    w3
    27d2:	15 00 37    	bra       0x27fe <.L267>

000027d4 <.L77>:
    27d4:	3c 00 90    	mov.w     [w12+6], w0
    27d6:	00 68 a3    	btst.z    w0, #0x6
    27d8:	09 00 32    	bra       Z, 0x27ec <.L74>
    27da:	08 00 78    	mov.w     w8, w0
    27dc:	b0 00 fb    	se        [w0++], w1
    27de:	00 04 78    	mov.w     w0, w8
    27e0:	0d 01 78    	mov.w     w13, w2
    27e2:	0c 00 78    	mov.w     w12, w0
    27e4:	f5 fe 07    	rcall     0x25d0 <_sputc> <L0>
    27e6:	00 00 e0    	cp0.w     w0
    27e8:	08 00 3a    	bra       NZ, 0x27fa <.L75>
    27ea:	0a 00 37    	bra       0x2800 <.L261>

000027ec <.L74>:
    27ec:	88 00 78    	mov.w     w8, w1
    27ee:	31 00 fb    	se        [w1++], w0
    27f0:	01 04 78    	mov.w     w1, w8
    27f2:	8c 00 78    	mov.w     w12, w1
    27f4:	ad 04 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    27f6:	e1 0f 40    	add.w     w0, #0x1, [w15]
    27f8:	03 00 32    	bra       Z, 0x2800 <.L261>

000027fa <.L75>:
    27fa:	8d 06 e8    	inc.w     w13, w13
    27fc:	01 00 37    	bra       0x2800 <.L261>

000027fe <.L267>:
    27fe:	03 07 78    	mov.w     w3, w14

00002800 <.L261>:
    2800:	09 00 78    	mov.w     w9, w0
    2802:	80 04 e9    	dec.w     w0, w9
    2804:	00 00 e0    	cp0.w     w0
    2806:	e6 ff 3a    	bra       NZ, 0x27d4 <.L77>
    2808:	8e 01 78    	mov.w     w14, w3
    280a:	df ab 97    	mov.w     [w15-38], w7
    280c:	07 00 e0    	cp0.w     w7
    280e:	94 04 32    	bra       Z, 0x3138 <.L263>
    2810:	03 07 78    	mov.w     w3, w14
    2812:	11 00 37    	bra       0x2836 <.L78>

00002814 <.L82>:
    2814:	3c 00 90    	mov.w     [w12+6], w0
    2816:	00 68 a3    	btst.z    w0, #0x6
    2818:	07 00 32    	bra       Z, 0x2828 <.L79>
    281a:	0d 01 78    	mov.w     w13, w2
    281c:	01 02 20    	mov.w     #0x20, w1
    281e:	0c 00 78    	mov.w     w12, w0
    2820:	d7 fe 07    	rcall     0x25d0 <_sputc> <L0>
    2822:	00 00 e0    	cp0.w     w0
    2824:	06 00 3a    	bra       NZ, 0x2832 <.L80>
    2826:	06 00 37    	bra       0x2834 <.L81>

00002828 <.L79>:
    2828:	8c 00 78    	mov.w     w12, w1
    282a:	00 02 20    	mov.w     #0x20, w0
    282c:	91 04 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    282e:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2830:	01 00 32    	bra       Z, 0x2834 <.L81>

00002832 <.L80>:
    2832:	8d 06 e8    	inc.w     w13, w13

00002834 <.L81>:
    2834:	0e 07 e9    	dec.w     w14, w14

00002836 <.L78>:
    2836:	0e 00 e0    	cp0.w     w14
    2838:	ed ff 3a    	bra       NZ, 0x2814 <.L82>
    283a:	7e 04 37    	bra       0x3138 <.L263>

0000283c <.L47>:
    283c:	8f a8 97    	mov.w     [w15-48], w1
    283e:	41 00 78    	mov.w     [--w1], w0
    2840:	81 af 9f    	mov.w     w1, [w15-48]
    2842:	61 02 b9    	mul.su    w0, #0x1, w4
    2844:	61 2b b9    	mul.su    w5, #0x1, w6
    2846:	94 af 9f    	mov.w     w4, [w15-46]
    2848:	a5 af 9f    	mov.w     w5, [w15-44]
    284a:	b6 af 9f    	mov.w     w6, [w15-42]
    284c:	c7 af 9f    	mov.w     w7, [w15-40]
    284e:	48 22 de    	lsr.w     w4, #0x8, w4
    2850:	48 28 dd    	sl.w      w5, #0x8, w0
    2852:	04 02 70    	ior.w     w0, w4, w4
    2854:	e4 77 9f    	mov.b     w4, [w15-74]
    2856:	0e 48 a3    	btst.z    w14, #0x4
    2858:	09 00 32    	bra       Z, 0x286c <.L83>
    285a:	04 04 e0    	cp0.b     w4
    285c:	07 00 32    	bra       Z, 0x286c <.L83>
    285e:	e1 4f 42    	add.b     w4, #0x1, [w15]
    2860:	05 00 32    	bra       Z, 0x286c <.L83>
    2862:	f4 77 9f    	mov.b     w4, [w15-73]
    2864:	af d0 97    	mov.b     [w15-46], w1
    2866:	81 7f 9f    	mov.b     w1, [w15-72]
    2868:	29 00 20    	mov.w     #0x2, w9
    286a:	03 00 37    	bra       0x2872 <.L84>

0000286c <.L83>:
    286c:	2f d1 97    	mov.b     [w15-46], w2
    286e:	f2 77 9f    	mov.b     w2, [w15-73]
    2870:	19 00 20    	mov.w     #0x1, w9

00002872 <.L84>:
    2872:	63 fb 2f    	mov.w     #0xffb6, w3
    2874:	8f 81 41    	add.w     w3, w15, w3
    2876:	03 04 e8    	inc.w     w3, w8
    2878:	88 ff 37    	bra       0x278a <.L64>

0000287a <.L44>:
    287a:	e0 77 9f    	mov.b     w0, [w15-74]
    287c:	68 fb 2f    	mov.w     #0xffb6, w8
    287e:	0f 04 44    	add.w     w8, w15, w8
    2880:	19 00 20    	mov.w     #0x1, w9
    2882:	83 ff 37    	bra       0x278a <.L64>

00002884 <.L53>:
    2884:	e0 77 9f    	mov.b     w0, [w15-74]
    2886:	0e 0c b3    	ior.w     #0xc0, w14

00002888 <.L59>:
    2888:	00 70 20    	mov.w     #0x700, w0
    288a:	00 00 67    	and.w     w14, w0, w0
    288c:	64 02 32    	bra       Z, 0x2d56 <.L85>
    288e:	0e c8 a3    	btst.z    w14, #0xc
    2890:	02 00 32    	bra       Z, 0x2896 <.L86>
    2892:	64 00 20    	mov.w     #0x6, w4
    2894:	d4 af 9f    	mov.w     w4, [w15-38]

00002896 <.L86>:
    2896:	0e 48 a3    	btst.z    w14, #0x4
    2898:	09 00 32    	bra       Z, 0x28ac <.L87>
    289a:	0f aa 97    	mov.w     [w15-48], w4
    289c:	44 01 be    	mov.d     [--w4], w2
    289e:	44 00 be    	mov.d     [--w4], w0
    28a0:	84 af 9f    	mov.w     w4, [w15-48]
    28a2:	90 af 9f    	mov.w     w0, [w15-46]
    28a4:	a1 af 9f    	mov.w     w1, [w15-44]
    28a6:	b2 af 9f    	mov.w     w2, [w15-42]
    28a8:	c3 af 9f    	mov.w     w3, [w15-40]
    28aa:	0a 00 37    	bra       0x28c0 <.L88>

000028ac <.L87>:
    28ac:	8f aa 97    	mov.w     [w15-48], w5
    28ae:	45 00 be    	mov.d     [--w5], w0
    28b0:	85 af 9f    	mov.w     w5, [w15-48]
    28b2:	e4 05 07    	rcall     0x347c <___extendsfdf2>
    28b4:	00 02 be    	mov.d     w0, w4
    28b6:	02 03 be    	mov.d     w2, w6
    28b8:	94 af 9f    	mov.w     w4, [w15-46]
    28ba:	a5 af 9f    	mov.w     w5, [w15-44]
    28bc:	b6 af 9f    	mov.w     w6, [w15-42]
    28be:	c7 af 9f    	mov.w     w7, [w15-40]

000028c0 <.L88>:
    28c0:	60 22 b8    	mul.uu    w4, #0x0, w4
    28c2:	60 33 b8    	mul.uu    w6, #0x0, w6
    28c4:	1f a8 97    	mov.w     [w15-46], w0
    28c6:	af a8 97    	mov.w     [w15-44], w1
    28c8:	3f a9 97    	mov.w     [w15-42], w2
    28ca:	cf a9 97    	mov.w     [w15-40], w3
    28cc:	42 05 07    	rcall     0x3352 <___eqdf2> <___ledf2> <___ltdf2>
    28ce:	00 00 e0    	cp0.w     w0
    28d0:	0a 00 3d    	bra       GE, 0x28e6 <.L89>
    28d2:	1f a8 97    	mov.w     [w15-46], w0
    28d4:	af a8 97    	mov.w     [w15-44], w1
    28d6:	3f a9 97    	mov.w     [w15-42], w2
    28d8:	cf a9 97    	mov.w     [w15-40], w3
    28da:	03 f0 a2    	btg.w     w3, #0xf
    28dc:	90 af 9f    	mov.w     w0, [w15-46]
    28de:	a1 af 9f    	mov.w     w1, [w15-44]
    28e0:	b2 af 9f    	mov.w     w2, [w15-42]
    28e2:	c3 af 9f    	mov.w     w3, [w15-40]
    28e4:	3e 00 b3    	ior.w     #0x3, w14

000028e6 <.L89>:
    28e6:	00 00 eb    	clr.w     w0
    28e8:	d0 9f 9f    	mov.w     w0, [w15-70]
    28ea:	60 22 b8    	mul.uu    w4, #0x0, w4
    28ec:	60 33 b8    	mul.uu    w6, #0x0, w6
    28ee:	1f a8 97    	mov.w     [w15-46], w0
    28f0:	af a8 97    	mov.w     [w15-44], w1
    28f2:	3f a9 97    	mov.w     [w15-42], w2
    28f4:	cf a9 97    	mov.w     [w15-40], w3
    28f6:	91 05 07    	rcall     0x341a <___nedf2>
    28f8:	00 00 e0    	cp0.w     w0
    28fa:	34 00 32    	bra       Z, 0x2964 <.L91>
    28fc:	a4 fb 2f    	mov.w     #0xffba, w4
    28fe:	0f 02 42    	add.w     w4, w15, w4
    2900:	1f a8 97    	mov.w     [w15-46], w0
    2902:	af a8 97    	mov.w     [w15-44], w1
    2904:	3f a9 97    	mov.w     [w15-42], w2
    2906:	cf a9 97    	mov.w     [w15-40], w3
    2908:	34 06 07    	rcall     0x3572 <_frexp> <_frexpl>
    290a:	5f 98 97    	mov.w     [w15-70], w0
    290c:	00 00 e9    	dec.w     w0, w0
    290e:	e3 00 b9    	.pword 0xb900e3
    2910:	a2 00 20    	mov.w     #0xa, w2
    2912:	11 00 09    	.pword 0x090011
    2914:	02 00 d8    	div.sw    w0, w2
    2916:	d0 9f 9f    	mov.w     w0, [w15-70]
    2918:	00 00 e0    	cp0.w     w0
    291a:	02 00 3d    	bra       GE, 0x2920 <.L93>
    291c:	00 00 e9    	dec.w     w0, w0
    291e:	d0 9f 9f    	mov.w     w0, [w15-70]

00002920 <.L93>:
    2920:	5f 9c 97    	mov.w     [w15-70], w8
    2922:	08 40 ea    	neg.b     w8, w0
    2924:	f3 fd 07    	rcall     0x250c <_scale> <L0> <.L0>
    2926:	1f aa 97    	mov.w     [w15-46], w4
    2928:	af aa 97    	mov.w     [w15-44], w5
    292a:	3f ab 97    	mov.w     [w15-42], w6
    292c:	cf ab 97    	mov.w     [w15-40], w7
    292e:	3e 06 07    	rcall     0x35ac <___muldf3>
    2930:	00 02 be    	mov.d     w0, w4
    2932:	02 03 be    	mov.d     w2, w6
    2934:	84 a7 9f    	mov.w     w4, [w15-64]
    2936:	95 a7 9f    	mov.w     w5, [w15-62]
    2938:	a6 a7 9f    	mov.w     w6, [w15-60]
    293a:	b7 a7 9f    	mov.w     w7, [w15-58]
    293c:	60 22 b8    	mul.uu    w4, #0x0, w4
    293e:	06 00 20    	mov.w     #0x0, w6
    2940:	07 ff 23    	mov.w     #0x3ff0, w7
    2942:	07 05 07    	rcall     0x3352 <___eqdf2> <___ledf2> <___ltdf2>
    2944:	00 00 e0    	cp0.w     w0
    2946:	02 00 3d    	bra       GE, 0x294c <.L265>
    2948:	08 04 e9    	dec.w     w8, w8
    294a:	0b 00 37    	bra       0x2962 <.L274>

0000294c <.L265>:
    294c:	60 22 b8    	mul.uu    w4, #0x0, w4
    294e:	06 00 20    	mov.w     #0x0, w6
    2950:	47 02 24    	mov.w     #0x4024, w7
    2952:	0f a0 97    	mov.w     [w15-64], w0
    2954:	9f a0 97    	mov.w     [w15-62], w1
    2956:	2f a1 97    	mov.w     [w15-60], w2
    2958:	bf a1 97    	mov.w     [w15-58], w3
    295a:	00 05 07    	rcall     0x335c <___gedf2> <___gtdf2> <.LASF7>
    295c:	00 00 e0    	cp0.w     w0
    295e:	02 00 35    	bra       LT, 0x2964 <.L91>
    2960:	08 04 e8    	inc.w     w8, w8

00002962 <.L274>:
    2962:	d8 9f 9f    	mov.w     w8, [w15-70]

00002964 <.L91>:
    2964:	df aa 97    	mov.w     [w15-38], w5
    2966:	f8 8f 52    	sub.w     w5, #0x18, [w15]
    2968:	0f 00 3c    	bra       GT, 0x2988 <.L97>
    296a:	05 40 78    	mov.b     w5, w0
    296c:	72 fd 07    	rcall     0x2452 <_fround> <L0>
    296e:	00 02 be    	mov.d     w0, w4
    2970:	02 03 be    	mov.d     w2, w6
    2972:	1f a8 97    	mov.w     [w15-46], w0
    2974:	af a8 97    	mov.w     [w15-44], w1
    2976:	3f a9 97    	mov.w     [w15-42], w2
    2978:	cf a9 97    	mov.w     [w15-40], w3
    297a:	6e 04 07    	rcall     0x3258 <___adddf3> <L0>
    297c:	00 02 be    	mov.d     w0, w4
    297e:	02 03 be    	mov.d     w2, w6
    2980:	94 af 9f    	mov.w     w4, [w15-46]
    2982:	a5 af 9f    	mov.w     w5, [w15-44]
    2984:	b6 af 9f    	mov.w     w6, [w15-42]
    2986:	c7 af 9f    	mov.w     w7, [w15-40]

00002988 <.L97>:
    2988:	5f 9c 97    	mov.w     [w15-70], w8
    298a:	e9 0f 54    	sub.w     w8, #0x9, [w15]
    298c:	15 00 3c    	bra       GT, 0x29b8 <.L98>
    298e:	60 22 b8    	mul.uu    w4, #0x0, w4
    2990:	60 33 b8    	mul.uu    w6, #0x0, w6
    2992:	1f a8 97    	mov.w     [w15-46], w0
    2994:	af a8 97    	mov.w     [w15-44], w1
    2996:	3f a9 97    	mov.w     [w15-42], w2
    2998:	cf a9 97    	mov.w     [w15-40], w3
    299a:	3f 05 07    	rcall     0x341a <___nedf2>
    299c:	00 00 e0    	cp0.w     w0
    299e:	32 00 32    	bra       Z, 0x2a04 <.L99>
    29a0:	1f a8 97    	mov.w     [w15-46], w0
    29a2:	af a8 97    	mov.w     [w15-44], w1
    29a4:	3f a9 97    	mov.w     [w15-42], w2
    29a6:	cf a9 97    	mov.w     [w15-40], w3
    29a8:	88 05 07    	rcall     0x34ba <___fixunsdfdi>
    29aa:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    29ac:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    29ae:	e0 0f 59    	subb.w    w2, #0x0, [w15]
    29b0:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    29b2:	28 00 3a    	bra       NZ, 0x2a04 <.L99>
    29b4:	e1 0f 54    	sub.w     w8, #0x1, [w15]
    29b6:	26 00 34    	bra       LE, 0x2a04 <.L99>

000029b8 <.L98>:
    29b8:	04 00 20    	mov.w     #0x0, w4
    29ba:	05 00 2e    	mov.w     #0xe000, w5
    29bc:	b6 e0 22    	mov.w     #0x2e0b, w6
    29be:	17 01 24    	mov.w     #0x4011, w7
    29c0:	0f a0 97    	mov.w     [w15-64], w0
    29c2:	9f a0 97    	mov.w     [w15-62], w1
    29c4:	2f a1 97    	mov.w     [w15-60], w2
    29c6:	bf a1 97    	mov.w     [w15-58], w3
    29c8:	c4 04 07    	rcall     0x3352 <___eqdf2> <___ledf2> <___ltdf2>
    29ca:	00 00 e0    	cp0.w     w0
    29cc:	02 00 3d    	bra       GE, 0x29d2 <.L266>
    29ce:	73 04 54    	sub.w     w8, #0x13, w8
    29d0:	01 00 37    	bra       0x29d4 <.L275>

000029d2 <.L266>:
    29d2:	72 04 54    	sub.w     w8, #0x12, w8

000029d4 <.L275>:
    29d4:	d8 9f 9f    	mov.w     w8, [w15-70]
    29d6:	2f 78 97    	mov.b     [w15-70], w0
    29d8:	99 fd 07    	rcall     0x250c <_scale> <L0> <.L0>
    29da:	00 02 be    	mov.d     w0, w4
    29dc:	02 03 be    	mov.d     w2, w6
    29de:	84 a7 9f    	mov.w     w4, [w15-64]
    29e0:	95 a7 9f    	mov.w     w5, [w15-62]
    29e2:	a6 a7 9f    	mov.w     w6, [w15-60]
    29e4:	b7 a7 9f    	mov.w     w7, [w15-58]
    29e6:	1f a8 97    	mov.w     [w15-46], w0
    29e8:	af a8 97    	mov.w     [w15-44], w1
    29ea:	3f a9 97    	mov.w     [w15-42], w2
    29ec:	cf a9 97    	mov.w     [w15-40], w3
    29ee:	bb 04 07    	rcall     0x3366 <___divdf3>
    29f0:	64 05 07    	rcall     0x34ba <___fixunsdfdi>
    29f2:	02 05 be    	mov.d     w2, w10
    29f4:	00 04 be    	mov.d     w0, w8
    29f6:	60 00 b8    	mul.uu    w0, #0x0, w0
    29f8:	60 11 b8    	mul.uu    w2, #0x0, w2
    29fa:	90 af 9f    	mov.w     w0, [w15-46]
    29fc:	a1 af 9f    	mov.w     w1, [w15-44]
    29fe:	b2 af 9f    	mov.w     w2, [w15-42]
    2a00:	c3 af 9f    	mov.w     w3, [w15-40]
    2a02:	17 00 37    	bra       0x2a32 <.L104>

00002a04 <.L99>:
    2a04:	1f a8 97    	mov.w     [w15-46], w0
    2a06:	af a8 97    	mov.w     [w15-44], w1
    2a08:	3f a9 97    	mov.w     [w15-42], w2
    2a0a:	cf a9 97    	mov.w     [w15-40], w3
    2a0c:	56 05 07    	rcall     0x34ba <___fixunsdfdi>
    2a0e:	02 05 be    	mov.d     w2, w10
    2a10:	00 04 be    	mov.d     w0, w8
    2a12:	84 05 07    	rcall     0x351c <___floatundidf>
    2a14:	00 02 be    	mov.d     w0, w4
    2a16:	02 03 be    	mov.d     w2, w6
    2a18:	1f a8 97    	mov.w     [w15-46], w0
    2a1a:	af a8 97    	mov.w     [w15-44], w1
    2a1c:	3f a9 97    	mov.w     [w15-42], w2
    2a1e:	cf a9 97    	mov.w     [w15-40], w3
    2a20:	3a 06 07    	rcall     0x3696 <___subdf3>
    2a22:	00 02 be    	mov.d     w0, w4
    2a24:	02 03 be    	mov.d     w2, w6
    2a26:	94 af 9f    	mov.w     w4, [w15-46]
    2a28:	a5 af 9f    	mov.w     w5, [w15-44]
    2a2a:	b6 af 9f    	mov.w     w6, [w15-42]
    2a2c:	c7 af 9f    	mov.w     w7, [w15-40]
    2a2e:	00 00 eb    	clr.w     w0
    2a30:	d0 9f 9f    	mov.w     w0, [w15-70]

00002a32 <.L104>:
    2a32:	45 00 24    	mov.w     #0x4004, w5
    2a34:	14 c0 b3    	mov.b     #0x1, w4
    2a36:	08 00 37    	bra       0x2a48 <.L105> <.Lframe0>

00002a38 <.L108>:
    2a38:	35 00 be    	mov.d     [w5++], w0
    2a3a:	35 01 be    	mov.d     [w5++], w2
    2a3c:	00 40 e1    	cp.w      w8, w0
    2a3e:	01 c8 e1    	cpb.w     w9, w1
    2a40:	02 d0 e1    	cpb.w     w10, w2
    2a42:	03 d8 e1    	cpb.w     w11, w3
    2a44:	03 00 39    	bra       NC, 0x2a4c <.L276>
    2a46:	04 42 e8    	inc.b     w4, w4

00002a48 <.L105>:
    2a48:	f4 4f 52    	sub.b     w4, #0x14, [w15]
    2a4a:	f6 ff 3a    	bra       NZ, 0x2a38 <.L108>

00002a4c <.L276>:
    2a4c:	e4 77 9f    	mov.b     w4, [w15-74]
    2a4e:	5f 98 97    	mov.w     [w15-70], w0
    2a50:	9f b2 97    	mov.w     [w15-30], w5
    2a52:	00 80 52    	sub.w     w5, w0, w0
    2a54:	5f ab 97    	mov.w     [w15-38], w6
    2a56:	86 00 50    	sub.w     w0, w6, w1
    2a58:	04 00 fb    	se        w4, w0
    2a5a:	00 80 50    	sub.w     w1, w0, w0
    2a5c:	90 b7 9f    	mov.w     w0, [w15-30]
    2a5e:	06 00 e0    	cp0.w     w6
    2a60:	02 00 32    	bra       Z, 0x2a66 <.L109>
    2a62:	00 00 e9    	dec.w     w0, w0
    2a64:	90 b7 9f    	mov.w     w0, [w15-30]

00002a66 <.L109>:
    2a66:	63 00 67    	and.w     w14, #0x3, w0
    2a68:	03 00 32    	bra       Z, 0x2a70 <.L110>
    2a6a:	9f b3 97    	mov.w     [w15-30], w7
    2a6c:	87 03 e9    	dec.w     w7, w7
    2a6e:	97 b7 9f    	mov.w     w7, [w15-30]

00002a70 <.L110>:
    2a70:	0e 28 a3    	btst.z    w14, #0x2
    2a72:	50 00 32    	bra       Z, 0x2b14 <.L111>
    2a74:	61 01 67    	and.w     w14, #0x1, w2
    2a76:	0e 18 a3    	btst.z    w14, #0x1
    2a78:	0f 00 32    	bra       Z, 0x2a98 <.L112>
    2a7a:	3c 00 90    	mov.w     [w12+6], w0
    2a7c:	00 68 a3    	btst.z    w0, #0x6
    2a7e:	06 00 32    	bra       Z, 0x2a8c <.L113>
    2a80:	b1 02 20    	mov.w     #0x2b, w1
    2a82:	02 00 e0    	cp0.w     w2
    2a84:	01 00 32    	bra       Z, 0x2a88 <.L114>
    2a86:	81 80 e8    	inc2.w    w1, w1

00002a88 <.L114>:
    2a88:	0d 01 78    	mov.w     w13, w2
    2a8a:	0d 00 37    	bra       0x2aa6 <.L294>

00002a8c <.L113>:
    2a8c:	b0 02 20    	mov.w     #0x2b, w0
    2a8e:	02 00 e0    	cp0.w     w2
    2a90:	01 00 32    	bra       Z, 0x2a94 <.L117>
    2a92:	00 80 e8    	inc2.w    w0, w0

00002a94 <.L117>:
    2a94:	8c 00 78    	mov.w     w12, w1
    2a96:	0e 00 37    	bra       0x2ab4 <.L293>

00002a98 <.L112>:
    2a98:	02 00 e0    	cp0.w     w2
    2a9a:	33 00 32    	bra       Z, 0x2b02 <.L270> <.LASF122>
    2a9c:	3c 00 90    	mov.w     [w12+6], w0
    2a9e:	00 68 a3    	btst.z    w0, #0x6
    2aa0:	07 00 32    	bra       Z, 0x2ab0 <.L119>
    2aa2:	0d 01 78    	mov.w     w13, w2
    2aa4:	01 02 20    	mov.w     #0x20, w1

00002aa6 <.L294>:
    2aa6:	0c 00 78    	mov.w     w12, w0
    2aa8:	93 fd 07    	rcall     0x25d0 <_sputc> <L0>
    2aaa:	00 00 e0    	cp0.w     w0
    2aac:	06 00 3a    	bra       NZ, 0x2aba <.L120>
    2aae:	29 00 37    	bra       0x2b02 <.L270> <.LASF122>

00002ab0 <.L119>:
    2ab0:	8c 00 78    	mov.w     w12, w1
    2ab2:	00 02 20    	mov.w     #0x20, w0

00002ab4 <.L293>:
    2ab4:	4d 03 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2ab6:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2ab8:	24 00 32    	bra       Z, 0x2b02 <.L270> <.LASF122>

00002aba <.L120>:
    2aba:	8d 06 e8    	inc.w     w13, w13
    2abc:	22 00 37    	bra       0x2b02 <.L270> <.LASF122>

00002abe <.L124>:
    2abe:	3c 00 90    	mov.w     [w12+6], w0
    2ac0:	00 68 a3    	btst.z    w0, #0x6
    2ac2:	0f 00 32    	bra       Z, 0x2ae2 <.L121>
    2ac4:	0d 01 78    	mov.w     w13, w2
    2ac6:	01 03 20    	mov.w     #0x30, w1
    2ac8:	0c 00 78    	mov.w     w12, w0
    2aca:	f4 b7 9f    	mov.w     w4, [w15-18]
    2acc:	85 bf 9f    	mov.w     w5, [w15-16]
    2ace:	d6 b7 9f    	mov.w     w6, [w15-22]
    2ad0:	e7 b7 9f    	mov.w     w7, [w15-20]
    2ad2:	7e fd 07    	rcall     0x25d0 <_sputc> <L0>
    2ad4:	7f b2 97    	mov.w     [w15-18], w4
    2ad6:	8f ba 97    	mov.w     [w15-16], w5
    2ad8:	5f b3 97    	mov.w     [w15-22], w6
    2ada:	ef b3 97    	mov.w     [w15-20], w7
    2adc:	00 00 e0    	cp0.w     w0
    2ade:	0e 00 3a    	bra       NZ, 0x2afc <.L122>
    2ae0:	0e 00 37    	bra       0x2afe <.L123>

00002ae2 <.L121>:
    2ae2:	8c 00 78    	mov.w     w12, w1
    2ae4:	00 03 20    	mov.w     #0x30, w0
    2ae6:	f4 b7 9f    	mov.w     w4, [w15-18]
    2ae8:	85 bf 9f    	mov.w     w5, [w15-16]
    2aea:	d6 b7 9f    	mov.w     w6, [w15-22]
    2aec:	e7 b7 9f    	mov.w     w7, [w15-20]
    2aee:	30 03 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2af0:	7f b2 97    	mov.w     [w15-18], w4
    2af2:	8f ba 97    	mov.w     [w15-16], w5
    2af4:	5f b3 97    	mov.w     [w15-22], w6
    2af6:	ef b3 97    	mov.w     [w15-20], w7
    2af8:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2afa:	01 00 32    	bra       Z, 0x2afe <.L123>

00002afc <.L122>:
    2afc:	8d 06 e8    	inc.w     w13, w13

00002afe <.L123>:
    2afe:	89 04 e9    	dec.w     w9, w9
    2b00:	03 00 37    	bra       0x2b08 <.L118>

00002b02 <.L270>:
    2b02:	08 02 be    	mov.d     w8, w4
    2b04:	0a 03 be    	mov.d     w10, w6
    2b06:	9f b4 97    	mov.w     [w15-30], w9

00002b08 <.L118>:
    2b08:	09 00 e0    	cp0.w     w9
    2b0a:	d9 ff 3c    	bra       GT, 0x2abe <.L124>
    2b0c:	99 b7 9f    	mov.w     w9, [w15-30]
    2b0e:	06 05 be    	mov.d     w6, w10
    2b10:	04 04 be    	mov.d     w4, w8
    2b12:	67 00 37    	bra       0x2be2 <.L262>

00002b14 <.L111>:
    2b14:	0e 38 a3    	btst.z    w14, #0x3
    2b16:	1e 00 3a    	bra       NZ, 0x2b54 <.L126>
    2b18:	c8 a7 9f    	mov.w     w8, [w15-56]
    2b1a:	d9 a7 9f    	mov.w     w9, [w15-54]
    2b1c:	ea a7 9f    	mov.w     w10, [w15-52]
    2b1e:	fb a7 9f    	mov.w     w11, [w15-50]
    2b20:	9f b4 97    	mov.w     [w15-30], w9
    2b22:	11 00 37    	bra       0x2b46 <.L127>

00002b24 <.L131>:
    2b24:	3c 00 90    	mov.w     [w12+6], w0
    2b26:	00 68 a3    	btst.z    w0, #0x6
    2b28:	07 00 32    	bra       Z, 0x2b38 <.L128> <.LASF132>
    2b2a:	0d 01 78    	mov.w     w13, w2
    2b2c:	01 02 20    	mov.w     #0x20, w1
    2b2e:	0c 00 78    	mov.w     w12, w0
    2b30:	4f fd 07    	rcall     0x25d0 <_sputc> <L0>
    2b32:	00 00 e0    	cp0.w     w0
    2b34:	06 00 3a    	bra       NZ, 0x2b42 <.L129>
    2b36:	06 00 37    	bra       0x2b44 <.L130> <.LASF95>

00002b38 <.L128>:
    2b38:	8c 00 78    	mov.w     w12, w1
    2b3a:	00 02 20    	mov.w     #0x20, w0
    2b3c:	09 03 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2b3e:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2b40:	01 00 32    	bra       Z, 0x2b44 <.L130> <.LASF95>

00002b42 <.L129>:
    2b42:	8d 06 e8    	inc.w     w13, w13

00002b44 <.L130>:
    2b44:	89 04 e9    	dec.w     w9, w9

00002b46 <.L127>:
    2b46:	09 00 e0    	cp0.w     w9
    2b48:	ed ff 3c    	bra       GT, 0x2b24 <.L131>
    2b4a:	99 b7 9f    	mov.w     w9, [w15-30]
    2b4c:	4f a4 97    	mov.w     [w15-56], w8
    2b4e:	df a4 97    	mov.w     [w15-54], w9
    2b50:	6f a5 97    	mov.w     [w15-52], w10
    2b52:	ff a5 97    	mov.w     [w15-50], w11

00002b54 <.L126>:
    2b54:	61 01 67    	and.w     w14, #0x1, w2
    2b56:	0e 18 a3    	btst.z    w14, #0x1
    2b58:	0e 00 32    	bra       Z, 0x2b76 <.L132>
    2b5a:	3c 00 90    	mov.w     [w12+6], w0
    2b5c:	00 68 a3    	btst.z    w0, #0x6
    2b5e:	05 00 32    	bra       Z, 0x2b6a <.L133>
    2b60:	b1 02 20    	mov.w     #0x2b, w1
    2b62:	02 00 e0    	cp0.w     w2
    2b64:	25 00 32    	bra       Z, 0x2bb0 <.L284>
    2b66:	81 80 e8    	inc2.w    w1, w1
    2b68:	23 00 37    	bra       0x2bb0 <.L284>

00002b6a <.L133>:
    2b6a:	b0 02 20    	mov.w     #0x2b, w0
    2b6c:	02 00 e0    	cp0.w     w2
    2b6e:	01 00 32    	bra       Z, 0x2b72 <.L136>
    2b70:	00 80 e8    	inc2.w    w0, w0

00002b72 <.L136>:
    2b72:	8c 00 78    	mov.w     w12, w1
    2b74:	32 00 37    	bra       0x2bda <.L282>

00002b76 <.L132>:
    2b76:	02 00 e0    	cp0.w     w2
    2b78:	34 00 32    	bra       Z, 0x2be2 <.L262>
    2b7a:	3c 00 90    	mov.w     [w12+6], w0
    2b7c:	00 68 a3    	btst.z    w0, #0x6
    2b7e:	03 00 32    	bra       Z, 0x2b86 <.L137>
    2b80:	0d 01 78    	mov.w     w13, w2
    2b82:	01 02 20    	mov.w     #0x20, w1
    2b84:	16 00 37    	bra       0x2bb2 <.L285>

00002b86 <.L137>:
    2b86:	8c 00 78    	mov.w     w12, w1
    2b88:	00 02 20    	mov.w     #0x20, w0
    2b8a:	27 00 37    	bra       0x2bda <.L282>

00002b8c <.L143>:
    2b8c:	3c 01 90    	mov.w     [w12+6], w2
    2b8e:	81 00 fb    	se        w1, w1
    2b90:	c0 ff 23    	mov.w     #0x3ffc, w0
    2b92:	02 68 a3    	btst.z    w2, #0x6
    2b94:	13 00 32    	bra       Z, 0x2bbc <.L140>
    2b96:	c3 08 dd    	sl.w      w1, #0x3, w1
    2b98:	01 00 40    	add.w     w0, w1, w0
    2b9a:	30 02 be    	mov.d     [w0++], w4
    2b9c:	20 03 be    	mov.d     [w0--], w6
    2b9e:	08 00 be    	mov.d     w8, w0
    2ba0:	0a 01 be    	mov.d     w10, w2
    2ba2:	1a 06 07    	rcall     0x37d8 <___udivdi3>
    2ba4:	a4 00 20    	mov.w     #0xa, w4
    2ba6:	05 00 20    	mov.w     #0x0, w5
    2ba8:	60 33 b8    	mul.uu    w6, #0x0, w6
    2baa:	1d 06 07    	rcall     0x37e6 <___umoddi3> <L0>
    2bac:	01 03 20    	mov.w     #0x30, w1
    2bae:	80 80 40    	add.w     w1, w0, w1

00002bb0 <.L284>:
    2bb0:	0d 01 78    	mov.w     w13, w2

00002bb2 <.L285>:
    2bb2:	0c 00 78    	mov.w     w12, w0
    2bb4:	0d fd 07    	rcall     0x25d0 <_sputc> <L0>
    2bb6:	00 00 e0    	cp0.w     w0
    2bb8:	13 00 3a    	bra       NZ, 0x2be0 <.L141> <.LASF131>
    2bba:	13 00 37    	bra       0x2be2 <.L262>

00002bbc <.L140>:
    2bbc:	c3 08 dd    	sl.w      w1, #0x3, w1
    2bbe:	01 00 40    	add.w     w0, w1, w0
    2bc0:	30 02 be    	mov.d     [w0++], w4
    2bc2:	20 03 be    	mov.d     [w0--], w6
    2bc4:	08 00 be    	mov.d     w8, w0
    2bc6:	0a 01 be    	mov.d     w10, w2
    2bc8:	07 06 07    	rcall     0x37d8 <___udivdi3>
    2bca:	a4 00 20    	mov.w     #0xa, w4
    2bcc:	05 00 20    	mov.w     #0x0, w5
    2bce:	60 33 b8    	mul.uu    w6, #0x0, w6
    2bd0:	0a 06 07    	rcall     0x37e6 <___umoddi3> <L0>
    2bd2:	02 03 20    	mov.w     #0x30, w2
    2bd4:	00 01 41    	add.w     w2, w0, w2
    2bd6:	8c 00 78    	mov.w     w12, w1
    2bd8:	02 00 78    	mov.w     w2, w0

00002bda <.L282>:
    2bda:	ba 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2bdc:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2bde:	01 00 32    	bra       Z, 0x2be2 <.L262>

00002be0 <.L141>:
    2be0:	8d 06 e8    	inc.w     w13, w13

00002be2 <.L262>:
    2be2:	6f 70 97    	mov.b     [w15-74], w0
    2be4:	80 40 e9    	dec.b     w0, w1
    2be6:	e1 77 9f    	mov.b     w1, [w15-74]
    2be8:	00 04 e0    	cp0.b     w0
    2bea:	d0 ff 3a    	bra       NZ, 0x2b8c <.L143>
    2bec:	13 00 37    	bra       0x2c14 <.L144>

00002bee <.L148>:
    2bee:	3c 00 90    	mov.w     [w12+6], w0
    2bf0:	00 68 a3    	btst.z    w0, #0x6
    2bf2:	07 00 32    	bra       Z, 0x2c02 <.L145>
    2bf4:	0d 01 78    	mov.w     w13, w2
    2bf6:	01 03 20    	mov.w     #0x30, w1
    2bf8:	0c 00 78    	mov.w     w12, w0
    2bfa:	ea fc 07    	rcall     0x25d0 <_sputc> <L0>
    2bfc:	00 00 e0    	cp0.w     w0
    2bfe:	06 00 3a    	bra       NZ, 0x2c0c <.L146>
    2c00:	06 00 37    	bra       0x2c0e <.L147>

00002c02 <.L145>:
    2c02:	8c 00 78    	mov.w     w12, w1
    2c04:	00 03 20    	mov.w     #0x30, w0
    2c06:	a4 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2c08:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2c0a:	01 00 32    	bra       Z, 0x2c0e <.L147>

00002c0c <.L146>:
    2c0c:	8d 06 e8    	inc.w     w13, w13

00002c0e <.L147>:
    2c0e:	5f 98 97    	mov.w     [w15-70], w0
    2c10:	00 00 e9    	dec.w     w0, w0
    2c12:	d0 9f 9f    	mov.w     w0, [w15-70]

00002c14 <.L144>:
    2c14:	5f 98 97    	mov.w     [w15-70], w0
    2c16:	00 00 e0    	cp0.w     w0
    2c18:	ea ff 3c    	bra       GT, 0x2bee <.L148>
    2c1a:	df a8 97    	mov.w     [w15-38], w1
    2c1c:	f2 8f 50    	sub.w     w1, #0x12, [w15]
    2c1e:	03 00 34    	bra       LE, 0x2c26 <.L149>
    2c20:	20 c1 b3    	mov.b     #0x12, w0
    2c22:	e0 77 9f    	mov.b     w0, [w15-74]
    2c24:	02 00 37    	bra       0x2c2a <.L150>

00002c26 <.L149>:
    2c26:	2f d9 97    	mov.b     [w15-38], w2
    2c28:	e2 77 9f    	mov.b     w2, [w15-74]

00002c2a <.L150>:
    2c2a:	6f 70 97    	mov.b     [w15-74], w0
    2c2c:	80 00 fb    	se        w0, w1
    2c2e:	df a9 97    	mov.w     [w15-38], w3
    2c30:	81 80 51    	sub.w     w3, w1, w1
    2c32:	d1 af 9f    	mov.w     w1, [w15-38]
    2c34:	00 04 e0    	cp0.b     w0
    2c36:	10 00 32    	bra       Z, 0x2c58 <.L151>
    2c38:	3c 00 90    	mov.w     [w12+6], w0
    2c3a:	00 68 a3    	btst.z    w0, #0x6
    2c3c:	07 00 32    	bra       Z, 0x2c4c <.L152>
    2c3e:	0d 01 78    	mov.w     w13, w2
    2c40:	e1 02 20    	mov.w     #0x2e, w1
    2c42:	0c 00 78    	mov.w     w12, w0
    2c44:	c5 fc 07    	rcall     0x25d0 <_sputc> <L0>
    2c46:	00 00 e0    	cp0.w     w0
    2c48:	06 00 3a    	bra       NZ, 0x2c56 <.L153>
    2c4a:	06 00 37    	bra       0x2c58 <.L151>

00002c4c <.L152>:
    2c4c:	8c 00 78    	mov.w     w12, w1
    2c4e:	e0 02 20    	mov.w     #0x2e, w0
    2c50:	7f 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2c52:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2c54:	01 00 32    	bra       Z, 0x2c58 <.L151>

00002c56 <.L153>:
    2c56:	8d 06 e8    	inc.w     w13, w13

00002c58 <.L151>:
    2c58:	6f 70 97    	mov.b     [w15-74], w0
    2c5a:	58 fc 07    	rcall     0x250c <_scale> <L0> <.L0>
    2c5c:	00 02 be    	mov.d     w0, w4
    2c5e:	02 03 be    	mov.d     w2, w6
    2c60:	1f a8 97    	mov.w     [w15-46], w0
    2c62:	af a8 97    	mov.w     [w15-44], w1
    2c64:	3f a9 97    	mov.w     [w15-42], w2
    2c66:	cf a9 97    	mov.w     [w15-40], w3
    2c68:	a1 04 07    	rcall     0x35ac <___muldf3>
    2c6a:	27 04 07    	rcall     0x34ba <___fixunsdfdi>
    2c6c:	33 00 37    	bra       0x2cd4 <.L277>

00002c6e <.L158>:
    2c6e:	3c 01 90    	mov.w     [w12+6], w2
    2c70:	c1 ff 23    	mov.w     #0x3ffc, w1
    2c72:	00 00 fb    	se        w0, w0
    2c74:	02 68 a3    	btst.z    w2, #0x6
    2c76:	13 00 32    	bra       Z, 0x2c9e <.L155>
    2c78:	43 00 dd    	sl.w      w0, #0x3, w0
    2c7a:	00 80 40    	add.w     w1, w0, w0
    2c7c:	30 02 be    	mov.d     [w0++], w4
    2c7e:	20 03 be    	mov.d     [w0--], w6
    2c80:	08 00 be    	mov.d     w8, w0
    2c82:	0a 01 be    	mov.d     w10, w2
    2c84:	a9 05 07    	rcall     0x37d8 <___udivdi3>
    2c86:	a4 00 20    	mov.w     #0xa, w4
    2c88:	05 00 20    	mov.w     #0x0, w5
    2c8a:	60 33 b8    	mul.uu    w6, #0x0, w6
    2c8c:	ac 05 07    	rcall     0x37e6 <___umoddi3> <L0>
    2c8e:	00 03 b0    	add.w     #0x30, w0
    2c90:	0d 01 78    	mov.w     w13, w2
    2c92:	80 00 78    	mov.w     w0, w1
    2c94:	0c 00 78    	mov.w     w12, w0
    2c96:	9c fc 07    	rcall     0x25d0 <_sputc> <L0>
    2c98:	00 00 e0    	cp0.w     w0
    2c9a:	11 00 3a    	bra       NZ, 0x2cbe <.L156>
    2c9c:	11 00 37    	bra       0x2cc0 <.L157>

00002c9e <.L155>:
    2c9e:	43 00 dd    	sl.w      w0, #0x3, w0
    2ca0:	00 80 40    	add.w     w1, w0, w0
    2ca2:	30 02 be    	mov.d     [w0++], w4
    2ca4:	20 03 be    	mov.d     [w0--], w6
    2ca6:	08 00 be    	mov.d     w8, w0
    2ca8:	0a 01 be    	mov.d     w10, w2
    2caa:	96 05 07    	rcall     0x37d8 <___udivdi3>
    2cac:	a4 00 20    	mov.w     #0xa, w4
    2cae:	05 00 20    	mov.w     #0x0, w5
    2cb0:	60 33 b8    	mul.uu    w6, #0x0, w6
    2cb2:	99 05 07    	rcall     0x37e6 <___umoddi3> <L0>
    2cb4:	00 03 b0    	add.w     #0x30, w0
    2cb6:	8c 00 78    	mov.w     w12, w1
    2cb8:	4b 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2cba:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2cbc:	01 00 32    	bra       Z, 0x2cc0 <.L157>

00002cbe <.L156>:
    2cbe:	8d 06 e8    	inc.w     w13, w13

00002cc0 <.L157>:
    2cc0:	6f 72 97    	mov.b     [w15-74], w4
    2cc2:	04 00 fb    	se        w4, w0
    2cc4:	43 00 dd    	sl.w      w0, #0x3, w0
    2cc6:	c1 ff 23    	mov.w     #0x3ffc, w1
    2cc8:	00 80 40    	add.w     w1, w0, w0
    2cca:	30 02 be    	mov.d     [w0++], w4
    2ccc:	20 03 be    	mov.d     [w0--], w6
    2cce:	08 00 be    	mov.d     w8, w0
    2cd0:	0a 01 be    	mov.d     w10, w2
    2cd2:	89 05 07    	rcall     0x37e6 <___umoddi3> <L0>

00002cd4 <.L277>:
    2cd4:	02 05 be    	mov.d     w2, w10
    2cd6:	00 04 be    	mov.d     w0, w8
    2cd8:	ef 70 97    	mov.b     [w15-74], w1
    2cda:	01 40 e9    	dec.b     w1, w0
    2cdc:	e0 77 9f    	mov.b     w0, [w15-74]
    2cde:	01 04 e0    	cp0.b     w1
    2ce0:	c6 ff 3a    	bra       NZ, 0x2c6e <.L158>
    2ce2:	98 af 9f    	mov.w     w8, [w15-46]
    2ce4:	a9 af 9f    	mov.w     w9, [w15-44]
    2ce6:	ba af 9f    	mov.w     w10, [w15-42]
    2ce8:	cb af 9f    	mov.w     w11, [w15-40]
    2cea:	df ac 97    	mov.w     [w15-38], w9
    2cec:	11 00 37    	bra       0x2d10 <.L159>

00002cee <.L163>:
    2cee:	3c 00 90    	mov.w     [w12+6], w0
    2cf0:	00 68 a3    	btst.z    w0, #0x6
    2cf2:	07 00 32    	bra       Z, 0x2d02 <.L160>
    2cf4:	0d 01 78    	mov.w     w13, w2
    2cf6:	01 03 20    	mov.w     #0x30, w1
    2cf8:	0c 00 78    	mov.w     w12, w0
    2cfa:	6a fc 07    	rcall     0x25d0 <_sputc> <L0>
    2cfc:	00 00 e0    	cp0.w     w0
    2cfe:	06 00 3a    	bra       NZ, 0x2d0c <.L161>
    2d00:	06 00 37    	bra       0x2d0e <.L162>

00002d02 <.L160>:
    2d02:	8c 00 78    	mov.w     w12, w1
    2d04:	00 03 20    	mov.w     #0x30, w0
    2d06:	24 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2d08:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2d0a:	01 00 32    	bra       Z, 0x2d0e <.L162>

00002d0c <.L161>:
    2d0c:	8d 06 e8    	inc.w     w13, w13

00002d0e <.L162>:
    2d0e:	89 04 e9    	dec.w     w9, w9

00002d10 <.L159>:
    2d10:	09 00 e0    	cp0.w     w9
    2d12:	ed ff 3a    	bra       NZ, 0x2cee <.L163>
    2d14:	1f ac 97    	mov.w     [w15-46], w8
    2d16:	af ac 97    	mov.w     [w15-44], w9
    2d18:	3f ad 97    	mov.w     [w15-42], w10
    2d1a:	cf ad 97    	mov.w     [w15-40], w11
    2d1c:	0e 38 a3    	btst.z    w14, #0x3
    2d1e:	0c 02 32    	bra       Z, 0x3138 <.L263>
    2d20:	9f b0 97    	mov.w     [w15-30], w1
    2d22:	01 00 e0    	cp0.w     w1
    2d24:	09 02 34    	bra       LE, 0x3138 <.L263>
    2d26:	d8 af 9f    	mov.w     w8, [w15-38]
    2d28:	e9 af 9f    	mov.w     w9, [w15-36]
    2d2a:	fa af 9f    	mov.w     w10, [w15-34]
    2d2c:	8b b7 9f    	mov.w     w11, [w15-32]
    2d2e:	81 04 78    	mov.w     w1, w9

00002d30 <.L167>:
    2d30:	3c 00 90    	mov.w     [w12+6], w0
    2d32:	00 68 a3    	btst.z    w0, #0x6
    2d34:	07 00 32    	bra       Z, 0x2d44 <.L164>
    2d36:	0d 01 78    	mov.w     w13, w2
    2d38:	01 02 20    	mov.w     #0x20, w1
    2d3a:	0c 00 78    	mov.w     w12, w0
    2d3c:	49 fc 07    	rcall     0x25d0 <_sputc> <L0>
    2d3e:	00 00 e0    	cp0.w     w0
    2d40:	06 00 3a    	bra       NZ, 0x2d4e <.L165>
    2d42:	06 00 37    	bra       0x2d50 <.L166>

00002d44 <.L164>:
    2d44:	8c 00 78    	mov.w     w12, w1
    2d46:	00 02 20    	mov.w     #0x20, w0
    2d48:	03 02 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2d4a:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2d4c:	01 00 32    	bra       Z, 0x2d50 <.L166>

00002d4e <.L165>:
    2d4e:	8d 06 e8    	inc.w     w13, w13

00002d50 <.L166>:
    2d50:	89 04 e9    	dec.w     w9, w9
    2d52:	ee ff 3a    	bra       NZ, 0x2d30 <.L167> <.LASF18>
    2d54:	f1 01 37    	bra       0x3138 <.L263>

00002d56 <.L85>:
    2d56:	0e 00 78    	mov.w     w14, w0
    2d58:	00 0c b2    	and.w     #0xc0, w0
    2d5a:	21 00 3a    	bra       NZ, 0x2d9e <.L168>
    2d5c:	0e 00 e0    	cp0.w     w14
    2d5e:	05 00 3d    	bra       GE, 0x2d6a <.L169>
    2d60:	8f aa 97    	mov.w     [w15-48], w5
    2d62:	45 05 be    	mov.d     [--w5], w10
    2d64:	45 04 be    	mov.d     [--w5], w8
    2d66:	85 af 9f    	mov.w     w5, [w15-48]
    2d68:	0d 00 37    	bra       0x2d84 <.L170>

00002d6a <.L169>:
    2d6a:	0e 48 a3    	btst.z    w14, #0x4
    2d6c:	06 00 32    	bra       Z, 0x2d7a <.L171>
    2d6e:	0f ab 97    	mov.w     [w15-48], w6
    2d70:	46 04 be    	mov.d     [--w6], w8
    2d72:	86 af 9f    	mov.w     w6, [w15-48]
    2d74:	4f cd de    	asr.w     w9, #0xf, w10
    2d76:	8a 05 78    	mov.w     w10, w11
    2d78:	05 00 37    	bra       0x2d84 <.L170>

00002d7a <.L171>:
    2d7a:	8f ab 97    	mov.w     [w15-48], w7
    2d7c:	47 04 78    	mov.w     [--w7], w8
    2d7e:	87 af 9f    	mov.w     w7, [w15-48]
    2d80:	cf c4 de    	asr.w     w8, #0xf, w9
    2d82:	61 4d b9    	mul.su    w9, #0x1, w10

00002d84 <.L170>:
    2d84:	e0 0f 54    	sub.w     w8, #0x0, [w15]
    2d86:	e0 8f 5c    	subb.w    w9, #0x0, [w15]
    2d88:	e0 0f 5d    	subb.w    w10, #0x0, [w15]
    2d8a:	e0 8f 5d    	subb.w    w11, #0x0, [w15]
    2d8c:	1b 00 3d    	bra       GE, 0x2dc4 <.L172>
    2d8e:	3e 00 b3    	ior.w     #0x3, w14
    2d90:	60 00 b8    	mul.uu    w0, #0x0, w0
    2d92:	60 11 b8    	mul.uu    w2, #0x0, w2
    2d94:	08 04 50    	sub.w     w0, w8, w8
    2d96:	89 84 58    	subb.w    w1, w9, w9
    2d98:	0a 05 59    	subb.w    w2, w10, w10
    2d9a:	8b 85 59    	subb.w    w3, w11, w11
    2d9c:	13 00 37    	bra       0x2dc4 <.L172>

00002d9e <.L168>:
    2d9e:	0e 00 e0    	cp0.w     w14
    2da0:	05 00 3d    	bra       GE, 0x2dac <.L173>
    2da2:	0f a8 97    	mov.w     [w15-48], w0
    2da4:	40 05 be    	mov.d     [--w0], w10
    2da6:	40 04 be    	mov.d     [--w0], w8
    2da8:	80 af 9f    	mov.w     w0, [w15-48]
    2daa:	0c 00 37    	bra       0x2dc4 <.L172>

00002dac <.L173>:
    2dac:	0e 48 a3    	btst.z    w14, #0x4
    2dae:	05 00 32    	bra       Z, 0x2dba <.L174>
    2db0:	8f a8 97    	mov.w     [w15-48], w1
    2db2:	41 04 be    	mov.d     [--w1], w8
    2db4:	60 55 b8    	mul.uu    w10, #0x0, w10
    2db6:	81 af 9f    	mov.w     w1, [w15-48]
    2db8:	05 00 37    	bra       0x2dc4 <.L172>

00002dba <.L174>:
    2dba:	0f a9 97    	mov.w     [w15-48], w2
    2dbc:	42 04 78    	mov.w     [--w2], w8
    2dbe:	82 af 9f    	mov.w     w2, [w15-48]
    2dc0:	80 04 eb    	clr.w     w9
    2dc2:	60 55 b8    	mul.uu    w10, #0x0, w10

00002dc4 <.L172>:
    2dc4:	df a9 97    	mov.w     [w15-38], w3
    2dc6:	03 00 e0    	cp0.w     w3
    2dc8:	09 00 3a    	bra       NZ, 0x2ddc <.L175> <.LASF112>
    2dca:	14 00 20    	mov.w     #0x1, w4
    2dcc:	d4 af 9f    	mov.w     w4, [w15-38]
    2dce:	e0 0f 54    	sub.w     w8, #0x0, [w15]
    2dd0:	e0 8f 5c    	subb.w    w9, #0x0, [w15]
    2dd2:	e0 0f 5d    	subb.w    w10, #0x0, [w15]
    2dd4:	e0 8f 5d    	subb.w    w11, #0x0, [w15]
    2dd6:	02 00 32    	bra       Z, 0x2ddc <.L175> <.LASF112>
    2dd8:	80 02 eb    	clr.w     w5
    2dda:	d5 af 9f    	mov.w     w5, [w15-38]

00002ddc <.L175>:
    2ddc:	0e 03 78    	mov.w     w14, w6
    2dde:	06 0c b2    	and.w     #0xc0, w6
    2de0:	96 af 9f    	mov.w     w6, [w15-46]
    2de2:	00 04 20    	mov.w     #0x40, w0
    2de4:	80 0f 53    	sub.w     w6, w0, [w15]
    2de6:	2c 00 32    	bra       Z, 0x2e40 <.L179>
    2de8:	03 00 3c    	bra       GT, 0x2df0 <.L181>
    2dea:	06 00 e0    	cp0.w     w6
    2dec:	08 00 32    	bra       Z, 0x2dfe <.L178>
    2dee:	3c 00 37    	bra       0x2e68 <.L177>

00002df0 <.L181>:
    2df0:	00 08 20    	mov.w     #0x80, w0
    2df2:	9f ab 97    	mov.w     [w15-46], w7
    2df4:	80 8f 53    	sub.w     w7, w0, [w15]
    2df6:	10 00 32    	bra       Z, 0x2e18 <.L180> <.LASF48>
    2df8:	00 0c 20    	mov.w     #0xc0, w0
    2dfa:	80 8f 53    	sub.w     w7, w0, [w15]
    2dfc:	35 00 3a    	bra       NZ, 0x2e68 <.L177>

00002dfe <.L178>:
    2dfe:	45 00 24    	mov.w     #0x4004, w5
    2e00:	14 c0 b3    	mov.b     #0x1, w4

00002e02 <.L183>:
    2e02:	35 00 be    	mov.d     [w5++], w0
    2e04:	35 01 be    	mov.d     [w5++], w2
    2e06:	00 40 e1    	cp.w      w8, w0
    2e08:	01 c8 e1    	cpb.w     w9, w1
    2e0a:	02 d0 e1    	cpb.w     w10, w2
    2e0c:	03 d8 e1    	cpb.w     w11, w3
    2e0e:	2b 00 39    	bra       NC, 0x2e66 <.L278>
    2e10:	04 42 e8    	inc.b     w4, w4
    2e12:	f4 4f 52    	sub.b     w4, #0x14, [w15]
    2e14:	f6 ff 3a    	bra       NZ, 0x2e02 <.L183>
    2e16:	27 00 37    	bra       0x2e66 <.L278>

00002e18 <.L180>:
    2e18:	14 c0 b3    	mov.b     #0x1, w4
    2e1a:	00 01 20    	mov.w     #0x10, w0
    2e1c:	01 00 20    	mov.w     #0x0, w1
    2e1e:	60 11 b8    	mul.uu    w2, #0x0, w2

00002e20 <.L185>:
    2e20:	00 40 e1    	cp.w      w8, w0
    2e22:	01 c8 e1    	cpb.w     w9, w1
    2e24:	02 d0 e1    	cpb.w     w10, w2
    2e26:	03 d8 e1    	cpb.w     w11, w3
    2e28:	1e 00 39    	bra       NC, 0x2e66 <.L278>
    2e2a:	45 00 20    	mov.w     #0x4, w5

00002e2c <.LB1696>:
    2e2c:	00 00 d0    	sl.w      w0, w0
    2e2e:	81 80 d2    	rlc.w     w1, w1
    2e30:	02 81 d2    	rlc.w     w2, w2
    2e32:	83 81 d2    	rlc.w     w3, w3
    2e34:	85 02 e9    	dec.w     w5, w5
    2e36:	fa ff 3a    	bra       NZ, 0x2e2c <.LB1696>
    2e38:	04 42 e8    	inc.b     w4, w4
    2e3a:	f0 4f 52    	sub.b     w4, #0x10, [w15]
    2e3c:	f1 ff 3a    	bra       NZ, 0x2e20 <.L185>
    2e3e:	13 00 37    	bra       0x2e66 <.L278>

00002e40 <.L179>:
    2e40:	14 c0 b3    	mov.b     #0x1, w4
    2e42:	80 00 20    	mov.w     #0x8, w0
    2e44:	01 00 20    	mov.w     #0x0, w1
    2e46:	60 11 b8    	mul.uu    w2, #0x0, w2

00002e48 <.L187>:
    2e48:	00 40 e1    	cp.w      w8, w0
    2e4a:	01 c8 e1    	cpb.w     w9, w1
    2e4c:	02 d0 e1    	cpb.w     w10, w2
    2e4e:	03 d8 e1    	cpb.w     w11, w3
    2e50:	0a 00 39    	bra       NC, 0x2e66 <.L278>
    2e52:	36 00 20    	mov.w     #0x3, w6

00002e54 <.LB1714>:
    2e54:	00 00 d0    	sl.w      w0, w0
    2e56:	81 80 d2    	rlc.w     w1, w1
    2e58:	02 81 d2    	rlc.w     w2, w2
    2e5a:	83 81 d2    	rlc.w     w3, w3
    2e5c:	06 03 e9    	dec.w     w6, w6
    2e5e:	fa ff 3a    	bra       NZ, 0x2e54 <.LB1714>
    2e60:	04 42 e8    	inc.b     w4, w4
    2e62:	f5 4f 52    	sub.b     w4, #0x15, [w15]
    2e64:	f1 ff 3a    	bra       NZ, 0x2e48 <.L187>

00002e66 <.L278>:
    2e66:	e4 77 9f    	mov.b     w4, [w15-74]

00002e68 <.L177>:
    2e68:	ef 73 97    	mov.b     [w15-74], w7
    2e6a:	07 00 fb    	se        w7, w0
    2e6c:	df a8 97    	mov.w     [w15-38], w1
    2e6e:	81 0f 50    	sub.w     w0, w1, [w15]
    2e70:	02 00 3d    	bra       GE, 0x2e76 <.L188>
    2e72:	e1 77 9f    	mov.b     w1, [w15-74]
    2e74:	04 00 37    	bra       0x2e7e <.L189>

00002e76 <.L188>:
    2e76:	5f a9 97    	mov.w     [w15-38], w2
    2e78:	80 0f 51    	sub.w     w2, w0, [w15]
    2e7a:	01 00 3d    	bra       GE, 0x2e7e <.L189>
    2e7c:	d0 af 9f    	mov.w     w0, [w15-38]

00002e7e <.L189>:
    2e7e:	9f b1 97    	mov.w     [w15-30], w3
    2e80:	03 00 e0    	cp0.w     w3
    2e82:	04 00 32    	bra       Z, 0x2e8c <.L190>
    2e84:	63 00 67    	and.w     w14, #0x3, w0
    2e86:	02 00 32    	bra       Z, 0x2e8c <.L190>
    2e88:	83 01 e9    	dec.w     w3, w3
    2e8a:	93 b7 9f    	mov.w     w3, [w15-30]

00002e8c <.L190>:
    2e8c:	0e e8 a3    	btst.z    w14, #0xe
    2e8e:	09 00 32    	bra       Z, 0x2ea2 <.L191>
    2e90:	1f b2 97    	mov.w     [w15-30], w4
    2e92:	df aa 97    	mov.w     [w15-38], w5
    2e94:	85 0f 52    	sub.w     w4, w5, [w15]
    2e96:	03 00 34    	bra       LE, 0x2e9e <.L245>
    2e98:	05 02 52    	sub.w     w4, w5, w4
    2e9a:	94 b7 9f    	mov.w     w4, [w15-30]
    2e9c:	02 00 37    	bra       0x2ea2 <.L191>

00002e9e <.L245>:
    2e9e:	00 03 eb    	clr.w     w6
    2ea0:	96 b7 9f    	mov.w     w6, [w15-30]

00002ea2 <.L191>:
    2ea2:	ef 73 97    	mov.b     [w15-74], w7
    2ea4:	07 00 fb    	se        w7, w0
    2ea6:	80 00 eb    	clr.w     w1
    2ea8:	c1 a7 9f    	mov.w     w1, [w15-56]
    2eaa:	1f b1 97    	mov.w     [w15-30], w2
    2eac:	80 0f 51    	sub.w     w2, w0, [w15]
    2eae:	02 00 34    	bra       LE, 0x2eb4 <.L192>
    2eb0:	00 00 51    	sub.w     w2, w0, w0
    2eb2:	c0 a7 9f    	mov.w     w0, [w15-56]

00002eb4 <.L192>:
    2eb4:	0e 28 a3    	btst.z    w14, #0x2
    2eb6:	44 00 32    	bra       Z, 0x2f40 <.L193>
    2eb8:	61 01 67    	and.w     w14, #0x1, w2
    2eba:	0e 18 a3    	btst.z    w14, #0x1
    2ebc:	0f 00 32    	bra       Z, 0x2edc <.L194>
    2ebe:	3c 00 90    	mov.w     [w12+6], w0
    2ec0:	00 68 a3    	btst.z    w0, #0x6
    2ec2:	06 00 32    	bra       Z, 0x2ed0 <.L195>
    2ec4:	b1 02 20    	mov.w     #0x2b, w1
    2ec6:	02 00 e0    	cp0.w     w2
    2ec8:	01 00 32    	bra       Z, 0x2ecc <.L196>
    2eca:	81 80 e8    	inc2.w    w1, w1

00002ecc <.L196>:
    2ecc:	0d 01 78    	mov.w     w13, w2
    2ece:	0d 00 37    	bra       0x2eea <.L288> <.LASF23>

00002ed0 <.L195>:
    2ed0:	b0 02 20    	mov.w     #0x2b, w0
    2ed2:	02 00 e0    	cp0.w     w2
    2ed4:	01 00 32    	bra       Z, 0x2ed8 <.L199>
    2ed6:	00 80 e8    	inc2.w    w0, w0

00002ed8 <.L199>:
    2ed8:	8c 00 78    	mov.w     w12, w1
    2eda:	0e 00 37    	bra       0x2ef8 <.L287>

00002edc <.L194>:
    2edc:	02 00 e0    	cp0.w     w2
    2ede:	10 00 32    	bra       Z, 0x2f00 <.L198>
    2ee0:	3c 00 90    	mov.w     [w12+6], w0
    2ee2:	00 68 a3    	btst.z    w0, #0x6
    2ee4:	07 00 32    	bra       Z, 0x2ef4 <.L200>
    2ee6:	0d 01 78    	mov.w     w13, w2
    2ee8:	01 02 20    	mov.w     #0x20, w1

00002eea <.L288>:
    2eea:	0c 00 78    	mov.w     w12, w0
    2eec:	71 fb 07    	rcall     0x25d0 <_sputc> <L0>
    2eee:	00 00 e0    	cp0.w     w0
    2ef0:	06 00 3a    	bra       NZ, 0x2efe <.L201>
    2ef2:	06 00 37    	bra       0x2f00 <.L198>

00002ef4 <.L200>:
    2ef4:	8c 00 78    	mov.w     w12, w1
    2ef6:	00 02 20    	mov.w     #0x20, w0

00002ef8 <.L287>:
    2ef8:	2b 01 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2efa:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2efc:	01 00 32    	bra       Z, 0x2f00 <.L198>

00002efe <.L201>:
    2efe:	8d 06 e8    	inc.w     w13, w13

00002f00 <.L198>:
    2f00:	cf a1 97    	mov.w     [w15-56], w3
    2f02:	03 00 e0    	cp0.w     w3
    2f04:	62 00 32    	bra       Z, 0x2fca <.L202>
    2f06:	98 b7 9f    	mov.w     w8, [w15-30]
    2f08:	a9 b7 9f    	mov.w     w9, [w15-28]
    2f0a:	ba b7 9f    	mov.w     w10, [w15-26]
    2f0c:	cb b7 9f    	mov.w     w11, [w15-24]
    2f0e:	83 04 78    	mov.w     w3, w9

00002f10 <.L206>:
    2f10:	3c 00 90    	mov.w     [w12+6], w0
    2f12:	00 68 a3    	btst.z    w0, #0x6
    2f14:	07 00 32    	bra       Z, 0x2f24 <.L203>
    2f16:	0d 01 78    	mov.w     w13, w2
    2f18:	01 03 20    	mov.w     #0x30, w1
    2f1a:	0c 00 78    	mov.w     w12, w0
    2f1c:	59 fb 07    	rcall     0x25d0 <_sputc> <L0>
    2f1e:	00 00 e0    	cp0.w     w0
    2f20:	06 00 3a    	bra       NZ, 0x2f2e <.L204> <.LASF0>
    2f22:	06 00 37    	bra       0x2f30 <.L205>

00002f24 <.L203>:
    2f24:	8c 00 78    	mov.w     w12, w1
    2f26:	00 03 20    	mov.w     #0x30, w0
    2f28:	13 01 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2f2a:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2f2c:	01 00 32    	bra       Z, 0x2f30 <.L205>

00002f2e <.L204>:
    2f2e:	8d 06 e8    	inc.w     w13, w13

00002f30 <.L205>:
    2f30:	89 04 e9    	dec.w     w9, w9
    2f32:	ee ff 3a    	bra       NZ, 0x2f10 <.L206>
    2f34:	c9 a7 9f    	mov.w     w9, [w15-56]
    2f36:	1f b4 97    	mov.w     [w15-30], w8
    2f38:	af b4 97    	mov.w     [w15-28], w9
    2f3a:	3f b5 97    	mov.w     [w15-26], w10
    2f3c:	cf b5 97    	mov.w     [w15-24], w11
    2f3e:	45 00 37    	bra       0x2fca <.L202>

00002f40 <.L193>:
    2f40:	cf a2 97    	mov.w     [w15-56], w5
    2f42:	05 00 e0    	cp0.w     w5
    2f44:	1e 00 32    	bra       Z, 0x2f82 <.L207>
    2f46:	0e 38 a3    	btst.z    w14, #0x3
    2f48:	1c 00 3a    	bra       NZ, 0x2f82 <.L207>
    2f4a:	98 b7 9f    	mov.w     w8, [w15-30]
    2f4c:	a9 b7 9f    	mov.w     w9, [w15-28]
    2f4e:	ba b7 9f    	mov.w     w10, [w15-26]
    2f50:	cb b7 9f    	mov.w     w11, [w15-24]
    2f52:	85 04 78    	mov.w     w5, w9

00002f54 <.L211>:
    2f54:	3c 00 90    	mov.w     [w12+6], w0
    2f56:	00 68 a3    	btst.z    w0, #0x6
    2f58:	07 00 32    	bra       Z, 0x2f68 <.L208>
    2f5a:	0d 01 78    	mov.w     w13, w2
    2f5c:	01 02 20    	mov.w     #0x20, w1
    2f5e:	0c 00 78    	mov.w     w12, w0
    2f60:	37 fb 07    	rcall     0x25d0 <_sputc> <L0>
    2f62:	00 00 e0    	cp0.w     w0
    2f64:	06 00 3a    	bra       NZ, 0x2f72 <.L209>
    2f66:	06 00 37    	bra       0x2f74 <.L210>

00002f68 <.L208>:
    2f68:	8c 00 78    	mov.w     w12, w1
    2f6a:	00 02 20    	mov.w     #0x20, w0
    2f6c:	f1 00 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2f6e:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2f70:	01 00 32    	bra       Z, 0x2f74 <.L210>

00002f72 <.L209>:
    2f72:	8d 06 e8    	inc.w     w13, w13

00002f74 <.L210>:
    2f74:	89 04 e9    	dec.w     w9, w9
    2f76:	ee ff 3a    	bra       NZ, 0x2f54 <.L211>
    2f78:	c9 a7 9f    	mov.w     w9, [w15-56]
    2f7a:	1f b4 97    	mov.w     [w15-30], w8
    2f7c:	af b4 97    	mov.w     [w15-28], w9
    2f7e:	3f b5 97    	mov.w     [w15-26], w10
    2f80:	cf b5 97    	mov.w     [w15-24], w11

00002f82 <.L207>:
    2f82:	61 01 67    	and.w     w14, #0x1, w2
    2f84:	0e 18 a3    	btst.z    w14, #0x1
    2f86:	0f 00 32    	bra       Z, 0x2fa6 <.L212>
    2f88:	3c 00 90    	mov.w     [w12+6], w0
    2f8a:	00 68 a3    	btst.z    w0, #0x6
    2f8c:	06 00 32    	bra       Z, 0x2f9a <.L213>
    2f8e:	b1 02 20    	mov.w     #0x2b, w1
    2f90:	02 00 e0    	cp0.w     w2
    2f92:	01 00 32    	bra       Z, 0x2f96 <.L214>
    2f94:	81 80 e8    	inc2.w    w1, w1

00002f96 <.L214>:
    2f96:	0d 01 78    	mov.w     w13, w2
    2f98:	0d 00 37    	bra       0x2fb4 <.L291>

00002f9a <.L213>:
    2f9a:	b0 02 20    	mov.w     #0x2b, w0
    2f9c:	02 00 e0    	cp0.w     w2
    2f9e:	01 00 32    	bra       Z, 0x2fa2 <.L216>
    2fa0:	00 80 e8    	inc2.w    w0, w0

00002fa2 <.L216>:
    2fa2:	8c 00 78    	mov.w     w12, w1
    2fa4:	0e 00 37    	bra       0x2fc2 <.L290>

00002fa6 <.L212>:
    2fa6:	02 00 e0    	cp0.w     w2
    2fa8:	10 00 32    	bra       Z, 0x2fca <.L202>
    2faa:	3c 00 90    	mov.w     [w12+6], w0
    2fac:	00 68 a3    	btst.z    w0, #0x6
    2fae:	07 00 32    	bra       Z, 0x2fbe <.L217>
    2fb0:	0d 01 78    	mov.w     w13, w2
    2fb2:	01 02 20    	mov.w     #0x20, w1

00002fb4 <.L291>:
    2fb4:	0c 00 78    	mov.w     w12, w0
    2fb6:	0c fb 07    	rcall     0x25d0 <_sputc> <L0>
    2fb8:	00 00 e0    	cp0.w     w0
    2fba:	06 00 3a    	bra       NZ, 0x2fc8 <.L218>
    2fbc:	06 00 37    	bra       0x2fca <.L202>

00002fbe <.L217>:
    2fbe:	8c 00 78    	mov.w     w12, w1
    2fc0:	00 02 20    	mov.w     #0x20, w0

00002fc2 <.L290>:
    2fc2:	c6 00 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    2fc4:	e1 0f 40    	add.w     w0, #0x1, [w15]
    2fc6:	01 00 32    	bra       Z, 0x2fca <.L202>

00002fc8 <.L218>:
    2fc8:	8d 06 e8    	inc.w     w13, w13

00002fca <.L202>:
    2fca:	5f a9 97    	mov.w     [w15-38], w2
    2fcc:	82 00 e9    	dec.w     w2, w1
    2fce:	c3 08 dd    	sl.w      w1, #0x3, w1
    2fd0:	c0 ff 23    	mov.w     #0x3ffc, w0
    2fd2:	00 80 40    	add.w     w1, w0, w0
    2fd4:	f0 9f 9f    	mov.w     w0, [w15-66]
    2fd6:	98 b7 9f    	mov.w     w8, [w15-30]
    2fd8:	a9 b7 9f    	mov.w     w9, [w15-28]
    2fda:	ba b7 9f    	mov.w     w10, [w15-26]
    2fdc:	cb b7 9f    	mov.w     w11, [w15-24]
    2fde:	91 00 37    	bra       0x3102 <.L219>

00002fe0 <.L232>:
    2fe0:	df aa 97    	mov.w     [w15-38], w5
    2fe2:	85 02 e9    	dec.w     w5, w5
    2fe4:	d5 af 9f    	mov.w     w5, [w15-38]
    2fe6:	00 04 20    	mov.w     #0x40, w0
    2fe8:	1f ab 97    	mov.w     [w15-46], w6
    2fea:	80 0f 53    	sub.w     w6, w0, [w15]
    2fec:	65 00 32    	bra       Z, 0x30b8 <.L222>
    2fee:	03 00 3c    	bra       GT, 0x2ff6 <.L224>
    2ff0:	06 00 e0    	cp0.w     w6
    2ff2:	08 00 32    	bra       Z, 0x3004 <.L221>
    2ff4:	72 00 37    	bra       0x30da <.L220>

00002ff6 <.L224>:
    2ff6:	00 08 20    	mov.w     #0x80, w0
    2ff8:	9f ab 97    	mov.w     [w15-46], w7
    2ffa:	80 8f 53    	sub.w     w7, w0, [w15]
    2ffc:	48 00 32    	bra       Z, 0x308e <.L223> <.LASF16>
    2ffe:	00 0c 20    	mov.w     #0xc0, w0
    3000:	80 8f 53    	sub.w     w7, w0, [w15]
    3002:	6b 00 3a    	bra       NZ, 0x30da <.L220>

00003004 <.L221>:
    3004:	0e 00 e0    	cp0.w     w14
    3006:	1a 00 3d    	bra       GE, 0x303c <.L225>
    3008:	7f 98 97    	mov.w     [w15-66], w0
    300a:	30 04 be    	mov.d     [w0++], w8
    300c:	20 05 be    	mov.d     [w0--], w10
    300e:	08 02 be    	mov.d     w8, w4
    3010:	0a 03 be    	mov.d     w10, w6
    3012:	1f b0 97    	mov.w     [w15-30], w0
    3014:	af b0 97    	mov.w     [w15-28], w1
    3016:	3f b1 97    	mov.w     [w15-26], w2
    3018:	cf b1 97    	mov.w     [w15-24], w3
    301a:	de 03 07    	rcall     0x37d8 <___udivdi3>
    301c:	e0 77 9f    	mov.b     w0, [w15-74]
    301e:	00 00 fb    	se        w0, w0
    3020:	cf 80 de    	asr.w     w0, #0xf, w1
    3022:	61 09 b9    	mul.su    w1, #0x1, w2
    3024:	08 02 be    	mov.d     w8, w4
    3026:	0a 03 be    	mov.d     w10, w6
    3028:	40 04 07    	rcall     0x38aa <___muldi3> <L0>
    302a:	1f b2 97    	mov.w     [w15-30], w4
    302c:	af b2 97    	mov.w     [w15-28], w5
    302e:	3f b3 97    	mov.w     [w15-26], w6
    3030:	cf b3 97    	mov.w     [w15-24], w7
    3032:	00 02 52    	sub.w     w4, w0, w4
    3034:	81 82 5a    	subb.w    w5, w1, w5
    3036:	02 03 5b    	subb.w    w6, w2, w6
    3038:	83 83 5b    	subb.w    w7, w3, w7
    303a:	17 00 37    	bra       0x306a <.L279>

0000303c <.L225>:
    303c:	0e 48 a3    	btst.z    w14, #0x4
    303e:	1a 00 32    	bra       Z, 0x3074 <.L227>
    3040:	1f b2 97    	mov.w     [w15-30], w4
    3042:	af b2 97    	mov.w     [w15-28], w5
    3044:	7f 9b 97    	mov.w     [w15-66], w6
    3046:	36 04 be    	mov.d     [w6++], w8
    3048:	26 05 be    	mov.d     [w6--], w10
    304a:	08 01 be    	mov.d     w8, w2
    304c:	04 00 be    	mov.d     w4, w0
    304e:	f4 b7 9f    	mov.w     w4, [w15-18]
    3050:	85 bf 9f    	mov.w     w5, [w15-16]
    3052:	70 f7 07    	rcall     0x1f34 <___udivsi3>
    3054:	e0 77 9f    	mov.b     w0, [w15-74]
    3056:	00 00 fb    	se        w0, w0
    3058:	cf 80 de    	asr.w     w0, #0xf, w1
    305a:	08 01 be    	mov.d     w8, w2
    305c:	1e 03 07    	rcall     0x369a <___mulp32eds3> <___mulp32peds3> <___mulsi3>
    305e:	7f b2 97    	mov.w     [w15-18], w4
    3060:	8f ba 97    	mov.w     [w15-16], w5
    3062:	00 00 52    	sub.w     w4, w0, w0
    3064:	81 80 5a    	subb.w    w5, w1, w1
    3066:	00 02 be    	mov.d     w0, w4
    3068:	60 33 b8    	mul.uu    w6, #0x0, w6

0000306a <.L279>:
    306a:	94 b7 9f    	mov.w     w4, [w15-30]
    306c:	a5 b7 9f    	mov.w     w5, [w15-28]
    306e:	b6 b7 9f    	mov.w     w6, [w15-26]
    3070:	c7 b7 9f    	mov.w     w7, [w15-24]
    3072:	09 00 37    	bra       0x3086 <.L226>

00003074 <.L227>:
    3074:	ff 9a 97    	mov.w     [w15-66], w5
    3076:	15 01 78    	mov.w     [w5], w2
    3078:	1f b3 97    	mov.w     [w15-30], w6
    307a:	11 00 09    	.pword 0x090011
    307c:	02 83 d8    	div.uw    w6, w2
    307e:	a2 00 20    	mov.w     #0xa, w2
    3080:	11 00 09    	.pword 0x090011
    3082:	02 80 d8    	div.uw    w0, w2
    3084:	e1 77 9f    	mov.b     w1, [w15-74]

00003086 <.L226>:
    3086:	ef 73 97    	mov.b     [w15-74], w7
    3088:	07 43 b0    	add.b     #0x30, w7
    308a:	e7 77 9f    	mov.b     w7, [w15-74]
    308c:	26 00 37    	bra       0x30da <.L220>

0000308e <.L223>:
    308e:	30 fe 23    	mov.w     #0x3fe3, w0
    3090:	0e 58 a3    	btst.z    w14, #0x5
    3092:	01 00 32    	bra       Z, 0x3096 <.L228>
    3094:	20 fd 23    	mov.w     #0x3fd2, w0

00003096 <.L228>:
    3096:	5f ac 97    	mov.w     [w15-38], w8
    3098:	c2 40 dd    	sl.w      w8, #0x2, w1
    309a:	1f b2 97    	mov.w     [w15-30], w4
    309c:	af b2 97    	mov.w     [w15-28], w5
    309e:	3f b3 97    	mov.w     [w15-26], w6
    30a0:	cf b3 97    	mov.w     [w15-24], w7

000030a2 <.LB2126>:
    30a2:	81 00 e9    	dec.w     w1, w1
    30a4:	05 00 33    	bra       N, 0x30b0 <.LE2126>
    30a6:	87 03 d1    	lsr.w     w7, w7
    30a8:	06 83 d3    	rrc.w     w6, w6
    30aa:	85 82 d3    	rrc.w     w5, w5
    30ac:	04 82 d3    	rrc.w     w4, w4
    30ae:	f9 ff 37    	bra       0x30a2 <.LB2126>

000030b0 <.LE2126>:
    30b0:	ef 00 62    	and.w     w4, #0xf, w1
    30b2:	01 00 40    	add.w     w0, w1, w0
    30b4:	10 40 78    	mov.b     [w0], w0
    30b6:	10 00 37    	bra       0x30d8 <.L280>

000030b8 <.L222>:
    30b8:	df a8 97    	mov.w     [w15-38], w1
    30ba:	e3 08 b9    	.pword 0xb908e3
    30bc:	1f b2 97    	mov.w     [w15-30], w4
    30be:	af b2 97    	mov.w     [w15-28], w5
    30c0:	3f b3 97    	mov.w     [w15-26], w6
    30c2:	cf b3 97    	mov.w     [w15-24], w7
    30c4:	00 04 78    	mov.w     w0, w8

000030c6 <.LB2138>:
    30c6:	08 04 e9    	dec.w     w8, w8
    30c8:	05 00 33    	bra       N, 0x30d4 <.LE2138>
    30ca:	87 03 d1    	lsr.w     w7, w7
    30cc:	06 83 d3    	rrc.w     w6, w6
    30ce:	85 82 d3    	rrc.w     w5, w5
    30d0:	04 82 d3    	rrc.w     w4, w4
    30d2:	f9 ff 37    	bra       0x30c6 <.LB2138>

000030d4 <.LE2138>:
    30d4:	67 40 62    	and.b     w4, #0x7, w0
    30d6:	00 43 b0    	add.b     #0x30, w0

000030d8 <.L280>:
    30d8:	e0 77 9f    	mov.b     w0, [w15-74]

000030da <.L220>:
    30da:	bc 00 90    	mov.w     [w12+6], w1
    30dc:	6f 71 97    	mov.b     [w15-74], w2
    30de:	02 00 fb    	se        w2, w0
    30e0:	01 68 a3    	btst.z    w1, #0x6
    30e2:	07 00 32    	bra       Z, 0x30f2 <.L229>
    30e4:	0d 01 78    	mov.w     w13, w2
    30e6:	80 00 78    	mov.w     w0, w1
    30e8:	0c 00 78    	mov.w     w12, w0
    30ea:	72 fa 07    	rcall     0x25d0 <_sputc> <L0>
    30ec:	00 00 e0    	cp0.w     w0
    30ee:	05 00 3a    	bra       NZ, 0x30fa <.L230>
    30f0:	05 00 37    	bra       0x30fc <.L231>

000030f2 <.L229>:
    30f2:	8c 00 78    	mov.w     w12, w1
    30f4:	2d 00 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    30f6:	e1 0f 40    	add.w     w0, #0x1, [w15]
    30f8:	01 00 32    	bra       Z, 0x30fc <.L231>

000030fa <.L230>:
    30fa:	8d 06 e8    	inc.w     w13, w13

000030fc <.L231>:
    30fc:	ff 99 97    	mov.w     [w15-66], w3
    30fe:	e8 81 51    	sub.w     w3, #0x8, w3
    3100:	f3 9f 9f    	mov.w     w3, [w15-66]

00003102 <.L219>:
    3102:	5f aa 97    	mov.w     [w15-38], w4
    3104:	04 00 e0    	cp0.w     w4
    3106:	6c ff 3a    	bra       NZ, 0x2fe0 <.L232>
    3108:	0e 38 a3    	btst.z    w14, #0x3
    310a:	16 00 32    	bra       Z, 0x3138 <.L263>
    310c:	cf a2 97    	mov.w     [w15-56], w5
    310e:	05 00 e0    	cp0.w     w5
    3110:	13 00 34    	bra       LE, 0x3138 <.L263>
    3112:	05 07 78    	mov.w     w5, w14

00003114 <.L236>:
    3114:	3c 00 90    	mov.w     [w12+6], w0
    3116:	00 68 a3    	btst.z    w0, #0x6
    3118:	07 00 32    	bra       Z, 0x3128 <.L233>
    311a:	0d 01 78    	mov.w     w13, w2
    311c:	01 02 20    	mov.w     #0x20, w1
    311e:	0c 00 78    	mov.w     w12, w0
    3120:	57 fa 07    	rcall     0x25d0 <_sputc> <L0>
    3122:	00 00 e0    	cp0.w     w0
    3124:	06 00 3a    	bra       NZ, 0x3132 <.L234>
    3126:	06 00 37    	bra       0x3134 <.L235>

00003128 <.L233>:
    3128:	8c 00 78    	mov.w     w12, w1
    312a:	00 02 20    	mov.w     #0x20, w0
    312c:	11 00 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>
    312e:	e1 0f 40    	add.w     w0, #0x1, [w15]
    3130:	01 00 32    	bra       Z, 0x3134 <.L235>

00003132 <.L234>:
    3132:	8d 06 e8    	inc.w     w13, w13

00003134 <.L235>:
    3134:	0e 07 e9    	dec.w     w14, w14
    3136:	ee ff 3a    	bra       NZ, 0x3114 <.L236>

00003138 <.L263>:
    3138:	6f 9b 97    	mov.w     [w15-68], w6
    313a:	16 40 78    	mov.b     [w6], w0
    313c:	e0 77 9f    	mov.b     w0, [w15-74]
    313e:	00 04 e0    	cp0.b     w0
    3140:	60 fa 3a    	bra       NZ, 0x2602 <.L237>

00003142 <.L45>:
    3142:	0d 00 78    	mov.w     w13, w0
    3144:	4f 07 78    	mov.w     [--w15], w14
    3146:	4f 06 be    	mov.d     [--w15], w12
    3148:	4f 05 be    	mov.d     [--w15], w10
    314a:	4f 04 be    	mov.d     [--w15], w8
    314c:	ef 03 b1    	sub.w     #0x3e, w15
    314e:	00 00 06    	return    

00003150 <_fputc>:
    3150:	88 9f be    	mov.d     w8, [w15++]
    3152:	01 04 78    	mov.w     w1, w8
    3154:	b8 00 90    	mov.w     [w8+6], w1
    3156:	80 84 eb    	setm.w    w9
    3158:	01 18 a3    	btst.z    w1, #0x1
    315a:	3a 00 32    	bra       Z, 0x31d0 <.L2>
    315c:	18 01 90    	mov.w     [w8+2], w2
    315e:	01 98 a3    	btst.z    w1, #0x9
    3160:	02 00 3a    	bra       NZ, 0x3166 <.L3>
    3162:	02 00 e0    	cp0.w     w2
    3164:	35 00 3a    	bra       NZ, 0x31d0 <.L2>

00003166 <.L3>:
    3166:	01 90 a0    	bset.w    w1, #0x9
    3168:	31 04 98    	mov.w     w1, [w8+6]
    316a:	80 04 78    	mov.w     w0, w9
    316c:	f9 0f b2    	and.w     #0xff, w9
    316e:	02 00 e0    	cp0.w     w2
    3170:	02 00 3a    	bra       NZ, 0x3176 <.L4>
    3172:	28 00 90    	mov.w     [w8+4], w0
    3174:	00 0c 78    	mov.w     w0, [w8]

00003176 <.L4>:
    3176:	ea 8f 54    	sub.w     w9, #0xa, [w15]
    3178:	05 00 3a    	bra       NZ, 0x3184 <.L5>
    317a:	01 78 a3    	btst.z    w1, #0x7
    317c:	03 00 3a    	bra       NZ, 0x3184 <.L5>
    317e:	88 00 78    	mov.w     w8, w1
    3180:	d0 00 20    	mov.w     #0xd, w0
    3182:	e6 ff 07    	rcall     0x3150 <_fputc> <L0> <.LASF23>

00003184 <.L5>:
    3184:	18 00 90    	mov.w     [w8+2], w0
    3186:	d8 00 90    	mov.w     [w8+10], w1
    3188:	81 0f 50    	sub.w     w0, w1, [w15]
    318a:	0b 00 32    	bra       Z, 0x31a2 <.L6>
    318c:	00 00 e8    	inc.w     w0, w0
    318e:	10 04 98    	mov.w     w0, [w8+2]
    3190:	18 00 78    	mov.w     [w8], w0
    3192:	09 48 78    	mov.b     w9, [w0]
    3194:	00 0c e8    	inc.w     w0, [w8]
    3196:	11 c0 b3    	mov.b     #0x1, w1
    3198:	60 49 24    	mov.w     #0x4496, w0
    319a:	01 48 78    	mov.b     w1, [w0]
    319c:	ea 8f 54    	sub.w     w9, #0xa, [w15]
    319e:	18 00 3a    	bra       NZ, 0x31d0 <.L2>
    31a0:	05 00 37    	bra       0x31ac <.L11>

000031a2 <.L6>:
    31a2:	88 00 78    	mov.w     w8, w1
    31a4:	09 40 78    	mov.b     w9, w0
    31a6:	17 00 07    	rcall     0x31d6 <__flsbuf> <L0>
    31a8:	80 04 78    	mov.w     w0, w9
    31aa:	12 00 37    	bra       0x31d0 <.L2>

000031ac <.L11>:
    31ac:	38 00 90    	mov.w     [w8+6], w0
    31ae:	00 88 a3    	btst.z    w0, #0x8
    31b0:	0f 00 32    	bra       Z, 0x31d0 <.L2>
    31b2:	18 01 90    	mov.w     [w8+2], w2
    31b4:	a8 00 90    	mov.w     [w8+4], w1
    31b6:	48 00 90    	mov.w     [w8+8], w0
    31b8:	3b f1 07    	rcall     0x1430 <_write>
    31ba:	98 00 90    	mov.w     [w8+2], w1
    31bc:	81 0f 50    	sub.w     w0, w1, [w15]
    31be:	04 00 32    	bra       Z, 0x31c8 <.L8>
    31c0:	38 00 90    	mov.w     [w8+6], w0
    31c2:	00 03 b3    	ior.w     #0x30, w0
    31c4:	30 04 98    	mov.w     w0, [w8+6]
    31c6:	80 84 eb    	setm.w    w9

000031c8 <.L8>:
    31c8:	00 00 eb    	clr.w     w0
    31ca:	10 04 98    	mov.w     w0, [w8+2]
    31cc:	28 00 90    	mov.w     [w8+4], w0
    31ce:	00 0c 78    	mov.w     w0, [w8]

000031d0 <.L2>:
    31d0:	09 00 78    	mov.w     w9, w0
    31d2:	4f 04 be    	mov.d     [--w15], w8
    31d4:	00 00 06    	return    

000031d6 <__flsbuf>:
    31d6:	02 00 fa    	lnk       #0x2
    31d8:	88 9f be    	mov.d     w8, [w15++]
    31da:	a0 ff 9f    	mov.b     w0, [w15-6]
    31dc:	01 04 78    	mov.w     w1, w8
    31de:	38 00 90    	mov.w     [w8+6], w0
    31e0:	00 68 a3    	btst.z    w0, #0x6
    31e2:	33 00 3a    	bra       NZ, 0x324a <.L7>
    31e4:	e2 00 60    	and.w     w0, #0x2, w1
    31e6:	05 00 3a    	bra       NZ, 0x31f2 <.L4>
    31e8:	00 03 b3    	ior.w     #0x30, w0
    31ea:	30 04 98    	mov.w     w0, [w8+6]
    31ec:	11 04 98    	mov.w     w1, [w8+2]
    31ee:	00 80 eb    	setm.w    w0
    31f0:	2e 00 37    	bra       0x324e <.L3>

000031f2 <.L4>:
    31f2:	d8 04 90    	mov.w     [w8+10], w9
    31f4:	09 00 e0    	cp0.w     w9
    31f6:	06 00 3a    	bra       NZ, 0x3204 <.L5>
    31f8:	12 00 20    	mov.w     #0x1, w2
    31fa:	e6 80 57    	sub.w     w15, #0x6, w1
    31fc:	48 00 90    	mov.w     [w8+8], w0
    31fe:	18 f1 07    	rcall     0x1430 <_write>
    3200:	19 04 98    	mov.w     w9, [w8+2]
    3202:	23 00 37    	bra       0x324a <.L7>

00003204 <.L5>:
    3204:	a8 00 90    	mov.w     [w8+4], w1
    3206:	01 00 e0    	cp0.w     w1
    3208:	08 00 3a    	bra       NZ, 0x321a <.L6>
    320a:	91 49 24    	mov.w     #0x4499, w1
    320c:	21 04 98    	mov.w     w1, [w8+4]
    320e:	01 0c 78    	mov.w     w1, [w8]
    3210:	21 00 20    	mov.w     #0x2, w1
    3212:	51 04 98    	mov.w     w1, [w8+10]
    3214:	11 04 98    	mov.w     w1, [w8+2]
    3216:	00 30 a0    	bset.w    w0, #0x3
    3218:	30 04 98    	mov.w     w0, [w8+6]

0000321a <.L6>:
    321a:	18 01 90    	mov.w     [w8+2], w2
    321c:	a8 00 90    	mov.w     [w8+4], w1
    321e:	48 00 90    	mov.w     [w8+8], w0
    3220:	07 f1 07    	rcall     0x1430 <_write>
    3222:	28 00 90    	mov.w     [w8+4], w0
    3224:	80 80 eb    	setm.w    w1
    3226:	11 04 98    	mov.w     w1, [w8+2]
    3228:	af f8 97    	mov.b     [w15-6], w1
    322a:	01 48 78    	mov.b     w1, [w0]
    322c:	00 0c e8    	inc.w     w0, [w8]
    322e:	2f f8 97    	mov.b     [w15-6], w0
    3230:	ea 4f 50    	sub.b     w0, #0xa, [w15]
    3232:	0b 00 3a    	bra       NZ, 0x324a <.L7>
    3234:	38 00 90    	mov.w     [w8+6], w0
    3236:	00 88 a3    	btst.z    w0, #0x8
    3238:	08 00 32    	bra       Z, 0x324a <.L7>
    323a:	18 01 90    	mov.w     [w8+2], w2
    323c:	a8 00 90    	mov.w     [w8+4], w1
    323e:	48 00 90    	mov.w     [w8+8], w0
    3240:	f7 f0 07    	rcall     0x1430 <_write>
    3242:	00 00 eb    	clr.w     w0
    3244:	10 04 98    	mov.w     w0, [w8+2]
    3246:	a8 00 90    	mov.w     [w8+4], w1
    3248:	01 0c 78    	mov.w     w1, [w8]

0000324a <.L7>:
    324a:	af f8 97    	mov.b     [w15-6], w1
    324c:	01 00 fb    	se        w1, w0

0000324e <.L3>:
    324e:	4f 04 be    	mov.d     [--w15], w8
    3250:	00 80 fa    	ulnk      
    3252:	00 00 06    	return    

00003254 <_dowrite>:
    3254:	00 c0 da    	.pword 0xdac000
    3256:	00 00 06    	return    

00003258 <___adddf3>:
    3258:	28 00 fa    	lnk       #0x28
    325a:	88 9f be    	mov.d     w8, [w15++]
    325c:	8a 9f be    	mov.d     w10, [w15++]
    325e:	8c 9f be    	mov.d     w12, [w15++]
    3260:	07 06 78    	mov.w     w7, w12
    3262:	87 86 69    	xor.w     w3, w7, w13
    3264:	0c 00 3b    	bra       NN, 0x327e <gotsign>
    3266:	03 04 78    	mov.w     w3, w8
    3268:	87 04 78    	mov.w     w7, w9
    326a:	08 f0 a1    	bclr.w    w8, #0xf
    326c:	09 f0 a1    	bclr.w    w9, #0xf
    326e:	84 0f 50    	sub.w     w0, w4, [w15]
    3270:	85 8f 58    	subb.w    w1, w5, [w15]
    3272:	86 0f 59    	subb.w    w2, w6, [w15]
    3274:	89 0f 5c    	subb.w    w8, w9, [w15]
    3276:	03 00 33    	bra       N, 0x327e <gotsign>
    3278:	0c f0 a2    	btg.w     w12, #0xf
    327a:	01 00 3a    	bra       NZ, 0x327e <gotsign>
    327c:	0c f0 a1    	bclr.w    w12, #0xf

0000327e <gotsign>:
    327e:	a1 f6 07    	rcall     0x1fc2 <__dunpack2>
    3280:	64 00 e1    	.pword 0xe10064
    3282:	5f 00 32    	bra       Z, 0x3342 <aisinfinite>
    3284:	78 01 47    	add.w     w14, #0x18, w2
    3286:	64 08 e1    	.pword 0xe10864
    3288:	61 00 32    	bra       Z, 0x334c <returnab>
    328a:	6c 01 47    	add.w     w14, #0xc, w2
    328c:	74 85 57    	sub.w     w15, #0x14, w10
    328e:	32 00 be    	mov.d     [w2++], w0
    3290:	12 01 be    	mov.d     [w2], w2
    3292:	3a 04 be    	mov.d     [w10++], w8
    3294:	1a 05 be    	mov.d     [w10], w10
    3296:	1e 03 90    	mov.w     [w14+2], w6
    3298:	be 0a 90    	mov.w     [w14+22], w5
    329a:	85 03 53    	sub.w     w6, w5, w7
    329c:	06 00 3d    	bra       GE, 0x32aa <expcanonical>
    329e:	00 04 fd    	exch      w0, w8
    32a0:	81 04 fd    	exch      w1, w9
    32a2:	02 05 fd    	exch      w2, w10
    32a4:	83 05 fd    	exch      w3, w11
    32a6:	87 03 ea    	neg.w     w7, w7
    32a8:	05 03 78    	mov.w     w5, w6

000032aa <expcanonical>:
    32aa:	0d f8 a3    	btst.z    w13, #0xf
    32ac:	04 00 32    	bra       Z, 0x32b6 <bcanonical>
    32ae:	60 04 14    	subr.w    w8, #0x0, w8
    32b0:	e0 84 1c    	subbr.w   w9, #0x0, w9
    32b2:	60 05 1d    	subbr.w   w10, #0x0, w10
    32b4:	e0 85 1d    	subbr.w   w11, #0x0, w11

000032b6 <bcanonical>:
    32b6:	60 22 b8    	mul.uu    w4, #0x0, w4
    32b8:	7d 03 20    	mov.w     #0x37, w13
    32ba:	0d 38 e1    	cp.w      w7, w13
    32bc:	80 06 eb    	clr.w     w13
    32be:	0b 00 39    	bra       NC, 0x32d6 <aligniter>
    32c0:	44 33 dd    	sl.w      w6, #0x4, w6
    32c2:	f3 00 b2    	and.w     #0xf, w3
    32c4:	83 01 73    	ior.w     w6, w3, w3
    32c6:	39 00 37    	bra       0x333a <signoff>

000032c8 <align>:
    32c8:	84 82 72    	ior.w     w5, w4, w5
    32ca:	0d 02 78    	mov.w     w13, w4
    32cc:	e1 06 64    	and.w     w8, #0x1, w13
    32ce:	8b 85 d1    	asr.w     w11, w11
    32d0:	0a 85 d3    	rrc.w     w10, w10
    32d2:	89 84 d3    	rrc.w     w9, w9
    32d4:	08 84 d3    	rrc.w     w8, w8

000032d6 <aligniter>:
    32d6:	87 03 e9    	dec.w     w7, w7
    32d8:	f7 ff 3b    	bra       NN, 0x32c8 <align>

000032da <aligned>:
    32da:	08 00 40    	add.w     w0, w8, w0
    32dc:	89 80 48    	addc.w    w1, w9, w1
    32de:	0a 01 49    	addc.w    w2, w10, w2
    32e0:	8b 81 49    	addc.w    w3, w11, w3
    32e2:	04 00 3b    	bra       NN, 0x32ec <normalizesum>
    32e4:	60 00 10    	subr.w    w0, #0x0, w0
    32e6:	e0 80 18    	subbr.w   w1, #0x0, w1
    32e8:	60 01 19    	subbr.w   w2, #0x0, w2
    32ea:	e0 81 19    	subbr.w   w3, #0x0, w3

000032ec <normalizesum>:
    32ec:	03 58 a3    	btst.z    w3, #0x5
    32ee:	09 00 32    	bra       Z, 0x3302 <checknormal>
    32f0:	8d 82 72    	ior.w     w5, w13, w5
    32f2:	84 82 72    	ior.w     w5, w4, w5
    32f4:	61 02 60    	and.w     w0, #0x1, w4
    32f6:	83 01 d1    	lsr.w     w3, w3
    32f8:	02 81 d3    	rrc.w     w2, w2
    32fa:	81 80 d3    	rrc.w     w1, w1
    32fc:	00 80 d3    	rrc.w     w0, w0
    32fe:	06 03 e8    	inc.w     w6, w6
    3300:	1b 00 37    	bra       0x3338 <round>

00003302 <checknormal>:
    3302:	03 48 a3    	btst.z    w3, #0x4
    3304:	17 00 3a    	bra       NZ, 0x3334 <discardguard>

00003306 <underflow>:
    3306:	06 00 e0    	cp0.w     w6
    3308:	17 00 34    	bra       LE, 0x3338 <round>
    330a:	06 03 e9    	dec.w     w6, w6
    330c:	0d 00 a3    	btst.c    w13, #0x0
    330e:	00 00 48    	addc.w    w0, w0, w0
    3310:	81 80 48    	addc.w    w1, w1, w1
    3312:	02 01 49    	addc.w    w2, w2, w2
    3314:	83 81 49    	addc.w    w3, w3, w3
    3316:	03 48 a3    	btst.z    w3, #0x4
    3318:	0f 00 3a    	bra       NZ, 0x3338 <round>

0000331a <normalizeloop>:
    331a:	06 00 e0    	cp0.w     w6
    331c:	09 00 34    	bra       LE, 0x3330 <normalizeexit> <.LASF1>
    331e:	06 03 e9    	dec.w     w6, w6
    3320:	00 00 40    	add.w     w0, w0, w0
    3322:	81 80 48    	addc.w    w1, w1, w1
    3324:	02 01 49    	addc.w    w2, w2, w2
    3326:	83 81 49    	addc.w    w3, w3, w3
    3328:	01 00 3a    	bra       NZ, 0x332c <normalizeexpok>
    332a:	00 03 eb    	clr.w     w6

0000332c <normalizeexpok>:
    332c:	03 48 a3    	btst.z    w3, #0x4
    332e:	f5 ff 32    	bra       Z, 0x331a <normalizeloop>

00003330 <normalizeexit>:
    3330:	60 22 b8    	mul.uu    w4, #0x0, w4
    3332:	02 00 37    	bra       0x3338 <round>

00003334 <discardguard>:
    3334:	84 82 72    	ior.w     w5, w4, w5
    3336:	61 82 66    	and.w     w13, #0x1, w4

00003338 <round>:
    3338:	75 00 07    	rcall     0x3424 <__dpack>

0000333a <signoff>:
    333a:	03 f0 a1    	bclr.w    w3, #0xf
    333c:	0c f0 a7    	btsc.w    w12, #0xf
    333e:	03 f0 a0    	bset.w    w3, #0xf
    3340:	54 f6 37    	bra       0x1fea <__dunpack2exit>

00003342 <aisinfinite>:
    3342:	64 01 47    	add.w     w14, #0x4, w2
    3344:	64 08 e1    	.pword 0xe10864
    3346:	02 00 3a    	bra       NZ, 0x334c <returnab>
    3348:	0d f8 a3    	btst.z    w13, #0xf
    334a:	4c f6 3a    	bra       NZ, 0x1fe4 <__dreturnNaN>

0000334c <returnab>:
    334c:	32 00 be    	mov.d     [w2++], w0
    334e:	12 01 be    	mov.d     [w2], w2
    3350:	4c f6 37    	bra       0x1fea <__dunpack2exit>

00003352 <___eqdf2>:
    3352:	8f 1f d1    	lsr.w     w15, [w15++]
    3354:	d3 02 07    	rcall     0x38fc <__dcompare> <L0>
    3356:	8f 87 e9    	dec2.w    w15, w15
    3358:	00 00 e0    	cp0.w     w0
    335a:	00 00 06    	return    

0000335c <___gedf2>:
    335c:	80 9f eb    	setm.w    [w15++]
    335e:	ce 02 07    	rcall     0x38fc <__dcompare> <L0>
    3360:	8f 87 e9    	dec2.w    w15, w15
    3362:	00 00 e0    	cp0.w     w0
    3364:	00 00 06    	return    

00003366 <___divdf3>:
    3366:	28 00 fa    	lnk       #0x28
    3368:	88 9f be    	mov.d     w8, [w15++]
    336a:	8a 9f be    	mov.d     w10, [w15++]
    336c:	8c 9f be    	mov.d     w12, [w15++]
    336e:	03 86 6b    	xor.w     w7, w3, w12
    3370:	28 f6 07    	rcall     0x1fc2 <__dunpack2>
    3372:	64 00 e1    	.pword 0xe10064
    3374:	44 00 32    	bra       Z, 0x33fe <aisinfinite>
    3376:	64 08 e1    	.pword 0xe10864
    3378:	4a 00 32    	bra       Z, 0x340e <returnZero>
    337a:	61 00 e1    	.pword 0xe10061
    337c:	46 00 32    	bra       Z, 0x340a <aiszero>
    337e:	61 08 e1    	.pword 0xe10861
    3380:	49 00 32    	bra       Z, 0x3414 <returnInf>

00003382 <finitenonzero>:
    3382:	ec 06 47    	add.w     w14, #0xc, w13
    3384:	60 00 b8    	mul.uu    w0, #0x0, w0
    3386:	3d 02 be    	mov.d     [w13++], w4
    3388:	3d 03 be    	mov.d     [w13++], w6
    338a:	f4 86 57    	sub.w     w15, #0x14, w13
    338c:	60 11 b8    	mul.uu    w2, #0x0, w2
    338e:	3d 04 be    	mov.d     [w13++], w8
    3390:	3d 05 be    	mov.d     [w13++], w10
    3392:	7d 03 20    	mov.w     #0x37, w13
    3394:	0b 00 37    	bra       0x33ac <diventry>

00003396 <divnext>:
    3396:	00 00 a0    	bset.w    w0, #0x0
    3398:	8d 06 e9    	dec.w     w13, w13
    339a:	13 00 32    	bra       Z, 0x33c2 <divdone>

0000339c <divloop>:
    339c:	04 02 42    	add.w     w4, w4, w4
    339e:	85 82 4a    	addc.w    w5, w5, w5
    33a0:	06 03 4b    	addc.w    w6, w6, w6
    33a2:	87 83 4b    	addc.w    w7, w7, w7
    33a4:	00 00 40    	add.w     w0, w0, w0
    33a6:	81 80 48    	addc.w    w1, w1, w1
    33a8:	02 01 49    	addc.w    w2, w2, w2
    33aa:	83 81 49    	addc.w    w3, w3, w3

000033ac <diventry>:
    33ac:	08 02 52    	sub.w     w4, w8, w4
    33ae:	89 82 5a    	subb.w    w5, w9, w5
    33b0:	0a 03 5b    	subb.w    w6, w10, w6
    33b2:	8b 83 5b    	subb.w    w7, w11, w7
    33b4:	f0 ff 3b    	bra       NN, 0x3396 <divnext>
    33b6:	08 02 42    	add.w     w4, w8, w4
    33b8:	89 82 4a    	addc.w    w5, w9, w5
    33ba:	0a 03 4b    	addc.w    w6, w10, w6
    33bc:	8b 83 4b    	addc.w    w7, w11, w7
    33be:	8d 06 e9    	dec.w     w13, w13
    33c0:	ed ff 3a    	bra       NZ, 0x339c <divloop> <.LASF17>

000033c2 <divdone>:
    33c2:	84 82 72    	ior.w     w5, w4, w5
    33c4:	86 82 72    	ior.w     w5, w6, w5
    33c6:	f7 07 b2    	and.w     #0x7f, w7
    33c8:	87 82 72    	ior.w     w5, w7, w5
    33ca:	01 00 32    	bra       Z, 0x33ce <stickyformed>
    33cc:	15 00 20    	mov.w     #0x1, w5

000033ce <stickyformed>:
    33ce:	1e 04 90    	mov.w     [w14+2], w8
    33d0:	3e 0b 90    	mov.w     [w14+22], w6
    33d2:	06 03 54    	sub.w     w8, w6, w6
    33d4:	e6 3f b0    	add.w     #0x3fe, w6
    33d6:	03 68 a3    	btst.z    w3, #0x6
    33d8:	07 00 32    	bra       Z, 0x33e8 <guardused>
    33da:	00 00 a7    	btsc.w    w0, #0x0
    33dc:	05 00 a0    	bset.w    w5, #0x0
    33de:	83 01 d1    	lsr.w     w3, w3
    33e0:	02 81 d3    	rrc.w     w2, w2
    33e2:	81 80 d3    	rrc.w     w1, w1
    33e4:	00 80 d3    	rrc.w     w0, w0
    33e6:	06 03 e8    	inc.w     w6, w6

000033e8 <guardused>:
    33e8:	83 01 d1    	lsr.w     w3, w3
    33ea:	02 81 d3    	rrc.w     w2, w2
    33ec:	81 80 d3    	rrc.w     w1, w1
    33ee:	00 80 d3    	rrc.w     w0, w0
    33f0:	00 02 eb    	clr.w     w4
    33f2:	04 82 d2    	rlc.w     w4, w4
    33f4:	17 00 07    	rcall     0x3424 <__dpack>

000033f6 <signoff>:
    33f6:	03 f0 a1    	bclr.w    w3, #0xf
    33f8:	0c f0 a7    	btsc.w    w12, #0xf
    33fa:	03 f0 a0    	bset.w    w3, #0xf
    33fc:	f6 f5 37    	bra       0x1fea <__dunpack2exit>

000033fe <aisinfinite>:
    33fe:	64 02 47    	add.w     w14, #0x4, w4
    3400:	64 08 e1    	.pword 0xe10864
    3402:	f0 f5 32    	bra       Z, 0x1fe4 <__dreturnNaN>
    3404:	34 00 be    	mov.d     [w4++], w0
    3406:	34 01 be    	mov.d     [w4++], w2
    3408:	f6 ff 37    	bra       0x33f6 <signoff>

0000340a <aiszero>:
    340a:	61 08 e1    	.pword 0xe10861
    340c:	eb f5 32    	bra       Z, 0x1fe4 <__dreturnNaN>

0000340e <returnZero>:
    340e:	60 11 b8    	mul.uu    w2, #0x0, w2

00003410 <returnZeroLo>:
    3410:	60 00 b8    	mul.uu    w0, #0x0, w0
    3412:	f1 ff 37    	bra       0x33f6 <signoff>

00003414 <returnInf>:
    3414:	03 ff 27    	mov.w     #0x7ff0, w3
    3416:	02 00 20    	mov.w     #0x0, w2
    3418:	fb ff 37    	bra       0x3410 <returnZeroLo>

0000341a <___nedf2>:
    341a:	80 1f eb    	clr.w     [w15++]
    341c:	6f 02 07    	rcall     0x38fc <__dcompare> <L0>
    341e:	8f 87 e9    	dec2.w    w15, w15
    3420:	00 00 e0    	cp0.w     w0
    3422:	00 00 06    	return    

00003424 <__dpack>:
    3424:	18 00 20    	mov.w     #0x1, w8
    3426:	57 00 20    	mov.w     #0x5, w7
    3428:	08 04 53    	sub.w     w6, w8, w8
    342a:	0d 00 3d    	bra       GE, 0x3446 <notsubnormal>
    342c:	06 00 20    	mov.w     #0x0, w6
    342e:	97 fc 2f    	mov.w     #0xffc9, w7
    3430:	07 40 e1    	cp.w      w8, w7
    3432:	1e 00 34    	bra       LE, 0x3470 <zerosig> <.LASF4>

00003434 <subnormal>:
    3434:	84 82 72    	ior.w     w5, w4, w5
    3436:	61 02 60    	and.w     w0, #0x1, w4
    3438:	83 01 d1    	lsr.w     w3, w3
    343a:	02 81 d3    	rrc.w     w2, w2
    343c:	81 80 d3    	rrc.w     w1, w1
    343e:	00 80 d3    	rrc.w     w0, w0
    3440:	08 04 e8    	inc.w     w8, w8
    3442:	f8 ff 3a    	bra       NZ, 0x3434 <subnormal>
    3444:	47 00 20    	mov.w     #0x4, w7

00003446 <notsubnormal>:
    3446:	61 04 60    	and.w     w0, #0x1, w8
    3448:	05 04 74    	ior.w     w8, w5, w8
    344a:	04 04 64    	and.w     w8, w4, w8
    344c:	0d 00 32    	bra       Z, 0x3468 <packupandgo>
    344e:	61 00 40    	add.w     w0, #0x1, w0
    3450:	e0 80 48    	addc.w    w1, #0x0, w1
    3452:	60 01 49    	addc.w    w2, #0x0, w2
    3454:	e0 81 49    	addc.w    w3, #0x0, w3
    3456:	03 b8 a5    	btst.z    w3, w7
    3458:	07 00 32    	bra       Z, 0x3468 <packupandgo>
    345a:	06 03 e8    	inc.w     w6, w6
    345c:	65 38 e1    	.pword 0xe13865
    345e:	04 00 3a    	bra       NZ, 0x3468 <packupandgo>
    3460:	83 01 d1    	lsr.w     w3, w3
    3462:	02 81 d3    	rrc.w     w2, w2
    3464:	81 80 d3    	rrc.w     w1, w1
    3466:	00 80 d3    	rrc.w     w0, w0

00003468 <packupandgo>:
    3468:	f8 7f 20    	mov.w     #0x7ff, w8
    346a:	08 30 e1    	cp.w      w6, w8
    346c:	03 00 35    	bra       LT, 0x3474 <nooverflow>
    346e:	08 03 78    	mov.w     w8, w6

00003470 <zerosig>:
    3470:	60 00 b8    	mul.uu    w0, #0x0, w0
    3472:	60 11 b8    	mul.uu    w2, #0x0, w2

00003474 <nooverflow>:
    3474:	44 33 dd    	sl.w      w6, #0x4, w6
    3476:	f3 00 b2    	and.w     #0xf, w3
    3478:	83 01 73    	ior.w     w6, w3, w3
    347a:	00 00 06    	return    

0000347c <___extendsfdf2>:
    347c:	81 03 78    	mov.w     w1, w7
    347e:	cc f2 07    	rcall     0x1a18 <__funpack> <.LASF94>
    3480:	00 01 be    	mov.d     w0, w2
    3482:	60 00 b8    	mul.uu    w0, #0x0, w0
    3484:	04 78 a3    	btst.z    w4, #0x7
    3486:	13 00 3a    	bra       NZ, 0x34ae <xIsNaN>
    3488:	62 20 e1    	.pword 0xe12062
    348a:	15 00 3e    	bra       GTU, 0x34b6 <xIsInf>
    348c:	0d 00 39    	bra       NC, 0x34a8 <signoff>
    348e:	83 01 d1    	lsr.w     w3, w3
    3490:	02 81 d3    	rrc.w     w2, w2
    3492:	81 80 d3    	rrc.w     w1, w1
    3494:	83 01 d1    	lsr.w     w3, w3
    3496:	02 81 d3    	rrc.w     w2, w2
    3498:	81 80 d3    	rrc.w     w1, w1
    349a:	83 01 d1    	lsr.w     w3, w3
    349c:	02 81 d3    	rrc.w     w2, w2
    349e:	81 80 d3    	rrc.w     w1, w1
    34a0:	05 38 b0    	add.w     #0x380, w5
    34a2:	c4 2a dd    	sl.w      w5, #0x4, w5
    34a4:	f3 00 b2    	and.w     #0xf, w3
    34a6:	83 81 72    	ior.w     w5, w3, w3

000034a8 <signoff>:
    34a8:	07 f0 a7    	btsc.w    w7, #0xf
    34aa:	03 f0 a0    	bset.w    w3, #0xf

000034ac <exit>:
    34ac:	00 00 06    	return    

000034ae <xIsNaN>:
    34ae:	f3 ff 27    	mov.w     #0x7fff, w3
    34b0:	f2 ff 2f    	mov.w     #0xffff, w2
    34b2:	61 10 b9    	mul.su    w2, #0x1, w0
    34b4:	fb ff 37    	bra       0x34ac <exit> <.LASF14>

000034b6 <xIsInf>:
    34b6:	03 ff 27    	mov.w     #0x7ff0, w3
    34b8:	f7 ff 37    	bra       0x34a8 <signoff>

000034ba <___fixunsdfdi>:
    34ba:	14 00 fa    	lnk       #0x14
    34bc:	88 9f be    	mov.d     w8, [w15++]
    34be:	8a 9f be    	mov.d     w10, [w15++]
    34c0:	8c 9f be    	mov.d     w12, [w15++]
    34c2:	00 04 be    	mov.d     w0, w8
    34c4:	02 05 be    	mov.d     w2, w10
    34c6:	68 00 47    	add.w     w14, #0x8, w0
    34c8:	0a 90 be    	mov.d     w10, [w0--]
    34ca:	08 90 be    	mov.d     w8, [w0--]
    34cc:	53 f5 07    	rcall     0x1f74 <__dunpack>
    34ce:	00 70 a7    	btsc.w    w0, #0x7
    34d0:	0b f0 a1    	bclr.w    w11, #0xf
    34d2:	0b f8 a3    	btst.z    w11, #0xf
    34d4:	20 00 3a    	bra       NZ, 0x3516 <underflow>
    34d6:	9e 09 90    	mov.w     [w14+18], w3
    34d8:	0e 09 90    	mov.w     [w14+16], w2
    34da:	fe 00 90    	mov.w     [w14+14], w1
    34dc:	6e 00 90    	mov.w     [w14+12], w0
    34de:	9e 02 90    	mov.w     [w14+2], w5
    34e0:	34 43 20    	mov.w     #0x433, w4
    34e2:	84 82 52    	sub.w     w5, w4, w5
    34e4:	82 f5 32    	bra       Z, 0x1fea <__dunpack2exit>
    34e6:	0a 00 3c    	bra       GT, 0x34fc <shiftleft>
    34e8:	b4 fc 2f    	mov.w     #0xffcb, w4
    34ea:	04 28 e1    	cp.w      w5, w4
    34ec:	14 00 34    	bra       LE, 0x3516 <underflow>

000034ee <shiftrightloop>:
    34ee:	83 01 d1    	lsr.w     w3, w3
    34f0:	02 81 d3    	rrc.w     w2, w2
    34f2:	81 80 d3    	rrc.w     w1, w1
    34f4:	00 80 d3    	rrc.w     w0, w0
    34f6:	85 02 e8    	inc.w     w5, w5
    34f8:	fa ff 3a    	bra       NZ, 0x34ee <shiftrightloop>
    34fa:	77 f5 37    	bra       0x1fea <__dunpack2exit>

000034fc <shiftleft>:
    34fc:	b4 00 20    	mov.w     #0xb, w4
    34fe:	04 28 e1    	cp.w      w5, w4
    3500:	07 00 3c    	bra       GT, 0x3510 <overflow>

00003502 <shiftleftloop>:
    3502:	00 00 40    	add.w     w0, w0, w0
    3504:	81 80 48    	addc.w    w1, w1, w1
    3506:	02 01 49    	addc.w    w2, w2, w2
    3508:	83 81 49    	addc.w    w3, w3, w3
    350a:	85 02 e9    	dec.w     w5, w5
    350c:	fa ff 3a    	bra       NZ, 0x3502 <shiftleftloop>
    350e:	6d f5 37    	bra       0x1fea <__dunpack2exit>

00003510 <overflow>:
    3510:	03 00 28    	mov.w     #0x8000, w3
    3512:	02 00 20    	mov.w     #0x0, w2
    3514:	01 00 37    	bra       0x3518 <returnz>

00003516 <underflow>:
    3516:	60 11 b8    	mul.uu    w2, #0x0, w2

00003518 <returnz>:
    3518:	60 00 b8    	mul.uu    w0, #0x0, w0
    351a:	67 f5 37    	bra       0x1fea <__dunpack2exit>

0000351c <___floatundidf>:
    351c:	88 9f be    	mov.d     w8, [w15++]
    351e:	00 82 70    	ior.w     w1, w0, w4
    3520:	04 02 71    	ior.w     w2, w4, w4
    3522:	04 82 71    	ior.w     w3, w4, w4
    3524:	24 00 32    	bra       Z, 0x356e <return0>
    3526:	36 43 20    	mov.w     #0x433, w6
    3528:	c5 00 20    	mov.w     #0xc, w5
    352a:	83 83 cf    	ff1l      w3, w7
    352c:	0a 00 39    	bra       NC, 0x3542 <fixshift>
    352e:	05 41 b1    	sub.b     #0x10, w5
    3530:	82 83 cf    	ff1l      w2, w7
    3532:	07 00 39    	bra       NC, 0x3542 <fixshift>
    3534:	05 41 b1    	sub.b     #0x10, w5
    3536:	81 83 cf    	ff1l      w1, w7
    3538:	04 00 39    	bra       NC, 0x3542 <fixshift>
    353a:	05 41 b1    	sub.b     #0x10, w5
    353c:	80 83 cf    	ff1l      w0, w7
    353e:	01 00 39    	bra       NC, 0x3542 <fixshift>
    3540:	05 41 b1    	sub.b     #0x10, w5

00003542 <fixshift>:
    3542:	85 c3 53    	sub.b     w7, w5, w7
    3544:	60 22 b8    	mul.uu    w4, #0x0, w4
    3546:	12 00 32    	bra       Z, 0x356c <round>
    3548:	0a 00 3b    	bra       NN, 0x355e <shiftleft>

0000354a <shiftright>:
    354a:	84 82 72    	ior.w     w5, w4, w5
    354c:	61 02 60    	and.w     w0, #0x1, w4
    354e:	83 01 d1    	lsr.w     w3, w3
    3550:	02 81 d3    	rrc.w     w2, w2
    3552:	81 80 d3    	rrc.w     w1, w1
    3554:	00 80 d3    	rrc.w     w0, w0
    3556:	06 03 e8    	inc.w     w6, w6
    3558:	87 43 e8    	inc.b     w7, w7
    355a:	f7 ff 3a    	bra       NZ, 0x354a <shiftright>
    355c:	07 00 37    	bra       0x356c <round>

0000355e <shiftleft>:
    355e:	00 00 40    	add.w     w0, w0, w0
    3560:	81 80 48    	addc.w    w1, w1, w1
    3562:	02 01 49    	addc.w    w2, w2, w2
    3564:	83 81 49    	addc.w    w3, w3, w3
    3566:	06 03 e9    	dec.w     w6, w6
    3568:	87 43 e9    	dec.b     w7, w7
    356a:	f9 ff 3a    	bra       NZ, 0x355e <shiftleft>

0000356c <round>:
    356c:	5b ff 07    	rcall     0x3424 <__dpack>

0000356e <return0>:
    356e:	4f 04 be    	mov.d     [--w15], w8
    3570:	00 00 06    	return    

00003572 <_frexp>:
    3572:	14 00 fa    	lnk       #0x14
    3574:	88 9f be    	mov.d     w8, [w15++]
    3576:	8a 9f be    	mov.d     w10, [w15++]
    3578:	8c 9f be    	mov.d     w12, [w15++]
    357a:	04 06 78    	mov.w     w4, w12
    357c:	00 04 be    	mov.d     w0, w8
    357e:	02 05 be    	mov.d     w2, w10
    3580:	68 00 47    	add.w     w14, #0x8, w0
    3582:	0a 90 be    	mov.d     w10, [w0--]
    3584:	08 90 be    	mov.d     w8, [w0--]
    3586:	f6 f4 07    	rcall     0x1f74 <__dunpack>
    3588:	62 00 e1    	.pword 0xe10062
    358a:	08 00 be    	mov.d     w8, w0
    358c:	0a 01 be    	mov.d     w10, w2
    358e:	04 00 20    	mov.w     #0x0, w4
    3590:	0b 00 3a    	bra       NZ, 0x35a8 <exit>
    3592:	1e 02 90    	mov.w     [w14+2], w4
    3594:	e4 3f b1    	sub.w     #0x3fe, w4
    3596:	6e 00 90    	mov.w     [w14+12], w0
    3598:	fe 00 90    	mov.w     [w14+14], w1
    359a:	0e 09 90    	mov.w     [w14+16], w2
    359c:	9e 09 90    	mov.w     [w14+18], w3
    359e:	f3 00 b2    	and.w     #0xf, w3
    35a0:	05 fe 23    	mov.w     #0x3fe0, w5
    35a2:	85 81 71    	ior.w     w3, w5, w3
    35a4:	0b f0 a7    	btsc.w    w11, #0xf
    35a6:	03 f0 a0    	bset.w    w3, #0xf

000035a8 <exit>:
    35a8:	04 0e 78    	mov.w     w4, [w12]
    35aa:	1f f5 37    	bra       0x1fea <__dunpack2exit>

000035ac <___muldf3>:
    35ac:	28 00 fa    	lnk       #0x28
    35ae:	88 9f be    	mov.d     w8, [w15++]
    35b0:	8a 9f be    	mov.d     w10, [w15++]
    35b2:	8c 9f be    	mov.d     w12, [w15++]
    35b4:	03 86 6b    	xor.w     w7, w3, w12
    35b6:	05 f5 07    	rcall     0x1fc2 <__dunpack2>
    35b8:	00 28 a3    	btst.z    w0, #0x2
    35ba:	64 00 3a    	bra       NZ, 0x3684 <aisinfinite>
    35bc:	01 28 a3    	btst.z    w1, #0x2
    35be:	67 00 3a    	bra       NZ, 0x368e <bisinfinite>
    35c0:	00 08 a3    	btst.z    w0, #0x0
    35c2:	62 00 3a    	bra       NZ, 0x3688 <returna> <returnab>
    35c4:	01 08 a3    	btst.z    w1, #0x0
    35c6:	65 00 3a    	bra       NZ, 0x3692 <returnb>
    35c8:	1e 00 90    	mov.w     [w14+2], w0
    35ca:	be 08 90    	mov.w     [w14+22], w1
    35cc:	81 06 40    	add.w     w0, w1, w13
    35ce:	ed 3f b1    	sub.w     #0x3fe, w13
    35d0:	f4 80 57    	sub.w     w15, #0x14, w1
    35d2:	ee 01 90    	mov.w     [w14+12], w3
    35d4:	11 1a b8    	mul.uu    w3, [w1], w4
    35d6:	8e 09 90    	mov.w     [w14+16], w3
    35d8:	31 1b b8    	mul.uu    w3, [w1++], w6
    35da:	9e 09 90    	mov.w     [w14+18], w3
    35dc:	31 1c b8    	mul.uu    w3, [w1++], w8
    35de:	51 1d b8    	mul.uu    w3, [++w1], w10
    35e0:	f4 85 57    	sub.w     w15, #0x14, w11
    35e2:	46 00 07    	rcall     0x3670 <muladd7>
    35e4:	fe 01 90    	mov.w     [w14+14], w3
    35e6:	3a 00 07    	rcall     0x365c <muladd5>
    35e8:	8b 85 e8    	inc2.w    w11, w11
    35ea:	3e 00 07    	rcall     0x3668 <muladd6>
    35ec:	8e 09 90    	mov.w     [w14+16], w3
    35ee:	40 00 07    	rcall     0x3670 <muladd7>
    35f0:	ee 01 90    	mov.w     [w14+12], w3
    35f2:	34 00 07    	rcall     0x365c <muladd5>
    35f4:	8b 85 e8    	inc2.w    w11, w11
    35f6:	38 00 07    	rcall     0x3668 <muladd6>
    35f8:	8e 09 90    	mov.w     [w14+16], w3
    35fa:	40 00 07    	rcall     0x367c <muladd8>
    35fc:	9e 09 90    	mov.w     [w14+18], w3
    35fe:	1b 18 b8    	mul.uu    w3, [w11], w0
    3600:	89 04 40    	add.w     w0, w9, w9
    3602:	0a 85 48    	addc.w    w1, w10, w10
    3604:	fe 01 90    	mov.w     [w14+14], w3
    3606:	34 00 07    	rcall     0x3670 <muladd7>
    3608:	8b 85 e8    	inc2.w    w11, w11
    360a:	38 00 07    	rcall     0x367c <muladd8>
    360c:	ee 01 90    	mov.w     [w14+12], w3
    360e:	30 00 07    	rcall     0x3670 <muladd7>
    3610:	8e 09 90    	mov.w     [w14+16], w3
    3612:	1b 18 b8    	mul.uu    w3, [w11], w0
    3614:	89 04 40    	add.w     w0, w9, w9
    3616:	0a 85 48    	addc.w    w1, w10, w10
    3618:	0a 98 a3    	btst.z    w10, #0x9
    361a:	08 00 3a    	bra       NZ, 0x362c <formsticky>
    361c:	04 02 42    	add.w     w4, w4, w4
    361e:	85 82 4a    	addc.w    w5, w5, w5
    3620:	06 03 4b    	addc.w    w6, w6, w6
    3622:	87 83 4b    	addc.w    w7, w7, w7
    3624:	08 04 4c    	addc.w    w8, w8, w8
    3626:	89 84 4c    	addc.w    w9, w9, w9
    3628:	0a 05 4d    	addc.w    w10, w10, w10
    362a:	8d 06 e9    	dec.w     w13, w13

0000362c <formsticky>:
    362c:	84 82 72    	ior.w     w5, w4, w5
    362e:	85 02 73    	ior.w     w6, w5, w5
    3630:	4c 3a dd    	sl.w      w7, #0xc, w4
    3632:	85 02 72    	ior.w     w4, w5, w5
    3634:	01 00 32    	bra       Z, 0x3638 <formRandSig>
    3636:	15 00 20    	mov.w     #0x1, w5

00003638 <formRandSig>:
    3638:	44 3a de    	lsr.w     w7, #0x4, w4
    363a:	14 00 b2    	and.w     #0x1, w4
    363c:	45 38 de    	lsr.w     w7, #0x5, w0
    363e:	cb 45 dd    	sl.w      w8, #0xb, w11
    3640:	0b 00 70    	ior.w     w0, w11, w0
    3642:	c5 40 de    	lsr.w     w8, #0x5, w1
    3644:	cb 4d dd    	sl.w      w9, #0xb, w11
    3646:	8b 80 70    	ior.w     w1, w11, w1
    3648:	45 49 de    	lsr.w     w9, #0x5, w2
    364a:	cb 55 dd    	sl.w      w10, #0xb, w11
    364c:	0b 01 71    	ior.w     w2, w11, w2
    364e:	c5 51 de    	lsr.w     w10, #0x5, w3
    3650:	0d 03 78    	mov.w     w13, w6
    3652:	e8 fe 07    	rcall     0x3424 <__dpack>

00003654 <signoff>:
    3654:	03 f0 a1    	bclr.w    w3, #0xf
    3656:	0c f0 a7    	btsc.w    w12, #0xf
    3658:	03 f0 a0    	bset.w    w3, #0xf
    365a:	c7 f4 37    	bra       0x1fea <__dunpack2exit>

0000365c <muladd5>:
    365c:	1b 18 b8    	mul.uu    w3, [w11], w0
    365e:	85 02 40    	add.w     w0, w5, w5
    3660:	06 83 48    	addc.w    w1, w6, w6
    3662:	e0 83 4b    	addc.w    w7, #0x0, w7

00003664 <carry8>:
    3664:	60 04 4c    	addc.w    w8, #0x0, w8
    3666:	07 00 37    	bra       0x3676 <carry9>

00003668 <muladd6>:
    3668:	1b 18 b8    	mul.uu    w3, [w11], w0
    366a:	06 03 40    	add.w     w0, w6, w6
    366c:	87 83 48    	addc.w    w1, w7, w7
    366e:	fa ff 37    	bra       0x3664 <carry8>

00003670 <muladd7>:
    3670:	1b 18 b8    	mul.uu    w3, [w11], w0
    3672:	87 03 40    	add.w     w0, w7, w7
    3674:	08 84 48    	addc.w    w1, w8, w8

00003676 <carry9>:
    3676:	e0 84 4c    	addc.w    w9, #0x0, w9

00003678 <carrya>:
    3678:	60 05 4d    	addc.w    w10, #0x0, w10
    367a:	00 00 06    	return    

0000367c <muladd8>:
    367c:	1b 18 b8    	mul.uu    w3, [w11], w0
    367e:	08 04 40    	add.w     w0, w8, w8
    3680:	89 84 48    	addc.w    w1, w9, w9
    3682:	fa ff 37    	bra       0x3678 <carrya>

00003684 <aisinfinite>:
    3684:	01 08 a3    	btst.z    w1, #0x0
    3686:	ae f4 3a    	bra       NZ, 0x1fe4 <__dreturnNaN>

00003688 <returna>:
    3688:	58 00 be    	mov.d     [++w8], w0
    368a:	58 01 be    	mov.d     [++w8], w2
    368c:	e3 ff 37    	bra       0x3654 <signoff>

0000368e <bisinfinite>:
    368e:	00 08 a3    	btst.z    w0, #0x0
    3690:	a9 f4 3a    	bra       NZ, 0x1fe4 <__dreturnNaN>

00003692 <returnb>:
    3692:	09 04 78    	mov.w     w9, w8
    3694:	f9 ff 37    	bra       0x3688 <returna> <returnab>

00003696 <___subdf3>:
    3696:	07 f0 a2    	btg.w     w7, #0xf
    3698:	df fd 37    	bra       0x3258 <___adddf3> <L0>

0000369a <___mulp32eds3>:
    369a:	02 0a b9    	mul.su    w1, w2, w4
    369c:	00 1b b9    	mul.su    w3, w0, w6
    369e:	02 00 b8    	mul.uu    w0, w2, w0
    36a0:	81 00 42    	add.w     w4, w1, w1
    36a2:	81 00 43    	add.w     w6, w1, w1
    36a4:	00 00 06    	return    

000036a6 <___PplusBdi>:
    36a6:	88 9f be    	mov.d     w8, [w15++]
    36a8:	8a 9f be    	mov.d     w10, [w15++]
    36aa:	30 04 42    	add.w     w4, [w0++], w8
    36ac:	b0 84 4a    	addc.w    w5, [w0++], w9
    36ae:	30 05 4b    	addc.w    w6, [w0++], w10
    36b0:	90 85 4b    	addc.w    w7, [w0], w11
    36b2:	60 00 b1    	sub.w     #0x6, w0
    36b4:	08 98 be    	mov.d     w8, [w0++]
    36b6:	0a 90 be    	mov.d     w10, [w0--]
    36b8:	04 40 e1    	cp.w      w8, w4
    36ba:	05 c8 e1    	cpb.w     w9, w5
    36bc:	06 d0 e1    	cpb.w     w10, w6
    36be:	07 d8 e1    	cpb.w     w11, w7
    36c0:	02 00 31    	bra       C, 0x36c6 <.L1>
    36c2:	68 00 40    	add.w     w0, #0x8, w0
    36c4:	10 08 e8    	inc.w     [w0], [w0]

000036c6 <.L1>:
    36c6:	4f 05 be    	mov.d     [--w15], w10
    36c8:	4f 04 be    	mov.d     [--w15], w8
    36ca:	00 00 06    	return    

000036cc <___PminusBdi>:
    36cc:	88 9f be    	mov.d     w8, [w15++]
    36ce:	8a 9f be    	mov.d     w10, [w15++]
    36d0:	30 04 be    	mov.d     [w0++], w8
    36d2:	20 05 be    	mov.d     [w0--], w10
    36d4:	04 18 54    	sub.w     w8, w4, [w0++]
    36d6:	05 98 5c    	subb.w    w9, w5, [w0++]
    36d8:	06 18 5d    	subb.w    w10, w6, [w0++]
    36da:	07 98 5d    	subb.w    w11, w7, [w0++]
    36dc:	11 00 20    	mov.w     #0x1, w1
    36de:	04 40 e1    	cp.w      w8, w4
    36e0:	05 c8 e1    	cpb.w     w9, w5
    36e2:	06 d0 e1    	cpb.w     w10, w6
    36e4:	07 d8 e1    	cpb.w     w11, w7
    36e6:	01 00 39    	bra       NC, 0x36ea <.L4>
    36e8:	80 00 eb    	clr.w     w1

000036ea <.L4>:
    36ea:	10 88 10    	subr.w    w1, [w0], [w0]
    36ec:	4f 05 be    	mov.d     [--w15], w10
    36ee:	4f 04 be    	mov.d     [--w15], w8
    36f0:	00 00 06    	return    

000036f2 <___udivmoddi3>:
    36f2:	12 00 fa    	lnk       #0x12
    36f4:	88 9f be    	mov.d     w8, [w15++]
    36f6:	8a 9f be    	mov.d     w10, [w15++]
    36f8:	8c 9f be    	mov.d     w12, [w15++]
    36fa:	e0 b7 9f    	mov.w     w0, [w15-20]
    36fc:	f1 b7 9f    	mov.w     w1, [w15-18]
    36fe:	82 bf 9f    	mov.w     w2, [w15-16]
    3700:	93 bf 9f    	mov.w     w3, [w15-14]
    3702:	06 05 be    	mov.d     w6, w10
    3704:	04 04 be    	mov.d     w4, w8
    3706:	00 00 eb    	clr.w     w0
    3708:	d0 b7 9f    	mov.w     w0, [w15-22]
    370a:	c0 b7 9f    	mov.w     w0, [w15-24]
    370c:	b0 b7 9f    	mov.w     w0, [w15-26]
    370e:	a0 b7 9f    	mov.w     w0, [w15-28]
    3710:	90 b7 9f    	mov.w     w0, [w15-30]
    3712:	00 06 eb    	clr.w     w12

00003714 <.L9>:
    3714:	5f b1 97    	mov.w     [w15-22], w2
    3716:	cf b0 97    	mov.w     [w15-24], w1
    3718:	82 01 41    	add.w     w2, w2, w3
    371a:	3f b0 97    	mov.w     [w15-26], w0
    371c:	02 00 e0    	cp0.w     w2
    371e:	04 00 3d    	bra       GE, 0x3728 <.L6>
    3720:	37 00 07    	rcall     0x3790 <.LPA0>
    3722:	7e 80 57    	sub.w     w15, #0x1e, w0
    3724:	c0 ff 07    	rcall     0x36a6 <___PplusBdi>
    3726:	03 00 37    	bra       0x372e <.L7>

00003728 <.L6>:
    3728:	33 00 07    	rcall     0x3790 <.LPA0>
    372a:	7e 80 57    	sub.w     w15, #0x1e, w0
    372c:	cf ff 07    	rcall     0x36cc <___PminusBdi> <L0>

0000372e <.L7>:
    372e:	df b6 97    	mov.w     [w15-22], w13
    3730:	0d 00 e0    	cp0.w     w13
    3732:	0c 00 35    	bra       LT, 0x374c <.L8>
    3734:	6f b2 97    	mov.w     [w15-20], w4
    3736:	ff b2 97    	mov.w     [w15-18], w5
    3738:	0f bb 97    	mov.w     [w15-16], w6
    373a:	9f bb 97    	mov.w     [w15-14], w7
    373c:	10 00 20    	mov.w     #0x1, w0
    373e:	01 00 20    	mov.w     #0x0, w1
    3740:	60 11 b8    	mul.uu    w2, #0x0, w2
    3742:	00 02 72    	ior.w     w4, w0, w4
    3744:	81 82 72    	ior.w     w5, w1, w5
    3746:	02 03 73    	ior.w     w6, w2, w6
    3748:	83 83 73    	ior.w     w7, w3, w7
    374a:	1b 00 07    	rcall     0x3782 <L0> <.LPA2>

0000374c <.L8>:
    374c:	0c 06 e8    	inc.w     w12, w12
    374e:	01 04 20    	mov.w     #0x40, w1
    3750:	81 0f 56    	sub.w     w12, w1, [w15]
    3752:	e0 ff 3a    	bra       NZ, 0x3714 <.L9>
    3754:	0d 00 e0    	cp0.w     w13
    3756:	04 00 3d    	bra       GE, 0x3760 <.L10>
    3758:	08 02 be    	mov.d     w8, w4
    375a:	0a 03 be    	mov.d     w10, w6
    375c:	7e 80 57    	sub.w     w15, #0x1e, w0
    375e:	a3 ff 07    	rcall     0x36a6 <___PplusBdi>

00003760 <.L10>:
    3760:	5f a8 97    	mov.w     [w15-38], w0
    3762:	00 00 e0    	cp0.w     w0
    3764:	05 00 3a    	bra       NZ, 0x3770 <.L11>
    3766:	1f b2 97    	mov.w     [w15-30], w4
    3768:	af b2 97    	mov.w     [w15-28], w5
    376a:	3f b3 97    	mov.w     [w15-26], w6
    376c:	cf b3 97    	mov.w     [w15-24], w7
    376e:	09 00 07    	rcall     0x3782 <L0> <.LPA2>

00003770 <.L11>:
    3770:	6f b0 97    	mov.w     [w15-20], w0
    3772:	ff b0 97    	mov.w     [w15-18], w1
    3774:	0f b9 97    	mov.w     [w15-16], w2
    3776:	9f b9 97    	mov.w     [w15-14], w3
    3778:	4f 06 be    	mov.d     [--w15], w12
    377a:	4f 05 be    	mov.d     [--w15], w10
    377c:	4f 04 be    	mov.d     [--w15], w8
    377e:	00 80 fa    	ulnk      
    3780:	00 00 06    	return    

00003782 <L0>:
    3782:	01 00 07    	rcall     0x3786 <.LPA5>
    3784:	00 00 06    	return    

00003786 <.LPA5>:
    3786:	a4 b7 9f    	mov.w     w4, [w15-28]
    3788:	b5 b7 9f    	mov.w     w5, [w15-26]
    378a:	c6 b7 9f    	mov.w     w6, [w15-24]
    378c:	d7 b7 9f    	mov.w     w7, [w15-22]
    378e:	00 00 06    	return    

00003790 <.LPA0>:
    3790:	4f 09 de    	lsr.w     w1, #0xf, w2
    3792:	82 81 71    	ior.w     w3, w2, w3
    3794:	b3 b7 9f    	mov.w     w3, [w15-26]
    3796:	4f 01 de    	lsr.w     w0, #0xf, w2
    3798:	81 80 40    	add.w     w1, w1, w1
    379a:	82 80 70    	ior.w     w1, w2, w1
    379c:	a1 b7 9f    	mov.w     w1, [w15-28]
    379e:	8f b0 97    	mov.w     [w15-32], w1
    37a0:	4f 09 de    	lsr.w     w1, #0xf, w2
    37a2:	00 00 40    	add.w     w0, w0, w0
    37a4:	02 00 70    	ior.w     w0, w2, w0
    37a6:	90 b7 9f    	mov.w     w0, [w15-30]
    37a8:	7f a8 97    	mov.w     [w15-34], w0
    37aa:	4f 01 de    	lsr.w     w0, #0xf, w2
    37ac:	81 80 40    	add.w     w1, w1, w1
    37ae:	82 80 70    	ior.w     w1, w2, w1
    37b0:	81 b7 9f    	mov.w     w1, [w15-32]
    37b2:	0d 00 07    	rcall     0x37ce <.LPA4>
    37b4:	4f 3a de    	lsr.w     w7, #0xf, w4
    37b6:	00 00 40    	add.w     w0, w0, w0
    37b8:	04 00 70    	ior.w     w0, w4, w0
    37ba:	f0 af 9f    	mov.w     w0, [w15-34]
    37bc:	08 00 07    	rcall     0x37ce <.LPA4>
    37be:	04 02 42    	add.w     w4, w4, w4
    37c0:	85 82 4a    	addc.w    w5, w5, w5
    37c2:	06 03 4b    	addc.w    w6, w6, w6
    37c4:	87 83 4b    	addc.w    w7, w7, w7
    37c6:	df ff 07    	rcall     0x3786 <.LPA5>
    37c8:	08 02 be    	mov.d     w8, w4
    37ca:	0a 03 be    	mov.d     w10, w6
    37cc:	00 00 06    	return    

000037ce <.LPA4>:
    37ce:	2f b2 97    	mov.w     [w15-28], w4
    37d0:	bf b2 97    	mov.w     [w15-26], w5
    37d2:	4f b3 97    	mov.w     [w15-24], w6
    37d4:	df b3 97    	mov.w     [w15-22], w7
    37d6:	00 00 06    	return    

000037d8 <___udivdi3>:
    37d8:	88 1f 78    	mov.w     w8, [w15++]
    37da:	18 00 20    	mov.w     #0x1, w8
    37dc:	88 1f 78    	mov.w     w8, [w15++]
    37de:	89 ff 07    	rcall     0x36f2 <___udivmoddi3> <L0>
    37e0:	8f 87 e9    	dec2.w    w15, w15
    37e2:	4f 04 78    	mov.w     [--w15], w8
    37e4:	00 00 06    	return    

000037e6 <___umoddi3>:
    37e6:	80 1f eb    	clr.w     [w15++]
    37e8:	84 ff 07    	rcall     0x36f2 <___udivmoddi3> <L0>
    37ea:	8f 87 e9    	dec2.w    w15, w15
    37ec:	00 00 06    	return    

000037ee <___divdi3>:
    37ee:	88 9f be    	mov.d     w8, [w15++]
    37f0:	8a 9f be    	mov.d     w10, [w15++]
    37f2:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    37f4:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    37f6:	e0 0f 59    	subb.w    w2, #0x0, [w15]
    37f8:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    37fa:	0c 00 3d    	bra       GE, 0x3814 <.L15>
    37fc:	60 44 b8    	mul.uu    w8, #0x0, w8
    37fe:	60 55 b8    	mul.uu    w10, #0x0, w10
    3800:	00 00 54    	sub.w     w8, w0, w0
    3802:	81 80 5c    	subb.w    w9, w1, w1
    3804:	02 01 5d    	subb.w    w10, w2, w2
    3806:	83 81 5d    	subb.w    w11, w3, w3
    3808:	18 00 20    	mov.w     #0x1, w8
    380a:	15 00 07    	rcall     0x3836 <L0> <.LPA3>
    380c:	08 00 3d    	bra       GE, 0x381e <.L16>
    380e:	18 00 07    	rcall     0x3840 <.LPA1>
    3810:	00 04 eb    	clr.w     w8
    3812:	05 00 37    	bra       0x381e <.L16>

00003814 <.L15>:
    3814:	00 04 eb    	clr.w     w8
    3816:	0f 00 07    	rcall     0x3836 <L0> <.LPA3>
    3818:	02 00 3d    	bra       GE, 0x381e <.L16>
    381a:	12 00 07    	rcall     0x3840 <.LPA1>
    381c:	18 00 20    	mov.w     #0x1, w8

0000381e <.L16>:
    381e:	dc ff 07    	rcall     0x37d8 <___udivdi3>
    3820:	08 00 e0    	cp0.w     w8
    3822:	06 00 32    	bra       Z, 0x3830 <.L17>
    3824:	60 22 b8    	mul.uu    w4, #0x0, w4
    3826:	60 33 b8    	mul.uu    w6, #0x0, w6
    3828:	00 00 52    	sub.w     w4, w0, w0
    382a:	81 80 5a    	subb.w    w5, w1, w1
    382c:	02 01 5b    	subb.w    w6, w2, w2
    382e:	83 81 5b    	subb.w    w7, w3, w3

00003830 <.L17>:
    3830:	4f 05 be    	mov.d     [--w15], w10
    3832:	4f 04 be    	mov.d     [--w15], w8
    3834:	00 00 06    	return    

00003836 <L0>:
    3836:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    3838:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    383a:	e0 0f 5b    	subb.w    w6, #0x0, [w15]
    383c:	e0 8f 5b    	subb.w    w7, #0x0, [w15]
    383e:	00 00 06    	return    

00003840 <.LPA1>:
    3840:	60 44 b8    	mul.uu    w8, #0x0, w8
    3842:	60 55 b8    	mul.uu    w10, #0x0, w10
    3844:	04 02 54    	sub.w     w8, w4, w4
    3846:	85 82 5c    	subb.w    w9, w5, w5
    3848:	06 03 5d    	subb.w    w10, w6, w6
    384a:	87 83 5d    	subb.w    w11, w7, w7
    384c:	00 00 06    	return    

0000384e <___moddi3>:
    384e:	88 9f be    	mov.d     w8, [w15++]
    3850:	8a 9f be    	mov.d     w10, [w15++]
    3852:	8c 1f 78    	mov.w     w12, [w15++]
    3854:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    3856:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    3858:	e0 0f 59    	subb.w    w2, #0x0, [w15]
    385a:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    385c:	0d 00 3d    	bra       GE, 0x3878 <.L21>
    385e:	60 44 b8    	mul.uu    w8, #0x0, w8
    3860:	60 55 b8    	mul.uu    w10, #0x0, w10
    3862:	00 00 54    	sub.w     w8, w0, w0
    3864:	81 80 5c    	subb.w    w9, w1, w1
    3866:	02 01 5d    	subb.w    w10, w2, w2
    3868:	83 81 5d    	subb.w    w11, w3, w3
    386a:	1c 00 20    	mov.w     #0x1, w12
    386c:	08 20 e1    	cp.w      w4, w8
    386e:	09 a8 e1    	cpb.w     w5, w9
    3870:	0a b0 e1    	cpb.w     w6, w10
    3872:	0b b8 e1    	cpb.w     w7, w11
    3874:	0d 00 3d    	bra       GE, 0x3890 <.L22>
    3876:	08 00 37    	bra       0x3888 <.L26>

00003878 <.L21>:
    3878:	00 06 eb    	clr.w     w12
    387a:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    387c:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    387e:	e0 0f 5b    	subb.w    w6, #0x0, [w15]
    3880:	e0 8f 5b    	subb.w    w7, #0x0, [w15]
    3882:	06 00 3d    	bra       GE, 0x3890 <.L22>
    3884:	60 44 b8    	mul.uu    w8, #0x0, w8
    3886:	60 55 b8    	mul.uu    w10, #0x0, w10

00003888 <.L26>:
    3888:	04 02 54    	sub.w     w8, w4, w4
    388a:	85 82 5c    	subb.w    w9, w5, w5
    388c:	06 03 5d    	subb.w    w10, w6, w6
    388e:	87 83 5d    	subb.w    w11, w7, w7

00003890 <.L22>:
    3890:	aa ff 07    	rcall     0x37e6 <___umoddi3> <L0>
    3892:	0c 00 e0    	cp0.w     w12
    3894:	06 00 32    	bra       Z, 0x38a2 <.L23>
    3896:	60 22 b8    	mul.uu    w4, #0x0, w4
    3898:	60 33 b8    	mul.uu    w6, #0x0, w6
    389a:	00 00 52    	sub.w     w4, w0, w0
    389c:	81 80 5a    	subb.w    w5, w1, w1
    389e:	02 01 5b    	subb.w    w6, w2, w2
    38a0:	83 81 5b    	subb.w    w7, w3, w3

000038a2 <.L23>:
    38a2:	4f 06 78    	mov.w     [--w15], w12
    38a4:	4f 05 be    	mov.d     [--w15], w10
    38a6:	4f 04 be    	mov.d     [--w15], w8
    38a8:	00 00 06    	return    

000038aa <___muldi3>:
    38aa:	88 9f be    	mov.d     w8, [w15++]
    38ac:	8a 9f be    	mov.d     w10, [w15++]
    38ae:	8c 1f 78    	mov.w     w12, [w15++]
    38b0:	00 06 eb    	clr.w     w12
    38b2:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    38b4:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    38b6:	e0 0f 59    	subb.w    w2, #0x0, [w15]
    38b8:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    38ba:	07 00 3d    	bra       GE, 0x38ca <.L2>
    38bc:	60 44 b8    	mul.uu    w8, #0x0, w8
    38be:	60 55 b8    	mul.uu    w10, #0x0, w10
    38c0:	00 00 54    	sub.w     w8, w0, w0
    38c2:	81 80 5c    	subb.w    w9, w1, w1
    38c4:	02 01 5d    	subb.w    w10, w2, w2
    38c6:	83 81 5d    	subb.w    w11, w3, w3
    38c8:	1c 00 20    	mov.w     #0x1, w12

000038ca <.L2>:
    38ca:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    38cc:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    38ce:	e0 0f 5b    	subb.w    w6, #0x0, [w15]
    38d0:	e0 8f 5b    	subb.w    w7, #0x0, [w15]
    38d2:	07 00 3d    	bra       GE, 0x38e2 <.L3>
    38d4:	60 44 b8    	mul.uu    w8, #0x0, w8
    38d6:	60 55 b8    	mul.uu    w10, #0x0, w10
    38d8:	04 02 54    	sub.w     w8, w4, w4
    38da:	85 82 5c    	subb.w    w9, w5, w5
    38dc:	06 03 5d    	subb.w    w10, w6, w6
    38de:	87 83 5d    	subb.w    w11, w7, w7
    38e0:	0c 00 a2    	btg.w     w12, #0x0

000038e2 <.L3>:
    38e2:	47 00 07    	rcall     0x3972 <___umuldi3>
    38e4:	0c 00 e0    	cp0.w     w12
    38e6:	06 00 32    	bra       Z, 0x38f4 <.L4>
    38e8:	60 22 b8    	mul.uu    w4, #0x0, w4
    38ea:	60 33 b8    	mul.uu    w6, #0x0, w6
    38ec:	00 00 52    	sub.w     w4, w0, w0
    38ee:	81 80 5a    	subb.w    w5, w1, w1
    38f0:	02 01 5b    	subb.w    w6, w2, w2
    38f2:	83 81 5b    	subb.w    w7, w3, w3

000038f4 <.L4>:
    38f4:	4f 06 78    	mov.w     [--w15], w12
    38f6:	4f 05 be    	mov.d     [--w15], w10
    38f8:	4f 04 be    	mov.d     [--w15], w8
    38fa:	00 00 06    	return    

000038fc <__dcompare>:
    38fc:	88 9f be    	mov.d     w8, [w15++]
    38fe:	8a 9f be    	mov.d     w10, [w15++]
    3900:	8c 9f be    	mov.d     w12, [w15++]
    3902:	04 04 be    	mov.d     w4, w8
    3904:	06 05 be    	mov.d     w6, w10
    3906:	80 9f be    	mov.d     w0, [w15++]
    3908:	82 9f be    	mov.d     w2, [w15++]
    390a:	21 00 07    	rcall     0x394e <__dtype>
    390c:	04 06 78    	mov.w     w4, w12
    390e:	08 00 be    	mov.d     w8, w0
    3910:	0a 01 be    	mov.d     w10, w2
    3912:	1d 00 07    	rcall     0x394e <__dtype>
    3914:	84 06 78    	mov.w     w4, w13
    3916:	4f 03 be    	mov.d     [--w15], w6
    3918:	4f 02 be    	mov.d     [--w15], w4
    391a:	8d 4f 76    	ior.b     w12, w13, [w15]
    391c:	7f b0 97    	mov.w     [w15-18], w0
    391e:	13 00 33    	bra       N, 0x3946 <exit>
    3920:	f0 ff 2f    	mov.w     #0xffff, w0
    3922:	8b 8f 6b    	xor.w     w7, w11, [w15]
    3924:	06 00 3b    	bra       NN, 0x3932 <comparemag>
    3926:	0d 06 66    	and.w     w12, w13, w12
    3928:	0c 00 a7    	btsc.w    w12, #0x0
    392a:	0a 00 37    	bra       0x3940 <returnEqual>
    392c:	07 f0 a6    	btss.w    w7, #0xf
    392e:	10 00 20    	mov.w     #0x1, w0
    3930:	0a 00 37    	bra       0x3946 <exit>

00003932 <comparemag>:
    3932:	88 0f 52    	sub.w     w4, w8, [w15]
    3934:	89 8f 5a    	subb.w    w5, w9, [w15]
    3936:	8a 0f 5b    	subb.w    w6, w10, [w15]
    3938:	8b 8f 5b    	subb.w    w7, w11, [w15]
    393a:	03 00 39    	bra       NC, 0x3942 <adjust>
    393c:	10 00 20    	mov.w     #0x1, w0
    393e:	01 00 3e    	bra       GTU, 0x3942 <adjust>

00003940 <returnEqual>:
    3940:	00 00 20    	mov.w     #0x0, w0

00003942 <adjust>:
    3942:	07 f0 a7    	btsc.w    w7, #0xf
    3944:	00 00 ea    	neg.w     w0, w0

00003946 <exit>:
    3946:	4f 06 be    	mov.d     [--w15], w12
    3948:	4f 05 be    	mov.d     [--w15], w10
    394a:	4f 04 be    	mov.d     [--w15], w8
    394c:	00 00 06    	return    

0000394e <__dtype>:
    394e:	05 ff 27    	mov.w     #0x7ff0, w5
    3950:	05 82 61    	and.w     w3, w5, w4
    3952:	07 00 32    	bra       Z, 0x3962 <zeroorsub>
    3954:	04 28 e1    	cp.w      w5, w4
    3956:	01 00 32    	bra       Z, 0x395a <NaNorInf>

00003958 <isFinite>:
    3958:	24 00 05    	retlw.w   #0x2, w4

0000395a <NaNorInf>:
    395a:	06 00 07    	rcall     0x3968 <checkfrac>
    395c:	01 00 3a    	bra       NZ, 0x3960 <isNaN>
    395e:	44 00 05    	retlw.w   #0x4, w4

00003960 <isNaN>:
    3960:	04 08 05    	retlw.w   #0x80, w4

00003962 <zeroorsub>:
    3962:	02 00 07    	rcall     0x3968 <checkfrac>
    3964:	f9 ff 3a    	bra       NZ, 0x3958 <isFinite>
    3966:	14 00 05    	retlw.w   #0x1, w4

00003968 <checkfrac>:
    3968:	6f 82 61    	and.w     w3, #0xf, w4
    396a:	81 02 70    	ior.w     w0, w1, w5
    396c:	85 02 71    	ior.w     w2, w5, w5
    396e:	85 02 72    	ior.w     w4, w5, w5
    3970:	00 00 06    	return    

00003972 <___umuldi3>:
    3972:	88 9f be    	mov.d     w8, [w15++]
    3974:	8a 9f be    	mov.d     w10, [w15++]
    3976:	8c 9f be    	mov.d     w12, [w15++]
    3978:	04 04 b8    	mul.uu    w0, w4, w8
    397a:	05 06 b8    	mul.uu    w0, w5, w12
    397c:	89 04 46    	add.w     w12, w9, w9
    397e:	60 85 4e    	addc.w    w13, #0x0, w10
    3980:	06 06 b8    	mul.uu    w0, w6, w12
    3982:	0a 05 46    	add.w     w12, w10, w10
    3984:	e0 85 4e    	addc.w    w13, #0x0, w11
    3986:	07 06 b8    	mul.uu    w0, w7, w12
    3988:	8b 05 46    	add.w     w12, w11, w11
    398a:	04 0e b8    	mul.uu    w1, w4, w12
    398c:	89 04 46    	add.w     w12, w9, w9
    398e:	0a 85 4e    	addc.w    w13, w10, w10
    3990:	e0 85 4d    	addc.w    w11, #0x0, w11
    3992:	05 0e b8    	mul.uu    w1, w5, w12
    3994:	0a 05 46    	add.w     w12, w10, w10
    3996:	8b 85 4e    	addc.w    w13, w11, w11
    3998:	06 0e b8    	mul.uu    w1, w6, w12
    399a:	8b 05 46    	add.w     w12, w11, w11
    399c:	04 16 b8    	mul.uu    w2, w4, w12
    399e:	0a 05 46    	add.w     w12, w10, w10
    39a0:	8b 85 4e    	addc.w    w13, w11, w11
    39a2:	05 16 b8    	mul.uu    w2, w5, w12
    39a4:	8b 05 46    	add.w     w12, w11, w11
    39a6:	04 1e b8    	mul.uu    w3, w4, w12
    39a8:	8b 05 46    	add.w     w12, w11, w11
    39aa:	08 00 be    	mov.d     w8, w0
    39ac:	0a 01 be    	mov.d     w10, w2
    39ae:	4f 06 be    	mov.d     [--w15], w12
    39b0:	4f 05 be    	mov.d     [--w15], w10
    39b2:	4f 04 be    	mov.d     [--w15], w8
    39b4:	00 00 06    	return    
Disassembly of section __FGS:

00f80004 <__FGS.sec>:
  f80004:	cf ff 00    	nop       
Disassembly of section __FOSCSEL:

00f80006 <__FOSCSEL>:
  f80006:	fa ff 00    	nop       
Disassembly of section __FOSC:

00f80008 <__FOSC>:
  f80008:	39 ff 00    	nop       
Disassembly of section __FWDT:

00f8000a <__FWDT>:
  f8000a:	7f ff 00    	nop       
Disassembly of section __FPOR:

00f8000c <__FPOR>:
  f8000c:	d7 ff 00    	nop       
Disassembly of section __FICD:

00f8000e <__FICD>:
  f8000e:	dd ff 00    	nop       
Disassembly of section __FAS:

00f80010 <__FAS>:
  f80010:	cf ff 00    	nop       
Disassembly of section .ivt._T2Interrupt:

00000022 <.ivt._T2Interrupt>:
  22:	20 03 00    	nop       
Disassembly of section .ivt._MI2C2Interrupt:

00000078 <.ivt._MI2C2Interrupt>:
  78:	c4 07 00    	nop       
Disassembly of section .ivt._IC1Interrupt:

00000016 <.ivt._IC1Interrupt>:
  16:	d6 0f 00    	nop       
Disassembly of section .ivt._IC2Interrupt:

0000001e <.ivt._IC2Interrupt>:
  1e:	18 10 00    	nop       
Disassembly of section .ivt._IC3Interrupt:

0000005e <.ivt._IC3Interrupt>:
  5e:	5a 10 00    	nop       
Disassembly of section .ivt._IC4Interrupt:

00000060 <.ivt._IC4Interrupt>:
  60:	9c 10 00    	nop       
Disassembly of section .ivt._IC5Interrupt:

00000062 <.ivt._IC5Interrupt>:
  62:	de 10 00    	nop       
Disassembly of section .ivt._IC6Interrupt:

00000064 <.ivt._IC6Interrupt>:
  64:	20 11 00    	nop       
Disassembly of section .ivt._IC7Interrupt:

00000040 <.ivt._IC7Interrupt>:
  40:	62 11 00    	nop       
Disassembly of section .ivt._IC8Interrupt:

00000042 <.ivt._IC8Interrupt>:
  42:	a4 11 00    	nop       
Disassembly of section .ivt._SPI1Interrupt:

00000028 <.ivt._SPI1Interrupt>:
  28:	e6 11 00    	nop       
Disassembly of section .ivt._U1TXInterrupt:

0000002c <.ivt._U1TXInterrupt>:
  2c:	64 13 00    	nop       
Disassembly of section .ivt._U4TXInterrupt:

000000c6 <.ivt._U4TXInterrupt>:
  c6:	c0 13 00    	nop       
Disassembly of section .ivt._U1RXInterrupt:

0000002a <.ivt._U1RXInterrupt>:
  2a:	2c c9 00    	nop       
Disassembly of section .ivt._U4RXInterrupt:

000000c4 <.ivt._U4RXInterrupt>:
  c4:	b4 11 01    	call      w4
Disassembly of section .text:

00004796 <_mul_wide_u32>:
RT_MODEL_AUAV_V3_TestSensors_T *const AUAV_V3_TestSensors_M =
  &AUAV_V3_TestSensors_M_;
void mul_wide_u32(uint32_T in0, uint32_T in1, uint32_T *ptrOutBitsHi, uint32_T
                  *ptrOutBitsLo)
{
    4796:	08 00 fa    	lnk       #0x8
    4798:	88 9f be    	mov.d     w8, [w15++]
    479a:	8a 9f be    	mov.d     w10, [w15++]
    479c:	8c 9f be    	mov.d     w12, [w15++]
  uint32_T outBitsLo;
  uint32_T in0Lo;
  uint32_T in0Hi;
  uint32_T in1Lo;
  uint32_T in1Hi;
  uint32_T productHiLo;
  uint32_T productLoHi;
  in0Hi = in0 >> 16UL;
    479e:	40 0b de    	lsr.w     w1, #0x0, w6
    47a0:	07 00 20    	mov.w     #0x0, w7
  in0Lo = in0 & 65535UL;
    47a2:	61 05 b8    	mul.uu    w0, #0x1, w10
  in1Hi = in1 >> 16UL;
    47a4:	40 18 de    	lsr.w     w3, #0x0, w0
    47a6:	01 00 20    	mov.w     #0x0, w1
  in1Lo = in1 & 65535UL;
    47a8:	61 14 b8    	mul.uu    w2, #0x1, w8
    47aa:	e8 b7 9f    	mov.w     w8, [w15-20]
    47ac:	f9 b7 9f    	mov.w     w9, [w15-18]
  productHiLo = in0Hi * in1Lo;
    47ae:	ef b4 97    	mov.w     [w15-20], w9
    47b0:	89 bc b9    	.pword 0xb9bc89
    47b2:	09 06 78    	mov.w     w9, w12
    47b4:	06 61 b8    	mul.uu    w12, w6, w2
    47b6:	83 01 44    	add.w     w8, w3, w3
  productLoHi = in0Lo * in1Hi;
    47b8:	8a 8e b9    	.pword 0xb98e8a
    47ba:	0a 04 b8    	mul.uu    w0, w10, w8
    47bc:	89 04 46    	add.w     w12, w9, w9
  in0Lo *= in1Lo;
    47be:	ef b6 97    	mov.w     [w15-20], w13
    47c0:	8d de b9    	.pword 0xb9de8d
    47c2:	0a 6d b8    	mul.uu    w13, w10, w10
    47c4:	8b 05 46    	add.w     w12, w11, w11
  in1Lo = 0UL;
  outBitsLo = (productLoHi << 16UL) + in0Lo;
    47c6:	c0 46 dd    	sl.w      w8, #0x0, w13
    47c8:	0c 00 20    	mov.w     #0x0, w12
    47ca:	0c 06 45    	add.w     w10, w12, w12
    47cc:	8d 86 4d    	addc.w    w11, w13, w13
    47ce:	8c bf 9f    	mov.w     w12, [w15-16]
    47d0:	9d bf 9f    	mov.w     w13, [w15-14]
    47d2:	1c 00 20    	mov.w     #0x1, w12
    47d4:	0d 00 20    	mov.w     #0x0, w13
    47d6:	ec b7 9f    	mov.w     w12, [w15-20]
    47d8:	fd b7 9f    	mov.w     w13, [w15-18]
    47da:	0f be 97    	mov.w     [w15-16], w12
    47dc:	9f be 97    	mov.w     [w15-14], w13
    47de:	8c 0f 55    	sub.w     w10, w12, [w15]
    47e0:	8d 8f 5d    	subb.w    w11, w13, [w15]
    47e2:	03 00 3e    	bra       GTU, 0x47ea <.L2>
    47e4:	60 55 b8    	mul.uu    w10, #0x0, w10
    47e6:	ea b7 9f    	mov.w     w10, [w15-20]
    47e8:	fb b7 9f    	mov.w     w11, [w15-18]

000047ea <.L2>:
  if (outBitsLo < in0Lo) {
    in1Lo = 1UL;
  }

  in0Lo = outBitsLo;
  outBitsLo += productHiLo << 16UL;
    47ea:	c0 15 dd    	sl.w      w2, #0x0, w11
    47ec:	0a 00 20    	mov.w     #0x0, w10
    47ee:	0f be 97    	mov.w     [w15-16], w12
    47f0:	9f be 97    	mov.w     [w15-14], w13
    47f2:	0c 05 45    	add.w     w10, w12, w10
    47f4:	8d 85 4d    	addc.w    w11, w13, w11
  if (outBitsLo < in0Lo) {
    47f6:	8a 0f 56    	sub.w     w12, w10, [w15]
    47f8:	8b 8f 5e    	subb.w    w13, w11, [w15]
    47fa:	06 00 36    	bra       LEU, 0x4808 <.L3>
    in1Lo++;
    47fc:	6f b6 97    	mov.w     [w15-20], w12
    47fe:	ff b6 97    	mov.w     [w15-18], w13
    4800:	61 06 46    	add.w     w12, #0x1, w12
    4802:	e0 86 4e    	addc.w    w13, #0x0, w13
    4804:	ec b7 9f    	mov.w     w12, [w15-20]
    4806:	fd b7 9f    	mov.w     w13, [w15-18]

00004808 <.L3>:
  }

  *ptrOutBitsHi = (((productLoHi >> 16UL) + (productHiLo >> 16UL)) + in0Hi *
    4808:	40 4c de    	lsr.w     w9, #0x0, w8
    480a:	09 00 20    	mov.w     #0x0, w9
    480c:	40 19 de    	lsr.w     w3, #0x0, w2
    480e:	03 00 20    	mov.w     #0x0, w3
    4810:	08 01 41    	add.w     w2, w8, w2
    4812:	89 81 49    	addc.w    w3, w9, w3
    4814:	86 8e b9    	.pword 0xb98e86
    4816:	80 bc b9    	.pword 0xb9bc80
    4818:	08 06 46    	add.w     w12, w8, w12
    481a:	06 00 b8    	mul.uu    w0, w6, w0
    481c:	81 00 46    	add.w     w12, w1, w1
    481e:	02 00 40    	add.w     w0, w2, w0
    4820:	83 80 48    	addc.w    w1, w3, w1
                   in1Hi) + in1Lo;
    4822:	6f b1 97    	mov.w     [w15-20], w2
    4824:	ff b1 97    	mov.w     [w15-18], w3
    4826:	02 1a 40    	add.w     w0, w2, [w4++]
    4828:	03 92 48    	addc.w    w1, w3, [w4--]
  *ptrOutBitsLo = outBitsLo;
    482a:	8a 8a be    	mov.d     w10, [w5]
}
    482c:	4f 06 be    	mov.d     [--w15], w12
    482e:	4f 05 be    	mov.d     [--w15], w10
    4830:	4f 04 be    	mov.d     [--w15], w8
    4832:	00 80 fa    	ulnk      
    4834:	00 00 06    	return    

00004836 <_mul_u32_u32_u32_sr15>:

uint32_T mul_u32_u32_u32_sr15(uint32_T a, uint32_T b)
{
    4836:	08 00 fa    	lnk       #0x8

00004838 <.L0>:
  uint32_T result;
  uint32_T u32_chi;
  mul_wide_u32(a, b, &u32_chi, &result);
    4838:	e8 82 57    	sub.w     w15, #0x8, w5
    483a:	64 82 57    	sub.w     w15, #0x4, w4
    483c:	ac ff 07    	rcall     0x4796 <_mul_wide_u32> <.L0> <.LFB1465> <.Ltext0>

0000483e <.L0>:
  return u32_chi << 17UL | result >> 15UL;
    483e:	4f b9 97    	mov.w     [w15-8], w2
    4840:	df b9 97    	mov.w     [w15-6], w3
    4842:	41 18 dd    	sl.w      w3, #0x1, w0
    4844:	4f 11 de    	lsr.w     w2, #0xf, w2
    4846:	02 01 70    	ior.w     w0, w2, w2
    4848:	cf 19 de    	lsr.w     w3, #0xf, w3
    484a:	6f b8 97    	mov.w     [w15-4], w0
    484c:	ff b8 97    	mov.w     [w15-2], w1
    484e:	c1 00 dd    	sl.w      w0, #0x1, w1
    4850:	00 00 20    	mov.w     #0x0, w0
    4852:	00 00 71    	ior.w     w2, w0, w0
    4854:	81 80 71    	ior.w     w3, w1, w1
}
    4856:	00 80 fa    	ulnk      
    4858:	00 00 06    	return    

0000485a <_mul_wide_s32>:

void mul_wide_s32(int32_T in0, int32_T in1, uint32_T *ptrOutBitsHi, uint32_T
                  *ptrOutBitsLo)
{
    485a:	f2 87 47    	add.w     w15, #0x12, w15
    485c:	88 9f be    	mov.d     w8, [w15++]
    485e:	8a 9f be    	mov.d     w10, [w15++]
    4860:	8c 9f be    	mov.d     w12, [w15++]
    4862:	8e 1f 78    	mov.w     w14, [w15++]
    4864:	f4 b7 9f    	mov.w     w4, [w15-18]
    4866:	85 bf 9f    	mov.w     w5, [w15-16]
  uint32_T absIn0;
  uint32_T absIn1;
  uint32_T in0Lo;
  uint32_T in0Hi;
  uint32_T in1Hi;
  uint32_T productHiLo;
  uint32_T productLoHi;
  absIn0 = (uint32_T)(in0 < 0L ? -in0 : in0);
    4868:	00 06 be    	mov.d     w0, w12
    486a:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    486c:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    486e:	02 00 3d    	bra       GE, 0x4874 <.L6>
    4870:	60 06 10    	subr.w    w0, #0x0, w12
    4872:	e0 86 18    	subbr.w   w1, #0x0, w13

00004874 <.L6>:
  absIn1 = (uint32_T)(in1 < 0L ? -in1 : in1);
    4874:	02 05 be    	mov.d     w2, w10
    4876:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4878:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    487a:	02 00 3d    	bra       GE, 0x4880 <.L7>
    487c:	60 05 11    	subr.w    w2, #0x0, w10
    487e:	e0 85 19    	subbr.w   w3, #0x0, w11

00004880 <.L7>:
  in0Hi = absIn0 >> 16UL;
    4880:	40 6b de    	lsr.w     w13, #0x0, w6
    4882:	07 00 20    	mov.w     #0x0, w7
  in0Lo = absIn0 & 65535UL;
    4884:	80 06 eb    	clr.w     w13
  in1Hi = absIn1 >> 16UL;
    4886:	40 5c de    	lsr.w     w11, #0x0, w8
    4888:	09 00 20    	mov.w     #0x0, w9
  absIn0 = absIn1 & 65535UL;
    488a:	80 05 eb    	clr.w     w11
  productHiLo = in0Hi * absIn0;
    488c:	8a ba b9    	.pword 0xb9ba8a
    488e:	04 07 78    	mov.w     w4, w14
    4890:	06 52 b8    	mul.uu    w10, w6, w4
    4892:	d4 b7 9f    	mov.w     w4, [w15-22]
    4894:	e5 b7 9f    	mov.w     w5, [w15-20]
    4896:	85 02 47    	add.w     w14, w5, w5
    4898:	e5 b7 9f    	mov.w     w5, [w15-20]
  productLoHi = in0Lo * in1Hi;
    489a:	8c ca b9    	.pword 0xb9ca8c
    489c:	04 07 78    	mov.w     w4, w14
    489e:	0c 42 b8    	mul.uu    w8, w12, w4
    48a0:	b4 b7 9f    	mov.w     w4, [w15-26]
    48a2:	c5 b7 9f    	mov.w     w5, [w15-24]
    48a4:	85 02 47    	add.w     w14, w5, w5
    48a6:	c5 b7 9f    	mov.w     w5, [w15-24]
  absIn0 *= in0Lo;
    48a8:	8a ea b9    	.pword 0xb9ea8a
    48aa:	04 07 78    	mov.w     w4, w14
    48ac:	0c 55 b8    	mul.uu    w10, w12, w10
    48ae:	8b 05 47    	add.w     w14, w11, w11
  absIn1 = 0UL;
  in0Lo = (productLoHi << 16UL) + absIn0;
    48b0:	3f b2 97    	mov.w     [w15-26], w4
    48b2:	cf b2 97    	mov.w     [w15-24], w5
    48b4:	c0 26 dd    	sl.w      w4, #0x0, w13
    48b6:	0c 00 20    	mov.w     #0x0, w12
    48b8:	0c 06 45    	add.w     w10, w12, w12
    48ba:	8d 86 4d    	addc.w    w11, w13, w13
    48bc:	14 00 20    	mov.w     #0x1, w4
    48be:	05 00 20    	mov.w     #0x0, w5
    48c0:	94 b7 9f    	mov.w     w4, [w15-30]
    48c2:	a5 b7 9f    	mov.w     w5, [w15-28]
    48c4:	8c 0f 55    	sub.w     w10, w12, [w15]
    48c6:	8d 8f 5d    	subb.w    w11, w13, [w15]
    48c8:	03 00 3e    	bra       GTU, 0x48d0 <.L8>
    48ca:	60 22 b8    	mul.uu    w4, #0x0, w4
    48cc:	94 b7 9f    	mov.w     w4, [w15-30]
    48ce:	a5 b7 9f    	mov.w     w5, [w15-28]

000048d0 <.L8>:
  if (in0Lo < absIn0) {
    absIn1 = 1UL;
  }

  absIn0 = in0Lo;
  in0Lo += productHiLo << 16UL;
    48d0:	5f b2 97    	mov.w     [w15-22], w4
    48d2:	ef b2 97    	mov.w     [w15-20], w5
    48d4:	c0 25 dd    	sl.w      w4, #0x0, w11
    48d6:	0a 00 20    	mov.w     #0x0, w10
    48d8:	0c 05 45    	add.w     w10, w12, w10
    48da:	8d 85 4d    	addc.w    w11, w13, w11
  if (in0Lo < absIn0) {
    48dc:	8a 0f 56    	sub.w     w12, w10, [w15]
    48de:	8b 8f 5e    	subb.w    w13, w11, [w15]
    48e0:	06 00 36    	bra       LEU, 0x48ee <.L9>
    absIn1++;
    48e2:	1f b2 97    	mov.w     [w15-30], w4
    48e4:	af b2 97    	mov.w     [w15-28], w5
    48e6:	61 02 42    	add.w     w4, #0x1, w4
    48e8:	e0 82 4a    	addc.w    w5, #0x0, w5
    48ea:	94 b7 9f    	mov.w     w4, [w15-30]
    48ec:	a5 b7 9f    	mov.w     w5, [w15-28]

000048ee <.L9>:
  }

  absIn0 = (((productLoHi >> 16UL) + (productHiLo >> 16UL)) + in0Hi * in1Hi) +
    48ee:	3f b2 97    	mov.w     [w15-26], w4
    48f0:	cf b2 97    	mov.w     [w15-24], w5
    48f2:	40 2a de    	lsr.w     w5, #0x0, w4
    48f4:	05 00 20    	mov.w     #0x0, w5
    48f6:	b4 b7 9f    	mov.w     w4, [w15-26]
    48f8:	c5 b7 9f    	mov.w     w5, [w15-24]
    48fa:	5f b2 97    	mov.w     [w15-22], w4
    48fc:	ef b2 97    	mov.w     [w15-20], w5
    48fe:	40 2e de    	lsr.w     w5, #0x0, w12
    4900:	0d 00 20    	mov.w     #0x0, w13
    4902:	3f b2 97    	mov.w     [w15-26], w4
    4904:	cf b2 97    	mov.w     [w15-24], w5
    4906:	04 02 46    	add.w     w12, w4, w4
    4908:	85 82 4e    	addc.w    w13, w5, w5
    490a:	d4 b7 9f    	mov.w     w4, [w15-22]
    490c:	e5 b7 9f    	mov.w     w5, [w15-20]
    490e:	86 ce b9    	.pword 0xb9ce86
    4910:	88 ba b9    	.pword 0xb9ba88
    4912:	04 07 78    	mov.w     w4, w14
    4914:	0e 06 46    	add.w     w12, w14, w12
    4916:	06 43 b8    	mul.uu    w8, w6, w6
    4918:	87 03 46    	add.w     w12, w7, w7
    491a:	5f b2 97    	mov.w     [w15-22], w4
    491c:	ef b2 97    	mov.w     [w15-20], w5
    491e:	04 03 43    	add.w     w6, w4, w6
    4920:	85 83 4b    	addc.w    w7, w5, w7
    4922:	1f b2 97    	mov.w     [w15-30], w4
    4924:	af b2 97    	mov.w     [w15-28], w5
    4926:	06 03 42    	add.w     w4, w6, w6
    4928:	87 83 4a    	addc.w    w5, w7, w7
    absIn1;
  if (!((in0 == 0L) || ((in1 == 0L) || ((in0 > 0L) == (in1 > 0L))))) {
    492a:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    492c:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    492e:	16 00 32    	bra       Z, 0x495c <.L10>
    4930:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4932:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4934:	13 00 32    	bra       Z, 0x495c <.L10>
    4936:	18 c0 b3    	mov.b     #0x1, w8
    4938:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    493a:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    493c:	01 00 3c    	bra       GT, 0x4940 <.L11>
    493e:	00 44 eb    	clr.b     w8

00004940 <.L11>:
    4940:	10 c0 b3    	mov.b     #0x1, w0
    4942:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4944:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4946:	01 00 3c    	bra       GT, 0x494a <.L12>
    4948:	00 40 eb    	clr.b     w0

0000494a <.L12>:
    494a:	80 4f 54    	sub.b     w8, w0, [w15]
    494c:	07 00 32    	bra       Z, 0x495c <.L10>
    absIn0 = ~absIn0;
    494e:	06 83 ea    	com.w     w6, w6
    4950:	87 83 ea    	com.w     w7, w7
    in0Lo = ~in0Lo;
    in0Lo++;
    4952:	60 05 15    	subr.w    w10, #0x0, w10
    4954:	e0 85 1d    	subbr.w   w11, #0x0, w11
    if (in0Lo == 0UL) {
    4956:	02 00 3a    	bra       NZ, 0x495c <.L10>
      absIn0++;
    4958:	61 03 43    	add.w     w6, #0x1, w6
    495a:	e0 83 4b    	addc.w    w7, #0x0, w7

0000495c <.L10>:
    }
  }

  *ptrOutBitsHi = absIn0;
    495c:	ff b2 97    	mov.w     [w15-18], w5
    495e:	86 8a be    	mov.d     w6, [w5]
  *ptrOutBitsLo = in0Lo;
    4960:	0f b8 97    	mov.w     [w15-16], w0
    4962:	0a 88 be    	mov.d     w10, [w0]
}
    4964:	4f 07 78    	mov.w     [--w15], w14
    4966:	4f 06 be    	mov.d     [--w15], w12
    4968:	4f 05 be    	mov.d     [--w15], w10
    496a:	4f 04 be    	mov.d     [--w15], w8
    496c:	2f 01 b1    	sub.w     #0x12, w15
    496e:	00 00 06    	return    

00004970 <_mul_u32_s32_s32_sat>:

uint32_T mul_u32_s32_s32_sat(int32_T a, int32_T b)
{
    4970:	08 00 fa    	lnk       #0x8

00004972 <.L0>:
  uint32_T result;
  uint32_T u32_chi;
  mul_wide_s32(a, b, &u32_chi, &result);
    4972:	e8 82 57    	sub.w     w15, #0x8, w5
    4974:	64 82 57    	sub.w     w15, #0x4, w4
    4976:	71 ff 07    	rcall     0x485a <_mul_wide_s32> <L0> <.LFB1467> <.LFE1466>

00004978 <.L0>:
  if ((int32_T)u32_chi >= 0L) {
    4978:	6f b8 97    	mov.w     [w15-4], w0
    497a:	ff b8 97    	mov.w     [w15-2], w1
    497c:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    497e:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4980:	08 00 35    	bra       LT, 0x4992 <.L14>
    if (u32_chi) {
    4982:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    4984:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4986:	08 00 32    	bra       Z, 0x4998 <.L15>
      result = MAX_uint32_T;
    4988:	00 80 eb    	setm.w    w0
    498a:	80 80 eb    	setm.w    w1
    498c:	c0 bf 9f    	mov.w     w0, [w15-8]
    498e:	d1 bf 9f    	mov.w     w1, [w15-6]
    4990:	03 00 37    	bra       0x4998 <.L15>

00004992 <.L14>:
    }
  } else {
    result = 0UL;
    4992:	60 00 b8    	mul.uu    w0, #0x0, w0
    4994:	c0 bf 9f    	mov.w     w0, [w15-8]
    4996:	d1 bf 9f    	mov.w     w1, [w15-6]

00004998 <.L15>:
  }

  return result;
}
    4998:	4f b8 97    	mov.w     [w15-8], w0
    499a:	df b8 97    	mov.w     [w15-6], w1
    499c:	00 80 fa    	ulnk      
    499e:	00 00 06    	return    

000049a0 <_mul_wide_su32>:

void mul_wide_su32(int32_T in0, uint32_T in1, uint32_T *ptrOutBitsHi, uint32_T
                   *ptrOutBitsLo)
{
    49a0:	f2 87 47    	add.w     w15, #0x12, w15
    49a2:	88 9f be    	mov.d     w8, [w15++]
    49a4:	8a 9f be    	mov.d     w10, [w15++]
    49a6:	8c 9f be    	mov.d     w12, [w15++]
    49a8:	8e 1f 78    	mov.w     w14, [w15++]
    49aa:	f4 b7 9f    	mov.w     w4, [w15-18]
    49ac:	85 bf 9f    	mov.w     w5, [w15-16]
  uint32_T outBitsLo;
  uint32_T absIn0;
  uint32_T in0Hi;
  uint32_T in1Lo;
  uint32_T in1Hi;
  uint32_T productHiLo;
  uint32_T productLoHi;
  absIn0 = (uint32_T)(in0 < 0L ? -in0 : in0);
    49ae:	00 05 be    	mov.d     w0, w10
    49b0:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    49b2:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    49b4:	02 00 3d    	bra       GE, 0x49ba <.L17>
    49b6:	60 05 10    	subr.w    w0, #0x0, w10
    49b8:	e0 85 18    	subbr.w   w1, #0x0, w11

000049ba <.L17>:
  in0Hi = absIn0 >> 16UL;
    49ba:	40 5c de    	lsr.w     w11, #0x0, w8
    49bc:	09 00 20    	mov.w     #0x0, w9
  absIn0 &= 65535UL;
    49be:	80 05 eb    	clr.w     w11
  in1Hi = in1 >> 16UL;
    49c0:	40 1b de    	lsr.w     w3, #0x0, w6
    49c2:	07 00 20    	mov.w     #0x0, w7
  in1Lo = in1 & 65535UL;
    49c4:	61 16 b8    	mul.uu    w2, #0x1, w12
  productHiLo = in0Hi * in1Lo;
    49c6:	8c ca b9    	.pword 0xb9ca8c
    49c8:	04 07 78    	mov.w     w4, w14
    49ca:	0c 42 b8    	mul.uu    w8, w12, w4
    49cc:	d4 b7 9f    	mov.w     w4, [w15-22]
    49ce:	e5 b7 9f    	mov.w     w5, [w15-20]
    49d0:	85 02 47    	add.w     w14, w5, w5
    49d2:	e5 b7 9f    	mov.w     w5, [w15-20]
  productLoHi = absIn0 * in1Hi;
    49d4:	8a ba b9    	.pword 0xb9ba8a
    49d6:	04 07 78    	mov.w     w4, w14
    49d8:	06 52 b8    	mul.uu    w10, w6, w4
    49da:	b4 b7 9f    	mov.w     w4, [w15-26]
    49dc:	c5 b7 9f    	mov.w     w5, [w15-24]
    49de:	85 02 47    	add.w     w14, w5, w5
    49e0:	c5 b7 9f    	mov.w     w5, [w15-24]
  absIn0 *= in1Lo;
    49e2:	8a ea b9    	.pword 0xb9ea8a
    49e4:	04 07 78    	mov.w     w4, w14
    49e6:	0c 55 b8    	mul.uu    w10, w12, w10
    49e8:	8b 05 47    	add.w     w14, w11, w11
  in1Lo = 0UL;
  outBitsLo = (productLoHi << 16UL) + absIn0;
    49ea:	3f b2 97    	mov.w     [w15-26], w4
    49ec:	cf b2 97    	mov.w     [w15-24], w5
    49ee:	c0 26 dd    	sl.w      w4, #0x0, w13
    49f0:	0c 00 20    	mov.w     #0x0, w12
    49f2:	0c 06 45    	add.w     w10, w12, w12
    49f4:	8d 86 4d    	addc.w    w11, w13, w13
    49f6:	14 00 20    	mov.w     #0x1, w4
    49f8:	05 00 20    	mov.w     #0x0, w5
    49fa:	94 b7 9f    	mov.w     w4, [w15-30]
    49fc:	a5 b7 9f    	mov.w     w5, [w15-28]
    49fe:	8c 0f 55    	sub.w     w10, w12, [w15]
    4a00:	8d 8f 5d    	subb.w    w11, w13, [w15]
    4a02:	03 00 3e    	bra       GTU, 0x4a0a <.L18>
    4a04:	60 22 b8    	mul.uu    w4, #0x0, w4
    4a06:	94 b7 9f    	mov.w     w4, [w15-30]
    4a08:	a5 b7 9f    	mov.w     w5, [w15-28]

00004a0a <.L18>:
  if (outBitsLo < absIn0) {
    in1Lo = 1UL;
  }

  absIn0 = outBitsLo;
  outBitsLo += productHiLo << 16UL;
    4a0a:	5f b2 97    	mov.w     [w15-22], w4
    4a0c:	ef b2 97    	mov.w     [w15-20], w5
    4a0e:	c0 25 dd    	sl.w      w4, #0x0, w11
    4a10:	0a 00 20    	mov.w     #0x0, w10
    4a12:	0c 05 45    	add.w     w10, w12, w10
    4a14:	8d 85 4d    	addc.w    w11, w13, w11
  if (outBitsLo < absIn0) {
    4a16:	8a 0f 56    	sub.w     w12, w10, [w15]
    4a18:	8b 8f 5e    	subb.w    w13, w11, [w15]
    4a1a:	06 00 36    	bra       LEU, 0x4a28 <.L19>
    in1Lo++;
    4a1c:	1f b2 97    	mov.w     [w15-30], w4
    4a1e:	af b2 97    	mov.w     [w15-28], w5
    4a20:	61 02 42    	add.w     w4, #0x1, w4
    4a22:	e0 82 4a    	addc.w    w5, #0x0, w5
    4a24:	94 b7 9f    	mov.w     w4, [w15-30]
    4a26:	a5 b7 9f    	mov.w     w5, [w15-28]

00004a28 <.L19>:
  }

  absIn0 = (((productLoHi >> 16UL) + (productHiLo >> 16UL)) + in0Hi * in1Hi) +
    4a28:	3f b2 97    	mov.w     [w15-26], w4
    4a2a:	cf b2 97    	mov.w     [w15-24], w5
    4a2c:	40 2a de    	lsr.w     w5, #0x0, w4
    4a2e:	05 00 20    	mov.w     #0x0, w5
    4a30:	b4 b7 9f    	mov.w     w4, [w15-26]
    4a32:	c5 b7 9f    	mov.w     w5, [w15-24]
    4a34:	5f b2 97    	mov.w     [w15-22], w4
    4a36:	ef b2 97    	mov.w     [w15-20], w5
    4a38:	40 2e de    	lsr.w     w5, #0x0, w12
    4a3a:	0d 00 20    	mov.w     #0x0, w13
    4a3c:	3f b2 97    	mov.w     [w15-26], w4
    4a3e:	cf b2 97    	mov.w     [w15-24], w5
    4a40:	04 02 46    	add.w     w12, w4, w4
    4a42:	85 82 4e    	addc.w    w13, w5, w5
    4a44:	d4 b7 9f    	mov.w     w4, [w15-22]
    4a46:	e5 b7 9f    	mov.w     w5, [w15-20]
    4a48:	86 ce b9    	.pword 0xb9ce86
    4a4a:	88 ba b9    	.pword 0xb9ba88
    4a4c:	04 07 78    	mov.w     w4, w14
    4a4e:	0e 06 46    	add.w     w12, w14, w12
    4a50:	06 43 b8    	mul.uu    w8, w6, w6
    4a52:	87 03 46    	add.w     w12, w7, w7
    4a54:	5f b2 97    	mov.w     [w15-22], w4
    4a56:	ef b2 97    	mov.w     [w15-20], w5
    4a58:	04 03 43    	add.w     w6, w4, w6
    4a5a:	85 83 4b    	addc.w    w7, w5, w7
    4a5c:	1f b2 97    	mov.w     [w15-30], w4
    4a5e:	af b2 97    	mov.w     [w15-28], w5
    4a60:	06 03 42    	add.w     w4, w6, w6
    4a62:	87 83 4a    	addc.w    w5, w7, w7
    in1Lo;
  if (!((in1 == 0UL) || (in0 >= 0L))) {
    4a64:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4a66:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4a68:	0a 00 32    	bra       Z, 0x4a7e <.L20>
    4a6a:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    4a6c:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4a6e:	07 00 3d    	bra       GE, 0x4a7e <.L20>
    absIn0 = ~absIn0;
    4a70:	06 83 ea    	com.w     w6, w6
    4a72:	87 83 ea    	com.w     w7, w7
    outBitsLo = ~outBitsLo;
    outBitsLo++;
    4a74:	60 05 15    	subr.w    w10, #0x0, w10
    4a76:	e0 85 1d    	subbr.w   w11, #0x0, w11
    if (outBitsLo == 0UL) {
    4a78:	02 00 3a    	bra       NZ, 0x4a7e <.L20>
      absIn0++;
    4a7a:	61 03 43    	add.w     w6, #0x1, w6
    4a7c:	e0 83 4b    	addc.w    w7, #0x0, w7

00004a7e <.L20>:
    }
  }

  *ptrOutBitsHi = absIn0;
    4a7e:	ff b2 97    	mov.w     [w15-18], w5
    4a80:	86 8a be    	mov.d     w6, [w5]
  *ptrOutBitsLo = outBitsLo;
    4a82:	0f b8 97    	mov.w     [w15-16], w0
    4a84:	0a 88 be    	mov.d     w10, [w0]
}
    4a86:	4f 07 78    	mov.w     [--w15], w14
    4a88:	4f 06 be    	mov.d     [--w15], w12
    4a8a:	4f 05 be    	mov.d     [--w15], w10
    4a8c:	4f 04 be    	mov.d     [--w15], w8
    4a8e:	2f 01 b1    	sub.w     #0x12, w15
    4a90:	00 00 06    	return    

00004a92 <_mul_s32_s32_u32_sr16>:

int32_T mul_s32_s32_u32_sr16(int32_T a, uint32_T b)
{
    4a92:	08 00 fa    	lnk       #0x8

00004a94 <.L0>:
  uint32_T u32_chi;
  uint32_T u32_clo;
  mul_wide_su32(a, b, &u32_chi, &u32_clo);
    4a94:	e4 82 57    	sub.w     w15, #0x4, w5
    4a96:	68 82 57    	sub.w     w15, #0x8, w4
    4a98:	83 ff 07    	rcall     0x49a0 <_mul_wide_su32> <L0> <.LFB1469> <.LFE1468>

00004a9a <.L0>:
  u32_clo = u32_chi << 16UL | u32_clo >> 16UL;
    4a9a:	6f b9 97    	mov.w     [w15-4], w2
    4a9c:	ff b9 97    	mov.w     [w15-2], w3
    4a9e:	40 19 de    	lsr.w     w3, #0x0, w2
    4aa0:	03 00 20    	mov.w     #0x0, w3
    4aa2:	4f b8 97    	mov.w     [w15-8], w0
    4aa4:	df b8 97    	mov.w     [w15-6], w1
    4aa6:	c0 00 dd    	sl.w      w0, #0x0, w1
    4aa8:	00 00 20    	mov.w     #0x0, w0
    4aaa:	00 00 71    	ior.w     w2, w0, w0
    4aac:	81 80 71    	ior.w     w3, w1, w1
  return (int32_T)u32_clo;
}
    4aae:	00 80 fa    	ulnk      
    4ab0:	00 00 06    	return    

00004ab2 <_div_u32_round>:

uint32_T div_u32_round(uint32_T numerator, uint32_T denominator)
{
    4ab2:	88 9f be    	mov.d     w8, [w15++]
    4ab4:	8a 9f be    	mov.d     w10, [w15++]
    4ab6:	8c 9f be    	mov.d     w12, [w15++]
    4ab8:	00 05 be    	mov.d     w0, w10
    4aba:	02 04 be    	mov.d     w2, w8
  uint32_T quotient;
  if (denominator == 0UL) {
    quotient = MAX_uint32_T;
    4abc:	00 86 eb    	setm.w    w12
    4abe:	80 86 eb    	setm.w    w13

00004ac0 <.L0>:
    4ac0:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4ac2:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4ac4:	14 00 32    	bra       Z, 0x4aee <.L23>

00004ac6 <.L0>:

    /* Divide by zero handler */
  } else {
    quotient = numerator / denominator;
    4ac6:	34 1f 02    	call      0x1f34 <___udivsi3>
    4ac8:	00 00 00 
    4aca:	00 06 be    	mov.d     w0, w12

00004acc <.L0>:
    numerator %= denominator;
    4acc:	08 01 be    	mov.d     w8, w2
    4ace:	0a 00 be    	mov.d     w10, w0
    4ad0:	54 1f 02    	call      0x1f54 <___umodsi3>
    4ad2:	00 00 00 

00004ad4 <.L0>:
    if (numerator > 2147483647UL) {
    4ad4:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    4ad6:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4ad8:	03 00 3d    	bra       GE, 0x4ae0 <.L24>
      quotient++;
    4ada:	61 06 46    	add.w     w12, #0x1, w12
    4adc:	e0 86 4e    	addc.w    w13, #0x0, w13
    4ade:	07 00 37    	bra       0x4aee <.L23>

00004ae0 <.L24>:
    } else {
      numerator <<= 1UL;
    4ae0:	00 00 40    	add.w     w0, w0, w0
    4ae2:	81 80 48    	addc.w    w1, w1, w1
      if (numerator >= denominator) {
    4ae4:	80 0f 54    	sub.w     w8, w0, [w15]
    4ae6:	81 8f 5c    	subb.w    w9, w1, [w15]
    4ae8:	02 00 3e    	bra       GTU, 0x4aee <.L23>
        quotient++;
    4aea:	61 06 46    	add.w     w12, #0x1, w12
    4aec:	e0 86 4e    	addc.w    w13, #0x0, w13

00004aee <.L23>:
      }
    }
  }

  return quotient;
}
    4aee:	0c 00 be    	mov.d     w12, w0
    4af0:	4f 06 be    	mov.d     [--w15], w12
    4af2:	4f 05 be    	mov.d     [--w15], w10
    4af4:	4f 04 be    	mov.d     [--w15], w8
    4af6:	00 00 06    	return    

00004af8 <_mul_u32_u32_u32_sr11_round>:

uint32_T mul_u32_u32_u32_sr11_round(uint32_T a, uint32_T b)
{
    4af8:	08 00 fa    	lnk       #0x8

00004afa <.L0>:
  uint32_T result;
  uint32_T u32_chi;
  mul_wide_u32(a, b, &u32_chi, &result);
    4afa:	e8 82 57    	sub.w     w15, #0x8, w5
    4afc:	64 82 57    	sub.w     w15, #0x4, w4
    4afe:	4b fe 07    	rcall     0x4796 <_mul_wide_u32> <.L0> <.LFB1465> <.Ltext0>

00004b00 <.L0>:
  return (u32_chi << 21UL | result >> 11UL) + ((result & 1024UL) != 0UL);
    4b00:	4f b8 97    	mov.w     [w15-8], w0
    4b02:	df b8 97    	mov.w     [w15-6], w1
    4b04:	02 40 20    	mov.w     #0x400, w2
    4b06:	00 01 61    	and.w     w2, w0, w2
    4b08:	02 01 ea    	neg.w     w2, w2
    4b0a:	4f 11 de    	lsr.w     w2, #0xf, w2
    4b0c:	c5 09 dd    	sl.w      w1, #0x5, w3
    4b0e:	4b 00 de    	lsr.w     w0, #0xb, w0
    4b10:	00 80 71    	ior.w     w3, w0, w0
    4b12:	cb 08 de    	lsr.w     w1, #0xb, w1
    4b14:	6f ba 97    	mov.w     [w15-4], w4
    4b16:	ff ba 97    	mov.w     [w15-2], w5
    4b18:	c5 22 dd    	sl.w      w4, #0x5, w5
    4b1a:	04 00 20    	mov.w     #0x0, w4
    4b1c:	04 00 70    	ior.w     w0, w4, w0
    4b1e:	85 80 70    	ior.w     w1, w5, w1
    4b20:	00 00 41    	add.w     w2, w0, w0
    4b22:	e0 80 48    	addc.w    w1, #0x0, w1
}
    4b24:	00 80 fa    	ulnk      
    4b26:	00 00 06    	return    

00004b28 <_div_repeat_u32_round>:

uint32_T div_repeat_u32_round(uint32_T numerator, uint32_T denominator, uint16_T
  nRepeatSub)
{
    4b28:	88 9f be    	mov.d     w8, [w15++]
    4b2a:	8a 9f be    	mov.d     w10, [w15++]
    4b2c:	8c 9f be    	mov.d     w12, [w15++]
    4b2e:	8e 1f 78    	mov.w     w14, [w15++]
    4b30:	00 05 be    	mov.d     w0, w10
    4b32:	02 04 be    	mov.d     w2, w8
    4b34:	04 07 78    	mov.w     w4, w14
  uint32_T quotient;
  uint16_T iRepeatSub;
  boolean_T numeratorExtraBit;
  if (denominator == 0UL) {
    quotient = MAX_uint32_T;
    4b36:	00 86 eb    	setm.w    w12
    4b38:	80 86 eb    	setm.w    w13

00004b3a <.L0>:
    4b3a:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4b3c:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4b3e:	26 00 32    	bra       Z, 0x4b8c <.L28>

00004b40 <.L0>:

    /* Divide by zero handler */
  } else {
    quotient = numerator / denominator;
    4b40:	34 1f 02    	call      0x1f34 <___udivsi3>
    4b42:	00 00 00 
    4b44:	00 06 be    	mov.d     w0, w12

00004b46 <.L0>:
    numerator %= denominator;
    4b46:	08 01 be    	mov.d     w8, w2
    4b48:	0a 00 be    	mov.d     w10, w0
    4b4a:	54 1f 02    	call      0x1f54 <___umodsi3>
    4b4c:	00 00 00 

00004b4e <.L0>:
    for (iRepeatSub = 0U; iRepeatSub < nRepeatSub; iRepeatSub++) {
    4b4e:	0e 00 e0    	cp0.w     w14
    4b50:	13 00 32    	bra       Z, 0x4b78 <.L29>
    4b52:	00 01 eb    	clr.w     w2

00004b54 <.L32>:
      numeratorExtraBit = (numerator >= 2147483648UL);
    4b54:	00 02 be    	mov.d     w0, w4
      numerator <<= 1UL;
    4b56:	00 00 40    	add.w     w0, w0, w0
    4b58:	81 80 48    	addc.w    w1, w1, w1
      quotient <<= 1UL;
    4b5a:	0c 06 46    	add.w     w12, w12, w12
    4b5c:	8d 86 4e    	addc.w    w13, w13, w13
      if (numeratorExtraBit || (numerator >= denominator)) {
    4b5e:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    4b60:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    4b62:	03 00 35    	bra       LT, 0x4b6a <.L30>
    4b64:	80 0f 54    	sub.w     w8, w0, [w15]
    4b66:	81 8f 5c    	subb.w    w9, w1, [w15]
    4b68:	04 00 3e    	bra       GTU, 0x4b72 <.L31>

00004b6a <.L30>:
        quotient++;
    4b6a:	61 06 46    	add.w     w12, #0x1, w12
    4b6c:	e0 86 4e    	addc.w    w13, #0x0, w13
        numerator -= denominator;
    4b6e:	08 00 50    	sub.w     w0, w8, w0
    4b70:	89 80 58    	subb.w    w1, w9, w1

00004b72 <.L31>:
    4b72:	02 01 e8    	inc.w     w2, w2
    4b74:	82 0f 57    	sub.w     w14, w2, [w15]
    4b76:	ee ff 3e    	bra       GTU, 0x4b54 <.L32>

00004b78 <.L29>:
      }
    }

    numeratorExtraBit = (numerator >= 2147483648UL);
    numerator <<= 1UL;
    if (numeratorExtraBit || (numerator >= denominator)) {
    4b78:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    4b7a:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4b7c:	05 00 35    	bra       LT, 0x4b88 <.L33>
    4b7e:	00 00 40    	add.w     w0, w0, w0
    4b80:	81 80 48    	addc.w    w1, w1, w1
    4b82:	80 0f 54    	sub.w     w8, w0, [w15]
    4b84:	81 8f 5c    	subb.w    w9, w1, [w15]
    4b86:	02 00 3e    	bra       GTU, 0x4b8c <.L28>

00004b88 <.L33>:
      quotient++;
    4b88:	61 06 46    	add.w     w12, #0x1, w12
    4b8a:	e0 86 4e    	addc.w    w13, #0x0, w13

00004b8c <.L28>:
    }
  }

  return quotient;
}
    4b8c:	0c 00 be    	mov.d     w12, w0
    4b8e:	4f 07 78    	mov.w     [--w15], w14
    4b90:	4f 06 be    	mov.d     [--w15], w12
    4b92:	4f 05 be    	mov.d     [--w15], w10
    4b94:	4f 04 be    	mov.d     [--w15], w8
    4b96:	00 00 06    	return    

00004b98 <_mul_u32_s32_u32_sr15>:

uint32_T mul_u32_s32_u32_sr15(int32_T a, uint32_T b)
{
    4b98:	08 00 fa    	lnk       #0x8

00004b9a <.L0>:
  uint32_T result;
  uint32_T u32_chi;
  mul_wide_su32(a, b, &u32_chi, &result);
    4b9a:	e8 82 57    	sub.w     w15, #0x8, w5
    4b9c:	64 82 57    	sub.w     w15, #0x4, w4
    4b9e:	00 ff 07    	rcall     0x49a0 <_mul_wide_su32> <L0> <.LFB1469> <.LFE1468>

00004ba0 <.L0>:
  return u32_chi << 17UL | result >> 15UL;
    4ba0:	4f b9 97    	mov.w     [w15-8], w2
    4ba2:	df b9 97    	mov.w     [w15-6], w3
    4ba4:	41 18 dd    	sl.w      w3, #0x1, w0
    4ba6:	4f 11 de    	lsr.w     w2, #0xf, w2
    4ba8:	02 01 70    	ior.w     w0, w2, w2
    4baa:	cf 19 de    	lsr.w     w3, #0xf, w3
    4bac:	6f b8 97    	mov.w     [w15-4], w0
    4bae:	ff b8 97    	mov.w     [w15-2], w1
    4bb0:	c1 00 dd    	sl.w      w0, #0x1, w1
    4bb2:	00 00 20    	mov.w     #0x0, w0
    4bb4:	00 00 71    	ior.w     w2, w0, w0
    4bb6:	81 80 71    	ior.w     w3, w1, w1
}
    4bb8:	00 80 fa    	ulnk      
    4bba:	00 00 06    	return    

00004bbc <_mul_s32_s32_s32_sr28>:

int32_T mul_s32_s32_s32_sr28(int32_T a, int32_T b)
{
    4bbc:	08 00 fa    	lnk       #0x8

00004bbe <.L0>:
  uint32_T u32_chi;
  uint32_T u32_clo;
  mul_wide_s32(a, b, &u32_chi, &u32_clo);
    4bbe:	e4 82 57    	sub.w     w15, #0x4, w5
    4bc0:	68 82 57    	sub.w     w15, #0x8, w4
    4bc2:	4b fe 07    	rcall     0x485a <_mul_wide_s32> <L0> <.LFB1467> <.LFE1466>

00004bc4 <.L0>:
  u32_clo = u32_chi << 4UL | u32_clo >> 28UL;
    4bc4:	6f b8 97    	mov.w     [w15-4], w0
    4bc6:	ff b8 97    	mov.w     [w15-2], w1
    4bc8:	4c 08 de    	lsr.w     w1, #0xc, w0
    4bca:	01 00 20    	mov.w     #0x0, w1
    4bcc:	4f ba 97    	mov.w     [w15-8], w4
    4bce:	df ba 97    	mov.w     [w15-6], w5
    4bd0:	44 29 dd    	sl.w      w5, #0x4, w2
    4bd2:	cc 21 de    	lsr.w     w4, #0xc, w3
    4bd4:	83 01 71    	ior.w     w2, w3, w3
    4bd6:	44 21 dd    	sl.w      w4, #0x4, w2
    4bd8:	02 00 70    	ior.w     w0, w2, w0
    4bda:	83 80 70    	ior.w     w1, w3, w1
  return (int32_T)u32_clo;
}
    4bdc:	00 80 fa    	ulnk      
    4bde:	00 00 06    	return    

00004be0 <_mul_s32_s32_s32_sr23>:

int32_T mul_s32_s32_s32_sr23(int32_T a, int32_T b)
{
    4be0:	08 00 fa    	lnk       #0x8

00004be2 <.L0>:
  uint32_T u32_chi;
  uint32_T u32_clo;
  mul_wide_s32(a, b, &u32_chi, &u32_clo);
    4be2:	e4 82 57    	sub.w     w15, #0x4, w5
    4be4:	68 82 57    	sub.w     w15, #0x8, w4
    4be6:	39 fe 07    	rcall     0x485a <_mul_wide_s32> <L0> <.LFB1467> <.LFE1466>

00004be8 <.L0>:
  u32_clo = u32_chi << 9UL | u32_clo >> 23UL;
    4be8:	6f b8 97    	mov.w     [w15-4], w0
    4bea:	ff b8 97    	mov.w     [w15-2], w1
    4bec:	47 08 de    	lsr.w     w1, #0x7, w0
    4bee:	01 00 20    	mov.w     #0x0, w1
    4bf0:	4f ba 97    	mov.w     [w15-8], w4
    4bf2:	df ba 97    	mov.w     [w15-6], w5
    4bf4:	49 29 dd    	sl.w      w5, #0x9, w2
    4bf6:	c7 21 de    	lsr.w     w4, #0x7, w3
    4bf8:	83 01 71    	ior.w     w2, w3, w3
    4bfa:	49 21 dd    	sl.w      w4, #0x9, w2
    4bfc:	02 00 70    	ior.w     w0, w2, w0
    4bfe:	83 80 70    	ior.w     w1, w3, w1
  return (int32_T)u32_clo;
}
    4c00:	00 80 fa    	ulnk      
    4c02:	00 00 06    	return    

00004c04 <_div_s16s32_round>:

int16_T div_s16s32_round(int32_T numerator, int32_T denominator)
{
    4c04:	08 00 fa    	lnk       #0x8
    4c06:	88 9f be    	mov.d     w8, [w15++]
    4c08:	8a 9f be    	mov.d     w10, [w15++]
    4c0a:	8c 9f be    	mov.d     w12, [w15++]
    4c0c:	00 05 be    	mov.d     w0, w10
    4c0e:	02 04 be    	mov.d     w2, w8
  int16_T quotient;
  uint32_T absNumerator;
  uint32_T absDenominator;
  uint32_T tempAbsQuotient;
  if (denominator == 0L) {
    4c10:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    4c12:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    4c14:	04 00 3a    	bra       NZ, 0x4c1e <.L40>
    quotient = numerator >= 0L ? MAX_int16_T : MIN_int16_T;
    4c16:	cf 58 de    	lsr.w     w11, #0xf, w1
    4c18:	f0 ff 27    	mov.w     #0x7fff, w0
    4c1a:	00 80 40    	add.w     w1, w0, w0
    4c1c:	30 00 37    	bra       0x4c7e <.L41>

00004c1e <.L40>:

    /* Divide by zero handler */
  } else {
    absNumerator = (uint32_T)(numerator >= 0L ? numerator : -numerator);
    4c1e:	00 06 be    	mov.d     w0, w12
    4c20:	e0 0f 50    	sub.w     w0, #0x0, [w15]
    4c22:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    4c24:	02 00 3d    	bra       GE, 0x4c2a <.L42>
    4c26:	60 06 10    	subr.w    w0, #0x0, w12
    4c28:	e0 86 18    	subbr.w   w1, #0x0, w13

00004c2a <.L42>:
    absDenominator = (uint32_T)(denominator >= 0L ? denominator : -denominator);
    4c2a:	88 bf 9f    	mov.w     w8, [w15-16]
    4c2c:	99 bf 9f    	mov.w     w9, [w15-14]
    4c2e:	e0 0f 54    	sub.w     w8, #0x0, [w15]
    4c30:	e0 8f 5c    	subb.w    w9, #0x0, [w15]
    4c32:	04 00 3d    	bra       GE, 0x4c3c <.L0> <.L43>
    4c34:	60 00 14    	subr.w    w8, #0x0, w0
    4c36:	e0 80 1c    	subbr.w   w9, #0x0, w1
    4c38:	80 bf 9f    	mov.w     w0, [w15-16]
    4c3a:	91 bf 9f    	mov.w     w1, [w15-14]

00004c3c <.L0>:
    tempAbsQuotient = absNumerator / absDenominator;
    4c3c:	0f b9 97    	mov.w     [w15-16], w2
    4c3e:	9f b9 97    	mov.w     [w15-14], w3
    4c40:	0c 00 be    	mov.d     w12, w0
    4c42:	34 1f 02    	call      0x1f34 <___udivsi3>
    4c44:	00 00 00 
    4c46:	e0 b7 9f    	mov.w     w0, [w15-20]
    4c48:	f1 b7 9f    	mov.w     w1, [w15-18]

00004c4a <.L0>:
    absNumerator %= absDenominator;
    4c4a:	0f b9 97    	mov.w     [w15-16], w2
    4c4c:	9f b9 97    	mov.w     [w15-14], w3
    4c4e:	0c 00 be    	mov.d     w12, w0
    4c50:	54 1f 02    	call      0x1f54 <___umodsi3>
    4c52:	00 00 00 

00004c54 <.L0>:
    absNumerator <<= 1UL;
    4c54:	00 00 40    	add.w     w0, w0, w0
    4c56:	81 80 48    	addc.w    w1, w1, w1
    if (absNumerator >= absDenominator) {
    4c58:	0f b9 97    	mov.w     [w15-16], w2
    4c5a:	9f b9 97    	mov.w     [w15-14], w3
    4c5c:	80 0f 51    	sub.w     w2, w0, [w15]
    4c5e:	81 8f 59    	subb.w    w3, w1, [w15]
    4c60:	06 00 3e    	bra       GTU, 0x4c6e <.L44>
      tempAbsQuotient++;
    4c62:	6f b0 97    	mov.w     [w15-20], w0
    4c64:	ff b0 97    	mov.w     [w15-18], w1
    4c66:	61 00 40    	add.w     w0, #0x1, w0
    4c68:	e0 80 48    	addc.w    w1, #0x0, w1
    4c6a:	e0 b7 9f    	mov.w     w0, [w15-20]
    4c6c:	f1 b7 9f    	mov.w     w1, [w15-18]

00004c6e <.L44>:
    }

    quotient = (numerator < 0L) != (denominator < 0L) ? (int16_T)-(int32_T)
    4c6e:	cf 58 de    	lsr.w     w11, #0xf, w1
    4c70:	4f 48 de    	lsr.w     w9, #0xf, w0
      tempAbsQuotient : (int16_T)tempAbsQuotient;
    4c72:	80 cf 50    	sub.b     w1, w0, [w15]
    4c74:	03 00 32    	bra       Z, 0x4c7c <.L45>
    4c76:	ef b0 97    	mov.w     [w15-20], w1
    4c78:	01 00 ea    	neg.w     w1, w0
    4c7a:	01 00 37    	bra       0x4c7e <.L41>

00004c7c <.L45>:
    4c7c:	6f b0 97    	mov.w     [w15-20], w0

00004c7e <.L41>:
  }

  return quotient;
}
    4c7e:	4f 06 be    	mov.d     [--w15], w12
    4c80:	4f 05 be    	mov.d     [--w15], w10
    4c82:	4f 04 be    	mov.d     [--w15], w8
    4c84:	00 80 fa    	ulnk      
    4c86:	00 00 06    	return    

00004c88 <_MultiWord2uLong>:

uint32_T MultiWord2uLong(const uint32_T u[])
{
    4c88:	10 00 be    	mov.d     [w0], w0
  return u[0];
}
    4c8a:	00 00 06    	return    

00004c8c <_uMultiWordShr>:

void uMultiWordShr(const uint32_T u1[], int16_T n1, uint16_T n2, uint32_T y[],
                   int16_T n)
{
    4c8c:	ec 87 47    	add.w     w15, #0xc, w15
    4c8e:	88 9f be    	mov.d     w8, [w15++]
    4c90:	8a 9f be    	mov.d     w10, [w15++]
    4c92:	8c 9f be    	mov.d     w12, [w15++]
    4c94:	8e 1f 78    	mov.w     w14, [w15++]
    4c96:	00 07 78    	mov.w     w0, w14
  int16_T nb;
  int16_T i;
  uint32_T yi;
  uint32_T u1i;
  int16_T nc;
  uint16_T nr;
  uint16_T nl;
  int16_T i1;
  nb = (int16_T)(n2 >> 5);
    4c98:	c5 14 de    	lsr.w     w2, #0x5, w9
    4c9a:	09 00 78    	mov.w     w9, w0
  i = 0;
    4c9c:	80 02 eb    	clr.w     w5
  if (nb < n1) {
    4c9e:	81 8f 54    	sub.w     w9, w1, [w15]
    4ca0:	50 00 3d    	bra       GE, 0x4d42 <.L49>
    nc = n + nb;
    4ca2:	89 02 42    	add.w     w4, w9, w5
    4ca4:	81 8f 52    	sub.w     w5, w1, [w15]
    4ca6:	01 00 34    	bra       LE, 0x4caa <.L50>
    4ca8:	81 02 78    	mov.w     w1, w5

00004caa <.L50>:
    if (nc > n1) {
      nc = n1;
    }

    nr = n2 - ((uint16_T)nb << 5);
    4caa:	45 4e dd    	sl.w      w9, #0x5, w12
    4cac:	0c 06 51    	sub.w     w2, w12, w12
    if (nr > 0U) {
    4cae:	04 00 3a    	bra       NZ, 0x4cb8 <.L51>
      nl = 32U - nr;
      u1i = u1[nb];
      for (i1 = nb + 1; i1 < nc; i1++) {
        yi = u1i >> nr;
        u1i = u1[i1];
        y[i] = u1i << nl | yi;
        i++;
      }

      yi = u1i >> nr;
      if (nc < n1) {
        yi |= u1[nc] << nl;
      }

      y[i] = yi;
      i++;
    } else {
      for (i1 = nb; i1 < nc; i1++) {
    4cb0:	85 0f 50    	sub.w     w0, w5, [w15]
    4cb2:	4a 00 35    	bra       LT, 0x4d48 <.L52>
    4cb4:	80 02 eb    	clr.w     w5
    4cb6:	45 00 37    	bra       0x4d42 <.L49>

00004cb8 <.L51>:
    4cb8:	0d 02 20    	mov.w     #0x20, w13
    4cba:	8c 86 56    	sub.w     w13, w12, w13
    4cbc:	42 49 dd    	sl.w      w9, #0x2, w2
    4cbe:	02 01 47    	add.w     w14, w2, w2
    4cc0:	12 03 be    	mov.d     [w2], w6
    4cc2:	00 00 e8    	inc.w     w0, w0
    4cc4:	00 01 eb    	clr.w     w2
    4cc6:	85 0f 50    	sub.w     w0, w5, [w15]
    4cc8:	27 00 3d    	bra       GE, 0x4d18 <.L53> <.LB837>
    4cca:	42 04 dd    	sl.w      w0, #0x2, w8
    4ccc:	08 04 47    	add.w     w14, w8, w8
    4cce:	03 01 78    	mov.w     w3, w2
    4cd0:	d9 b7 9f    	mov.w     w9, [w15-22]
    4cd2:	85 04 78    	mov.w     w5, w9
    4cd4:	8e 02 78    	mov.w     w14, w5
    4cd6:	c5 b7 9f    	mov.w     w5, [w15-24]
    4cd8:	81 bf 9f    	mov.w     w1, [w15-16]
    4cda:	04 07 78    	mov.w     w4, w14

00004cdc <.L54>:
    4cdc:	06 02 be    	mov.d     w6, w4
    4cde:	0c 05 78    	mov.w     w12, w10

00004ce0 <.LB816>:
    4ce0:	0a 05 e9    	dec.w     w10, w10
    4ce2:	03 00 33    	bra       N, 0x4cea <.LE816>
    4ce4:	85 02 d1    	lsr.w     w5, w5
    4ce6:	04 82 d3    	rrc.w     w4, w4
    4ce8:	fb ff 37    	bra       0x4ce0 <.LB816>

00004cea <.LE816>:
    4cea:	e4 b7 9f    	mov.w     w4, [w15-20]
    4cec:	f5 b7 9f    	mov.w     w5, [w15-18]
    4cee:	38 03 be    	mov.d     [w8++], w6
    4cf0:	06 05 be    	mov.d     w6, w10
    4cf2:	8d 00 78    	mov.w     w13, w1

00004cf4 <.LB821>:
    4cf4:	81 00 e9    	dec.w     w1, w1
    4cf6:	03 00 33    	bra       N, 0x4cfe <.LE821>
    4cf8:	0a 05 45    	add.w     w10, w10, w10
    4cfa:	8b 85 4d    	addc.w    w11, w11, w11
    4cfc:	fb ff 37    	bra       0x4cf4 <.LB821>

00004cfe <.LE821>:
    4cfe:	0a 02 72    	ior.w     w4, w10, w4
    4d00:	8b 82 72    	ior.w     w5, w11, w5
    4d02:	04 99 be    	mov.d     w4, [w2++]
    4d04:	00 00 e8    	inc.w     w0, w0
    4d06:	89 0f 50    	sub.w     w0, w9, [w15]
    4d08:	e9 ff 35    	bra       LT, 0x4cdc <.L54>
    4d0a:	89 02 78    	mov.w     w9, w5
    4d0c:	df b4 97    	mov.w     [w15-22], w9
    4d0e:	8f b8 97    	mov.w     [w15-16], w1
    4d10:	0e 02 78    	mov.w     w14, w4
    4d12:	4f b7 97    	mov.w     [w15-24], w14
    4d14:	09 81 52    	sub.w     w5, w9, w2
    4d16:	02 01 e9    	dec.w     w2, w2

00004d18 <.L53>:
    4d18:	0c 06 e9    	dec.w     w12, w12
    4d1a:	03 00 33    	bra       N, 0x4d22 <.LE837>
    4d1c:	87 03 d1    	lsr.w     w7, w7
    4d1e:	06 83 d3    	rrc.w     w6, w6
    4d20:	fb ff 37    	bra       0x4d18 <.L53> <.LB837>

00004d22 <.LE837>:
    4d22:	85 8f 50    	sub.w     w1, w5, [w15]
    4d24:	0a 00 34    	bra       LE, 0x4d3a <.L55>
    4d26:	c2 2a dd    	sl.w      w5, #0x2, w5
    4d28:	05 07 47    	add.w     w14, w5, w14
    4d2a:	1e 00 be    	mov.d     [w14], w0

00004d2c <.LB844>:
    4d2c:	8d 06 e9    	dec.w     w13, w13
    4d2e:	03 00 33    	bra       N, 0x4d36 <.LE844>
    4d30:	00 00 40    	add.w     w0, w0, w0
    4d32:	81 80 48    	addc.w    w1, w1, w1
    4d34:	fb ff 37    	bra       0x4d2c <.LB844>

00004d36 <.LE844>:
    4d36:	00 03 73    	ior.w     w6, w0, w6
    4d38:	81 83 73    	ior.w     w7, w1, w7

00004d3a <.L55>:
    4d3a:	42 10 dd    	sl.w      w2, #0x2, w0
    4d3c:	00 80 41    	add.w     w3, w0, w0
    4d3e:	06 88 be    	mov.d     w6, [w0]
    4d40:	82 02 e8    	inc.w     w2, w5

00004d42 <.L49>:
        y[i] = u1[i1];
        i++;
      }
    }
  }

  while (i < n) {
    4d42:	84 8f 52    	sub.w     w5, w4, [w15]
    4d44:	0d 00 35    	bra       LT, 0x4d60 <.L56>
    4d46:	14 00 37    	bra       0x4d70 <.L48>

00004d48 <.L52>:
    4d48:	89 00 e9    	dec.w     w9, w1
    4d4a:	c2 08 dd    	sl.w      w1, #0x2, w1
    4d4c:	01 07 47    	add.w     w14, w1, w14
    4d4e:	83 00 78    	mov.w     w3, w1

00004d50 <.L58>:
    4d50:	4e 00 b0    	add.w     #0x4, w14
    4d52:	be 18 78    	mov.w     [w14++], [w1++]
    4d54:	ae 18 78    	mov.w     [w14--], [w1++]
    4d56:	00 00 e8    	inc.w     w0, w0
    4d58:	85 0f 50    	sub.w     w0, w5, [w15]
    4d5a:	fa ff 35    	bra       LT, 0x4d50 <.L58>
    4d5c:	89 82 52    	sub.w     w5, w9, w5
    4d5e:	f1 ff 37    	bra       0x4d42 <.L49>

00004d60 <.L56>:
    4d60:	05 00 e9    	dec.w     w5, w0
    4d62:	42 00 dd    	sl.w      w0, #0x2, w0
    4d64:	80 81 41    	add.w     w3, w0, w3
    y[i] = 0UL;
    4d66:	60 00 b8    	mul.uu    w0, #0x0, w0

00004d68 <.L59>:
    4d68:	80 a9 be    	mov.d     w0, [++w3]
    i++;
    4d6a:	85 02 e8    	inc.w     w5, w5
    4d6c:	85 0f 52    	sub.w     w4, w5, [w15]
    4d6e:	fc ff 3c    	bra       GT, 0x4d68 <.L59>

00004d70 <.L48>:
  }
}
    4d70:	4f 07 78    	mov.w     [--w15], w14
    4d72:	4f 06 be    	mov.d     [--w15], w12
    4d74:	4f 05 be    	mov.d     [--w15], w10
    4d76:	4f 04 be    	mov.d     [--w15], w8
    4d78:	cf 00 b1    	sub.w     #0xc, w15
    4d7a:	00 00 06    	return    

00004d7c <_uMultiWordMul>:

void uMultiWordMul(const uint32_T u1[], int16_T n1, const uint32_T u2[], int16_T
                   n2, uint32_T y[], int16_T n)
{
    4d7c:	0f 04 b0    	add.w     #0x40, w15
    4d7e:	88 9f be    	mov.d     w8, [w15++]
    4d80:	8a 9f be    	mov.d     w10, [w15++]
    4d82:	8c 9f be    	mov.d     w12, [w15++]
    4d84:	8e 1f 78    	mov.w     w14, [w15++]
    4d86:	c1 9f 9f    	mov.w     w1, [w15-72]
    4d88:	b2 9f 9f    	mov.w     w2, [w15-74]
    4d8a:	e3 9f 9f    	mov.w     w3, [w15-68]
    4d8c:	a4 9f 9f    	mov.w     w4, [w15-76]
    4d8e:	85 a7 9f    	mov.w     w5, [w15-64]
  int16_T i;
  int16_T j;
  int16_T k;
  int16_T nj;
  uint32_T u1i;
  uint32_T yk;
  uint32_T a1;
  uint32_T a0;
  uint32_T b1;
  uint32_T w10;
  uint32_T w01;
  uint32_T cb;

  /* Initialize output to zero */
  for (k = 0; k < n; k++) {
    4d90:	85 00 78    	mov.w     w5, w1
    4d92:	01 00 e0    	cp0.w     w1
    4d94:	08 00 34    	bra       LE, 0x4da6 <.L66>
    4d96:	04 01 78    	mov.w     w4, w2
    4d98:	80 00 eb    	clr.w     w1
    y[k] = 0UL;
    4d9a:	60 22 b8    	mul.uu    w4, #0x0, w4
    4d9c:	8f a1 97    	mov.w     [w15-64], w3

00004d9e <.L67>:
    4d9e:	04 99 be    	mov.d     w4, [w2++]
    4da0:	81 00 e8    	inc.w     w1, w1
    4da2:	83 8f 50    	sub.w     w1, w3, [w15]
    4da4:	fc ff 3a    	bra       NZ, 0x4d9e <.L67>

00004da6 <.L66>:
  }

  for (i = 0; i < n1; i++) {
    4da6:	4f 99 97    	mov.w     [w15-72], w2
    4da8:	02 00 e0    	cp0.w     w2
    4daa:	cf 00 34    	bra       LE, 0x4f4a <.L65>
    4dac:	f0 9f 9f    	mov.w     w0, [w15-66]

00004dae <.L0>:
    4dae:	af 99 97    	mov.w     [w15-76], w3
    4db0:	e4 81 51    	sub.w     w3, #0x4, w3
    4db2:	93 a7 9f    	mov.w     w3, [w15-62]
    4db4:	00 03 eb    	clr.w     w6
    4db6:	a6 a7 9f    	mov.w     w6, [w15-60]

00004db8 <.L0>:
    cb = 0UL;
    u1i = u1[i];
    a1 = u1i >> 16U;
    a0 = u1i & 65535UL;
    k = n - i;
    nj = n2 <= k ? n2 : k;
    k = i;
    for (j = 0; j < nj; j++) {
      yk = y[k];
      u1i = u2[j];
      b1 = u1i >> 16U;
      u1i &= 65535UL;
      w10 = a1 * u1i;
      w01 = a0 * b1;
      yk += cb;
      cb = (uint32_T)(yk < cb);
      u1i *= a0;
      yk += u1i;
      cb += (yk < u1i);
      u1i = w10 << 16U;
      yk += u1i;
      cb += (yk < u1i);
      u1i = w01 << 16U;
      yk += u1i;
      cb += (yk < u1i);
    4db8:	60 44 b8    	mul.uu    w8, #0x0, w8
    4dba:	c8 a7 9f    	mov.w     w8, [w15-56]
    4dbc:	d9 a7 9f    	mov.w     w9, [w15-54]

00004dbe <.L77>:
    4dbe:	ff 9c 97    	mov.w     [w15-66], w9
    4dc0:	39 02 be    	mov.d     [w9++], w4
    4dc2:	f9 9f 9f    	mov.w     w9, [w15-66]
    4dc4:	40 29 de    	lsr.w     w5, #0x0, w2
    4dc6:	03 00 20    	mov.w     #0x0, w3
    4dc8:	80 02 eb    	clr.w     w5
    4dca:	2f a5 97    	mov.w     [w15-60], w10
    4dcc:	da 9f 9f    	mov.w     w10, [w15-70]
    4dce:	8f a5 97    	mov.w     [w15-64], w11
    4dd0:	8a 00 78    	mov.w     w10, w1
    4dd2:	01 80 55    	sub.w     w11, w1, w0
    4dd4:	6f 9b 97    	mov.w     [w15-68], w6
    4dd6:	b6 a7 9f    	mov.w     w6, [w15-58]
    4dd8:	86 03 78    	mov.w     w6, w7
    4dda:	80 8f 53    	sub.w     w7, w0, [w15]
    4ddc:	01 00 34    	bra       LE, 0x4de0 <.L69>
    4dde:	b0 a7 9f    	mov.w     w0, [w15-58]

00004de0 <.L69>:
    4de0:	3f a4 97    	mov.w     [w15-58], w8
    4de2:	08 00 e0    	cp0.w     w8
    4de4:	9c 00 34    	bra       LE, 0x4f1e <.L78>
    4de6:	bf 9c 97    	mov.w     [w15-74], w9
    4de8:	e9 a7 9f    	mov.w     w9, [w15-52]
    4dea:	1f a6 97    	mov.w     [w15-62], w12
    4dec:	60 55 b8    	mul.uu    w10, #0x0, w10
    4dee:	ba b7 9f    	mov.w     w10, [w15-26]
    4df0:	cb b7 9f    	mov.w     w11, [w15-24]
    4df2:	80 06 eb    	clr.w     w13

00004df4 <.L75>:
    4df4:	64 06 46    	add.w     w12, #0x4, w12
    4df6:	fc af 9f    	mov.w     w12, [w15-34]
    4df8:	6f a0 97    	mov.w     [w15-52], w0
    4dfa:	30 03 be    	mov.d     [w0++], w6
    4dfc:	e0 a7 9f    	mov.w     w0, [w15-52]
    4dfe:	40 38 de    	lsr.w     w7, #0x0, w0
    4e00:	01 00 20    	mov.w     #0x0, w1
    4e02:	80 03 eb    	clr.w     w7
    4e04:	86 9c b9    	.pword 0xb99c86
    4e06:	02 35 b8    	mul.uu    w6, w2, w10
    4e08:	da b7 9f    	mov.w     w10, [w15-22]
    4e0a:	eb b7 9f    	mov.w     w11, [w15-20]
    4e0c:	8b 05 44    	add.w     w8, w11, w11
    4e0e:	eb b7 9f    	mov.w     w11, [w15-20]
    4e10:	84 8c b9    	.pword 0xb98c84
    4e12:	08 07 78    	mov.w     w8, w14
    4e14:	80 ac b9    	.pword 0xb9ac80
    4e16:	08 07 47    	add.w     w14, w8, w14
    4e18:	04 05 b8    	mul.uu    w0, w4, w10
    4e1a:	fa b7 9f    	mov.w     w10, [w15-18]
    4e1c:	8b bf 9f    	mov.w     w11, [w15-16]
    4e1e:	8b 05 47    	add.w     w14, w11, w11
    4e20:	8b bf 9f    	mov.w     w11, [w15-16]
    4e22:	3f b5 97    	mov.w     [w15-26], w10
    4e24:	cf b5 97    	mov.w     [w15-24], w11
    4e26:	3c 04 45    	add.w     w10, [w12++], w8
    4e28:	ac 84 4d    	addc.w    w11, [w12--], w9
    4e2a:	98 b7 9f    	mov.w     w8, [w15-30]
    4e2c:	a9 b7 9f    	mov.w     w9, [w15-28]
    4e2e:	18 00 20    	mov.w     #0x1, w8
    4e30:	09 00 20    	mov.w     #0x0, w9
    4e32:	f8 a7 9f    	mov.w     w8, [w15-50]
    4e34:	89 af 9f    	mov.w     w9, [w15-48]
    4e36:	1f b4 97    	mov.w     [w15-30], w8
    4e38:	af b4 97    	mov.w     [w15-28], w9
    4e3a:	8a 0f 54    	sub.w     w8, w10, [w15]
    4e3c:	8b 8f 5c    	subb.w    w9, w11, [w15]
    4e3e:	04 00 39    	bra       NC, 0x4e48 <.L71>
    4e40:	4f a5 97    	mov.w     [w15-56], w10
    4e42:	df a5 97    	mov.w     [w15-54], w11
    4e44:	fa a7 9f    	mov.w     w10, [w15-50]
    4e46:	8b af 9f    	mov.w     w11, [w15-48]

00004e48 <.L71>:
    4e48:	86 ac b9    	.pword 0xb9ac86
    4e4a:	08 07 78    	mov.w     w8, w14
    4e4c:	04 33 b8    	mul.uu    w6, w4, w6
    4e4e:	87 03 47    	add.w     w14, w7, w7
    4e50:	1f b5 97    	mov.w     [w15-30], w10
    4e52:	af b5 97    	mov.w     [w15-28], w11
    4e54:	0a 05 43    	add.w     w6, w10, w10
    4e56:	8b 85 4b    	addc.w    w7, w11, w11
    4e58:	ba b7 9f    	mov.w     w10, [w15-26]
    4e5a:	cb b7 9f    	mov.w     w11, [w15-24]
    4e5c:	5f b4 97    	mov.w     [w15-22], w8
    4e5e:	ef b4 97    	mov.w     [w15-20], w9
    4e60:	c0 44 dd    	sl.w      w8, #0x0, w9
    4e62:	08 00 20    	mov.w     #0x0, w8
    4e64:	98 b7 9f    	mov.w     w8, [w15-30]
    4e66:	a9 b7 9f    	mov.w     w9, [w15-28]
    4e68:	0a 05 44    	add.w     w8, w10, w10
    4e6a:	8b 85 4c    	addc.w    w9, w11, w11
    4e6c:	da af 9f    	mov.w     w10, [w15-38]
    4e6e:	eb af 9f    	mov.w     w11, [w15-36]
    4e70:	7f b4 97    	mov.w     [w15-18], w8
    4e72:	8f bc 97    	mov.w     [w15-16], w9
    4e74:	c0 44 dd    	sl.w      w8, #0x0, w9
    4e76:	08 00 20    	mov.w     #0x0, w8
    4e78:	b8 af 9f    	mov.w     w8, [w15-42]
    4e7a:	c9 af 9f    	mov.w     w9, [w15-40]
    4e7c:	0a 05 44    	add.w     w8, w10, w10
    4e7e:	8b 85 4c    	addc.w    w9, w11, w11
    4e80:	9a af 9f    	mov.w     w10, [w15-46]
    4e82:	ab af 9f    	mov.w     w11, [w15-44]
      y[k] = yk;
    4e84:	7f ac 97    	mov.w     [w15-34], w8
    4e86:	0a 8c be    	mov.d     w10, [w8]
      cb += w10 >> 16U;
    4e88:	5f b5 97    	mov.w     [w15-22], w10
    4e8a:	ef b5 97    	mov.w     [w15-20], w11
    4e8c:	40 5d de    	lsr.w     w11, #0x0, w10
    4e8e:	0b 00 20    	mov.w     #0x0, w11
    4e90:	fa af 9f    	mov.w     w10, [w15-34]
    4e92:	8b b7 9f    	mov.w     w11, [w15-32]
      cb += w01 >> 16U;
    4e94:	7f b5 97    	mov.w     [w15-18], w10
    4e96:	8f bd 97    	mov.w     [w15-16], w11
    4e98:	40 5c de    	lsr.w     w11, #0x0, w8
    4e9a:	09 00 20    	mov.w     #0x0, w9
    4e9c:	7f ad 97    	mov.w     [w15-34], w10
    4e9e:	8f b5 97    	mov.w     [w15-32], w11
    4ea0:	0a 05 44    	add.w     w8, w10, w10
    4ea2:	8b 85 4c    	addc.w    w9, w11, w11
    4ea4:	fa af 9f    	mov.w     w10, [w15-34]
    4ea6:	8b b7 9f    	mov.w     w11, [w15-32]
      cb += a1 * b1;
    4ea8:	82 8c b9    	.pword 0xb98c82
    4eaa:	80 9d b9    	.pword 0xb99d80
    4eac:	0a 04 44    	add.w     w8, w10, w8
    4eae:	02 00 b8    	mul.uu    w0, w2, w0
    4eb0:	81 00 44    	add.w     w8, w1, w1
    4eb2:	7f ac 97    	mov.w     [w15-34], w8
    4eb4:	8f b4 97    	mov.w     [w15-32], w9
    4eb6:	08 00 40    	add.w     w0, w8, w0
    4eb8:	89 80 48    	addc.w    w1, w9, w1
    4eba:	7f a5 97    	mov.w     [w15-50], w10
    4ebc:	8f ad 97    	mov.w     [w15-48], w11
    4ebe:	00 00 45    	add.w     w10, w0, w0
    4ec0:	81 80 4d    	addc.w    w11, w1, w1
    4ec2:	18 00 20    	mov.w     #0x1, w8
    4ec4:	09 00 20    	mov.w     #0x0, w9
    4ec6:	3f b5 97    	mov.w     [w15-26], w10
    4ec8:	cf b5 97    	mov.w     [w15-24], w11
    4eca:	86 0f 55    	sub.w     w10, w6, [w15]
    4ecc:	87 8f 5d    	subb.w    w11, w7, [w15]
    4ece:	02 00 39    	bra       NC, 0x4ed4 <.L72>
    4ed0:	4f a4 97    	mov.w     [w15-56], w8
    4ed2:	df a4 97    	mov.w     [w15-54], w9

00004ed4 <.L72>:
    4ed4:	00 00 44    	add.w     w8, w0, w0
    4ed6:	81 80 4c    	addc.w    w9, w1, w1
    4ed8:	16 00 20    	mov.w     #0x1, w6
    4eda:	07 00 20    	mov.w     #0x0, w7
    4edc:	5f ac 97    	mov.w     [w15-38], w8
    4ede:	ef ac 97    	mov.w     [w15-36], w9
    4ee0:	1f b5 97    	mov.w     [w15-30], w10
    4ee2:	af b5 97    	mov.w     [w15-28], w11
    4ee4:	8a 0f 54    	sub.w     w8, w10, [w15]
    4ee6:	8b 8f 5c    	subb.w    w9, w11, [w15]
    4ee8:	02 00 39    	bra       NC, 0x4eee <.L73>
    4eea:	4f a3 97    	mov.w     [w15-56], w6
    4eec:	df a3 97    	mov.w     [w15-54], w7

00004eee <.L73>:
    4eee:	00 00 43    	add.w     w6, w0, w0
    4ef0:	81 80 4b    	addc.w    w7, w1, w1
    4ef2:	1a 00 20    	mov.w     #0x1, w10
    4ef4:	0b 00 20    	mov.w     #0x0, w11
    4ef6:	1f ab 97    	mov.w     [w15-46], w6
    4ef8:	af ab 97    	mov.w     [w15-44], w7
    4efa:	3f ac 97    	mov.w     [w15-42], w8
    4efc:	cf ac 97    	mov.w     [w15-40], w9
    4efe:	88 0f 53    	sub.w     w6, w8, [w15]
    4f00:	89 8f 5b    	subb.w    w7, w9, [w15]
    4f02:	02 00 39    	bra       NC, 0x4f08 <.L74>
    4f04:	4f a5 97    	mov.w     [w15-56], w10
    4f06:	df a5 97    	mov.w     [w15-54], w11

00004f08 <.L74>:
    4f08:	00 03 45    	add.w     w10, w0, w6
    4f0a:	81 83 4d    	addc.w    w11, w1, w7
    4f0c:	b6 b7 9f    	mov.w     w6, [w15-26]
    4f0e:	c7 b7 9f    	mov.w     w7, [w15-24]
    4f10:	8d 06 e8    	inc.w     w13, w13
    4f12:	bf a3 97    	mov.w     [w15-58], w7
    4f14:	87 8f 56    	sub.w     w13, w7, [w15]
    4f16:	6e ff 3a    	bra       NZ, 0x4df4 <.L75>
    4f18:	5f 9c 97    	mov.w     [w15-70], w8
    4f1a:	08 80 43    	add.w     w7, w8, w0
    4f1c:	04 00 37    	bra       0x4f26 <.L70>

00004f1e <.L78>:
    4f1e:	2f a0 97    	mov.w     [w15-60], w0
    4f20:	60 55 b8    	mul.uu    w10, #0x0, w10
    4f22:	ba b7 9f    	mov.w     w10, [w15-26]
    4f24:	cb b7 9f    	mov.w     w11, [w15-24]

00004f26 <.L70>:
      k++;
    }

    if (k < n) {
    4f26:	8f a5 97    	mov.w     [w15-64], w11
    4f28:	80 8f 55    	sub.w     w11, w0, [w15]
    4f2a:	06 00 34    	bra       LE, 0x4f38 <.L76>
      y[k] = cb;
    4f2c:	42 00 dd    	sl.w      w0, #0x2, w0
    4f2e:	af 98 97    	mov.w     [w15-76], w1
    4f30:	00 80 40    	add.w     w1, w0, w0
    4f32:	3f b1 97    	mov.w     [w15-26], w2
    4f34:	cf b1 97    	mov.w     [w15-24], w3
    4f36:	02 88 be    	mov.d     w2, [w0]

00004f38 <.L76>:
    4f38:	af a1 97    	mov.w     [w15-60], w3
    4f3a:	83 01 e8    	inc.w     w3, w3
    4f3c:	a3 a7 9f    	mov.w     w3, [w15-60]
    4f3e:	1f a3 97    	mov.w     [w15-62], w6
    4f40:	64 03 43    	add.w     w6, #0x4, w6
    4f42:	96 a7 9f    	mov.w     w6, [w15-62]
    4f44:	cf 9b 97    	mov.w     [w15-72], w7
    4f46:	87 8f 51    	sub.w     w3, w7, [w15]
    4f48:	3a ff 3a    	bra       NZ, 0x4dbe <.L77>

00004f4a <.L65>:
    }
  }
}
    4f4a:	4f 07 78    	mov.w     [--w15], w14
    4f4c:	4f 06 be    	mov.d     [--w15], w12
    4f4e:	4f 05 be    	mov.d     [--w15], w10
    4f50:	4f 04 be    	mov.d     [--w15], w8
    4f52:	0f 04 b1    	sub.w     #0x40, w15
    4f54:	00 00 06    	return    

00004f56 <_AUAV_V3_TestS_negprotect_l>:

/*
 * Output and update for atomic system:
 *    '<S174>/negprotect'
 *    '<S453>/negprotect'
 *    '<S311>/negprotect'
 *    '<S335>/negprotect'
 *    '<S342>/negprotect'
 *    '<S390>/negprotect'
 *    '<S397>/negprotect'
 *    '<S437>/negprotect'
 *    '<S296>/negprotect'
 *    '<S225>/negprotect'
 *    ...
 */
void AUAV_V3_TestS_negprotect_l(real32_T rtu_val,
  rtB_negprotect_AUAV_V3_Test_p_T *localB)
{
    4f56:	88 9f be    	mov.d     w8, [w15++]
    4f58:	8a 1f 78    	mov.w     w10, [w15++]
    4f5a:	00 04 be    	mov.d     w0, w8
    4f5c:	02 05 78    	mov.w     w2, w10

00004f5e <.L0>:
  /* MATLAB Function 'Inner Loop// Navigation/Longitudinal Channel Encaps [updated 4.28.16]/Longitudinal Channel/Pitot Control End/Compute Airspeed/dsPIC_SQRT/negprotect': '<S176>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  if (rtu_val >= 0.001F) {
    4f5e:	f2 26 21    	mov.w     #0x126f, w2
    4f60:	33 a8 23    	mov.w     #0x3a83, w3
    4f62:	90 18 02    	call      0x1890 <___gesf2>
    4f64:	00 00 00 
    4f66:	00 00 e0    	cp0.w     w0
    4f68:	02 00 35    	bra       LT, 0x4f6e <.L87>

00004f6a <.L0>:
    /* '<S176>:1:5' */
    /* '<S176>:1:6' */
    localB->zpVal = rtu_val;
    4f6a:	08 8d be    	mov.d     w8, [w10]
    4f6c:	03 00 37    	bra       0x4f74 <.L82>

00004f6e <.L87>:
  } else {
    /* '<S176>:1:8' */
    localB->zpVal = 0.001F;
    4f6e:	f0 26 21    	mov.w     #0x126f, w0
    4f70:	31 a8 23    	mov.w     #0x3a83, w1
    4f72:	00 8d be    	mov.d     w0, [w10]

00004f74 <.L82>:
  }
}
    4f74:	4f 05 78    	mov.w     [--w15], w10
    4f76:	4f 04 be    	mov.d     [--w15], w8
    4f78:	00 00 06    	return    

00004f7a <_A_EmbeddedMATLABFunction_b>:

/*
 * Output and update for atomic system:
 *    '<S452>/Embedded MATLAB Function'
 *    '<S334>/Embedded MATLAB Function'
 *    '<S341>/Embedded MATLAB Function'
 *    '<S389>/Embedded MATLAB Function'
 *    '<S396>/Embedded MATLAB Function'
 *    '<S436>/Embedded MATLAB Function'
 *    '<S295>/Embedded MATLAB Function'
 *    '<S224>/Embedded MATLAB Function'
 *    '<S237>/Embedded MATLAB Function'
 *    '<S250>/Embedded MATLAB Function'
 *    ...
 */
void A_EmbeddedMATLABFunction_b(const real32_T rtu_x[3],
  rtB_EmbeddedMATLABFunction_b_T *localB)
{
    4f7a:	88 9f be    	mov.d     w8, [w15++]
    4f7c:	8a 9f be    	mov.d     w10, [w15++]
    4f7e:	8c 9f be    	mov.d     w12, [w15++]
    4f80:	8e 1f 78    	mov.w     w14, [w15++]
    4f82:	00 01 78    	mov.w     w0, w2
    4f84:	01 07 78    	mov.w     w1, w14
  /* MATLAB Function 'dsPIC Dot Product/Embedded MATLAB Function': '<S454>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S454>:1:5' */
  localB->xDoty = (rtu_x[0] * rtu_x[0] + rtu_x[1] * rtu_x[1]) + rtu_x[2] *
    4f86:	12 00 be    	mov.d     [w2], w0
    4f88:	22 05 90    	mov.w     [w2+4], w10
    4f8a:	b2 05 90    	mov.w     [w2+6], w11
    rtu_x[2];
    4f8c:	42 06 90    	mov.w     [w2+8], w12
    4f8e:	d2 06 90    	mov.w     [w2+10], w13

00004f90 <.L0>:
    4f90:	00 01 be    	mov.d     w0, w2
    4f92:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    4f94:	00 00 00 
    4f96:	00 04 be    	mov.d     w0, w8
    4f98:	0a 01 be    	mov.d     w10, w2
    4f9a:	0a 00 be    	mov.d     w10, w0
    4f9c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    4f9e:	00 00 00 
    4fa0:	00 01 be    	mov.d     w0, w2
    4fa2:	08 00 be    	mov.d     w8, w0
    4fa4:	92 14 02    	call      0x1492 <___addsf3>
    4fa6:	00 00 00 
    4fa8:	00 04 be    	mov.d     w0, w8
    4faa:	0c 01 be    	mov.d     w12, w2
    4fac:	0c 00 be    	mov.d     w12, w0
    4fae:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    4fb0:	00 00 00 
    4fb2:	00 01 be    	mov.d     w0, w2
    4fb4:	08 00 be    	mov.d     w8, w0
    4fb6:	92 14 02    	call      0x1492 <___addsf3>
    4fb8:	00 00 00 
    4fba:	00 8f be    	mov.d     w0, [w14]

00004fbc <.L0>:
}
    4fbc:	4f 07 78    	mov.w     [--w15], w14
    4fbe:	4f 06 be    	mov.d     [--w15], w12
    4fc0:	4f 05 be    	mov.d     [--w15], w10
    4fc2:	4f 04 be    	mov.d     [--w15], w8
    4fc4:	00 00 06    	return    

00004fc6 <_AUAV_V3_TestSens_ZerooutZ1>:

/*
 * Output and update for atomic system:
 *    '<S188>/Zero out Z1'
 *    '<S303>/Zero out Z1'
 *    '<S303>/Zero out Z2'
 *    '<S303>/Zero out Z3'
 *    '<S187>/Zero out Z2'
 *    '<S198>/Zero out Z2'
 *    '<S277>/Zero out Z1'
 *    '<S180>/Zero out Z1'
 *    '<S180>/Zero out Z2'
 */
void AUAV_V3_TestSens_ZerooutZ1(const real32_T rtu_Pin[3],
  rtB_ZerooutZ1_AUAV_V3_TestSen_T *localB)
{
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/RTB//Follow Mobile Navigation/Zero out Z1': '<S445>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S445>:1:5' */
  localB->P[0] = rtu_Pin[0];
    4fc6:	b0 18 78    	mov.w     [w0++], [w1++]
    4fc8:	a0 10 78    	mov.w     [w0--], [w1--]
  localB->P[1] = rtu_Pin[1];
    4fca:	20 01 90    	mov.w     [w0+4], w2
    4fcc:	b0 01 90    	mov.w     [w0+6], w3
    4fce:	a2 00 98    	mov.w     w2, [w1+4]
    4fd0:	b3 00 98    	mov.w     w3, [w1+6]
  localB->P[2] = 0.0F;
    4fd2:	60 11 b8    	mul.uu    w2, #0x0, w2
    4fd4:	c2 00 98    	mov.w     w2, [w1+8]
    4fd6:	d3 00 98    	mov.w     w3, [w1+10]
}
    4fd8:	00 00 06    	return    

00004fda <_A_EmbeddedMATLABFunction_k>:

/*
 * Output and update for atomic system:
 *    '<S316>/Embedded MATLAB Function'
 *    '<S309>/Embedded MATLAB Function'
 *    '<S221>/Embedded MATLAB Function'
 *    '<S234>/Embedded MATLAB Function'
 */
void A_EmbeddedMATLABFunction_k(const real32_T rtu_x[3], const real32_T rtu_y[3],
  rtB_EmbeddedMATLABFunction_i_T *localB)
{
    4fda:	88 9f be    	mov.d     w8, [w15++]
    4fdc:	8a 9f be    	mov.d     w10, [w15++]
    4fde:	8c 1f 78    	mov.w     w12, [w15++]
    4fe0:	80 05 78    	mov.w     w0, w11
    4fe2:	01 05 78    	mov.w     w1, w10
    4fe4:	02 06 78    	mov.w     w2, w12

00004fe6 <.L0>:
  /* MATLAB Function 'dsPIC Dot Product/Embedded MATLAB Function': '<S317>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S317>:1:5' */
  localB->xDoty = (rtu_x[0] * rtu_y[0] + rtu_x[1] * rtu_y[1]) + rtu_x[2] *
    4fe6:	1a 01 be    	mov.d     [w10], w2
    4fe8:	1b 00 be    	mov.d     [w11], w0
    4fea:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    4fec:	00 00 00 
    4fee:	00 04 be    	mov.d     w0, w8
    4ff0:	2a 01 90    	mov.w     [w10+4], w2
    4ff2:	ba 01 90    	mov.w     [w10+6], w3
    4ff4:	2b 00 90    	mov.w     [w11+4], w0
    4ff6:	bb 00 90    	mov.w     [w11+6], w1
    4ff8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    4ffa:	00 00 00 
    4ffc:	00 01 be    	mov.d     w0, w2
    4ffe:	08 00 be    	mov.d     w8, w0
    5000:	92 14 02    	call      0x1492 <___addsf3>
    5002:	00 00 00 
    5004:	00 04 be    	mov.d     w0, w8
    5006:	4a 01 90    	mov.w     [w10+8], w2
    5008:	da 01 90    	mov.w     [w10+10], w3
    500a:	4b 00 90    	mov.w     [w11+8], w0
    500c:	db 00 90    	mov.w     [w11+10], w1
    500e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5010:	00 00 00 
    5012:	00 01 be    	mov.d     w0, w2
    5014:	08 00 be    	mov.d     w8, w0
    5016:	92 14 02    	call      0x1492 <___addsf3>
    5018:	00 00 00 
    501a:	00 8e be    	mov.d     w0, [w12]

0000501c <.L0>:
    rtu_y[2];
}
    501c:	4f 06 78    	mov.w     [--w15], w12
    501e:	4f 05 be    	mov.d     [--w15], w10
    5020:	4f 04 be    	mov.d     [--w15], w8
    5022:	00 00 06    	return    

00005024 <_AUAV_V3_TestS_SelectNTerms>:

/*
 * Output and update for atomic system:
 *    '<S324>/Select N  Terms'
 *    '<S382>/Select N  Terms'
 */
void AUAV_V3_TestS_SelectNTerms(const real32_T rtu_T[3],
  rtB_SelectNTerms_AUAV_V3_Test_T *localB)
{
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Normal WP  Navigation/Get Frenet/Compute Frenet/Select N  Terms': '<S332>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S332>:1:5' */
  localB->N[0] = -rtu_T[1];
    5024:	20 01 90    	mov.w     [w0+4], w2
    5026:	b0 01 90    	mov.w     [w0+6], w3
    5028:	03 f0 a2    	btg.w     w3, #0xf
    502a:	82 88 be    	mov.d     w2, [w1]
  localB->N[1] = rtu_T[0];
    502c:	10 01 be    	mov.d     [w0], w2
    502e:	a2 00 98    	mov.w     w2, [w1+4]
    5030:	b3 00 98    	mov.w     w3, [w1+6]
  localB->N[2] = 0.0F;
    5032:	60 11 b8    	mul.uu    w2, #0x0, w2
    5034:	c2 00 98    	mov.w     w2, [w1+8]
    5036:	d3 00 98    	mov.w     w3, [w1+10]
}
    5038:	00 00 06    	return    

0000503a <_AUAV_V3_TestSe_negprotect3>:

/*
 * Output and update for atomic system:
 *    '<S212>/negprotect3'
 *    '<S213>/negprotect3'
 *    '<S200>/negprotect1'
 *    '<S200>/negprotect2'
 *    '<S269>/negprotect'
 *    '<S270>/negprotect'
 */
void AUAV_V3_TestSe_negprotect3(real32_T rtu_val,
  rtB_negprotect3_AUAV_V3_TestS_T *localB)
{
    503a:	88 9f be    	mov.d     w8, [w15++]
    503c:	8a 1f 78    	mov.w     w10, [w15++]
    503e:	00 04 be    	mov.d     w0, w8
    5040:	02 05 78    	mov.w     w2, w10

00005042 <.L0>:
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Circle Navigation/Intersection. Circular Navigation/Compute Angle Between Vectors1/negprotect3': '<S223>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  if (rtu_val >= 0.0001F) {
    5042:	72 71 2b    	mov.w     #0xb717, w2
    5044:	13 8d 23    	mov.w     #0x38d1, w3
    5046:	90 18 02    	call      0x1890 <___gesf2>
    5048:	00 00 00 
    504a:	00 00 e0    	cp0.w     w0
    504c:	02 00 35    	bra       LT, 0x5052 <.L97>

0000504e <.L0>:
    /* '<S223>:1:5' */
    /* '<S223>:1:6' */
    localB->zpVal = rtu_val;
    504e:	08 8d be    	mov.d     w8, [w10]
    5050:	03 00 37    	bra       0x5058 <.L92>

00005052 <.L97>:
  } else {
    /* '<S223>:1:8' */
    localB->zpVal = 0.0001F;
    5052:	70 71 2b    	mov.w     #0xb717, w0
    5054:	11 8d 23    	mov.w     #0x38d1, w1
    5056:	00 8d be    	mov.d     w0, [w10]

00005058 <.L92>:
  }
}
    5058:	4f 05 78    	mov.w     [--w15], w10
    505a:	4f 04 be    	mov.d     [--w15], w8
    505c:	00 00 06    	return    

0000505e <_AUAV__BufferICChannel_Init>:

/*
 * Initial conditions for atomic system:
 *    '<S655>/Buffer IC Channel'
 *    '<S655>/Buffer IC Channel1'
 *    '<S655>/Buffer IC Channel2'
 *    '<S655>/Buffer IC Channel3'
 *    '<S660>/Buffer Failsafe Channel'
 */
void AUAV__BufferICChannel_Init(rtDW_BufferICChannel_AUAV_V3__T *localDW)
{
  int16_T i;
  for (i = 0; i < 7; i++) {
    localDW->oldValues[i] = 0U;
    505e:	80 00 eb    	clr.w     w1
    5060:	01 08 78    	mov.w     w1, [w0]
    5062:	11 00 98    	mov.w     w1, [w0+2]
    5064:	21 00 98    	mov.w     w1, [w0+4]
    5066:	31 00 98    	mov.w     w1, [w0+6]
    5068:	41 00 98    	mov.w     w1, [w0+8]
    506a:	51 00 98    	mov.w     w1, [w0+10]
    506c:	61 00 98    	mov.w     w1, [w0+12]
  }
}
    506e:	00 00 06    	return    

00005070 <_AUAV_V3_Te_BufferICChannel>:

/*
 * Output and update for atomic system:
 *    '<S655>/Buffer IC Channel'
 *    '<S655>/Buffer IC Channel1'
 *    '<S655>/Buffer IC Channel2'
 *    '<S655>/Buffer IC Channel3'
 *    '<S660>/Buffer Failsafe Channel'
 */
void AUAV_V3_Te_BufferICChannel(uint16_T rtu_latest,
  rtB_BufferICChannel_AUAV_V3_T_T *localB, rtDW_BufferICChannel_AUAV_V3__T
  *localDW)
{
  int16_T i;

  /* MATLAB Function 'Trim Vals [updated 4.28.16]/Bufffer IC/Buffer IC Channel': '<S661>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S661>:1:11' */
  for (i = 0; i < 7; i++) {
    localB->history[i] = 0U;
    5070:	80 01 eb    	clr.w     w3
    5072:	83 08 78    	mov.w     w3, [w1]
    5074:	93 00 98    	mov.w     w3, [w1+2]
    5076:	a3 00 98    	mov.w     w3, [w1+4]
    5078:	b3 00 98    	mov.w     w3, [w1+6]
    507a:	c3 00 98    	mov.w     w3, [w1+8]
    507c:	d3 00 98    	mov.w     w3, [w1+10]
    507e:	e3 00 98    	mov.w     w3, [w1+12]
    5080:	6c 02 41    	add.w     w2, #0xc, w4
    5082:	ee 03 41    	add.w     w2, #0xe, w7
    5084:	6e 83 40    	add.w     w1, #0xe, w6
    5086:	84 02 78    	mov.w     w4, w5
    5088:	63 00 20    	mov.w     #0x6, w3

0000508a <.L100>:
  }

  /* '<S661>:1:13' */
  for (i = 0; i < 6; i++) {
    /* '<S661>:1:13' */
    /* '<S661>:1:14' */
    localDW->oldValues[6 - i] = localDW->oldValues[5 - i];
    508a:	c4 23 78    	mov.w     [--w4], [--w7]

    /* '<S661>:1:15' */
    localB->history[6 - i] = localDW->oldValues[5 - i];
    508c:	45 23 78    	mov.w     [--w5], [--w6]
    508e:	83 01 e9    	dec.w     w3, w3
    5090:	fc ff 3a    	bra       NZ, 0x508a <.L100>

    /* '<S661>:1:13' */
  }

  /* '<S661>:1:18' */
  localDW->oldValues[0] = rtu_latest;
    5092:	00 09 78    	mov.w     w0, [w2]

  /* '<S661>:1:19' */
  localB->history[0] = rtu_latest;
    5094:	80 08 78    	mov.w     w0, [w1]
}
    5096:	00 00 06    	return    

00005098 <_AUAV_V3_TestSe_myMuxFun1_d>:

/*
 * Output and update for atomic system:
 *    '<S688>/myMux Fun1'
 *    '<S687>/myMux Fun1'
 */
void AUAV_V3_TestSe_myMuxFun1_d(uint16_T rtu_u1, uint16_T rtu_u2, uint16_T
  rtu_u3, uint16_T rtu_u4, uint16_T rty_y[4])
{
  /* MATLAB Function 'Update PWM Commands and Send Telemetry [updated 4.27.16]/Generate PWM Signals Based on the Control Type/If  Control Type Is Wp, ISR, LP or  Mid Lvl Cmds/myMux Fun1': '<S698>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S698>:1:5' */
  rty_y[0] = rtu_u1;
    5098:	00 0a 78    	mov.w     w0, [w4]
  rty_y[1] = rtu_u2;
    509a:	11 02 98    	mov.w     w1, [w4+2]
  rty_y[2] = rtu_u3;
    509c:	22 02 98    	mov.w     w2, [w4+4]
  rty_y[3] = rtu_u4;
    509e:	33 02 98    	mov.w     w3, [w4+6]
}
    50a0:	00 00 06    	return    

000050a2 <_AUAV_V3_TestSens_myMuxFun3>:

/*
 * Output and update for atomic system:
 *    '<Root>/myMux Fun3'
 *    '<Root>/myMux Fun4'
 */
void AUAV_V3_TestSens_myMuxFun3(const real32_T rtu_u1[3], const real32_T rtu_u2
  [3], rtB_myMuxFun3_AUAV_V3_TestSen_T *localB)
{
  /* MATLAB Function 'myMux Fun3': '<S24>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S24>:1:5' */
  localB->y[0] = rtu_u1[0];
    50a2:	30 19 78    	mov.w     [w0++], [w2++]
    50a4:	20 11 78    	mov.w     [w0--], [w2--]
  localB->y[1] = rtu_u1[1];
    50a6:	20 02 90    	mov.w     [w0+4], w4
    50a8:	b0 02 90    	mov.w     [w0+6], w5
    50aa:	24 01 98    	mov.w     w4, [w2+4]
    50ac:	35 01 98    	mov.w     w5, [w2+6]
  localB->y[2] = rtu_u1[2];
    50ae:	40 02 90    	mov.w     [w0+8], w4
    50b0:	d0 02 90    	mov.w     [w0+10], w5
    50b2:	44 01 98    	mov.w     w4, [w2+8]
    50b4:	55 01 98    	mov.w     w5, [w2+10]
  localB->y[3] = rtu_u2[0];
    50b6:	11 02 be    	mov.d     [w1], w4
    50b8:	64 01 98    	mov.w     w4, [w2+12]
    50ba:	75 01 98    	mov.w     w5, [w2+14]
  localB->y[4] = rtu_u2[1];
    50bc:	21 02 90    	mov.w     [w1+4], w4
    50be:	b1 02 90    	mov.w     [w1+6], w5
    50c0:	04 09 98    	mov.w     w4, [w2+16]
    50c2:	15 09 98    	mov.w     w5, [w2+18]
  localB->y[5] = rtu_u2[2];
    50c4:	41 02 90    	mov.w     [w1+8], w4
    50c6:	d1 02 90    	mov.w     [w1+10], w5
    50c8:	24 09 98    	mov.w     w4, [w2+20]
    50ca:	35 09 98    	mov.w     w5, [w2+22]
}
    50cc:	00 00 06    	return    

000050ce <_AUAV_V3_TestSensors_step0>:

/* Model step function for TID0 */
void AUAV_V3_TestSensors_step0(void)   /* Sample time: [0.01s, 0.0s] */
{
    50ce:	00 02 fa    	lnk       #0x200
    50d0:	88 9f be    	mov.d     w8, [w15++]
    50d2:	8a 9f be    	mov.d     w10, [w15++]
    50d4:	8c 9f be    	mov.d     w12, [w15++]
  /* local block i/o variables */
  boolean_T rtb_ConfigUART4RxPin;
  real32_T rtb_Product3_j0[3];
  real32_T rtb_VectorConcatenate[9];
  real32_T rtb_Product2_c[3];
  real32_T rtb_VectorConcatenate_m[9];
  real32_T rtb_VectorConcatenate_h[7];
  uint8_T rtb_DataTypeConversion1_hq;
  boolean_T rtb_IC1_a;
  uint16_T rtb_u2deg;
  uint8_T rtb_Compare_j;
  boolean_T rtb_IC1;
  uint8_T rtb_DataTypeConversion2_fi;
  uint8_T rtb_IC2;
  real32_T rtb_Product3_bo;
  real32_T rtb_Switch3;
  real32_T rtb_Projection;
  real32_T rtb_Switch3_gd;
  real32_T rtb_Subtract_a;
  real32_T rtb_Subtract_od;
  real32_T rtb_Switch1_a;
  real32_T rtb_Merge_m[3];
  real32_T rtb_Ze_b;
  real32_T rtb_cosphi;
  real32_T rtb_Sum1_mzp;
  real32_T rtb_Deg2R1;
  real32_T rtb_RhhcosphisinlambYe;
  real32_T rtb_RhhcosphicoslambXe;
  real32_T rtb_Product_lf;
  real32_T rtb_Switch3_kh;
  uint16_T rtb_Switch1_m;
  uint16_T rtb_Switch2;
  uint16_T rtb_Switch3_fq;
  real32_T rtb_P32[3];
  real32_T rtb_MathFunction[9];
  int16_T i;
  int16_T i_0;
  real32_T tmp[9];
  real32_T tmp_0[3];
  real32_T tmp_1[9];
  real32_T tmp_2[9];
  real32_T tmp_3[9];
  real32_T rtb_IC4_idx_1;
  real32_T rtb_IC4_idx_0;
  real32_T rtb_Deg2R_h_idx_0;
  real32_T rtb_y_jl_idx_1;
  real32_T rtb_y_jl_idx_0;
  real_T tmp_4;
  real_T tmp_5;
  real_T tmp_6;
  real_T tmp_7;
  uint64m_T tmp_8;
  uint64m_T tmp_9;
  uint32_T tmp_a;

  /* Update the flag to indicate when data transfers from
   *  Sample time: [0.01s, 0.0s] to Sample time: [0.1s, 0.0s]  */
  (AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_2)++;
    50d6:	b1 24 22    	mov.w     #0x224b, w1
    50d8:	11 40 e8    	inc.b     [w1], w0
    50da:	80 48 78    	mov.b     w0, [w1]
  if ((AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_2) > 9) {
    50dc:	e9 4f 50    	sub.b     w0, #0x9, [w15]
    50de:	02 00 36    	bra       LEU, 0x50e4 <.L105>
    AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_2 = 0;
    50e0:	01 00 78    	mov.w     w1, w0
    50e2:	00 48 eb    	clr.b     [w0]

000050e4 <.L105>:
  }

  /* Update the flag to indicate when data transfers from
   *  Sample time: [0.01s, 0.0s] to Sample time: [0.2s, 0.0s]  */
  (AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_3)++;
    50e4:	c1 24 22    	mov.w     #0x224c, w1
    50e6:	11 40 e8    	inc.b     [w1], w0
    50e8:	80 48 78    	mov.b     w0, [w1]
  if ((AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_3) > 19) {
    50ea:	f3 4f 50    	sub.b     w0, #0x13, [w15]
    50ec:	02 00 36    	bra       LEU, 0x50f2 <.L0> <.L106>
    AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_3 = 0;
    50ee:	01 00 78    	mov.w     w1, w0
    50f0:	00 48 eb    	clr.b     [w0]

000050f2 <.L0>:
  }

  /* Gain: '<S699>/Unit Conversion' incorporates:
   *  DataStoreRead: '<S21>/PAR_CONFIG_ROLL_R PAR_CONFIG_PITCH_R PAR_CONFIG_YAW_R'
   */
  rtb_Product3_j0[0] = 0.0174532924F * mlParamInterface.param[15L];
    50f2:	52 a3 2f    	mov.w     #0xfa35, w2
    50f4:	e3 c8 23    	mov.w     #0x3c8e, w3
    50f6:	b0 94 80    	mov.w     0x1296, w0
    50f8:	c1 94 80    	mov.w     0x1298, w1
    50fa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    50fc:	00 00 00 
    50fe:	00 05 be    	mov.d     w0, w10

00005100 <.L0>:
  rtb_Product3_j0[1] = 0.0174532924F * mlParamInterface.param[16L];
    5100:	52 a3 2f    	mov.w     #0xfa35, w2
    5102:	e3 c8 23    	mov.w     #0x3c8e, w3
    5104:	d0 94 80    	mov.w     0x129a, w0
    5106:	e1 94 80    	mov.w     0x129c, w1
    5108:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    510a:	00 00 00 
    510c:	00 06 be    	mov.d     w0, w12

0000510e <.L0>:
  rtb_Product3_j0[2] = 0.0174532924F * mlParamInterface.param[17L];
    510e:	52 a3 2f    	mov.w     #0xfa35, w2
    5110:	e3 c8 23    	mov.w     #0x3c8e, w3
    5112:	f0 94 80    	mov.w     0x129e, w0
    5114:	01 95 80    	mov.w     0x12a0, w1
    5116:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5118:	00 00 00 
    511a:	30 af 99    	mov.w     w0, [w14+470]
    511c:	41 af 99    	mov.w     w1, [w14+472]
    511e:	40 07 98    	mov.w     w0, [w14+8]
    5120:	51 07 98    	mov.w     w1, [w14+10]

00005122 <.L0>:

  /* Trigonometry: '<S702>/SinCos' */
  rtb_Product2_c[0] = (real32_T)cos(rtb_Product3_j0[0]);
    5122:	0a 00 be    	mov.d     w10, w0
    5124:	22 17 02    	call      0x1722 <_cosf>
    5126:	00 00 00 
    5128:	00 04 be    	mov.d     w0, w8
    512a:	00 1f 98    	mov.w     w0, [w14+48]
    512c:	11 1f 98    	mov.w     w1, [w14+50]

0000512e <.L0>:
  rtb_Product3_j0[0] = (real32_T)sin(rtb_Product3_j0[0]);
    512e:	0a 00 be    	mov.d     w10, w0
    5130:	b6 1d 02    	call      0x1db6 <_sinf>
    5132:	00 00 00 
    5134:	00 05 be    	mov.d     w0, w10
    5136:	00 8f be    	mov.d     w0, [w14]

00005138 <.L0>:
  rtb_Product2_c[1] = (real32_T)cos(rtb_Product3_j0[1]);
    5138:	0c 00 be    	mov.d     w12, w0
    513a:	22 17 02    	call      0x1722 <_cosf>
    513c:	00 00 00 
    513e:	70 af 99    	mov.w     w0, [w14+478]
    5140:	01 b7 99    	mov.w     w1, [w14+480]
    5142:	20 1f 98    	mov.w     w0, [w14+52]
    5144:	31 1f 98    	mov.w     w1, [w14+54]

00005146 <.L0>:
  rtb_Product3_j0[1] = (real32_T)sin(rtb_Product3_j0[1]);
    5146:	0c 00 be    	mov.d     w12, w0
    5148:	b6 1d 02    	call      0x1db6 <_sinf>
    514a:	00 00 00 
    514c:	30 b7 99    	mov.w     w0, [w14+486]
    514e:	41 b7 99    	mov.w     w1, [w14+488]
    5150:	20 07 98    	mov.w     w0, [w14+4]
    5152:	31 07 98    	mov.w     w1, [w14+6]

00005154 <.L0>:
  rtb_RhhcosphisinlambYe = (real32_T)cos(rtb_Product3_j0[2]);
    5154:	3e a8 91    	mov.w     [w14+470], w0
    5156:	ce a8 91    	mov.w     [w14+472], w1
    5158:	22 17 02    	call      0x1722 <_cosf>
    515a:	00 00 00 
    515c:	50 b7 99    	mov.w     w0, [w14+490]
    515e:	61 b7 99    	mov.w     w1, [w14+492]

00005160 <.L0>:
  rtb_Sum1_mzp = (real32_T)sin(rtb_Product3_j0[2]);
    5160:	3e a8 91    	mov.w     [w14+470], w0
    5162:	ce a8 91    	mov.w     [w14+472], w1
    5164:	b6 1d 02    	call      0x1db6 <_sinf>
    5166:	00 00 00 
    5168:	00 06 be    	mov.d     w0, w12

0000516a <.L0>:

  /* Product: '<S709>/u(5)*u(6)' incorporates:
   *  Trigonometry: '<S702>/SinCos'
   */
  rtb_VectorConcatenate[0] = rtb_Product2_c[1] * rtb_RhhcosphisinlambYe;
    516a:	5e b1 91    	mov.w     [w14+490], w2
    516c:	ee b1 91    	mov.w     [w14+492], w3
    516e:	7e a8 91    	mov.w     [w14+478], w0
    5170:	8e b0 91    	mov.w     [w14+480], w1
    5172:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5174:	00 00 00 
    5176:	20 8f 98    	mov.w     w0, [w14+148]
    5178:	31 8f 98    	mov.w     w1, [w14+150]
    517a:	60 07 98    	mov.w     w0, [w14+12]
    517c:	71 07 98    	mov.w     w1, [w14+14]

0000517e <.L0>:

  /* Sum: '<S712>/Sum' incorporates:
   *  Product: '<S712>/u(3)*u(4)'
   *  Product: '<S712>/u(6)*u(1)*u(2)'
   *  Trigonometry: '<S702>/SinCos'
   */
  rtb_VectorConcatenate[1] = rtb_RhhcosphisinlambYe * rtb_Product3_j0[0] *
    517e:	5e b1 91    	mov.w     [w14+490], w2
    5180:	ee b1 91    	mov.w     [w14+492], w3
    5182:	0a 00 be    	mov.d     w10, w0
    5184:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5186:	00 00 00 
    5188:	70 a7 99    	mov.w     w0, [w14+462]
    518a:	01 af 99    	mov.w     w1, [w14+464]
    518c:	00 01 be    	mov.d     w0, w2
    518e:	3e b0 91    	mov.w     [w14+486], w0
    5190:	ce b0 91    	mov.w     [w14+488], w1
    5192:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5194:	00 00 00 
    5196:	30 a7 99    	mov.w     w0, [w14+454]
    5198:	41 a7 99    	mov.w     w1, [w14+456]

0000519a <.L0>:
    rtb_Product3_j0[1] - rtb_Sum1_mzp * rtb_Product2_c[0];
    519a:	0c 01 be    	mov.d     w12, w2
    519c:	08 00 be    	mov.d     w8, w0
    519e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51a0:	00 00 00 
    51a2:	00 01 be    	mov.d     w0, w2
    51a4:	3e a0 91    	mov.w     [w14+454], w0
    51a6:	ce a0 91    	mov.w     [w14+456], w1
    51a8:	90 14 02    	call      0x1490 <___subsf3>
    51aa:	00 00 00 
    51ac:	00 97 98    	mov.w     w0, [w14+160]
    51ae:	11 97 98    	mov.w     w1, [w14+162]

000051b0 <.L0>:
    51b0:	00 0f 98    	mov.w     w0, [w14+16]
    51b2:	11 0f 98    	mov.w     w1, [w14+18]

000051b4 <.L0>:

  /* Sum: '<S715>/Sum' incorporates:
   *  Product: '<S715>/u(1)*u(3)'
   *  Product: '<S715>/u(2)*u(4)*u(6)'
   *  Trigonometry: '<S702>/SinCos'
   */
  rtb_VectorConcatenate[2] = rtb_Product3_j0[1] * rtb_Product2_c[0] *
    51b4:	3e b1 91    	mov.w     [w14+486], w2
    51b6:	ce b1 91    	mov.w     [w14+488], w3
    51b8:	08 00 be    	mov.d     w8, w0
    51ba:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51bc:	00 00 00 
    51be:	5e b1 91    	mov.w     [w14+490], w2
    51c0:	ee b1 91    	mov.w     [w14+492], w3
    51c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51c4:	00 00 00 
    51c6:	10 b7 99    	mov.w     w0, [w14+482]
    51c8:	21 b7 99    	mov.w     w1, [w14+484]

000051ca <.L0>:
    rtb_RhhcosphisinlambYe + rtb_Product3_j0[0] * rtb_Sum1_mzp;
    51ca:	0c 01 be    	mov.d     w12, w2
    51cc:	0a 00 be    	mov.d     w10, w0
    51ce:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51d0:	00 00 00 
    51d2:	00 01 be    	mov.d     w0, w2
    51d4:	1e b0 91    	mov.w     [w14+482], w0
    51d6:	ae b0 91    	mov.w     [w14+484], w1
    51d8:	92 14 02    	call      0x1492 <___addsf3>
    51da:	00 00 00 
    51dc:	60 97 98    	mov.w     w0, [w14+172]
    51de:	71 97 98    	mov.w     w1, [w14+174]

000051e0 <.L0>:
    51e0:	20 0f 98    	mov.w     w0, [w14+20]
    51e2:	31 0f 98    	mov.w     w1, [w14+22]

000051e4 <.L0>:

  /* Product: '<S710>/u(3)*u(5)' */
  rtb_VectorConcatenate[3] = rtb_Sum1_mzp * rtb_Product2_c[1];
    51e4:	0c 01 be    	mov.d     w12, w2
    51e6:	7e a8 91    	mov.w     [w14+478], w0
    51e8:	8e b0 91    	mov.w     [w14+480], w1
    51ea:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51ec:	00 00 00 
    51ee:	40 8f 98    	mov.w     w0, [w14+152]
    51f0:	51 8f 98    	mov.w     w1, [w14+154]
    51f2:	40 0f 98    	mov.w     w0, [w14+24]
    51f4:	51 0f 98    	mov.w     w1, [w14+26]

000051f6 <.L0>:

  /* Sum: '<S713>/Sum' incorporates:
   *  Product: '<S713>/u(1)*u(2)*u(3)'
   *  Product: '<S713>/u(4)*u(6)'
   *  Trigonometry: '<S702>/SinCos'
   */
  rtb_VectorConcatenate[4] = rtb_Product3_j0[0] * rtb_Product3_j0[1] *
    51f6:	3e b1 91    	mov.w     [w14+486], w2
    51f8:	ce b1 91    	mov.w     [w14+488], w3
    51fa:	0a 00 be    	mov.d     w10, w0
    51fc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    51fe:	00 00 00 
    5200:	0c 01 be    	mov.d     w12, w2
    5202:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5204:	00 00 00 
    5206:	10 af 99    	mov.w     w0, [w14+466]
    5208:	21 af 99    	mov.w     w1, [w14+468]

0000520a <.L0>:
    rtb_Sum1_mzp + rtb_Product2_c[0] * rtb_RhhcosphisinlambYe;
    520a:	5e b1 91    	mov.w     [w14+490], w2
    520c:	ee b1 91    	mov.w     [w14+492], w3
    520e:	08 00 be    	mov.d     w8, w0
    5210:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5212:	00 00 00 
    5214:	00 01 be    	mov.d     w0, w2
    5216:	1e a8 91    	mov.w     [w14+466], w0
    5218:	ae a8 91    	mov.w     [w14+468], w1
    521a:	92 14 02    	call      0x1492 <___addsf3>
    521c:	00 00 00 
    521e:	20 97 98    	mov.w     w0, [w14+164]
    5220:	31 97 98    	mov.w     w1, [w14+166]

00005222 <.L0>:
    5222:	60 0f 98    	mov.w     w0, [w14+28]
    5224:	71 0f 98    	mov.w     w1, [w14+30]

00005226 <.L0>:

  /* Sum: '<S716>/Sum' incorporates:
   *  Product: '<S716>/u(1)*u(6)'
   *  Product: '<S716>/u(2)*u(3)*u(4)'
   *  Trigonometry: '<S702>/SinCos'
   */
  rtb_VectorConcatenate[5] = rtb_Product3_j0[1] * rtb_Sum1_mzp * rtb_Product2_c
    5226:	0c 01 be    	mov.d     w12, w2
    5228:	3e b0 91    	mov.w     [w14+486], w0
    522a:	ce b0 91    	mov.w     [w14+488], w1
    522c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    522e:	00 00 00 
    5230:	00 01 be    	mov.d     w0, w2
    5232:	08 00 be    	mov.d     w8, w0
    5234:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5236:	00 00 00 

00005238 <.L0>:
    [0] - rtb_RhhcosphisinlambYe * rtb_Product3_j0[0];
    5238:	7e a1 91    	mov.w     [w14+462], w2
    523a:	8e a9 91    	mov.w     [w14+464], w3
    523c:	90 14 02    	call      0x1490 <___subsf3>
    523e:	00 00 00 
    5240:	00 06 be    	mov.d     w0, w12

00005242 <.L0>:
    5242:	00 17 98    	mov.w     w0, [w14+32]
    5244:	11 17 98    	mov.w     w1, [w14+34]

  /* Gain: '<S711>/Gain2' */
  rtb_VectorConcatenate[6] = -rtb_Product3_j0[1];
    5246:	3e b2 91    	mov.w     [w14+486], w4
    5248:	ce b2 91    	mov.w     [w14+488], w5
    524a:	05 f0 a2    	btg.w     w5, #0xf
    524c:	64 8f 98    	mov.w     w4, [w14+156]
    524e:	75 8f 98    	mov.w     w5, [w14+158]
    5250:	24 17 98    	mov.w     w4, [w14+36]
    5252:	35 17 98    	mov.w     w5, [w14+38]

00005254 <.L0>:

  /* Product: '<S714>/u(1)*u(3)' */
  rtb_VectorConcatenate[7] = rtb_Product3_j0[0] * rtb_Product2_c[1];
    5254:	7e a9 91    	mov.w     [w14+478], w2
    5256:	8e b1 91    	mov.w     [w14+480], w3
    5258:	0a 00 be    	mov.d     w10, w0
    525a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    525c:	00 00 00 
    525e:	00 05 be    	mov.d     w0, w10
    5260:	40 17 98    	mov.w     w0, [w14+40]
    5262:	51 17 98    	mov.w     w1, [w14+42]

00005264 <.L0>:

  /* Product: '<S717>/u(4)*u(5)' */
  rtb_VectorConcatenate[8] = rtb_Product2_c[0] * rtb_Product2_c[1];
    5264:	7e a9 91    	mov.w     [w14+478], w2
    5266:	8e b1 91    	mov.w     [w14+480], w3
    5268:	08 00 be    	mov.d     w8, w0
    526a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    526c:	00 00 00 
    526e:	60 17 98    	mov.w     w0, [w14+44]
    5270:	71 17 98    	mov.w     w1, [w14+46]

00005272 <.L0>:

  /* Math: '<S21>/Math Function' */
  for (i = 0; i < 3; i++) {
    rtb_MathFunction[3 * i] = rtb_VectorConcatenate[i];
    rtb_MathFunction[1 + 3 * i] = rtb_VectorConcatenate[i + 3];
    rtb_MathFunction[2 + 3 * i] = rtb_VectorConcatenate[i + 6];
    5272:	4a 97 98    	mov.w     w10, [w14+168]
    5274:	5b 97 98    	mov.w     w11, [w14+170]
    5276:	0c 9f 98    	mov.w     w12, [w14+176]
    5278:	1d 9f 98    	mov.w     w13, [w14+178]
    527a:	20 9f 98    	mov.w     w0, [w14+180]
    527c:	31 9f 98    	mov.w     w1, [w14+182]

0000527e <.L0>:
  }

  /* End of Math: '<S21>/Math Function' */

  /* ManualSwitch: '<Root>/HIL Manual Switch' incorporates:
   *  Constant: '<Root>/Constant'
   */
  AUAV_V3_TestSensors_B.HILManualSwitch = 1.0;
    527e:	00 00 20    	mov.w     #0x0, w0
    5280:	01 f8 23    	mov.w     #0x3f80, w1
    5282:	f0 ae 88    	mov.w     w0, 0x15de
    5284:	01 af 88    	mov.w     w1, 0x15e0

00005286 <.L0>:

  /* Outputs for Atomic SubSystem: '<Root>/Sensor_Data_Adapter' */
  AUAV_V_Sensor_Data_Adapter();
    5286:	88 d7 02    	call      0xd788 <_AUAV_V_Sensor_Data_Adapter>
    5288:	00 00 00 

0000528a <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Sensor_Data_Adapter' */

  /* Outputs for Atomic SubSystem: '<Root>/Position_and_Attitude_Filter' */
  Position_and_Attitude_Filt();
    528a:	be ab 02    	call      0xabbe <_Position_and_Attitude_Filt>
    528c:	00 00 00 

  /* End of Outputs for SubSystem: '<Root>/Position_and_Attitude_Filter' */

  /* MATLAB Function: '<Root>/myMux Fun2' incorporates:
   *  SignalConversion: '<S23>/TmpSignal ConversionAt SFunction Inport1'
   */
  /* MATLAB Function 'myMux Fun2': '<S23>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S23>:1:5' */
  AUAV_V3_TestSensors_B.y_k[0] = AUAV_V3_TestSensors_B.DataTypeConversion_m[2];
    528e:	18 bb 80    	mov.w     0x1762, w8
    5290:	29 bb 80    	mov.w     0x1764, w9
    5292:	78 b0 88    	mov.w     w8, 0x160e
    5294:	89 b0 88    	mov.w     w9, 0x1610
  AUAV_V3_TestSensors_B.y_k[1] = AUAV_V3_TestSensors_B.DataTypeConversion_m[1];
    5296:	fc ba 80    	mov.w     0x175e, w12
    5298:	0d bb 80    	mov.w     0x1760, w13
    529a:	9c b0 88    	mov.w     w12, 0x1612
    529c:	ad b0 88    	mov.w     w13, 0x1614
  AUAV_V3_TestSensors_B.y_k[2] =
    529e:	e0 e0 80    	mov.w     0x1c1c, w0
    52a0:	f1 e0 80    	mov.w     0x1c1e, w1
    52a2:	b0 b0 88    	mov.w     w0, 0x1616
    52a4:	c1 b0 88    	mov.w     w1, 0x1618
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_lt.y;
  AUAV_V3_TestSensors_B.y_k[3] = AUAV_V3_TestSensors_B.GyroErr[0];
    52a6:	32 bb 80    	mov.w     0x1766, w2
    52a8:	43 bb 80    	mov.w     0x1768, w3
    52aa:	d2 b0 88    	mov.w     w2, 0x161a
    52ac:	e3 b0 88    	mov.w     w3, 0x161c
  AUAV_V3_TestSensors_B.y_k[4] = AUAV_V3_TestSensors_B.GyroErr[1];
    52ae:	54 bb 80    	mov.w     0x176a, w4
    52b0:	65 bb 80    	mov.w     0x176c, w5
    52b2:	f4 b0 88    	mov.w     w4, 0x161e
    52b4:	05 b1 88    	mov.w     w5, 0x1620
  AUAV_V3_TestSensors_B.y_k[5] = AUAV_V3_TestSensors_B.GyroErr[2];
    52b6:	70 bb 80    	mov.w     0x176e, w0
    52b8:	81 bb 80    	mov.w     0x1770, w1
    52ba:	10 b1 88    	mov.w     w0, 0x1622
    52bc:	21 b1 88    	mov.w     w1, 0x1624

000052be <.L0>:

  /* Trigonometry: '<S703>/SinCos' */
  rtb_Product2_c[0] = (real32_T)sin(AUAV_V3_TestSensors_B.y_k[0]);
    52be:	08 00 be    	mov.d     w8, w0
    52c0:	b6 1d 02    	call      0x1db6 <_sinf>
    52c2:	00 00 00 
    52c4:	00 05 be    	mov.d     w0, w10
    52c6:	00 1f 98    	mov.w     w0, [w14+48]
    52c8:	11 1f 98    	mov.w     w1, [w14+50]

000052ca <.L0>:
  rtb_Product3_j0[0] = (real32_T)cos(AUAV_V3_TestSensors_B.y_k[0]);
    52ca:	08 00 be    	mov.d     w8, w0
    52cc:	22 17 02    	call      0x1722 <_cosf>
    52ce:	00 00 00 
    52d0:	00 04 be    	mov.d     w0, w8
    52d2:	00 8f be    	mov.d     w0, [w14]

000052d4 <.L0>:
  rtb_Product2_c[1] = (real32_T)sin(AUAV_V3_TestSensors_B.y_k[1]);
    52d4:	0c 00 be    	mov.d     w12, w0
    52d6:	b6 1d 02    	call      0x1db6 <_sinf>
    52d8:	00 00 00 
    52da:	30 b7 99    	mov.w     w0, [w14+486]
    52dc:	41 b7 99    	mov.w     w1, [w14+488]
    52de:	20 1f 98    	mov.w     w0, [w14+52]
    52e0:	31 1f 98    	mov.w     w1, [w14+54]

000052e2 <.L0>:
  rtb_Product3_j0[1] = (real32_T)cos(AUAV_V3_TestSensors_B.y_k[1]);
    52e2:	0c 00 be    	mov.d     w12, w0
    52e4:	22 17 02    	call      0x1722 <_cosf>
    52e6:	00 00 00 
    52e8:	70 af 99    	mov.w     w0, [w14+478]
    52ea:	01 b7 99    	mov.w     w1, [w14+480]
    52ec:	20 07 98    	mov.w     w0, [w14+4]
    52ee:	31 07 98    	mov.w     w1, [w14+6]

000052f0 <.L0>:
  rtb_Product2_c[2] = (real32_T)sin(AUAV_V3_TestSensors_B.y_k[2]);
    52f0:	e0 e0 80    	mov.w     0x1c1c, w0
    52f2:	f1 e0 80    	mov.w     0x1c1e, w1
    52f4:	b6 1d 02    	call      0x1db6 <_sinf>
    52f6:	00 00 00 
    52f8:	00 06 be    	mov.d     w0, w12
    52fa:	40 1f 98    	mov.w     w0, [w14+56]
    52fc:	51 1f 98    	mov.w     w1, [w14+58]

000052fe <.L0>:
  rtb_Product3_j0[2] = (real32_T)cos(AUAV_V3_TestSensors_B.y_k[2]);
    52fe:	e0 e0 80    	mov.w     0x1c1c, w0
    5300:	f1 e0 80    	mov.w     0x1c1e, w1
    5302:	22 17 02    	call      0x1722 <_cosf>
    5304:	00 00 00 
    5306:	00 01 be    	mov.d     w0, w2
    5308:	50 b7 99    	mov.w     w0, [w14+490]
    530a:	61 b7 99    	mov.w     w1, [w14+492]
    530c:	40 07 98    	mov.w     w0, [w14+8]
    530e:	51 07 98    	mov.w     w1, [w14+10]

00005310 <.L0>:

  /* Product: '<S719>/u(5)*u(6)' */
  rtb_VectorConcatenate_m[0] = rtb_Product3_j0[1] * rtb_Product3_j0[2];
    5310:	7e a8 91    	mov.w     [w14+478], w0
    5312:	8e b0 91    	mov.w     [w14+480], w1
    5314:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5316:	00 00 00 
    5318:	60 1f 98    	mov.w     w0, [w14+60]
    531a:	71 1f 98    	mov.w     w1, [w14+62]

0000531c <.L0>:

  /* Sum: '<S722>/Sum' incorporates:
   *  Product: '<S722>/u(3)*u(4)'
   *  Product: '<S722>/u(6)*u(1)*u(2)'
   */
  rtb_VectorConcatenate_m[1] = rtb_Product3_j0[2] * rtb_Product2_c[0] *
    531c:	5e b1 91    	mov.w     [w14+490], w2
    531e:	ee b1 91    	mov.w     [w14+492], w3
    5320:	0a 00 be    	mov.d     w10, w0
    5322:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5324:	00 00 00 
    5326:	30 af 99    	mov.w     w0, [w14+470]
    5328:	41 af 99    	mov.w     w1, [w14+472]
    532a:	00 01 be    	mov.d     w0, w2
    532c:	3e b0 91    	mov.w     [w14+486], w0
    532e:	ce b0 91    	mov.w     [w14+488], w1
    5330:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5332:	00 00 00 
    5334:	70 a7 99    	mov.w     w0, [w14+462]
    5336:	01 af 99    	mov.w     w1, [w14+464]

00005338 <.L0>:
    rtb_Product2_c[1] - rtb_Product2_c[2] * rtb_Product3_j0[0];
    5338:	0c 01 be    	mov.d     w12, w2
    533a:	08 00 be    	mov.d     w8, w0
    533c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    533e:	00 00 00 
    5340:	00 01 be    	mov.d     w0, w2
    5342:	7e a0 91    	mov.w     [w14+462], w0
    5344:	8e a8 91    	mov.w     [w14+464], w1
    5346:	90 14 02    	call      0x1490 <___subsf3>
    5348:	00 00 00 

0000534a <.L0>:
    534a:	00 27 98    	mov.w     w0, [w14+64]
    534c:	11 27 98    	mov.w     w1, [w14+66]

0000534e <.L0>:

  /* Sum: '<S725>/Sum' incorporates:
   *  Product: '<S725>/u(1)*u(3)'
   *  Product: '<S725>/u(2)*u(4)*u(6)'
   */
  rtb_VectorConcatenate_m[2] = rtb_Product2_c[1] * rtb_Product3_j0[0] *
    534e:	3e b1 91    	mov.w     [w14+486], w2
    5350:	ce b1 91    	mov.w     [w14+488], w3
    5352:	08 00 be    	mov.d     w8, w0
    5354:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5356:	00 00 00 
    5358:	00 01 be    	mov.d     w0, w2
    535a:	5e b0 91    	mov.w     [w14+490], w0
    535c:	ee b0 91    	mov.w     [w14+492], w1
    535e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5360:	00 00 00 
    5362:	70 a7 99    	mov.w     w0, [w14+462]
    5364:	01 af 99    	mov.w     w1, [w14+464]

00005366 <.L0>:
    rtb_Product3_j0[2] + rtb_Product2_c[0] * rtb_Product2_c[2];
    5366:	0c 01 be    	mov.d     w12, w2
    5368:	0a 00 be    	mov.d     w10, w0
    536a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    536c:	00 00 00 
    536e:	00 01 be    	mov.d     w0, w2
    5370:	7e a0 91    	mov.w     [w14+462], w0
    5372:	8e a8 91    	mov.w     [w14+464], w1
    5374:	92 14 02    	call      0x1492 <___addsf3>
    5376:	00 00 00 

00005378 <.L0>:
    5378:	20 27 98    	mov.w     w0, [w14+68]
    537a:	31 27 98    	mov.w     w1, [w14+70]

0000537c <.L0>:

  /* Product: '<S720>/u(3)*u(5)' */
  rtb_VectorConcatenate_m[3] = rtb_Product2_c[2] * rtb_Product3_j0[1];
    537c:	0c 01 be    	mov.d     w12, w2
    537e:	7e a8 91    	mov.w     [w14+478], w0
    5380:	8e b0 91    	mov.w     [w14+480], w1
    5382:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5384:	00 00 00 
    5386:	40 27 98    	mov.w     w0, [w14+72]
    5388:	51 27 98    	mov.w     w1, [w14+74]

0000538a <.L0>:

  /* Sum: '<S723>/Sum' incorporates:
   *  Product: '<S723>/u(1)*u(2)*u(3)'
   *  Product: '<S723>/u(4)*u(6)'
   */
  rtb_VectorConcatenate_m[4] = rtb_Product2_c[0] * rtb_Product2_c[1] *
    538a:	3e b1 91    	mov.w     [w14+486], w2
    538c:	ce b1 91    	mov.w     [w14+488], w3
    538e:	0a 00 be    	mov.d     w10, w0
    5390:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5392:	00 00 00 
    5394:	00 01 be    	mov.d     w0, w2
    5396:	0c 00 be    	mov.d     w12, w0
    5398:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    539a:	00 00 00 
    539c:	70 a7 99    	mov.w     w0, [w14+462]
    539e:	01 af 99    	mov.w     w1, [w14+464]

000053a0 <.L0>:
    rtb_Product2_c[2] + rtb_Product3_j0[0] * rtb_Product3_j0[2];
    53a0:	5e b1 91    	mov.w     [w14+490], w2
    53a2:	ee b1 91    	mov.w     [w14+492], w3
    53a4:	08 00 be    	mov.d     w8, w0
    53a6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    53a8:	00 00 00 
    53aa:	00 01 be    	mov.d     w0, w2
    53ac:	7e a0 91    	mov.w     [w14+462], w0
    53ae:	8e a8 91    	mov.w     [w14+464], w1
    53b0:	92 14 02    	call      0x1492 <___addsf3>
    53b2:	00 00 00 

000053b4 <.L0>:
    53b4:	60 27 98    	mov.w     w0, [w14+76]
    53b6:	71 27 98    	mov.w     w1, [w14+78]

000053b8 <.L0>:

  /* Sum: '<S726>/Sum' incorporates:
   *  Product: '<S726>/u(1)*u(6)'
   *  Product: '<S726>/u(2)*u(3)*u(4)'
   */
  rtb_VectorConcatenate_m[5] = rtb_Product2_c[1] * rtb_Product2_c[2] *
    53b8:	0c 01 be    	mov.d     w12, w2
    53ba:	3e b0 91    	mov.w     [w14+486], w0
    53bc:	ce b0 91    	mov.w     [w14+488], w1
    53be:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    53c0:	00 00 00 
    53c2:	00 01 be    	mov.d     w0, w2
    53c4:	08 00 be    	mov.d     w8, w0
    53c6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    53c8:	00 00 00 

000053ca <.L0>:
    rtb_Product3_j0[0] - rtb_Product3_j0[2] * rtb_Product2_c[0];
    53ca:	3e a9 91    	mov.w     [w14+470], w2
    53cc:	ce a9 91    	mov.w     [w14+472], w3
    53ce:	90 14 02    	call      0x1490 <___subsf3>
    53d0:	00 00 00 

000053d2 <.L0>:
    53d2:	00 2f 98    	mov.w     w0, [w14+80]
    53d4:	11 2f 98    	mov.w     w1, [w14+82]

  /* Gain: '<S721>/Gain2' */
  rtb_VectorConcatenate_m[6] = -rtb_Product2_c[1];
    53d6:	3e b0 91    	mov.w     [w14+486], w0
    53d8:	ce b0 91    	mov.w     [w14+488], w1
    53da:	01 f0 a2    	btg.w     w1, #0xf
    53dc:	20 2f 98    	mov.w     w0, [w14+84]
    53de:	31 2f 98    	mov.w     w1, [w14+86]

000053e0 <.L0>:

  /* Product: '<S724>/u(1)*u(3)' */
  rtb_VectorConcatenate_m[7] = rtb_Product2_c[0] * rtb_Product3_j0[1];
    53e0:	7e a9 91    	mov.w     [w14+478], w2
    53e2:	8e b1 91    	mov.w     [w14+480], w3
    53e4:	0a 00 be    	mov.d     w10, w0
    53e6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    53e8:	00 00 00 
    53ea:	40 2f 98    	mov.w     w0, [w14+88]
    53ec:	51 2f 98    	mov.w     w1, [w14+90]

000053ee <.L0>:

  /* Product: '<S727>/u(4)*u(5)' */
  rtb_VectorConcatenate_m[8] = rtb_Product3_j0[0] * rtb_Product3_j0[1];
    53ee:	7e a9 91    	mov.w     [w14+478], w2
    53f0:	8e b1 91    	mov.w     [w14+480], w3
    53f2:	08 00 be    	mov.d     w8, w0
    53f4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    53f6:	00 00 00 
    53f8:	60 2f 98    	mov.w     w0, [w14+92]
    53fa:	71 2f 98    	mov.w     w1, [w14+94]
    53fc:	43 09 20    	mov.w     #0x94, w3
    53fe:	8e 81 41    	add.w     w3, w14, w3
    5400:	e4 81 51    	sub.w     w3, #0x4, w3
    5402:	73 a7 99    	mov.w     w3, [w14+462]
    5404:	44 09 20    	mov.w     #0x94, w4
    5406:	0e 02 42    	add.w     w4, w14, w4
    5408:	68 02 42    	add.w     w4, #0x8, w4
    540a:	34 a7 99    	mov.w     w4, [w14+454]
    540c:	45 09 20    	mov.w     #0x94, w5
    540e:	8e 82 42    	add.w     w5, w14, w5
    5410:	f4 82 42    	add.w     w5, #0x14, w5
    5412:	35 af 99    	mov.w     w5, [w14+470]
    5414:	05 00 78    	mov.w     w5, w0
    5416:	10 b7 99    	mov.w     w0, [w14+482]
    5418:	84 00 78    	mov.w     w4, w1
    541a:	51 af 99    	mov.w     w1, [w14+474]
    541c:	03 01 78    	mov.w     w3, w2
    541e:	12 af 99    	mov.w     w2, [w14+466]

00005420 <.L0>:

  /* Product: '<S21>/Product' */
  for (i = 0; i < 3; i++) {
    5420:	80 01 eb    	clr.w     w3
    5422:	73 af 99    	mov.w     w3, [w14+478]
    5424:	04 06 20    	mov.w     #0x60, w4
    5426:	04 02 47    	add.w     w14, w4, w4
    5428:	54 a7 99    	mov.w     w4, [w14+458]
    542a:	2e 00 37    	bra       0x5488 <.L107>

0000542c <.L0>:
    for (i_0 = 0; i_0 < 3; i_0++) {
      rtb_VectorConcatenate[i + 3 * i_0] = 0.0F;
      rtb_VectorConcatenate[i + 3 * i_0] += rtb_VectorConcatenate_m[3 * i_0] *
    542c:	9e a2 91    	mov.w     [w14+450], w5
    542e:	15 01 be    	mov.d     [w5], w2
    5430:	0a 00 be    	mov.d     w10, w0
    5432:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5434:	00 00 00 
    5436:	60 11 b8    	mul.uu    w2, #0x0, w2
    5438:	92 14 02    	call      0x1492 <___addsf3>
    543a:	00 00 00 
    543c:	00 04 be    	mov.d     w0, w8

0000543e <.L0>:
        rtb_MathFunction[i];
      rtb_VectorConcatenate[i + 3 * i_0] += rtb_VectorConcatenate_m[3 * i_0 + 1]
        * rtb_MathFunction[i + 3];
    543e:	1e a0 91    	mov.w     [w14+450], w0
    5440:	20 01 90    	mov.w     [w0+4], w2
    5442:	b0 01 90    	mov.w     [w0+6], w3
    5444:	0c 00 be    	mov.d     w12, w0
    5446:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5448:	00 00 00 
    544a:	00 01 be    	mov.d     w0, w2

0000544c <.L0>:
    544c:	08 00 be    	mov.d     w8, w0
    544e:	92 14 02    	call      0x1492 <___addsf3>
    5450:	00 00 00 
    5452:	00 04 be    	mov.d     w0, w8

00005454 <.L0>:
      rtb_VectorConcatenate[i + 3 * i_0] += rtb_VectorConcatenate_m[3 * i_0 + 2]
        * rtb_MathFunction[i + 6];
    5454:	9e a0 91    	mov.w     [w14+450], w1
    5456:	41 01 90    	mov.w     [w1+8], w2
    5458:	d1 01 90    	mov.w     [w1+10], w3
    545a:	5e b0 91    	mov.w     [w14+490], w0
    545c:	ee b0 91    	mov.w     [w14+492], w1
    545e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5460:	00 00 00 
    5462:	00 01 be    	mov.d     w0, w2

00005464 <.L0>:
    5464:	08 00 be    	mov.d     w8, w0
    5466:	92 14 02    	call      0x1492 <___addsf3>
    5468:	00 00 00 
    546a:	3e b1 91    	mov.w     [w14+486], w2
    546c:	00 89 be    	mov.d     w0, [w2]
    546e:	9e a1 91    	mov.w     [w14+450], w3
    5470:	ec 81 41    	add.w     w3, #0xc, w3
    5472:	13 a7 99    	mov.w     w3, [w14+450]
    5474:	6c 01 41    	add.w     w2, #0xc, w2
    5476:	32 b7 99    	mov.w     w2, [w14+486]

00005478 <.L0>:
    5478:	5e a2 91    	mov.w     [w14+458], w4
    547a:	84 8f 51    	sub.w     w3, w4, [w15]
    547c:	d7 ff 3a    	bra       NZ, 0x542c <.L0> <.L108>
    547e:	fe aa 91    	mov.w     [w14+478], w5
    5480:	85 02 e8    	inc.w     w5, w5
    5482:	75 af 99    	mov.w     w5, [w14+478]
    5484:	e3 8f 52    	sub.w     w5, #0x3, [w15]
    5486:	14 00 32    	bra       Z, 0x54b0 <.L109>

00005488 <.L107>:
    5488:	1e a8 91    	mov.w     [w14+466], w0
    548a:	50 05 be    	mov.d     [++w0], w10
    548c:	10 af 99    	mov.w     w0, [w14+466]
    548e:	de a8 91    	mov.w     [w14+474], w1
    5490:	51 06 be    	mov.d     [++w1], w12
    5492:	51 af 99    	mov.w     w1, [w14+474]
    5494:	1e b2 91    	mov.w     [w14+482], w4
    5496:	54 01 be    	mov.d     [++w4], w2
    5498:	14 b7 99    	mov.w     w4, [w14+482]
    549a:	52 b7 99    	mov.w     w2, [w14+490]
    549c:	63 b7 99    	mov.w     w3, [w14+492]
    549e:	c8 03 20    	mov.w     #0x3c, w8
    54a0:	0e 04 44    	add.w     w8, w14, w8
    54a2:	fe aa 91    	mov.w     [w14+478], w5
    54a4:	42 28 dd    	sl.w      w5, #0x2, w0
    54a6:	ec 00 47    	add.w     w14, #0xc, w1
    54a8:	80 80 40    	add.w     w1, w0, w1
    54aa:	31 b7 99    	mov.w     w1, [w14+486]
    54ac:	18 a7 99    	mov.w     w8, [w14+450]
    54ae:	be ff 37    	bra       0x542c <.L0> <.L108>

000054b0 <.L109>:
    }
  }

  /* End of Product: '<S21>/Product' */

  /* Gain: '<S708>/Gain1' incorporates:
   *  Selector: '<S708>/Selector1'
   */
  rtb_VectorConcatenate_h[0] = rtb_VectorConcatenate[3];
    54b0:	4e 09 90    	mov.w     [w14+24], w2
    54b2:	de 09 90    	mov.w     [w14+26], w3
    54b4:	02 37 98    	mov.w     w2, [w14+96]
    54b6:	13 37 98    	mov.w     w3, [w14+98]
  rtb_VectorConcatenate_h[1] = rtb_VectorConcatenate[0];
    54b8:	6e 02 90    	mov.w     [w14+12], w4
    54ba:	fe 02 90    	mov.w     [w14+14], w5
    54bc:	24 37 98    	mov.w     w4, [w14+100]
    54be:	35 37 98    	mov.w     w5, [w14+102]
  rtb_VectorConcatenate_h[2] = -rtb_VectorConcatenate[6];
    54c0:	2e 14 90    	mov.w     [w14+36], w8
    54c2:	be 14 90    	mov.w     [w14+38], w9
    54c4:	08 00 be    	mov.d     w8, w0
    54c6:	01 f0 a2    	btg.w     w1, #0xf
    54c8:	40 37 98    	mov.w     w0, [w14+104]
    54ca:	51 37 98    	mov.w     w1, [w14+106]

  /* Gain: '<S708>/Gain2' incorporates:
   *  Selector: '<S708>/Selector2'
   */
  rtb_VectorConcatenate_h[3] = rtb_VectorConcatenate[7];
    54cc:	4e 10 90    	mov.w     [w14+40], w0
    54ce:	de 10 90    	mov.w     [w14+42], w1
    54d0:	60 37 98    	mov.w     w0, [w14+108]
    54d2:	71 37 98    	mov.w     w1, [w14+110]
  rtb_VectorConcatenate_h[4] = rtb_VectorConcatenate[8];
    54d4:	6e 11 90    	mov.w     [w14+44], w2
    54d6:	fe 11 90    	mov.w     [w14+46], w3
    54d8:	02 3f 98    	mov.w     w2, [w14+112]
    54da:	13 3f 98    	mov.w     w3, [w14+114]

  /* Gain: '<S708>/Gain3' incorporates:
   *  Selector: '<S708>/Selector3'
   */
  rtb_VectorConcatenate_h[5] = -rtb_VectorConcatenate[1];
    54dc:	0e 08 90    	mov.w     [w14+16], w0
    54de:	9e 08 90    	mov.w     [w14+18], w1
    54e0:	01 f0 a2    	btg.w     w1, #0xf
    54e2:	20 3f 98    	mov.w     w0, [w14+116]
    54e4:	31 3f 98    	mov.w     w1, [w14+118]
  rtb_VectorConcatenate_h[6] = rtb_VectorConcatenate[4];
    54e6:	6e 0a 90    	mov.w     [w14+28], w4
    54e8:	fe 0a 90    	mov.w     [w14+30], w5
    54ea:	44 3f 98    	mov.w     w4, [w14+120]
    54ec:	55 3f 98    	mov.w     w5, [w14+122]

000054ee <.L0>:

  /* If: '<S700>/If' incorporates:
   *  Gain: '<S708>/Gain1'
   *  Selector: '<S708>/Selector1'
   */
  if ((-rtb_VectorConcatenate[6] >= 1.0F) || (-rtb_VectorConcatenate[6] <= -1.0F))
    54ee:	02 00 20    	mov.w     #0x0, w2
    54f0:	03 f8 2b    	mov.w     #0xbf80, w3
    54f2:	08 00 be    	mov.d     w8, w0
    54f4:	8c 18 02    	call      0x188c <___eqsf2>
    54f6:	00 00 00 
    54f8:	00 00 e0    	cp0.w     w0
    54fa:	07 00 34    	bra       LE, 0x550a <.L0> <.L0> <.L110>
    54fc:	02 00 20    	mov.w     #0x0, w2
    54fe:	03 f8 23    	mov.w     #0x3f80, w3
    5500:	08 00 be    	mov.d     w8, w0
    5502:	90 18 02    	call      0x1890 <___gesf2>
    5504:	00 00 00 
    5506:	00 00 e0    	cp0.w     w0
    5508:	0a 00 35    	bra       LT, 0x551e <.L0> <.L0> <.L599>

0000550a <.L0>:
  {
    /* Outputs for IfAction SubSystem: '<S700>/AxisRotZeroR3' incorporates:
     *  ActionPort: '<S707>/Action Port'
     */
    AUAV_V3_Test_AxisRotZeroR3(rtb_VectorConcatenate_h, &rtb_Merge_m[0],
    550a:	c5 07 20    	mov.w     #0x7c, w5
    550c:	8e 82 42    	add.w     w5, w14, w5
    550e:	64 81 42    	add.w     w5, #0x4, w2
    5510:	e8 81 42    	add.w     w5, #0x8, w3
    5512:	85 00 78    	mov.w     w5, w1
    5514:	00 06 20    	mov.w     #0x60, w0
    5516:	0e 00 40    	add.w     w0, w14, w0
    5518:	4e 0c 02    	call      0x10c4e <_AUAV_V3_Test_AxisRotZeroR3>
    551a:	01 00 00 
    551c:	09 00 37    	bra       0x5530 <.L0> <.L0> <.L113>

0000551e <.L0>:
      &rtb_Merge_m[1], &rtb_Merge_m[2]);

    /* End of Outputs for SubSystem: '<S700>/AxisRotZeroR3' */
  } else {
    /* Outputs for IfAction SubSystem: '<S700>/AxisRotDefault' incorporates:
     *  ActionPort: '<S706>/Action Port'
     */
    AUAV_V3_Tes_AxisRotDefault(rtb_VectorConcatenate_h, &rtb_Merge_m[0],
    551e:	c0 07 20    	mov.w     #0x7c, w0
    5520:	0e 00 40    	add.w     w0, w14, w0
    5522:	64 01 40    	add.w     w0, #0x4, w2
    5524:	e8 01 40    	add.w     w0, #0x8, w3
    5526:	80 00 78    	mov.w     w0, w1
    5528:	00 06 20    	mov.w     #0x60, w0
    552a:	0e 00 40    	add.w     w0, w14, w0
    552c:	e0 10 02    	call      0x110e0 <_AUAV_V3_Tes_AxisRotDefault>
    552e:	01 00 00 

00005530 <.L0>:
      &rtb_Merge_m[1], &rtb_Merge_m[2]);

    /* End of Outputs for SubSystem: '<S700>/AxisRotDefault' */
  }

  /* End of If: '<S700>/If' */

  /* MATLAB Function: '<S21>/Embedded MATLAB Function1' */
  A_EmbeddedMATLABFunction_l(rtb_Merge_m[0],
    5530:	e2 af 21    	mov.w     #0x1afe, w2
    5532:	6e 38 90    	mov.w     [w14+124], w0
    5534:	fe 38 90    	mov.w     [w14+126], w1
    5536:	ec 11 02    	call      0x111ec <_A_EmbeddedMATLABFunction_l>
    5538:	01 00 00 

0000553a <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1);

  /* MATLAB Function: '<S21>/myMux Fun1' */
  /* MATLAB Function 'get Nav Vars [updated 4.28.16]/myMux Fun1': '<S704>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S704>:1:5' */
  rtb_y_jl_idx_0 = rtb_Merge_m[2];
    553a:	2e 81 90    	mov.w     [w14+132], w2
    553c:	be 81 90    	mov.w     [w14+134], w3
    553e:	72 9f 99    	mov.w     w2, [w14+446]
    5540:	03 a7 99    	mov.w     w3, [w14+448]
  rtb_y_jl_idx_1 = rtb_Merge_m[1];
    5542:	0e 82 90    	mov.w     [w14+128], w4
    5544:	9e 82 90    	mov.w     [w14+130], w5
    5546:	54 9f 99    	mov.w     w4, [w14+442]
    5548:	65 9f 99    	mov.w     w5, [w14+444]

  /* DataStoreWrite: '<S20>/mlAttitudeEuler' incorporates:
   *  DataStoreRead: '<S20>/Get time3'
   *  MATLAB Function: '<S21>/myMux Fun1'
   */
  mlAttitudeSol.roll = rtb_Merge_m[2];
    554a:	12 0f 89    	mov.w     w2, 0x21e2
    554c:	23 0f 89    	mov.w     w3, 0x21e4
  mlAttitudeSol.pitch = rtb_Merge_m[1];
    554e:	34 0f 89    	mov.w     w4, 0x21e6
    5550:	45 0f 89    	mov.w     w5, 0x21e8
  mlAttitudeSol.yaw = AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1.y;
    5552:	f0 d7 80    	mov.w     0x1afe, w0
    5554:	01 d8 80    	mov.w     0x1b00, w1
    5556:	50 0f 89    	mov.w     w0, 0x21ea
    5558:	61 0f 89    	mov.w     w1, 0x21ec
  mlAttitudeSol.time_boot_ms = AUAV_V3_TestSensors_DWork.time_since_boot_usec;
    555a:	82 ff 80    	mov.w     0x1ff0, w2
    555c:	93 ff 80    	mov.w     0x1ff2, w3
    555e:	f2 0e 89    	mov.w     w2, 0x21de
    5560:	03 0f 89    	mov.w     w3, 0x21e0

  /* DataTypeConversion: '<S682>/Data Type Conversion1' incorporates:
   *  DataStoreRead: '<S20>/mlHeartbeatLocal'
   */
  rtb_DataTypeConversion1_hq = (uint8_T)mlHeartbeatLocal.custom_mode;
    5562:	04 89 80    	mov.w     0x1120, w4
    5564:	15 89 80    	mov.w     0x1122, w5
    5566:	04 8f 99    	mov.w     w4, [w14+400]
    5568:	15 8f 99    	mov.w     w5, [w14+402]

  /* S-Function "dsPIC_PWM_IC" Block: <S656>/Input Capture */
  AUAV_V3_TestSensors_B.InputCapture_o1 = MCHP_ic1up>>2;
    556a:	30 21 82    	mov.w     0x4426, w0
    556c:	cc 9b 21    	mov.w     #0x19bc, w12
    556e:	42 00 de    	lsr.w     w0, #0x2, w0
    5570:	00 0e 78    	mov.w     w0, [w12]
  AUAV_V3_TestSensors_B.InputCapture_o2 = MCHP_ic2up>>2;
    5572:	40 21 82    	mov.w     0x4428, w0
    5574:	8c 84 e8    	inc2.w    w12, w9
    5576:	42 00 de    	lsr.w     w0, #0x2, w0
    5578:	80 0c 78    	mov.w     w0, [w9]
  AUAV_V3_TestSensors_B.InputCapture_o3 = MCHP_ic3up>>2;
    557a:	50 21 82    	mov.w     0x442a, w0
    557c:	09 85 e8    	inc2.w    w9, w10
    557e:	42 00 de    	lsr.w     w0, #0x2, w0
    5580:	00 0d 78    	mov.w     w0, [w10]
  AUAV_V3_TestSensors_B.InputCapture_o4 = MCHP_ic4up>>2;
    5582:	60 21 82    	mov.w     0x442c, w0
    5584:	e4 85 44    	add.w     w9, #0x4, w11
    5586:	42 00 de    	lsr.w     w0, #0x2, w0
    5588:	80 0d 78    	mov.w     w0, [w11]
  AUAV_V3_TestSensors_B.InputCapture_o5 = MCHP_ic5up>>2;
    558a:	70 21 82    	mov.w     0x442e, w0
    558c:	42 00 de    	lsr.w     w0, #0x2, w0
    558e:	20 ce 88    	mov.w     w0, 0x19c4
  AUAV_V3_TestSensors_B.InputCapture_o6 = MCHP_ic6up>>2;
    5590:	81 21 82    	mov.w     0x4430, w1
    5592:	c2 08 de    	lsr.w     w1, #0x2, w1
    5594:	c1 d0 88    	mov.w     w1, 0x1a18
  AUAV_V3_TestSensors_B.InputCapture_o7 = MCHP_ic7up>>2;
    5596:	91 21 82    	mov.w     0x4432, w1
    5598:	c2 08 de    	lsr.w     w1, #0x2, w1
    559a:	d1 d0 88    	mov.w     w1, 0x1a1a
  AUAV_V3_TestSensors_B.InputCapture_o8 = MCHP_ic8up>>2;
    559c:	a1 21 82    	mov.w     0x4434, w1
    559e:	c2 08 de    	lsr.w     w1, #0x2, w1
    55a0:	e1 d0 88    	mov.w     w1, 0x1a1c

  /* MATLAB Function: '<S660>/Buffer Failsafe Channel' incorporates:
   *  DataTypeConversion: '<S657>/Data Type Conversion'
   *  Gain: '<S657>/Convert to  Microseconds'
   *  MATLAB Function: '<S656>/myMux Fun5'
   */
  /* MATLAB Function 'Trim Vals [updated 4.28.16]/Control Surface Input/myMux Fun5': '<S668>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S668>:1:5' */
  AUAV_V3_Te_BufferICChannel((uint16_T)(52429UL *
    55a2:	d4 cc 2c    	mov.w     #0xcccd, w4
    55a4:	04 00 b8    	mul.uu    w0, w4, w0
    AUAV_V3_TestSensors_B.InputCapture_o5 >> 18),
    55a6:	42 0a de    	lsr.w     w1, #0x2, w4
    55a8:	05 00 20    	mov.w     #0x0, w5

000055aa <.L0>:
    55aa:	e2 00 22    	mov.w     #0x200e, w2
    55ac:	41 14 20    	mov.w     #0x144, w1
    55ae:	89 80 40    	add.w     w1, w9, w1
    55b0:	04 00 78    	mov.w     w4, w0
    55b2:	5e fd 07    	rcall     0x5070 <_AUAV_V3_Te_BufferICChannel> <L0> <.LFB1488> <.LFE1487>

000055b4 <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferFailsafeChannel,
    &AUAV_V3_TestSensors_DWork.sf_BufferFailsafeChannel);

  /* S-Function (MCHP_C_function_Call): '<S660>/Choose the Median [navSupport.c] [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupdat = meanFilter5(
    55b4:	40 14 20    	mov.w     #0x144, w0
    55b6:	09 00 40    	add.w     w0, w9, w0
    55b8:	de f6 02    	call      0xf6de <_meanFilter5>
    55ba:	00 00 00 
    55bc:	30 ce 88    	mov.w     w0, 0x19c6

000055be <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferFailsafeChannel.history[0]
    );

  /* S-Function (MCHP_C_function_Call): '<S19>/Manual or Auto? [navSupport.c] [updated 4.28.16]' */
  AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 = isApManual(
    55be:	82 f2 02    	call      0xf282 <_isApManual>
    55c0:	00 00 00 
    55c2:	08 06 20    	mov.w     #0x60, w8
    55c4:	09 04 44    	add.w     w8, w9, w8
    55c6:	00 4c 78    	mov.b     w0, [w8]

000055c8 <.L0>:
    AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupdat
    );

  /* MATLAB Function: '<S655>/Buffer IC Channel' incorporates:
   *  MATLAB Function: '<S656>/myMux Fun5'
   */
  AUAV_V3_Te_BufferICChannel(AUAV_V3_TestSensors_B.InputCapture_o3,
    55c8:	a2 06 22    	mov.w     #0x206a, w2
    55ca:	41 12 20    	mov.w     #0x124, w1
    55cc:	88 80 40    	add.w     w1, w8, w1
    55ce:	1a 00 78    	mov.w     [w10], w0
    55d0:	4f fd 07    	rcall     0x5070 <_AUAV_V3_Te_BufferICChannel> <L0> <.LFB1488> <.LFE1487>

000055d2 <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferICChannel,
    &AUAV_V3_TestSensors_DWork.sf_BufferICChannel);

  /* MATLAB Function: '<S655>/Buffer IC Channel1' incorporates:
   *  MATLAB Function: '<S656>/myMux Fun5'
   */
  AUAV_V3_Te_BufferICChannel(AUAV_V3_TestSensors_B.InputCapture_o1,
    55d2:	c2 05 22    	mov.w     #0x205c, w2
    55d4:	61 11 20    	mov.w     #0x116, w1
    55d6:	88 80 40    	add.w     w1, w8, w1
    55d8:	1c 00 78    	mov.w     [w12], w0
    55da:	4a fd 07    	rcall     0x5070 <_AUAV_V3_Te_BufferICChannel> <L0> <.LFB1488> <.LFE1487>

000055dc <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferICChannel1,
    &AUAV_V3_TestSensors_DWork.sf_BufferICChannel1);

  /* MATLAB Function: '<S655>/Buffer IC Channel2' incorporates:
   *  MATLAB Function: '<S656>/myMux Fun5'
   */
  AUAV_V3_Te_BufferICChannel(AUAV_V3_TestSensors_B.InputCapture_o4,
    55dc:	e2 04 22    	mov.w     #0x204e, w2
    55de:	81 10 20    	mov.w     #0x108, w1
    55e0:	88 80 40    	add.w     w1, w8, w1
    55e2:	1b 00 78    	mov.w     [w11], w0
    55e4:	45 fd 07    	rcall     0x5070 <_AUAV_V3_Te_BufferICChannel> <L0> <.LFB1488> <.LFE1487>

000055e6 <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferICChannel2,
    &AUAV_V3_TestSensors_DWork.sf_BufferICChannel2);

  /* MATLAB Function: '<S655>/Buffer IC Channel3' incorporates:
   *  MATLAB Function: '<S656>/myMux Fun5'
   */
  AUAV_V3_Te_BufferICChannel(AUAV_V3_TestSensors_B.InputCapture_o2,
    55e6:	02 04 22    	mov.w     #0x2040, w2
    55e8:	a1 0f 20    	mov.w     #0xfa, w1
    55ea:	88 80 40    	add.w     w1, w8, w1
    55ec:	19 00 78    	mov.w     [w9], w0
    55ee:	40 fd 07    	rcall     0x5070 <_AUAV_V3_Te_BufferICChannel> <L0> <.LFB1488> <.LFE1487>

000055f0 <.L0>:
    &AUAV_V3_TestSensors_B.sf_BufferICChannel3,
    &AUAV_V3_TestSensors_DWork.sf_BufferICChannel3);

  /* Logic: '<S658>/Logical Operator' */
  rtb_IC1_a = !(AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 != 0);
    55f0:	98 40 78    	mov.b     [w8], w1

  /* InitialCondition: '<S658>/IC1' */
  if (AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime) {
    55f2:	f0 ff 21    	mov.w     #0x1fff, w0
    55f4:	10 04 e0    	cp0.b     [w0]
    55f6:	04 00 3a    	bra       NZ, 0x5600 <.L114>
    55f8:	01 80 fb    	ze        w1, w0
    55fa:	00 00 e9    	dec.w     w0, w0
    55fc:	4f 00 de    	lsr.w     w0, #0xf, w0
    55fe:	03 00 37    	bra       0x5606 <.L115>

00005600 <.L114>:
    AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime = false;
    5600:	f0 ff 21    	mov.w     #0x1fff, w0
    5602:	00 48 eb    	clr.b     [w0]
    rtb_IC1_a = false;
    5604:	00 40 eb    	clr.b     w0

00005606 <.L115>:
  }

  /* End of InitialCondition: '<S658>/IC1' */

  /* DataTypeConversion: '<S671>/Data Type Conversion1' */
  AUAV_V3_TestSensors_B.DataTypeConversion1_h = rtb_IC1_a;
    5606:	f1 a1 21    	mov.w     #0x1a1f, w1
    5608:	80 48 78    	mov.b     w0, [w1]

0000560a <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S671>/C Function Call' */
  AUAV_V3_TestSensors_B.CFunctionCall = justEnabled(
    560a:	21 c0 b3    	mov.b     #0x2, w1
    560c:	e8 f5 02    	call      0xf5e8 <_justEnabled>
    560e:	00 00 00 
    5610:	01 a2 21    	mov.w     #0x1a20, w1
    5612:	80 48 78    	mov.b     w0, [w1]

00005614 <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1_h
    , ((uint8_T)2U)
    );

  /* Outputs for Enabled SubSystem: '<S19>/Grab I.C.' incorporates:
   *  EnablePort: '<S659>/Enable'
   */
  if (AUAV_V3_TestSensors_B.CFunctionCall > 0) {
    5614:	00 04 e0    	cp0.b     w0
    5616:	99 00 32    	bra       Z, 0x574a <.L116>

00005618 <.L0>:
    /* S-Function (MCHP_C_function_Call): '<S659>/Choose the Median navSupport.c [updated 4.28.16]' */
    AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupd_a = meanFilter5(
    5618:	20 12 20    	mov.w     #0x122, w0
    561a:	01 00 40    	add.w     w0, w1, w0
    561c:	de f6 02    	call      0xf6de <_meanFilter5>
    561e:	00 00 00 
    5620:	00 04 78    	mov.w     w0, w8
    5622:	b8 ce 88    	mov.w     w8, 0x19d6

00005624 <.L0>:
      &AUAV_V3_TestSensors_B.sf_BufferICChannel.history[0]
      );

    /* Saturate: '<S659>/[0.55 0.68]' */
    if (AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupd_a > 2349+200) {
    5624:	50 9f 20    	mov.w     #0x9f5, w0
    5626:	80 0f 54    	sub.w     w8, w0, [w15]
    5628:	05 00 3e    	bra       GTU, 0x5634 <.L426>
      rtb_u2deg = 2349+200;
    } else if (AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupd_a < 2349) {
    562a:	90 0c b1    	sub.w     #0xc9, w0
    562c:	80 0f 54    	sub.w     w8, w0, [w15]
    562e:	03 00 3e    	bra       GTU, 0x5636 <.L117>
      rtb_u2deg = 2349;
    5630:	d8 92 20    	mov.w     #0x92d, w8
    5632:	01 00 37    	bra       0x5636 <.L117>

00005634 <.L426>:
    5634:	58 9f 20    	mov.w     #0x9f5, w8

00005636 <.L117>:
    } else {
      rtb_u2deg = AUAV_V3_TestSensors_B.ChoosetheMediannavSupportcupd_a;
    }

    /* End of Saturate: '<S659>/[0.55 0.68]' */

    /* DataTypeConversion: '<S672>/Data Type Conversion' incorporates:
     *  Gain: '<S672>/Convert to  Microseconds'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_hn = (uint16_T)(52429UL * rtb_u2deg
    5636:	d2 cc 2c    	mov.w     #0xcccd, w2
    5638:	02 41 b8    	mul.uu    w8, w2, w2
      >> 18);
    563a:	42 19 de    	lsr.w     w3, #0x2, w2
    563c:	c2 ce 88    	mov.w     w2, 0x19d8

0000563e <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S659>/update dT Trim updateControlMcu.c [updated 4.28.16]' */
    updatePWMTrim(
    563e:	80 40 eb    	clr.b     w1
    5640:	02 00 78    	mov.w     w2, w0
    5642:	52 0e 02    	call      0x10e52 <_updatePWMTrim>
    5644:	01 00 00 

00005646 <.L0>:
                  AUAV_V3_TestSensors_B.DataTypeConversion_hn
                  , ((uint8_T)0U)
                  );

    /* DataTypeConversion: '<S676>/Data Type Conversion' incorporates:
     *  Constant: '<S676>/Constant1'
     *  Constant: '<S676>/Constant2'
     *  Product: '<S676>/Divide'
     *  Sum: '<S676>/Add'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion = (real32_T)((real_T)rtb_u2deg *
    5646:	61 40 b8    	mul.uu    w8, #0x1, w0
    5648:	12 19 02    	call      0x1912 <___floatunsisf>
    564a:	00 00 00 
    564c:	f2 26 21    	mov.w     #0x126f, w2
    564e:	33 98 23    	mov.w     #0x3983, w3
    5650:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5652:	00 00 00 

00005654 <.L0>:
      0.00025000000000000011 *2.0+ -1.0000000000000009);
    5654:	00 01 be    	mov.d     w0, w2
    5656:	92 14 02    	call      0x1492 <___addsf3>
    5658:	00 00 00 
    565a:	02 00 20    	mov.w     #0x0, w2
    565c:	03 f8 23    	mov.w     #0x3f80, w3
    565e:	90 14 02    	call      0x1490 <___subsf3>
    5660:	00 00 00 

00005662 <.L0>:
    5662:	f0 b1 88    	mov.w     w0, 0x163e
    5664:	01 b2 88    	mov.w     w1, 0x1640

00005666 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S659>/2' */
    AUAV_V3_TestSensors_B.u = meanFilter5(
    5666:	40 b3 21    	mov.w     #0x1b34, w0
    5668:	de f6 02    	call      0xf6de <_meanFilter5>
    566a:	00 00 00 
    566c:	00 04 78    	mov.w     w0, w8
    566e:	d8 ce 88    	mov.w     w8, 0x19da

00005670 <.L0>:
      &AUAV_V3_TestSensors_B.sf_BufferICChannel1.history[0]
      );

    /* Saturate: '<S659>/[-2  2] deg' */
    if (AUAV_V3_TestSensors_B.u > 3280+200) {
    5670:	80 d9 20    	mov.w     #0xd98, w0
    5672:	80 0f 54    	sub.w     w8, w0, [w15]
    5674:	05 00 3e    	bra       GTU, 0x5680 <.L427>
      rtb_u2deg = 3280+200;
    } else if (AUAV_V3_TestSensors_B.u < 3280-200) {
    5676:	10 19 b1    	sub.w     #0x191, w0
    5678:	80 0f 54    	sub.w     w8, w0, [w15]
    567a:	03 00 3e    	bra       GTU, 0x5682 <.L118>
      rtb_u2deg = 3280-200;
    567c:	88 c0 20    	mov.w     #0xc08, w8
    567e:	01 00 37    	bra       0x5682 <.L118>

00005680 <.L427>:
    5680:	88 d9 20    	mov.w     #0xd98, w8

00005682 <.L118>:
    } else {
      rtb_u2deg = AUAV_V3_TestSensors_B.u;
    }

    /* End of Saturate: '<S659>/[-2  2] deg' */

    /* DataTypeConversion: '<S673>/Data Type Conversion' incorporates:
     *  Gain: '<S673>/Convert to  Microseconds'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_e = (uint16_T)(52429UL * rtb_u2deg >>
    5682:	d2 cc 2c    	mov.w     #0xcccd, w2
    5684:	02 41 b8    	mul.uu    w8, w2, w2
    5686:	42 19 de    	lsr.w     w3, #0x2, w2
    5688:	e2 ce 88    	mov.w     w2, 0x19dc

0000568a <.L0>:
      18);

    /* S-Function (MCHP_C_function_Call): '<S659>/update dA Trim updateControlMcu.c' */
    updatePWMTrim(
    568a:	11 c0 b3    	mov.b     #0x1, w1
    568c:	02 00 78    	mov.w     w2, w0
    568e:	52 0e 02    	call      0x10e52 <_updatePWMTrim>
    5690:	01 00 00 

00005692 <.L0>:
                  AUAV_V3_TestSensors_B.DataTypeConversion_e
                  , ((uint8_T)1U)
                  );

    /* DataTypeConversion: '<S677>/Data Type Conversion' incorporates:
     *  Constant: '<S677>/Constant1'
     *  Constant: '<S677>/Constant2'
     *  Product: '<S677>/Divide'
     *  Sum: '<S677>/Add'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_h = (real32_T)((real_T)rtb_u2deg *
    5692:	61 40 b8    	mul.uu    w8, #0x1, w0
    5694:	12 19 02    	call      0x1912 <___floatunsisf>
    5696:	00 00 00 
    5698:	32 2d 20    	mov.w     #0x2d3, w2
    569a:	73 8b 2b    	mov.w     #0xb8b7, w3
    569c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    569e:	00 00 00 

000056a0 <.L0>:
      -8.7266462599716536E-5 *2.0+ 0.52359877559829948);
    56a0:	00 01 be    	mov.d     w0, w2
    56a2:	92 14 02    	call      0x1492 <___addsf3>
    56a4:	00 00 00 
    56a6:	22 a9 20    	mov.w     #0xa92, w2
    56a8:	63 f0 23    	mov.w     #0x3f06, w3
    56aa:	92 14 02    	call      0x1492 <___addsf3>
    56ac:	00 00 00 

000056ae <.L0>:
    56ae:	10 b2 88    	mov.w     w0, 0x1642
    56b0:	21 b2 88    	mov.w     w1, 0x1644

000056b2 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S659>/3' */
    AUAV_V3_TestSensors_B.u_h = meanFilter5(
    56b2:	60 b2 21    	mov.w     #0x1b26, w0
    56b4:	de f6 02    	call      0xf6de <_meanFilter5>
    56b6:	00 00 00 
    56b8:	00 04 78    	mov.w     w0, w8
    56ba:	f8 ce 88    	mov.w     w8, 0x19de

000056bc <.L0>:
      &AUAV_V3_TestSensors_B.sf_BufferICChannel2.history[0]
      );

    /* Saturate: '<S659>/[-2  2] deg ' */
    if (AUAV_V3_TestSensors_B.u_h > 3280+200) {
    56bc:	80 d9 20    	mov.w     #0xd98, w0
    56be:	80 0f 54    	sub.w     w8, w0, [w15]
    56c0:	05 00 3e    	bra       GTU, 0x56cc <.L428>
      rtb_u2deg = 3280+200;
    } else if (AUAV_V3_TestSensors_B.u_h < 3280-200) {
    56c2:	10 19 b1    	sub.w     #0x191, w0
    56c4:	80 0f 54    	sub.w     w8, w0, [w15]
    56c6:	03 00 3e    	bra       GTU, 0x56ce <.L119>
      rtb_u2deg = 3280-200;
    56c8:	88 c0 20    	mov.w     #0xc08, w8
    56ca:	01 00 37    	bra       0x56ce <.L119>

000056cc <.L428>:
    56cc:	88 d9 20    	mov.w     #0xd98, w8

000056ce <.L119>:
    } else {
      rtb_u2deg = AUAV_V3_TestSensors_B.u_h;
    }

    /* End of Saturate: '<S659>/[-2  2] deg ' */

    /* DataTypeConversion: '<S674>/Data Type Conversion' incorporates:
     *  Gain: '<S674>/Convert to  Microseconds'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_go = (uint16_T)(52429UL * rtb_u2deg
    56ce:	d2 cc 2c    	mov.w     #0xcccd, w2
    56d0:	02 41 b8    	mul.uu    w8, w2, w2
      >> 18);
    56d2:	42 19 de    	lsr.w     w3, #0x2, w2
    56d4:	02 cf 88    	mov.w     w2, 0x19e0

000056d6 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S659>/update dR Trim updateControlMcu.c' */
    updatePWMTrim(
    56d6:	21 c0 b3    	mov.b     #0x2, w1
    56d8:	02 00 78    	mov.w     w2, w0
    56da:	52 0e 02    	call      0x10e52 <_updatePWMTrim>
    56dc:	01 00 00 

000056de <.L0>:
                  AUAV_V3_TestSensors_B.DataTypeConversion_go
                  , ((uint8_T)2U)
                  );

    /* DataTypeConversion: '<S678>/Data Type Conversion' incorporates:
     *  Constant: '<S678>/Constant1'
     *  Constant: '<S678>/Constant2'
     *  Product: '<S678>/Divide'
     *  Sum: '<S678>/Add'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_g = (real32_T)((real_T)rtb_u2deg *
    56de:	61 40 b8    	mul.uu    w8, #0x1, w0
    56e0:	12 19 02    	call      0x1912 <___floatunsisf>
    56e2:	00 00 00 
    56e4:	32 2d 20    	mov.w     #0x2d3, w2
    56e6:	73 8b 2b    	mov.w     #0xb8b7, w3
    56e8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    56ea:	00 00 00 

000056ec <.L0>:
      -8.7266462599716536E-5 *2.0+ 0.52359877559829948);
    56ec:	00 01 be    	mov.d     w0, w2
    56ee:	92 14 02    	call      0x1492 <___addsf3>
    56f0:	00 00 00 
    56f2:	22 a9 20    	mov.w     #0xa92, w2
    56f4:	63 f0 23    	mov.w     #0x3f06, w3
    56f6:	92 14 02    	call      0x1492 <___addsf3>
    56f8:	00 00 00 

000056fa <.L0>:
    56fa:	30 b2 88    	mov.w     w0, 0x1646
    56fc:	41 b2 88    	mov.w     w1, 0x1648

000056fe <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S659>/4' */
    AUAV_V3_TestSensors_B.u_m = meanFilter5(
    56fe:	80 b1 21    	mov.w     #0x1b18, w0
    5700:	de f6 02    	call      0xf6de <_meanFilter5>
    5702:	00 00 00 
    5704:	00 04 78    	mov.w     w0, w8
    5706:	18 cf 88    	mov.w     w8, 0x19e2

00005708 <.L0>:
      &AUAV_V3_TestSensors_B.sf_BufferICChannel3.history[0]
      );

    /* Saturate: '<S659>/[-2  2] deg  ' */
    if (AUAV_V3_TestSensors_B.u_m > 3280+200) {
    5708:	80 d9 20    	mov.w     #0xd98, w0
    570a:	80 0f 54    	sub.w     w8, w0, [w15]
    570c:	05 00 3e    	bra       GTU, 0x5718 <.L429>
      rtb_u2deg = 3280+200;
    } else if (AUAV_V3_TestSensors_B.u_m < 3280-200) {
    570e:	10 19 b1    	sub.w     #0x191, w0
    5710:	80 0f 54    	sub.w     w8, w0, [w15]
    5712:	03 00 3e    	bra       GTU, 0x571a <.L120>
      rtb_u2deg = 3280-200;
    5714:	88 c0 20    	mov.w     #0xc08, w8
    5716:	01 00 37    	bra       0x571a <.L120>

00005718 <.L429>:
    5718:	88 d9 20    	mov.w     #0xd98, w8

0000571a <.L120>:
    } else {
      rtb_u2deg = AUAV_V3_TestSensors_B.u_m;
    }

    /* End of Saturate: '<S659>/[-2  2] deg  ' */

    /* DataTypeConversion: '<S675>/Data Type Conversion' incorporates:
     *  Gain: '<S675>/Convert to  Microseconds'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_k = (uint16_T)(52429UL * rtb_u2deg >>
    571a:	d2 cc 2c    	mov.w     #0xcccd, w2
    571c:	02 41 b8    	mul.uu    w8, w2, w2
    571e:	42 19 de    	lsr.w     w3, #0x2, w2
    5720:	22 cf 88    	mov.w     w2, 0x19e4

00005722 <.L0>:
      18);

    /* S-Function (MCHP_C_function_Call): '<S659>/update dE Trim updateControlMcu.c' */
    updatePWMTrim(
    5722:	31 c0 b3    	mov.b     #0x3, w1
    5724:	02 00 78    	mov.w     w2, w0
    5726:	52 0e 02    	call      0x10e52 <_updatePWMTrim>
    5728:	01 00 00 

0000572a <.L0>:
                  AUAV_V3_TestSensors_B.DataTypeConversion_k
                  , ((uint8_T)3U)
                  );

    /* DataTypeConversion: '<S679>/Data Type Conversion' incorporates:
     *  Constant: '<S679>/Constant1'
     *  Constant: '<S679>/Constant2'
     *  Product: '<S679>/Divide'
     *  Sum: '<S679>/Add'
     */
    AUAV_V3_TestSensors_B.DataTypeConversion_f = (real32_T)((real_T)rtb_u2deg *
    572a:	61 40 b8    	mul.uu    w8, #0x1, w0
    572c:	12 19 02    	call      0x1912 <___floatunsisf>
    572e:	00 00 00 
    5730:	32 2d 20    	mov.w     #0x2d3, w2
    5732:	73 8b 23    	mov.w     #0x38b7, w3
    5734:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5736:	00 00 00 

00005738 <.L0>:
      8.7266462599716536E-5 *2.0+ -0.52359877559829948);
    5738:	00 01 be    	mov.d     w0, w2
    573a:	92 14 02    	call      0x1492 <___addsf3>
    573c:	00 00 00 
    573e:	22 a9 20    	mov.w     #0xa92, w2
    5740:	63 f0 23    	mov.w     #0x3f06, w3
    5742:	90 14 02    	call      0x1490 <___subsf3>
    5744:	00 00 00 

00005746 <.L0>:
    5746:	50 b2 88    	mov.w     w0, 0x164a
    5748:	61 b2 88    	mov.w     w1, 0x164c

0000574a <.L116>:
  }

  /* End of Outputs for SubSystem: '<S19>/Grab I.C.' */

  /* Logic: '<S11>/Logical Operator' incorporates:
   *  Constant: '<S469>/Constant'
   *  Constant: '<S470>/Constant'
   *  Constant: '<S471>/Constant'
   *  DataStoreRead: '<Root>/isPassthrough'
   *  RelationalOperator: '<S469>/Compare'
   *  RelationalOperator: '<S470>/Compare'
   *  RelationalOperator: '<S471>/Compare'
   */
  rtb_IC1_a = (boolean_T)((mlHeartbeatLocal.custom_mode == 2UL) ^
    574a:	08 12 21    	mov.w     #0x1120, w8
    574c:	18 02 be    	mov.d     [w8], w4
    (mlHeartbeatLocal.custom_mode == 4UL)) ^ (mlHeartbeatLocal.custom_mode ==
    574e:	04 00 be    	mov.d     w4, w0
    5750:	00 20 a2    	btg.w     w0, #0x2
    5752:	00 80 70    	ior.w     w1, w0, w0
    5754:	00 f0 a7    	btsc.w    w0, #0xf
    5756:	00 00 ea    	neg.w     w0, w0
    5758:	00 01 e9    	dec.w     w0, w2
    575a:	4f 11 de    	lsr.w     w2, #0xf, w2

0000575c <.L0>:
    575c:	04 00 be    	mov.d     w4, w0
    575e:	00 10 a2    	btg.w     w0, #0x1
    5760:	00 80 70    	ior.w     w1, w0, w0
    5762:	00 f0 a7    	btsc.w    w0, #0xf
    5764:	00 00 ea    	neg.w     w0, w0
    5766:	00 00 e9    	dec.w     w0, w0
    5768:	4f 00 de    	lsr.w     w0, #0xf, w0
    576a:	00 40 69    	xor.b     w2, w0, w0

0000576c <.L0>:
    576c:	04 30 a2    	btg.w     w4, #0x3
    576e:	04 82 72    	ior.w     w5, w4, w4
    5770:	04 f0 a7    	btsc.w    w4, #0xf
    5772:	04 02 ea    	neg.w     w4, w4
    5774:	84 00 e9    	dec.w     w4, w1
    5776:	cf 08 de    	lsr.w     w1, #0xf, w1
    5778:	81 40 68    	xor.b     w0, w1, w1
    577a:	41 5f 9b    	mov.b     w1, [w14+412]

0000577c <.L0>:
    8UL);

  /* S-Function (MCHP_C_function_Call): '<Root>/Get RTB Order [navSupport.c] [updated 4.27.16]' */
  getRTB(
    577c:	10 a2 21    	mov.w     #0x1a21, w0
    577e:	58 f5 02    	call      0xf558 <_getRTB>
    5780:	00 00 00 

00005782 <.L0>:
         &AUAV_V3_TestSensors_B.GetRTBOrdernavSupportcupdated42[0]
         );

  /* Outputs for Atomic SubSystem: '<S6>/Navigation Encaps [updated 4.28.16]' */
  /* DataTypeConversion: '<S72>/Data Type Conversion' incorporates:
   *  DataStoreRead: '<S72>/Get Nav Mode'
   */
  rtb_Compare_j = (uint8_T)mlHeartbeatLocal.custom_mode;
    5782:	18 00 be    	mov.d     [w8], w0
    5784:	70 af 99    	mov.w     w0, [w14+478]
    5786:	01 b7 99    	mov.w     w1, [w14+480]

  /* InitialCondition: '<S189>/IC1' incorporates:
   *  DataStoreRead: '<Root>/isWpFly?'
   *  Logic: '<S180>/Logical Operator'
   *  Logic: '<S180>/Logical Operator1'
   */
  if (AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime_m) {
    5788:	10 00 22    	mov.w     #0x2001, w0
    578a:	10 04 e0    	cp0.b     [w0]
    578c:	04 00 32    	bra       Z, 0x5796 <.L121>
    AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime_m = false;
    578e:	00 48 eb    	clr.b     [w0]
    rtb_IC1 = false;
    5790:	80 40 eb    	clr.b     w1
    5792:	61 e7 9b    	mov.b     w1, [w14+486]
    5794:	0b 00 37    	bra       0x57ac <.L122>

00005796 <.L121>:
  } else {
    rtb_IC1 = ((mlHeartbeatLocal.custom_mode != 0UL) &&
    5796:	00 00 eb    	clr.w     w0
    5798:	7e a9 91    	mov.w     [w14+478], w2
    579a:	8e b1 91    	mov.w     [w14+480], w3
    579c:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    579e:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    57a0:	04 00 32    	bra       Z, 0x57aa <.L123>
               (!(AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 != 0)));
    57a2:	e0 a1 21    	mov.w     #0x1a1e, w0
    57a4:	10 80 fb    	ze        [w0], w0
    57a6:	00 00 e9    	dec.w     w0, w0
    57a8:	4f 00 de    	lsr.w     w0, #0xf, w0

000057aa <.L123>:
    57aa:	60 e7 9b    	mov.b     w0, [w14+486]

000057ac <.L122>:
  }

  /* End of InitialCondition: '<S189>/IC1' */

  /* DataTypeConversion: '<S459>/Data Type Conversion2' incorporates:
   *  Delay: '<S464>/Delay'
   *  Logic: '<S464>/Logical Operator'
   *  RelationalOperator: '<S464>/Relational Operator'
   */
  rtb_DataTypeConversion2_fi = (uint8_T)
    57ac:	00 00 eb    	clr.w     w0
    57ae:	a1 ff 21    	mov.w     #0x1ffa, w1
    57b0:	ee e1 93    	mov.b     [w14+486], w3
    57b2:	91 cf 11    	subr.b    w3, [w1], [w15]
    57b4:	03 00 32    	bra       Z, 0x57bc <.L124>
    57b6:	03 80 fb    	ze        w3, w0
    57b8:	00 00 ea    	neg.w     w0, w0
    57ba:	4f 00 de    	lsr.w     w0, #0xf, w0

000057bc <.L124>:
    57bc:	20 e7 9b    	mov.b     w0, [w14+482]
    ((AUAV_V3_TestSensors_DWork.Delay_DSTATE_e != rtb_IC1) && rtb_IC1);

  /* InitialCondition: '<S189>/IC2' */
  if (AUAV_V3_TestSensors_DWork.IC2_FirstOutputTime) {
    57be:	20 00 22    	mov.w     #0x2002, w0
    57c0:	10 04 e0    	cp0.b     [w0]
    57c2:	02 00 32    	bra       Z, 0x57c8 <.L125>
    AUAV_V3_TestSensors_DWork.IC2_FirstOutputTime = false;
    57c4:	00 48 eb    	clr.b     [w0]
    57c6:	8a 00 37    	bra       0x58dc <.L126>

000057c8 <.L125>:
    rtb_IC2 = 0U;
  } else {
    rtb_IC2 = rtb_DataTypeConversion2_fi;
  }

  /* End of InitialCondition: '<S189>/IC2' */

  /* Outputs for Enabled SubSystem: '<S189>/Grab Upon Enable' incorporates:
   *  EnablePort: '<S458>/Enable'
   */
  if (rtb_IC2 > 0) {
    57c8:	2e e2 93    	mov.b     [w14+482], w4
    57ca:	04 04 e0    	cp0.b     w4
    57cc:	87 00 32    	bra       Z, 0x58dc <.L126>

000057ce <.L0>:
    /* SignalConversion: '<S461>/Numerical Unity' incorporates:
     *  DataStoreRead: '<S458>/Get GS Location'
     *  Gain: '<S458>/Gain'
     *  Gain: '<S458>/Gain1'
     *  Gain: '<S458>/Gain2'
     */
    AUAV_V3_TestSensors_B.NumericalUnity[0] = 0.001F * mlGSLocationFloat.alt;
    57ce:	f2 26 21    	mov.w     #0x126f, w2
    57d0:	33 a8 23    	mov.w     #0x3a83, w3
    57d2:	30 88 80    	mov.w     0x1106, w0
    57d4:	41 88 80    	mov.w     0x1108, w1
    57d6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    57d8:	00 00 00 
    57da:	d0 be 88    	mov.w     w0, 0x17da
    57dc:	e1 be 88    	mov.w     w1, 0x17dc

000057de <.L0>:
    AUAV_V3_TestSensors_B.NumericalUnity[1] = 1.0E-7F * mlGSLocationFloat.lat;
    57de:	52 f9 2b    	mov.w     #0xbf95, w2
    57e0:	63 3d 23    	mov.w     #0x33d6, w3
    57e2:	f0 87 80    	mov.w     0x10fe, w0
    57e4:	01 88 80    	mov.w     0x1100, w1
    57e6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    57e8:	00 00 00 
    57ea:	00 04 be    	mov.d     w0, w8
    57ec:	f0 be 88    	mov.w     w0, 0x17de
    57ee:	01 bf 88    	mov.w     w1, 0x17e0

000057f0 <.L0>:
    AUAV_V3_TestSensors_B.NumericalUnity[2] = 1.0E-7F * mlGSLocationFloat.lon;
    57f0:	52 f9 2b    	mov.w     #0xbf95, w2
    57f2:	63 3d 23    	mov.w     #0x33d6, w3
    57f4:	10 88 80    	mov.w     0x1102, w0
    57f6:	21 88 80    	mov.w     0x1104, w1
    57f8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    57fa:	00 00 00 
    57fc:	10 bf 88    	mov.w     w0, 0x17e2
    57fe:	21 bf 88    	mov.w     w1, 0x17e4

00005800 <.L0>:

    /* Gain: '<S462>/Deg2R' */
    rtb_cosphi = 0.0174532924F * AUAV_V3_TestSensors_B.NumericalUnity[1];
    5800:	52 a3 2f    	mov.w     #0xfa35, w2
    5802:	e3 c8 23    	mov.w     #0x3c8e, w3
    5804:	08 00 be    	mov.d     w8, w0
    5806:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5808:	00 00 00 
    580a:	00 04 be    	mov.d     w0, w8

0000580c <.L0>:

    /* Trigonometry: '<S462>/sin(phi)' */
    rtb_Ze_b = (real32_T)sin(rtb_cosphi);
    580c:	b6 1d 02    	call      0x1db6 <_sinf>
    580e:	00 00 00 
    5810:	00 01 be    	mov.d     w0, w2
    5812:	50 b7 99    	mov.w     w0, [w14+490]
    5814:	61 b7 99    	mov.w     w1, [w14+492]

00005816 <.L0>:

    /* Sum: '<S462>/Sum1' incorporates:
     *  Constant: '<S462>/const'
     *  Product: '<S462>/Product1'
     *  Product: '<S462>/sin(phi)^2'
     */
    rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    5816:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5818:	00 00 00 
    581a:	02 b8 25    	mov.w     #0x5b80, w2
    581c:	b3 bd 23    	mov.w     #0x3bdb, w3
    581e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5820:	00 00 00 
    5822:	00 01 be    	mov.d     w0, w2
    5824:	00 00 20    	mov.w     #0x0, w0
    5826:	01 f8 23    	mov.w     #0x3f80, w1
    5828:	90 14 02    	call      0x1490 <___subsf3>
    582a:	00 00 00 
    582c:	00 05 be    	mov.d     w0, w10

0000582e <.L0>:

    /* Fcn: '<S462>/f' */
    if (rtb_Sum1_mzp < 0.0F) {
    582e:	60 11 b8    	mul.uu    w2, #0x0, w2
    5830:	8c 18 02    	call      0x188c <___eqsf2>
    5832:	00 00 00 
    5834:	00 00 e0    	cp0.w     w0
    5836:	07 00 3d    	bra       GE, 0x5846 <.L0> <.L0> <.L600>

00005838 <.L0>:
      rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    5838:	0a 00 be    	mov.d     w10, w0
    583a:	01 f0 a2    	btg.w     w1, #0xf
    583c:	ba 1d 02    	call      0x1dba <_sqrtf>
    583e:	00 00 00 
    5840:	00 01 be    	mov.d     w0, w2
    5842:	03 f0 a2    	btg.w     w3, #0xf
    5844:	04 00 37    	bra       0x584e <.L0> <.L0> <.L129>

00005846 <.L0>:
    } else {
      rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    5846:	0a 00 be    	mov.d     w10, w0
    5848:	ba 1d 02    	call      0x1dba <_sqrtf>
    584a:	00 00 00 
    584c:	00 01 be    	mov.d     w0, w2

0000584e <.L0>:
    }

    /* End of Fcn: '<S462>/f' */

    /* Product: '<S462>/Rh' incorporates:
     *  Constant: '<S462>/Re=equatorial radius'
     */
    rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    584e:	20 53 2a    	mov.w     #0xa532, w0
    5850:	21 ac 24    	mov.w     #0x4ac2, w1
    5852:	26 17 02    	call      0x1726 <___divsf3>
    5854:	00 00 00 
    5856:	00 06 be    	mov.d     w0, w12

00005858 <.L0>:

    /* Sum: '<S462>/Sum2' */
    rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_B.NumericalUnity[0] +
      rtb_Sum1_mzp;

    /* Trigonometry: '<S462>/cos(phi)' */
    rtb_cosphi = (real32_T)cos(rtb_cosphi);
    5858:	08 00 be    	mov.d     w8, w0
    585a:	22 17 02    	call      0x1722 <_cosf>
    585c:	00 00 00 
    585e:	00 05 be    	mov.d     w0, w10

00005860 <.L0>:

    /* Gain: '<S462>/Deg2R1' */
    rtb_Deg2R1 = 0.0174532924F * AUAV_V3_TestSensors_B.NumericalUnity[2];
    5860:	52 a3 2f    	mov.w     #0xfa35, w2
    5862:	e3 c8 23    	mov.w     #0x3c8e, w3
    5864:	10 bf 80    	mov.w     0x17e2, w0
    5866:	21 bf 80    	mov.w     0x17e4, w1
    5868:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    586a:	00 00 00 
    586c:	00 04 be    	mov.d     w0, w8

0000586e <.L0>:
    586e:	0c 01 be    	mov.d     w12, w2
    5870:	d0 be 80    	mov.w     0x17da, w0
    5872:	e1 be 80    	mov.w     0x17dc, w1
    5874:	92 14 02    	call      0x1492 <___addsf3>
    5876:	00 00 00 

00005878 <.L0>:

    /* Product: '<S462>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
     *  Trigonometry: '<S462>/cos(lamb)'
     */
    rtb_RhhcosphicoslambXe = rtb_RhhcosphisinlambYe * rtb_cosphi * (real32_T)cos
    5878:	0a 01 be    	mov.d     w10, w2
    587a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    587c:	00 00 00 
    587e:	00 05 be    	mov.d     w0, w10
    5880:	08 00 be    	mov.d     w8, w0
    5882:	22 17 02    	call      0x1722 <_cosf>
    5884:	00 00 00 
    5886:	10 a7 99    	mov.w     w0, [w14+450]
    5888:	21 a7 99    	mov.w     w1, [w14+452]

0000588a <.L0>:
      (rtb_Deg2R1);

    /* Product: '<S462>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
     *  Trigonometry: '<S462>/sin(lamb)'
     */
    rtb_RhhcosphisinlambYe = rtb_RhhcosphisinlambYe * rtb_cosphi * (real32_T)sin
    588a:	08 00 be    	mov.d     w8, w0
    588c:	b6 1d 02    	call      0x1db6 <_sinf>
    588e:	00 00 00 
    5890:	00 04 be    	mov.d     w0, w8

00005892 <.L0>:
      (rtb_Deg2R1);

    /* Product: '<S462>/Ze' incorporates:
     *  Product: '<S462>/Rh(1-e^2)'
     *  Sum: '<S462>/Sum4'
     */
    rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp +
      AUAV_V3_TestSensors_B.NumericalUnity[0];

    /* DataTypeConversion: '<S458>/Data Type Conversion' */
    AUAV_V3_TestSensors_B.DataTypeConversion_c[0] =
    5892:	10 bf 80    	mov.w     0x17e2, w0
    5894:	21 bf 80    	mov.w     0x17e4, w1
    5896:	30 bf 88    	mov.w     w0, 0x17e6
    5898:	41 bf 88    	mov.w     w1, 0x17e8
      AUAV_V3_TestSensors_B.NumericalUnity[2];
    AUAV_V3_TestSensors_B.DataTypeConversion_c[1] =
    589a:	f2 be 80    	mov.w     0x17de, w2
    589c:	03 bf 80    	mov.w     0x17e0, w3
    589e:	52 bf 88    	mov.w     w2, 0x17ea
    58a0:	63 bf 88    	mov.w     w3, 0x17ec

000058a2 <.L0>:
    58a2:	1e a1 91    	mov.w     [w14+450], w2
    58a4:	ae a1 91    	mov.w     [w14+452], w3
    58a6:	0a 00 be    	mov.d     w10, w0
    58a8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    58aa:	00 00 00 

000058ac <.L0>:
      AUAV_V3_TestSensors_B.NumericalUnity[1];

    /* DataTypeConversion: '<S458>/Data Type Conversion1' */
    AUAV_V3_TestSensors_B.DataTypeConversion1_l[0] = rtb_RhhcosphicoslambXe;
    58ac:	70 bf 88    	mov.w     w0, 0x17ee
    58ae:	81 bf 88    	mov.w     w1, 0x17f0

000058b0 <.L0>:
    58b0:	08 01 be    	mov.d     w8, w2
    58b2:	0a 00 be    	mov.d     w10, w0
    58b4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    58b6:	00 00 00 

000058b8 <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1_l[1] = rtb_RhhcosphisinlambYe;
    58b8:	90 bf 88    	mov.w     w0, 0x17f2
    58ba:	a1 bf 88    	mov.w     w1, 0x17f4

000058bc <.L0>:
    58bc:	92 94 24    	mov.w     #0x4949, w2
    58be:	e3 f7 23    	mov.w     #0x3f7e, w3
    58c0:	0c 00 be    	mov.d     w12, w0
    58c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    58c4:	00 00 00 
    58c6:	00 01 be    	mov.d     w0, w2
    58c8:	d0 be 80    	mov.w     0x17da, w0
    58ca:	e1 be 80    	mov.w     0x17dc, w1
    58cc:	92 14 02    	call      0x1492 <___addsf3>
    58ce:	00 00 00 
    58d0:	5e b1 91    	mov.w     [w14+490], w2
    58d2:	ee b1 91    	mov.w     [w14+492], w3
    58d4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    58d6:	00 00 00 

000058d8 <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1_l[2] = rtb_Ze_b;
    58d8:	b0 bf 88    	mov.w     w0, 0x17f6
    58da:	c1 bf 88    	mov.w     w1, 0x17f8

000058dc <.L126>:
  }

  /* End of Outputs for SubSystem: '<S189>/Grab Upon Enable' */

  /* MATLAB Function: '<S180>/myMux Fun2' */
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/myMux Fun2': '<S193>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S193>:1:5' */
  AUAV_V3_TestSensors_B.y_p[0] = AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    58dc:	e0 7b 21    	mov.w     #0x17be, w0
    58de:	74 bf 80    	mov.w     0x17ee, w4
    58e0:	85 bf 80    	mov.w     0x17f0, w5
    58e2:	04 88 be    	mov.d     w4, [w0]
  AUAV_V3_TestSensors_B.y_p[1] = AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    58e4:	92 bf 80    	mov.w     0x17f2, w2
    58e6:	a3 bf 80    	mov.w     0x17f4, w3
    58e8:	12 be 88    	mov.w     w2, 0x17c2
    58ea:	23 be 88    	mov.w     w3, 0x17c4

000058ec <.L0>:
  AUAV_V3_TestSensors_B.y_p[2] = AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    58ec:	b4 bf 80    	mov.w     0x17f6, w4
    58ee:	c5 bf 80    	mov.w     0x17f8, w5
    58f0:	34 be 88    	mov.w     w4, 0x17c6
    58f2:	45 be 88    	mov.w     w5, 0x17c8

000058f4 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S180>/Diagnoistics Set navsupport.c [updated 5.1.16]1' */
  setDiagnosticFloat(
    58f4:	88 f3 02    	call      0xf388 <_setDiagnosticFloat>
    58f6:	00 00 00 
                     &AUAV_V3_TestSensors_B.y_p[0]
                     );

  /* InitialCondition: '<S189>/IC4' */
  if (AUAV_V3_TestSensors_DWork.IC4_FirstOutputTime) {
    58f8:	30 00 22    	mov.w     #0x2003, w0
    58fa:	10 04 e0    	cp0.b     [w0]
    58fc:	06 00 32    	bra       Z, 0x590a <.L130>
    AUAV_V3_TestSensors_DWork.IC4_FirstOutputTime = false;
    58fe:	00 48 eb    	clr.b     [w0]
    rtb_IC4_idx_0 = 36.9885063F;
    5900:	ba 43 2f    	mov.w     #0xf43b, w10
    5902:	3b 21 24    	mov.w     #0x4213, w11
    rtb_IC4_idx_1 = -122.055305F;
    5904:	1c c5 21    	mov.w     #0x1c51, w12
    5906:	4d 2f 2c    	mov.w     #0xc2f4, w13
    5908:	04 00 37    	bra       0x5912 <.L0> <.L131>

0000590a <.L130>:
  } else {
    rtb_IC4_idx_0 = AUAV_V3_TestSensors_B.DataTypeConversion_c[0];
    590a:	3a bf 80    	mov.w     0x17e6, w10
    590c:	4b bf 80    	mov.w     0x17e8, w11
    rtb_IC4_idx_1 = AUAV_V3_TestSensors_B.DataTypeConversion_c[1];
    590e:	5c bf 80    	mov.w     0x17ea, w12
    5910:	6d bf 80    	mov.w     0x17ec, w13

00005912 <.L0>:
  }

  /* End of InitialCondition: '<S189>/IC4' */

  /* MATLAB Function: '<S180>/Zero out Z2' */
  AUAV_V3_TestSens_ZerooutZ1(AUAV_V3_TestSensors_B.sf_myMuxFun1_e.y,
    5912:	c1 c2 21    	mov.w     #0x1c2c, w1
    5914:	c0 fb 2f    	mov.w     #0xffbc, w0
    5916:	01 00 40    	add.w     w0, w1, w0
    5918:	56 fb 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

0000591a <.L0>:
    &AUAV_V3_TestSensors_B.sf_ZerooutZ2);

  /* MATLAB Function: '<S180>/Zero out Z1' */
  AUAV_V3_TestSens_ZerooutZ1(AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y,
    591a:	81 c3 21    	mov.w     #0x1c38, w1
    591c:	40 fa 2f    	mov.w     #0xffa4, w0
    591e:	01 00 40    	add.w     w0, w1, w0
    5920:	52 fb 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00005922 <.L0>:
    &AUAV_V3_TestSensors_B.sf_ZerooutZ1);

  /* MATLAB Function: '<S263>/Embedded MATLAB Function' */
  A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.sf_ZerooutZ1.P,
    5922:	41 c6 21    	mov.w     #0x1c64, w1
    5924:	40 fd 2f    	mov.w     #0xffd4, w0
    5926:	01 00 40    	add.w     w0, w1, w0
    5928:	28 fb 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

0000592a <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i1);

  /* MATLAB Function: '<S264>/negprotect' */
  AUAV_V3_TestS_negprotect_l
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i1.xDoty,
    592a:	02 c6 21    	mov.w     #0x1c60, w2
    592c:	20 e3 80    	mov.w     0x1c64, w0
    592e:	31 e3 80    	mov.w     0x1c66, w1
    5930:	12 fb 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00005932 <.L0>:
     &AUAV_V3_TestSensors_B.sf_negprotect_lq);

  /* S-Function (MCHP_C_function_Call): '<S264>/mySqrt() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116 = mySqrt(
    5932:	00 e3 80    	mov.w     0x1c60, w0
    5934:	11 e3 80    	mov.w     0x1c62, w1
    5936:	16 10 02    	call      0x11016 <_mySqrt>
    5938:	01 00 00 
    593a:	00 04 be    	mov.d     w0, w8
    593c:	30 bc 88    	mov.w     w0, 0x1786
    593e:	41 bc 88    	mov.w     w1, 0x1788

00005940 <.L0>:
    AUAV_V3_TestSensors_B.sf_negprotect_lq.zpVal
    );

  /* InitialCondition: '<S186>/IC' incorporates:
   *  DataStoreRead: '<Root>/PAR_NAV_ISR_FAC PAR_PID_RMIX_ON PAR_PID_RMIX_P'
   */
  if (AUAV_V3_TestSensors_DWork.IC_FirstOutputTime) {
    5940:	40 00 22    	mov.w     #0x2004, w0
    5942:	10 04 e0    	cp0.b     [w0]
    5944:	06 00 32    	bra       Z, 0x5952 <.L132>
    AUAV_V3_TestSensors_DWork.IC_FirstOutputTime = false;
    5946:	00 48 eb    	clr.b     [w0]
    rtb_RhhcosphisinlambYe = 1.5F;
    5948:	00 00 20    	mov.w     #0x0, w0
    594a:	01 fc 23    	mov.w     #0x3fc0, w1
    594c:	50 b7 99    	mov.w     w0, [w14+490]
    594e:	61 b7 99    	mov.w     w1, [w14+492]
    5950:	1e 00 37    	bra       0x598e <.L134>

00005952 <.L132>:
  } else {
    rtb_RhhcosphisinlambYe = mlParamInterface.param[26];
    5952:	12 96 80    	mov.w     0x12c2, w2
    5954:	23 96 80    	mov.w     0x12c4, w3
    5956:	52 b7 99    	mov.w     w2, [w14+490]
    5958:	63 b7 99    	mov.w     w3, [w14+492]

0000595a <.L0>:
  }

  /* End of InitialCondition: '<S186>/IC' */

  /* Saturate: '<S186>/[1.5 10]' */
  if (rtb_RhhcosphisinlambYe > 10.0F) {
    595a:	02 00 20    	mov.w     #0x0, w2
    595c:	03 12 24    	mov.w     #0x4120, w3
    595e:	5e b0 91    	mov.w     [w14+490], w0
    5960:	ee b0 91    	mov.w     [w14+492], w1
    5962:	90 18 02    	call      0x1890 <___gesf2>
    5964:	00 00 00 
    5966:	00 00 e0    	cp0.w     w0
    5968:	09 00 3c    	bra       GT, 0x597c <.L0> <.L432>

0000596a <.L0>:
    rtb_RhhcosphisinlambYe = 10.0F;
  } else {
    if (rtb_RhhcosphisinlambYe < 1.5F) {
    596a:	02 00 20    	mov.w     #0x0, w2
    596c:	03 fc 23    	mov.w     #0x3fc0, w3
    596e:	5e b0 91    	mov.w     [w14+490], w0
    5970:	ee b0 91    	mov.w     [w14+492], w1
    5972:	8c 18 02    	call      0x188c <___eqsf2>
    5974:	00 00 00 
    5976:	00 00 e0    	cp0.w     w0
    5978:	06 00 35    	bra       LT, 0x5986 <.L433>
    597a:	09 00 37    	bra       0x598e <.L134>

0000597c <.L0>:
    597c:	04 00 20    	mov.w     #0x0, w4
    597e:	05 12 24    	mov.w     #0x4120, w5
    5980:	54 b7 99    	mov.w     w4, [w14+490]
    5982:	65 b7 99    	mov.w     w5, [w14+492]
    5984:	04 00 37    	bra       0x598e <.L134>

00005986 <.L433>:
      rtb_RhhcosphisinlambYe = 1.5F;
    5986:	00 00 20    	mov.w     #0x0, w0
    5988:	01 fc 23    	mov.w     #0x3fc0, w1
    598a:	50 b7 99    	mov.w     w0, [w14+490]
    598c:	61 b7 99    	mov.w     w1, [w14+492]

0000598e <.L134>:
    }
  }

  /* Product: '<S186>/Product3' incorporates:
   *  Constant: '<S186>/Constant1'
   *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
   *  Product: '<S186>/Product1'
   *  Product: '<S186>/Product2'
   *  Saturate: '<S186>/[1.5 10]'
   */
  rtb_Product3_bo = mlMidLevelCommands.uCommand * mlMidLevelCommands.uCommand *
    598e:	72 89 80    	mov.w     0x112e, w2
    5990:	83 89 80    	mov.w     0x1130, w3
    5992:	52 af 99    	mov.w     w2, [w14+474]
    5994:	63 af 99    	mov.w     w3, [w14+476]
    rtb_RhhcosphisinlambYe / 4.57681F;

  /* If: '<S180>/Determine Overall Nav by the Nav Mode' incorporates:
   *  Constant: '<S181>/RTB1'
   *  Constant: '<S185>/RTB'
   *  Constant: '<S185>/RTB1'
   *  Constant: '<S188>/RTB'
   *  Constant: '<S188>/RTB1'
   *  Constant: '<S381>/Constant'
   *  Constant: '<S381>/Constant1'
   *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
   *  Gain: '<S206>/Deg2R'
   *  Gain: '<S447>/Deg2R'
   *  Inport: '<S185>/MidLvl h_c'
   *  Inport: '<S188>/MidLvl h_c'
   *  Product: '<S330>/Divide'
   *  Product: '<S385>/Divide'
   *  Sum: '<S324>/Add'
   */
  if (AUAV_V3_TestSensors_B.GetRTBOrdernavSupportcupdated42[0] == 1) {
    5996:	10 a2 21    	mov.w     #0x1a21, w0
    5998:	13 c0 b3    	mov.b     #0x1, w3
    599a:	90 cf 11    	subr.b    w3, [w0], [w15]
    599c:	db 01 3a    	bra       NZ, 0x5d54 <.L0> <.L135>
    /* Outputs for IfAction SubSystem: '<S180>/RTB//Follow Mobile Navigation' incorporates:
     *  ActionPort: '<S188>/Action Port'
     */
    /* Outputs for Enabled SubSystem: '<S188>/Compute Mobile Location' incorporates:
     *  EnablePort: '<S442>/Enable'
     */
    if (AUAV_V3_TestSensors_B.GetRTBOrdernavSupportcupdated42[1] > 0) {
    599e:	00 00 e8    	inc.w     w0, w0
    59a0:	10 04 e0    	cp0.b     [w0]
    59a2:	29 01 32    	bra       Z, 0x5bf6 <.L0> <.L136>

000059a4 <.L0>:
      rtb_IC4_idx_0 *= 0.0174532924F;
    59a4:	52 a3 2f    	mov.w     #0xfa35, w2
    59a6:	e3 c8 23    	mov.w     #0x3c8e, w3
    59a8:	0a 00 be    	mov.d     w10, w0
    59aa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    59ac:	00 00 00 
    59ae:	50 b7 99    	mov.w     w0, [w14+490]
    59b0:	61 b7 99    	mov.w     w1, [w14+492]

000059b2 <.L0>:

      /* Gain: '<S447>/Deg2R' */
      rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_1;
    59b2:	52 a3 2f    	mov.w     #0xfa35, w2
    59b4:	e3 c8 23    	mov.w     #0x3c8e, w3
    59b6:	0c 00 be    	mov.d     w12, w0
    59b8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    59ba:	00 00 00 
    59bc:	10 b7 99    	mov.w     w0, [w14+482]
    59be:	21 b7 99    	mov.w     w1, [w14+484]

000059c0 <.L0>:

      /* Gain: '<S448>/Deg2R' incorporates:
       *  DataStoreRead: '<Root>/Get Mobile Location'
       */
      rtb_RhhcosphicoslambXe = 0.0174532924F * mlMobileLocation.latitude;
    59c0:	52 a3 2f    	mov.w     #0xfa35, w2
    59c2:	e3 c8 23    	mov.w     #0x3c8e, w3
    59c4:	30 a6 80    	mov.w     0x14c6, w0
    59c6:	41 a6 80    	mov.w     0x14c8, w1
    59c8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    59ca:	00 00 00 
    59cc:	00 04 be    	mov.d     w0, w8

000059ce <.L0>:

      /* Trigonometry: '<S448>/sin(phi)' */
      rtb_cosphi = (real32_T)sin(rtb_RhhcosphicoslambXe);
    59ce:	b6 1d 02    	call      0x1db6 <_sinf>
    59d0:	00 00 00 
    59d2:	70 af 99    	mov.w     w0, [w14+478]
    59d4:	01 b7 99    	mov.w     w1, [w14+480]

000059d6 <.L0>:

      /* Sum: '<S448>/Sum1' incorporates:
       *  Constant: '<S448>/const'
       *  Product: '<S448>/Product1'
       *  Product: '<S448>/sin(phi)^2'
       */
      rtb_Sum1_mzp = 1.0F - rtb_cosphi * rtb_cosphi * 0.00669425726F;
    59d6:	00 01 be    	mov.d     w0, w2
    59d8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    59da:	00 00 00 
    59dc:	02 b8 25    	mov.w     #0x5b80, w2
    59de:	b3 bd 23    	mov.w     #0x3bdb, w3
    59e0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    59e2:	00 00 00 
    59e4:	00 01 be    	mov.d     w0, w2
    59e6:	00 00 20    	mov.w     #0x0, w0
    59e8:	01 f8 23    	mov.w     #0x3f80, w1
    59ea:	90 14 02    	call      0x1490 <___subsf3>
    59ec:	00 00 00 
    59ee:	00 05 be    	mov.d     w0, w10

000059f0 <.L0>:

      /* Fcn: '<S448>/f' */
      if (rtb_Sum1_mzp < 0.0F) {
    59f0:	60 11 b8    	mul.uu    w2, #0x0, w2
    59f2:	8c 18 02    	call      0x188c <___eqsf2>
    59f4:	00 00 00 
    59f6:	00 00 e0    	cp0.w     w0
    59f8:	07 00 3d    	bra       GE, 0x5a08 <.L0> <.L0> <.L601>

000059fa <.L0>:
        rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    59fa:	0a 00 be    	mov.d     w10, w0
    59fc:	01 f0 a2    	btg.w     w1, #0xf
    59fe:	ba 1d 02    	call      0x1dba <_sqrtf>
    5a00:	00 00 00 
    5a02:	00 01 be    	mov.d     w0, w2
    5a04:	03 f0 a2    	btg.w     w3, #0xf
    5a06:	04 00 37    	bra       0x5a10 <.L0> <.L0> <.L139>

00005a08 <.L0>:
      } else {
        rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    5a08:	0a 00 be    	mov.d     w10, w0
    5a0a:	ba 1d 02    	call      0x1dba <_sqrtf>
    5a0c:	00 00 00 
    5a0e:	00 01 be    	mov.d     w0, w2

00005a10 <.L0>:
      }

      /* End of Fcn: '<S448>/f' */

      /* Product: '<S448>/Rh' incorporates:
       *  Constant: '<S448>/Re=equatorial radius'
       */
      rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    5a10:	20 53 2a    	mov.w     #0xa532, w0
    5a12:	21 ac 24    	mov.w     #0x4ac2, w1
    5a14:	26 17 02    	call      0x1726 <___divsf3>
    5a16:	00 00 00 
    5a18:	00 05 be    	mov.d     w0, w10

00005a1a <.L0>:

      /* Trigonometry: '<S448>/cos(phi)' */
      rtb_RhhcosphicoslambXe = (real32_T)cos(rtb_RhhcosphicoslambXe);
    5a1a:	08 00 be    	mov.d     w8, w0
    5a1c:	22 17 02    	call      0x1722 <_cosf>
    5a1e:	00 00 00 
    5a20:	10 a7 99    	mov.w     w0, [w14+450]
    5a22:	21 a7 99    	mov.w     w1, [w14+452]

00005a24 <.L0>:

      /* Gain: '<S448>/Deg2R1' incorporates:
       *  DataStoreRead: '<Root>/Get Mobile Location'
       */
      rtb_RhhcosphisinlambYe = 0.0174532924F * mlMobileLocation.longitude;
    5a24:	52 a3 2f    	mov.w     #0xfa35, w2
    5a26:	e3 c8 23    	mov.w     #0x3c8e, w3
    5a28:	50 a6 80    	mov.w     0x14ca, w0
    5a2a:	61 a6 80    	mov.w     0x14cc, w1
    5a2c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5a2e:	00 00 00 
    5a30:	00 06 be    	mov.d     w0, w12

00005a32 <.L0>:

      /* Product: '<S448>/Ze' incorporates:
       *  Product: '<S448>/Rh(1-e^2)'
       */
      rtb_cosphi *= 0.993305743F * rtb_Sum1_mzp;
    5a32:	92 94 24    	mov.w     #0x4949, w2
    5a34:	e3 f7 23    	mov.w     #0x3f7e, w3
    5a36:	0a 00 be    	mov.d     w10, w0
    5a38:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5a3a:	00 00 00 
    5a3c:	7e a9 91    	mov.w     [w14+478], w2
    5a3e:	8e b1 91    	mov.w     [w14+480], w3
    5a40:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5a42:	00 00 00 
    5a44:	50 a7 99    	mov.w     w0, [w14+458]
    5a46:	61 a7 99    	mov.w     w1, [w14+460]

00005a48 <.L0>:

      /* SignalConversion: '<S447>/TmpSignal ConversionAtProduct1Inport1' incorporates:
       *  Fcn: '<S450>/11'
       *  Fcn: '<S450>/12'
       *  Fcn: '<S450>/13'
       *  Fcn: '<S450>/21'
       *  Fcn: '<S450>/22'
       *  Fcn: '<S450>/23'
       *  Fcn: '<S450>/31'
       *  Fcn: '<S450>/32'
       *  Fcn: '<S450>/33'
       */
      tmp[0] = (real32_T)cos(rtb_IC4_idx_0) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    5a48:	5e b0 91    	mov.w     [w14+490], w0
    5a4a:	ee b0 91    	mov.w     [w14+492], w1
    5a4c:	22 17 02    	call      0x1722 <_cosf>
    5a4e:	00 00 00 
    5a50:	00 04 be    	mov.d     w0, w8
    5a52:	1e b0 91    	mov.w     [w14+482], w0
    5a54:	ae b0 91    	mov.w     [w14+484], w1
    5a56:	22 17 02    	call      0x1722 <_cosf>
    5a58:	00 00 00 
    5a5a:	00 01 be    	mov.d     w0, w2
    5a5c:	40 af 98    	mov.w     w0, [w14+216]
    5a5e:	51 af 98    	mov.w     w1, [w14+218]
    5a60:	08 00 be    	mov.d     w8, w0
    5a62:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5a64:	00 00 00 
    5a66:	40 9f 98    	mov.w     w0, [w14+184]
    5a68:	51 9f 98    	mov.w     w1, [w14+186]

00005a6a <.L0>:
      tmp[1] = -(real32_T)sin(rtb_IC4_idx_0);
    5a6a:	5e b0 91    	mov.w     [w14+490], w0
    5a6c:	ee b0 91    	mov.w     [w14+492], w1
    5a6e:	b6 1d 02    	call      0x1db6 <_sinf>
    5a70:	00 00 00 
    5a72:	00 02 be    	mov.d     w0, w4
    5a74:	50 af 99    	mov.w     w0, [w14+474]
    5a76:	61 af 99    	mov.w     w1, [w14+476]
    5a78:	05 f0 a2    	btg.w     w5, #0xf
    5a7a:	14 af 99    	mov.w     w4, [w14+466]
    5a7c:	25 af 99    	mov.w     w5, [w14+468]
    5a7e:	64 9f 98    	mov.w     w4, [w14+188]
    5a80:	75 9f 98    	mov.w     w5, [w14+190]

00005a82 <.L0>:
      tmp[2] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_IC4_idx_0);
    5a82:	1e b0 91    	mov.w     [w14+482], w0
    5a84:	ae b0 91    	mov.w     [w14+484], w1
    5a86:	b6 1d 02    	call      0x1db6 <_sinf>
    5a88:	00 00 00 
    5a8a:	00 01 be    	mov.d     w0, w2
    5a8c:	00 af 98    	mov.w     w0, [w14+208]
    5a8e:	11 af 98    	mov.w     w1, [w14+210]
    5a90:	03 f0 a2    	btg.w     w3, #0xf
    5a92:	08 00 be    	mov.d     w8, w0
    5a94:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5a96:	00 00 00 
    5a98:	00 a7 98    	mov.w     w0, [w14+192]
    5a9a:	11 a7 98    	mov.w     w1, [w14+194]

00005a9c <.L0>:
      tmp[3] = (real32_T)sin(rtb_IC4_idx_0) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    5a9c:	5e a9 91    	mov.w     [w14+474], w2
    5a9e:	ee a9 91    	mov.w     [w14+476], w3
    5aa0:	4e a8 90    	mov.w     [w14+216], w0
    5aa2:	de a8 90    	mov.w     [w14+218], w1
    5aa4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5aa6:	00 00 00 
    5aa8:	20 a7 98    	mov.w     w0, [w14+196]
    5aaa:	31 a7 98    	mov.w     w1, [w14+198]

00005aac <.L0>:
      tmp[4] = (real32_T)cos(rtb_IC4_idx_0);
    5aac:	48 a7 98    	mov.w     w8, [w14+200]
    5aae:	59 a7 98    	mov.w     w9, [w14+202]

00005ab0 <.L0>:
      tmp[5] = -(real32_T)sin(rtb_IC4_idx_0) * (real32_T)sin(rtb_Deg2R_h_idx_0);
    5ab0:	0e a9 90    	mov.w     [w14+208], w2
    5ab2:	9e a9 90    	mov.w     [w14+210], w3
    5ab4:	1e a8 91    	mov.w     [w14+466], w0
    5ab6:	ae a8 91    	mov.w     [w14+468], w1
    5ab8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5aba:	00 00 00 
    5abc:	60 a7 98    	mov.w     w0, [w14+204]
    5abe:	71 a7 98    	mov.w     w1, [w14+206]

00005ac0 <.L0>:
      tmp[6] = (real32_T)sin(rtb_Deg2R_h_idx_0);
      tmp[7] = 0.0F;
    5ac0:	60 00 b8    	mul.uu    w0, #0x0, w0
    5ac2:	20 af 98    	mov.w     w0, [w14+212]
    5ac4:	31 af 98    	mov.w     w1, [w14+214]

00005ac6 <.L0>:
      tmp[8] = (real32_T)cos(rtb_Deg2R_h_idx_0);

      /* Sum: '<S446>/Sum1' incorporates:
       *  Product: '<S447>/Product1'
       *  Product: '<S448>/(Rh+h)cos(phi)*cos(lamb)=Xe'
       *  Product: '<S448>/(Rh+h)cos(phi)*sin(lamb)=Ye'
       *  Sum: '<S448>/Sum2'
       *  Trigonometry: '<S448>/cos(lamb)'
       *  Trigonometry: '<S448>/sin(lamb)'
       */
      rtb_Deg2R1 = rtb_Sum1_mzp * rtb_RhhcosphicoslambXe * (real32_T)cos
    5ac6:	1e a1 91    	mov.w     [w14+450], w2
    5ac8:	ae a1 91    	mov.w     [w14+452], w3
    5aca:	0a 00 be    	mov.d     w10, w0
    5acc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ace:	00 00 00 
    5ad0:	00 04 be    	mov.d     w0, w8
    5ad2:	0c 00 be    	mov.d     w12, w0
    5ad4:	22 17 02    	call      0x1722 <_cosf>
    5ad6:	00 00 00 
    5ad8:	00 01 be    	mov.d     w0, w2
    5ada:	08 00 be    	mov.d     w8, w0
    5adc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ade:	00 00 00 
    5ae0:	72 bf 80    	mov.w     0x17ee, w2
    5ae2:	83 bf 80    	mov.w     0x17f0, w3
    5ae4:	90 14 02    	call      0x1490 <___subsf3>
    5ae6:	00 00 00 
    5ae8:	10 af 99    	mov.w     w0, [w14+466]
    5aea:	21 af 99    	mov.w     w1, [w14+468]

00005aec <.L0>:
        (rtb_RhhcosphisinlambYe) - AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
      rtb_RhhcosphisinlambYe = rtb_Sum1_mzp * rtb_RhhcosphicoslambXe * (real32_T)
    5aec:	0c 00 be    	mov.d     w12, w0
    5aee:	b6 1d 02    	call      0x1db6 <_sinf>
    5af0:	00 00 00 
    5af2:	00 01 be    	mov.d     w0, w2
    5af4:	08 00 be    	mov.d     w8, w0
    5af6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5af8:	00 00 00 
    5afa:	92 bf 80    	mov.w     0x17f2, w2
    5afc:	a3 bf 80    	mov.w     0x17f4, w3
    5afe:	90 14 02    	call      0x1490 <___subsf3>
    5b00:	00 00 00 
    5b02:	10 a7 99    	mov.w     w0, [w14+450]
    5b04:	21 a7 99    	mov.w     w1, [w14+452]

00005b06 <.L0>:
        sin(rtb_RhhcosphisinlambYe) -
        AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
      rtb_Sum1_mzp = rtb_cosphi - AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    5b06:	b2 bf 80    	mov.w     0x17f6, w2
    5b08:	c3 bf 80    	mov.w     0x17f8, w3
    5b0a:	5e a0 91    	mov.w     [w14+458], w0
    5b0c:	ee a0 91    	mov.w     [w14+460], w1
    5b0e:	90 14 02    	call      0x1490 <___subsf3>
    5b10:	00 00 00 
    5b12:	00 06 be    	mov.d     w0, w12
    5b14:	83 0b 20    	mov.w     #0xb8, w3
    5b16:	8e 81 41    	add.w     w3, w14, w3
    5b18:	f4 81 41    	add.w     w3, #0x14, w3
    5b1a:	13 b7 99    	mov.w     w3, [w14+482]
    5b1c:	84 0b 20    	mov.w     #0xb8, w4
    5b1e:	0e 02 42    	add.w     w4, w14, w4
    5b20:	68 02 42    	add.w     w4, #0x8, w4
    5b22:	74 af 99    	mov.w     w4, [w14+478]
    5b24:	85 0b 20    	mov.w     #0xb8, w5
    5b26:	8e 82 42    	add.w     w5, w14, w5
    5b28:	e4 82 52    	sub.w     w5, #0x4, w5
    5b2a:	55 af 99    	mov.w     w5, [w14+474]
    5b2c:	80 0d 20    	mov.w     #0xd8, w0
    5b2e:	00 00 47    	add.w     w14, w0, w0
    5b30:	50 b7 99    	mov.w     w0, [w14+490]

00005b32 <.L0>:

      /* Product: '<S447>/Product1' incorporates:
       *  Gain: '<S446>/UEN 2 NEU'
       */
      for (i = 0; i < 3; i++) {
    5b32:	00 04 eb    	clr.w     w8
    5b34:	58 a7 99    	mov.w     w8, [w14+458]

00005b36 <.L0>:
        tmp_0[i] = tmp[i + 6] * rtb_Sum1_mzp + (tmp[i + 3] *
    5b36:	9e b0 91    	mov.w     [w14+482], w1
    5b38:	51 01 be    	mov.d     [++w1], w2
    5b3a:	11 b7 99    	mov.w     w1, [w14+482]
    5b3c:	0c 00 be    	mov.d     w12, w0
    5b3e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5b40:	00 00 00 
    5b42:	00 05 be    	mov.d     w0, w10
    5b44:	7e aa 91    	mov.w     [w14+478], w4
    5b46:	54 01 be    	mov.d     [++w4], w2
    5b48:	74 af 99    	mov.w     w4, [w14+478]
    5b4a:	1e a0 91    	mov.w     [w14+450], w0
    5b4c:	ae a0 91    	mov.w     [w14+452], w1
    5b4e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5b50:	00 00 00 
    5b52:	00 04 be    	mov.d     w0, w8

00005b54 <.L0>:
          rtb_RhhcosphisinlambYe + tmp[i] * rtb_Deg2R1);
    5b54:	de aa 91    	mov.w     [w14+474], w5
    5b56:	55 01 be    	mov.d     [++w5], w2
    5b58:	55 af 99    	mov.w     w5, [w14+474]
    5b5a:	1e a8 91    	mov.w     [w14+466], w0
    5b5c:	ae a8 91    	mov.w     [w14+468], w1
    5b5e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5b60:	00 00 00 
    5b62:	00 01 be    	mov.d     w0, w2
    5b64:	08 00 be    	mov.d     w8, w0
    5b66:	92 14 02    	call      0x1492 <___addsf3>
    5b68:	00 00 00 
    5b6a:	00 01 be    	mov.d     w0, w2

00005b6c <.L0>:
    5b6c:	0a 00 be    	mov.d     w10, w0
    5b6e:	92 14 02    	call      0x1492 <___addsf3>
    5b70:	00 00 00 
    5b72:	5e b1 91    	mov.w     [w14+490], w2
    5b74:	00 a9 be    	mov.d     w0, [++w2]
    5b76:	52 b7 99    	mov.w     w2, [w14+490]

00005b78 <.L0>:
    5b78:	de a1 91    	mov.w     [w14+458], w3
    5b7a:	83 01 e8    	inc.w     w3, w3
    5b7c:	53 a7 99    	mov.w     w3, [w14+458]
    5b7e:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    5b80:	da ff 3a    	bra       NZ, 0x5b36 <.L0> <.L140>
      }

      /* Reshape: '<S446>/Reshape1' incorporates:
       *  Gain: '<S446>/UEN 2 NEU'
       */
      for (i = 0; i < 3; i++) {
        AUAV_V3_TestSensors_B.Reshape1[i] = 0.0F;
        AUAV_V3_TestSensors_B.Reshape1[i] +=
          AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0];
    5b82:	6e ad 90    	mov.w     [w14+220], w10
    5b84:	fe ad 90    	mov.w     [w14+222], w11
        AUAV_V3_TestSensors_B.Reshape1[i] +=
          AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1];
    5b86:	0e b6 90    	mov.w     [w14+224], w12
    5b88:	9e b6 90    	mov.w     [w14+226], w13
        AUAV_V3_TestSensors_B.Reshape1[i] +=
          AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0[2];
    5b8a:	2e b2 90    	mov.w     [w14+228], w4
    5b8c:	be b2 90    	mov.w     [w14+230], w5
    5b8e:	14 af 99    	mov.w     w4, [w14+466]
    5b90:	25 af 99    	mov.w     w5, [w14+468]
    5b92:	c5 73 2c    	mov.w     #0xc73c, w5
    5b94:	55 af 99    	mov.w     w5, [w14+474]
    5b96:	6c 80 42    	add.w     w5, #0xc, w0
    5b98:	10 b7 99    	mov.w     w0, [w14+482]
    5b9a:	ec 00 40    	add.w     w0, #0xc, w1
    5b9c:	51 b7 99    	mov.w     w1, [w14+490]
    5b9e:	a2 88 21    	mov.w     #0x188a, w2
    5ba0:	72 af 99    	mov.w     w2, [w14+478]
    5ba2:	00 04 eb    	clr.w     w8
    5ba4:	58 a7 99    	mov.w     w8, [w14+458]

00005ba6 <.L0>:
    5ba6:	5e aa 91    	mov.w     [w14+474], w4
    5ba8:	54 01 be    	mov.d     [++w4], w2
    5baa:	54 af 99    	mov.w     w4, [w14+474]
    5bac:	0a 00 be    	mov.d     w10, w0
    5bae:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5bb0:	00 00 00 

00005bb2 <.L0>:
    5bb2:	60 11 b8    	mul.uu    w2, #0x0, w2
    5bb4:	92 14 02    	call      0x1492 <___addsf3>
    5bb6:	00 00 00 
    5bb8:	00 04 be    	mov.d     w0, w8

00005bba <.L0>:
    5bba:	9e b2 91    	mov.w     [w14+482], w5
    5bbc:	55 01 be    	mov.d     [++w5], w2
    5bbe:	15 b7 99    	mov.w     w5, [w14+482]
    5bc0:	0c 00 be    	mov.d     w12, w0
    5bc2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5bc4:	00 00 00 
    5bc6:	00 01 be    	mov.d     w0, w2

00005bc8 <.L0>:
    5bc8:	08 00 be    	mov.d     w8, w0
    5bca:	92 14 02    	call      0x1492 <___addsf3>
    5bcc:	00 00 00 
    5bce:	00 04 be    	mov.d     w0, w8

00005bd0 <.L0>:
    5bd0:	5e b0 91    	mov.w     [w14+490], w0
    5bd2:	50 01 be    	mov.d     [++w0], w2
    5bd4:	50 b7 99    	mov.w     w0, [w14+490]
    5bd6:	1e a8 91    	mov.w     [w14+466], w0
    5bd8:	ae a8 91    	mov.w     [w14+468], w1
    5bda:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5bdc:	00 00 00 
    5bde:	00 01 be    	mov.d     w0, w2

00005be0 <.L0>:
    5be0:	08 00 be    	mov.d     w8, w0
    5be2:	92 14 02    	call      0x1492 <___addsf3>
    5be4:	00 00 00 
    5be6:	7e a9 91    	mov.w     [w14+478], w2
    5be8:	00 a9 be    	mov.d     w0, [++w2]
    5bea:	72 af 99    	mov.w     w2, [w14+478]

00005bec <.L0>:
    5bec:	de a1 91    	mov.w     [w14+458], w3
    5bee:	83 01 e8    	inc.w     w3, w3
    5bf0:	53 a7 99    	mov.w     w3, [w14+458]
    5bf2:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    5bf4:	d8 ff 3a    	bra       NZ, 0x5ba6 <.L0> <.L141>

00005bf6 <.L0>:
      }

      /* End of Reshape: '<S446>/Reshape1' */
    }

    /* End of Outputs for SubSystem: '<S188>/Compute Mobile Location' */

    /* MATLAB Function: '<S188>/Zero out Z1' incorporates:
     *  Gain: '<S447>/Deg2R'
     */
    AUAV_V3_TestSens_ZerooutZ1(AUAV_V3_TestSensors_B.Reshape1,
    5bf6:	c1 d2 21    	mov.w     #0x1d2c, w1
    5bf8:	e0 88 21    	mov.w     #0x188e, w0
    5bfa:	e5 f9 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00005bfc <.L0>:
      &AUAV_V3_TestSensors_B.sf_ZerooutZ1_a);

    /* Sum: '<S188>/Subtract' */
    rtb_Product3_j0[0] = AUAV_V3_TestSensors_B.sf_ZerooutZ1_a.P[0] -
    5bfc:	62 e1 80    	mov.w     0x1c2c, w2
    5bfe:	73 e1 80    	mov.w     0x1c2e, w3
    5c00:	60 e9 80    	mov.w     0x1d2c, w0
    5c02:	71 e9 80    	mov.w     0x1d2e, w1
    5c04:	90 14 02    	call      0x1490 <___subsf3>
    5c06:	00 00 00 
    5c08:	00 04 be    	mov.d     w0, w8
    5c0a:	00 8f be    	mov.d     w0, [w14]

00005c0c <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    rtb_Product3_j0[1] = AUAV_V3_TestSensors_B.sf_ZerooutZ1_a.P[1] -
    5c0c:	82 e1 80    	mov.w     0x1c30, w2
    5c0e:	93 e1 80    	mov.w     0x1c32, w3
    5c10:	80 e9 80    	mov.w     0x1d30, w0
    5c12:	91 e9 80    	mov.w     0x1d32, w1
    5c14:	90 14 02    	call      0x1490 <___subsf3>
    5c16:	00 00 00 
    5c18:	00 05 be    	mov.d     w0, w10
    5c1a:	20 07 98    	mov.w     w0, [w14+4]
    5c1c:	31 07 98    	mov.w     w1, [w14+6]

00005c1e <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    rtb_Product3_j0[2] = AUAV_V3_TestSensors_B.sf_ZerooutZ1_a.P[2] -
    5c1e:	a2 e1 80    	mov.w     0x1c34, w2
    5c20:	b3 e1 80    	mov.w     0x1c36, w3
    5c22:	a0 e9 80    	mov.w     0x1d34, w0
    5c24:	b1 e9 80    	mov.w     0x1d36, w1
    5c26:	90 14 02    	call      0x1490 <___subsf3>
    5c28:	00 00 00 
    5c2a:	00 06 be    	mov.d     w0, w12
    5c2c:	40 07 98    	mov.w     w0, [w14+8]
    5c2e:	51 07 98    	mov.w     w1, [w14+10]

00005c30 <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];

    /* DiscreteIntegrator: '<S443>/Discrete-Time Integrator' */
    if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_IC_LOADI != 0) {
    5c30:	e0 ff 21    	mov.w     #0x1ffe, w0
    5c32:	10 04 e0    	cp0.b     [w0]
    5c34:	06 00 32    	bra       Z, 0x5c42 <.L142>
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[0] =
    5c36:	08 f3 88    	mov.w     w8, 0x1e60
    5c38:	19 f3 88    	mov.w     w9, 0x1e62
        rtb_Product3_j0[0];
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[1] =
    5c3a:	2a f3 88    	mov.w     w10, 0x1e64
    5c3c:	3b f3 88    	mov.w     w11, 0x1e66
        rtb_Product3_j0[1];
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[2] =
    5c3e:	4c f3 88    	mov.w     w12, 0x1e68
    5c40:	5d f3 88    	mov.w     w13, 0x1e6a

00005c42 <.L142>:
        rtb_Product3_j0[2];
    }

    /* Sum: '<S443>/Sum' incorporates:
     *  DiscreteIntegrator: '<S443>/Discrete-Time Integrator'
     */
    rtb_Product2_c[0] = rtb_Product3_j0[0] -
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[0];
    5c42:	05 e6 21    	mov.w     #0x1e60, w5
    5c44:	15 02 be    	mov.d     [w5], w4
    5c46:	04 bf 99    	mov.w     w4, [w14+496]
    5c48:	15 bf 99    	mov.w     w5, [w14+498]

00005c4a <.L0>:
    5c4a:	04 01 be    	mov.d     w4, w2
    5c4c:	08 00 be    	mov.d     w8, w0
    5c4e:	90 14 02    	call      0x1490 <___subsf3>
    5c50:	00 00 00 
    5c52:	50 af 99    	mov.w     w0, [w14+474]
    5c54:	61 af 99    	mov.w     w1, [w14+476]
    5c56:	00 1f 98    	mov.w     w0, [w14+48]
    5c58:	11 1f 98    	mov.w     w1, [w14+50]

00005c5a <.L0>:
    rtb_Product2_c[1] = rtb_Product3_j0[1] -
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[1];
    5c5a:	45 e6 21    	mov.w     #0x1e64, w5
    5c5c:	15 02 be    	mov.d     [w5], w4
    5c5e:	24 bf 99    	mov.w     w4, [w14+500]
    5c60:	35 bf 99    	mov.w     w5, [w14+502]

00005c62 <.L0>:
    5c62:	04 01 be    	mov.d     w4, w2
    5c64:	0a 00 be    	mov.d     w10, w0
    5c66:	90 14 02    	call      0x1490 <___subsf3>
    5c68:	00 00 00 
    5c6a:	00 04 be    	mov.d     w0, w8
    5c6c:	20 1f 98    	mov.w     w0, [w14+52]
    5c6e:	31 1f 98    	mov.w     w1, [w14+54]

00005c70 <.L0>:
    rtb_Product2_c[2] = rtb_Product3_j0[2] -
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[2];
    5c70:	81 e6 21    	mov.w     #0x1e68, w1
    5c72:	11 00 be    	mov.d     [w1], w0
    5c74:	40 bf 99    	mov.w     w0, [w14+504]
    5c76:	51 bf 99    	mov.w     w1, [w14+506]

00005c78 <.L0>:
    5c78:	00 01 be    	mov.d     w0, w2
    5c7a:	0c 00 be    	mov.d     w12, w0
    5c7c:	90 14 02    	call      0x1490 <___subsf3>
    5c7e:	00 00 00 
    5c80:	00 05 be    	mov.d     w0, w10
    5c82:	40 1f 98    	mov.w     w0, [w14+56]
    5c84:	51 1f 98    	mov.w     w1, [w14+58]

00005c86 <.L0>:

    /* Sum: '<S443>/Sum1' incorporates:
     *  DiscreteIntegrator: '<S443>/Discrete-Time Integrator'
     *  Gain: '<S443>/Gain1'
     */
    AUAV_V3_TestSensors_B.Merge_o[0] = 3.0F * rtb_Product2_c[0] +
    5c86:	02 00 20    	mov.w     #0x0, w2
    5c88:	03 04 24    	mov.w     #0x4040, w3
    5c8a:	5e a8 91    	mov.w     [w14+474], w0
    5c8c:	ee a8 91    	mov.w     [w14+476], w1
    5c8e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5c90:	00 00 00 
    5c92:	00 01 be    	mov.d     w0, w2
    5c94:	0e b8 91    	mov.w     [w14+496], w0
    5c96:	9e b8 91    	mov.w     [w14+498], w1
    5c98:	92 14 02    	call      0x1492 <___addsf3>
    5c9a:	00 00 00 
    5c9c:	50 bc 88    	mov.w     w0, 0x178a
    5c9e:	61 bc 88    	mov.w     w1, 0x178c

00005ca0 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[0];
    AUAV_V3_TestSensors_B.Merge_o[1] = 3.0F * rtb_Product2_c[1] +
    5ca0:	02 00 20    	mov.w     #0x0, w2
    5ca2:	03 04 24    	mov.w     #0x4040, w3
    5ca4:	08 00 be    	mov.d     w8, w0
    5ca6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ca8:	00 00 00 
    5caa:	00 01 be    	mov.d     w0, w2
    5cac:	2e b8 91    	mov.w     [w14+500], w0
    5cae:	be b8 91    	mov.w     [w14+502], w1
    5cb0:	92 14 02    	call      0x1492 <___addsf3>
    5cb2:	00 00 00 
    5cb4:	70 bc 88    	mov.w     w0, 0x178e
    5cb6:	81 bc 88    	mov.w     w1, 0x1790

00005cb8 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[1];
    AUAV_V3_TestSensors_B.Merge_o[2] = 3.0F * rtb_Product2_c[2] +
    5cb8:	02 00 20    	mov.w     #0x0, w2
    5cba:	03 04 24    	mov.w     #0x4040, w3
    5cbc:	0a 00 be    	mov.d     w10, w0
    5cbe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5cc0:	00 00 00 
    5cc2:	00 01 be    	mov.d     w0, w2
    5cc4:	4e b8 91    	mov.w     [w14+504], w0
    5cc6:	de b8 91    	mov.w     [w14+506], w1
    5cc8:	92 14 02    	call      0x1492 <___addsf3>
    5cca:	00 00 00 
    5ccc:	90 bc 88    	mov.w     w0, 0x1792
    5cce:	a1 bc 88    	mov.w     w1, 0x1794

00005cd0 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[2];

    /* MATLAB Function: '<S452>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(rtb_Product3_j0,
    5cd0:	c1 d3 21    	mov.w     #0x1d3c, w1
    5cd2:	0e 00 78    	mov.w     w14, w0
    5cd4:	52 f9 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00005cd6 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_bs);

    /* MATLAB Function: '<S453>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_bs.xDoty,
    5cd6:	82 d3 21    	mov.w     #0x1d38, w2
    5cd8:	e0 e9 80    	mov.w     0x1d3c, w0
    5cda:	f1 e9 80    	mov.w     0x1d3e, w1
    5cdc:	3c f9 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00005cde <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_la);

    /* S-Function (MCHP_C_function_Call): '<S453>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_g = mySqrt(
    5cde:	c0 e9 80    	mov.w     0x1d38, w0
    5ce0:	d1 e9 80    	mov.w     0x1d3a, w1
    5ce2:	16 10 02    	call      0x11016 <_mySqrt>
    5ce4:	01 00 00 
    5ce6:	50 c4 88    	mov.w     w0, 0x188a
    5ce8:	61 c4 88    	mov.w     w1, 0x188c

00005cea <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_la.zpVal
      );

    /* SignalConversion: '<S456>/Numerical Unity' */
    AUAV_V3_TestSensors_B.Merge2 =
    5cea:	30 bd 88    	mov.w     w0, 0x17a6
    5cec:	41 bd 88    	mov.w     w1, 0x17a8
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_g;
    AUAV_V3_TestSensors_B.Merge1 = mlMidLevelCommands.hCommand;
    5cee:	52 89 80    	mov.w     0x112a, w2
    5cf0:	63 89 80    	mov.w     0x112c, w3
    5cf2:	b2 bd 88    	mov.w     w2, 0x17b6
    5cf4:	c3 bd 88    	mov.w     w3, 0x17b8
    AUAV_V3_TestSensors_B.Merge3 = 0U;
    5cf6:	00 40 eb    	clr.b     w0
    5cf8:	91 a9 21    	mov.w     #0x1a99, w1
    5cfa:	80 48 78    	mov.b     w0, [w1]
    AUAV_V3_TestSensors_B.Merge4 = 0U;
    5cfc:	81 00 e8    	inc.w     w1, w1
    5cfe:	80 48 78    	mov.b     w0, [w1]

    /* Update for DiscreteIntegrator: '<S443>/Discrete-Time Integrator' incorporates:
     *  Constant: '<S188>/RTB'
     *  Constant: '<S188>/RTB1'
     *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
     *  Inport: '<S188>/MidLvl h_c'
     */
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_IC_LOADI = 0U;
    5d00:	e1 ff 21    	mov.w     #0x1ffe, w1
    5d02:	80 48 78    	mov.b     w0, [w1]

00005d04 <.L0>:
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[0] += 0.01F *
    5d04:	a2 70 2d    	mov.w     #0xd70a, w2
    5d06:	33 c2 23    	mov.w     #0x3c23, w3
    5d08:	0e 18 90    	mov.w     [w14+48], w0
    5d0a:	9e 18 90    	mov.w     [w14+50], w1
    5d0c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d0e:	00 00 00 
    5d10:	00 01 be    	mov.d     w0, w2
    5d12:	04 e6 21    	mov.w     #0x1e60, w4
    5d14:	14 00 be    	mov.d     [w4], w0
    5d16:	92 14 02    	call      0x1492 <___addsf3>
    5d18:	00 00 00 
    5d1a:	05 e6 21    	mov.w     #0x1e60, w5
    5d1c:	80 8a be    	mov.d     w0, [w5]

00005d1e <.L0>:
      rtb_Product2_c[0];
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[1] += 0.01F *
    5d1e:	a2 70 2d    	mov.w     #0xd70a, w2
    5d20:	33 c2 23    	mov.w     #0x3c23, w3
    5d22:	2e 18 90    	mov.w     [w14+52], w0
    5d24:	be 18 90    	mov.w     [w14+54], w1
    5d26:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d28:	00 00 00 
    5d2a:	00 01 be    	mov.d     w0, w2
    5d2c:	44 e6 21    	mov.w     #0x1e64, w4
    5d2e:	14 00 be    	mov.d     [w4], w0
    5d30:	92 14 02    	call      0x1492 <___addsf3>
    5d32:	00 00 00 
    5d34:	45 e6 21    	mov.w     #0x1e64, w5
    5d36:	80 8a be    	mov.d     w0, [w5]

00005d38 <.L0>:
      rtb_Product2_c[1];
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_DSTATE[2] += 0.01F *
    5d38:	a2 70 2d    	mov.w     #0xd70a, w2
    5d3a:	33 c2 23    	mov.w     #0x3c23, w3
    5d3c:	4e 18 90    	mov.w     [w14+56], w0
    5d3e:	de 18 90    	mov.w     [w14+58], w1
    5d40:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d42:	00 00 00 
    5d44:	00 01 be    	mov.d     w0, w2
    5d46:	84 e6 21    	mov.w     #0x1e68, w4
    5d48:	14 00 be    	mov.d     [w4], w0
    5d4a:	92 14 02    	call      0x1492 <___addsf3>
    5d4c:	00 00 00 
    5d4e:	85 e6 21    	mov.w     #0x1e68, w5
    5d50:	80 8a be    	mov.d     w0, [w5]
    5d52:	39 0a 37    	bra       0x71c6 <.L0> <.L143>

00005d54 <.L0>:
    5d54:	6e d8 93    	mov.b     [w14+478], w0
      rtb_Product2_c[2];

    /* End of Outputs for SubSystem: '<S180>/RTB//Follow Mobile Navigation' */
  } else if (rtb_Compare_j == 3) {
    5d56:	e3 4f 50    	sub.b     w0, #0x3, [w15]
    5d58:	cf 06 3a    	bra       NZ, 0x6af8 <.L0> <.L144>

00005d5a <.L0>:
    /* Outputs for IfAction SubSystem: '<S180>/Normal WP  Navigation' incorporates:
     *  ActionPort: '<S187>/Action Port'
     */
    /* Product: '<S187>/Product' incorporates:
     *  DataStoreRead: '<Root>/PAR_NAV_L2_BASE PAR_NAV_PRETURN_K PAR_NAV_SSCOMP_ON'
     */
    rtb_Product_lf = mlParamInterface.param[19] *
    5d5a:	32 95 80    	mov.w     0x12a6, w2
    5d5c:	43 95 80    	mov.w     0x12a8, w3
    5d5e:	08 00 be    	mov.d     w8, w0
    5d60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d62:	00 00 00 
    5d64:	50 af 99    	mov.w     w0, [w14+474]
    5d66:	61 af 99    	mov.w     w1, [w14+476]

00005d68 <.L0>:
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116;

    /* Outputs for Enabled SubSystem: '<S187>/On WP Enable' incorporates:
     *  EnablePort: '<S304>/Enable'
     */
    /* Gain: '<S405>/Deg2R' */
    rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_0;
    5d68:	52 a3 2f    	mov.w     #0xfa35, w2
    5d6a:	e3 c8 23    	mov.w     #0x3c8e, w3
    5d6c:	0a 00 be    	mov.d     w10, w0
    5d6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d70:	00 00 00 
    5d72:	50 b7 99    	mov.w     w0, [w14+490]
    5d74:	61 b7 99    	mov.w     w1, [w14+492]

00005d76 <.L0>:
    rtb_Product3_bo = 0.0174532924F * rtb_IC4_idx_1;
    5d76:	52 a3 2f    	mov.w     #0xfa35, w2
    5d78:	e3 c8 23    	mov.w     #0x3c8e, w3
    5d7a:	0c 00 be    	mov.d     w12, w0
    5d7c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d7e:	00 00 00 
    5d80:	00 06 be    	mov.d     w0, w12

00005d82 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S383>/Get WP Coord navsupport.c [updated 5.1.16]' */
    getWP(
    5d82:	a1 83 21    	mov.w     #0x183a, w1
    5d84:	10 c0 b3    	mov.b     #0x1, w0
    5d86:	ae f3 02    	call      0xf3ae <_getWP>
    5d88:	00 00 00 

00005d8a <.L0>:
          ((uint8_T)1U)
          , &AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated511[0]
          );

    /* Gain: '<S406>/Deg2R' incorporates:
     *  Constant: '<S381>/Constant'
     */
    rtb_cosphi = 0.0174532924F *
    5d8a:	52 a3 2f    	mov.w     #0xfa35, w2
    5d8c:	e3 c8 23    	mov.w     #0x3c8e, w3
    5d8e:	d0 c1 80    	mov.w     0x183a, w0
    5d90:	e1 c1 80    	mov.w     0x183c, w1
    5d92:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5d94:	00 00 00 
    5d96:	00 04 be    	mov.d     w0, w8

00005d98 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated511[0];

    /* Trigonometry: '<S406>/sin(phi)' */
    rtb_Ze_b = (real32_T)sin(rtb_cosphi);
    5d98:	b6 1d 02    	call      0x1db6 <_sinf>
    5d9a:	00 00 00 
    5d9c:	00 01 be    	mov.d     w0, w2
    5d9e:	70 af 99    	mov.w     w0, [w14+478]
    5da0:	01 b7 99    	mov.w     w1, [w14+480]

00005da2 <.L0>:

    /* Sum: '<S406>/Sum1' incorporates:
     *  Constant: '<S406>/const'
     *  Product: '<S406>/Product1'
     *  Product: '<S406>/sin(phi)^2'
     */
    rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    5da2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5da4:	00 00 00 
    5da6:	02 b8 25    	mov.w     #0x5b80, w2
    5da8:	b3 bd 23    	mov.w     #0x3bdb, w3
    5daa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5dac:	00 00 00 
    5dae:	00 01 be    	mov.d     w0, w2
    5db0:	00 00 20    	mov.w     #0x0, w0
    5db2:	01 f8 23    	mov.w     #0x3f80, w1
    5db4:	90 14 02    	call      0x1490 <___subsf3>
    5db6:	00 00 00 
    5db8:	00 05 be    	mov.d     w0, w10

00005dba <.L0>:

    /* Fcn: '<S406>/f' */
    if (rtb_Sum1_mzp < 0.0F) {
    5dba:	60 11 b8    	mul.uu    w2, #0x0, w2
    5dbc:	8c 18 02    	call      0x188c <___eqsf2>
    5dbe:	00 00 00 
    5dc0:	00 00 e0    	cp0.w     w0
    5dc2:	07 00 3d    	bra       GE, 0x5dd2 <.L0> <.L0> <.L602>

00005dc4 <.L0>:
      rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    5dc4:	0a 00 be    	mov.d     w10, w0
    5dc6:	01 f0 a2    	btg.w     w1, #0xf
    5dc8:	ba 1d 02    	call      0x1dba <_sqrtf>
    5dca:	00 00 00 
    5dcc:	00 01 be    	mov.d     w0, w2
    5dce:	03 f0 a2    	btg.w     w3, #0xf
    5dd0:	04 00 37    	bra       0x5dda <.L0> <.L0> <.L147>

00005dd2 <.L0>:
    } else {
      rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    5dd2:	0a 00 be    	mov.d     w10, w0
    5dd4:	ba 1d 02    	call      0x1dba <_sqrtf>
    5dd6:	00 00 00 
    5dd8:	00 01 be    	mov.d     w0, w2

00005dda <.L0>:
    }

    /* End of Fcn: '<S406>/f' */

    /* Product: '<S406>/Rh' incorporates:
     *  Constant: '<S406>/Re=equatorial radius'
     */
    rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    5dda:	20 53 2a    	mov.w     #0xa532, w0
    5ddc:	21 ac 24    	mov.w     #0x4ac2, w1
    5dde:	26 17 02    	call      0x1726 <___divsf3>
    5de0:	00 00 00 
    5de2:	10 a7 99    	mov.w     w0, [w14+450]
    5de4:	21 a7 99    	mov.w     w1, [w14+452]

00005de6 <.L0>:

    /* Sum: '<S406>/Sum2' */
    rtb_RhhcosphicoslambXe =
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated511[2] + rtb_Sum1_mzp;

    /* Trigonometry: '<S406>/cos(phi)' */
    rtb_cosphi = (real32_T)cos(rtb_cosphi);
    5de6:	08 00 be    	mov.d     w8, w0
    5de8:	22 17 02    	call      0x1722 <_cosf>
    5dea:	00 00 00 
    5dec:	00 05 be    	mov.d     w0, w10

00005dee <.L0>:

    /* Gain: '<S406>/Deg2R1' */
    rtb_RhhcosphisinlambYe = 0.0174532924F *
    5dee:	52 a3 2f    	mov.w     #0xfa35, w2
    5df0:	e3 c8 23    	mov.w     #0x3c8e, w3
    5df2:	f0 c1 80    	mov.w     0x183e, w0
    5df4:	01 c2 80    	mov.w     0x1840, w1
    5df6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5df8:	00 00 00 
    5dfa:	00 04 be    	mov.d     w0, w8

00005dfc <.L0>:
    5dfc:	1e a1 91    	mov.w     [w14+450], w2
    5dfe:	ae a1 91    	mov.w     [w14+452], w3
    5e00:	10 c2 80    	mov.w     0x1842, w0
    5e02:	21 c2 80    	mov.w     0x1844, w1
    5e04:	92 14 02    	call      0x1492 <___addsf3>
    5e06:	00 00 00 

00005e08 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated511[1];

    /* Product: '<S406>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
     *  Trigonometry: '<S406>/cos(lamb)'
     */
    rtb_Deg2R1 = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)cos
    5e08:	0a 01 be    	mov.d     w10, w2
    5e0a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5e0c:	00 00 00 
    5e0e:	00 05 be    	mov.d     w0, w10
    5e10:	08 00 be    	mov.d     w8, w0
    5e12:	22 17 02    	call      0x1722 <_cosf>
    5e14:	00 00 00 
    5e16:	00 01 be    	mov.d     w0, w2
    5e18:	0a 00 be    	mov.d     w10, w0
    5e1a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5e1c:	00 00 00 
    5e1e:	10 9f 99    	mov.w     w0, [w14+434]
    5e20:	21 9f 99    	mov.w     w1, [w14+436]

00005e22 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S406>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
     *  Trigonometry: '<S406>/sin(lamb)'
     */
    rtb_RhhcosphicoslambXe = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)sin
    5e22:	08 00 be    	mov.d     w8, w0
    5e24:	b6 1d 02    	call      0x1db6 <_sinf>
    5e26:	00 00 00 
    5e28:	50 a7 99    	mov.w     w0, [w14+458]
    5e2a:	61 a7 99    	mov.w     w1, [w14+460]

00005e2c <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S406>/Ze' incorporates:
     *  Product: '<S406>/Rh(1-e^2)'
     *  Sum: '<S406>/Sum4'
     */
    rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp +
    5e2c:	92 94 24    	mov.w     #0x4949, w2
    5e2e:	e3 f7 23    	mov.w     #0x3f7e, w3
    5e30:	1e a0 91    	mov.w     [w14+450], w0
    5e32:	ae a0 91    	mov.w     [w14+452], w1
    5e34:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5e36:	00 00 00 
    5e38:	00 01 be    	mov.d     w0, w2
    5e3a:	10 c2 80    	mov.w     0x1842, w0
    5e3c:	21 c2 80    	mov.w     0x1844, w1
    5e3e:	92 14 02    	call      0x1492 <___addsf3>
    5e40:	00 00 00 
    5e42:	7e a9 91    	mov.w     [w14+478], w2
    5e44:	8e b1 91    	mov.w     [w14+480], w3
    5e46:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5e48:	00 00 00 
    5e4a:	00 04 be    	mov.d     w0, w8

00005e4c <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated511[2];

    /* SignalConversion: '<S405>/TmpSignal ConversionAtProduct1Inport1' incorporates:
     *  Fcn: '<S408>/11'
     *  Fcn: '<S408>/12'
     *  Fcn: '<S408>/13'
     *  Fcn: '<S408>/21'
     *  Fcn: '<S408>/22'
     *  Fcn: '<S408>/23'
     *  Fcn: '<S408>/31'
     *  Fcn: '<S408>/32'
     *  Fcn: '<S408>/33'
     */
    tmp[0] = (real32_T)cos(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    5e4c:	5e b0 91    	mov.w     [w14+490], w0
    5e4e:	ee b0 91    	mov.w     [w14+492], w1
    5e50:	22 17 02    	call      0x1722 <_cosf>
    5e52:	00 00 00 
    5e54:	30 9f 99    	mov.w     w0, [w14+438]
    5e56:	41 9f 99    	mov.w     w1, [w14+440]
    5e58:	0c 00 be    	mov.d     w12, w0
    5e5a:	22 17 02    	call      0x1722 <_cosf>
    5e5c:	00 00 00 
    5e5e:	70 97 99    	mov.w     w0, [w14+430]
    5e60:	01 9f 99    	mov.w     w1, [w14+432]
    5e62:	00 01 be    	mov.d     w0, w2
    5e64:	3e 98 91    	mov.w     [w14+438], w0
    5e66:	ce 98 91    	mov.w     [w14+440], w1
    5e68:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5e6a:	00 00 00 
    5e6c:	20 3f 99    	mov.w     w0, [w14+372]
    5e6e:	31 3f 99    	mov.w     w1, [w14+374]
    5e70:	40 9f 98    	mov.w     w0, [w14+184]
    5e72:	51 9f 98    	mov.w     w1, [w14+186]

00005e74 <.L0>:
    tmp[1] = -(real32_T)sin(rtb_Deg2R_h_idx_0);
    5e74:	5e b0 91    	mov.w     [w14+490], w0
    5e76:	ee b0 91    	mov.w     [w14+492], w1
    5e78:	b6 1d 02    	call      0x1db6 <_sinf>
    5e7a:	00 00 00 
    5e7c:	00 02 be    	mov.d     w0, w4
    5e7e:	70 af 99    	mov.w     w0, [w14+478]
    5e80:	01 b7 99    	mov.w     w1, [w14+480]
    5e82:	05 f0 a2    	btg.w     w5, #0xf
    5e84:	44 3f 99    	mov.w     w4, [w14+376]
    5e86:	55 3f 99    	mov.w     w5, [w14+378]
    5e88:	64 9f 98    	mov.w     w4, [w14+188]
    5e8a:	75 9f 98    	mov.w     w5, [w14+190]

00005e8c <.L0>:
    tmp[2] = -(real32_T)sin(rtb_Product3_bo) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    5e8c:	0c 00 be    	mov.d     w12, w0
    5e8e:	b6 1d 02    	call      0x1db6 <_sinf>
    5e90:	00 00 00 
    5e92:	00 01 be    	mov.d     w0, w2
    5e94:	70 8f 99    	mov.w     w0, [w14+414]
    5e96:	01 97 99    	mov.w     w1, [w14+416]
    5e98:	03 f0 a2    	btg.w     w3, #0xf
    5e9a:	3e 98 91    	mov.w     [w14+438], w0
    5e9c:	ce 98 91    	mov.w     [w14+440], w1
    5e9e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ea0:	00 00 00 
    5ea2:	00 3f 99    	mov.w     w0, [w14+368]
    5ea4:	11 3f 99    	mov.w     w1, [w14+370]
    5ea6:	00 a7 98    	mov.w     w0, [w14+192]
    5ea8:	11 a7 98    	mov.w     w1, [w14+194]

00005eaa <.L0>:
    tmp[3] = (real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    5eaa:	7e a9 91    	mov.w     [w14+478], w2
    5eac:	8e b1 91    	mov.w     [w14+480], w3
    5eae:	7e 90 91    	mov.w     [w14+430], w0
    5eb0:	8e 98 91    	mov.w     [w14+432], w1
    5eb2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5eb4:	00 00 00 
    5eb6:	60 37 99    	mov.w     w0, [w14+364]
    5eb8:	71 37 99    	mov.w     w1, [w14+366]
    5eba:	20 a7 98    	mov.w     w0, [w14+196]
    5ebc:	31 a7 98    	mov.w     w1, [w14+198]

00005ebe <.L0>:
    tmp[4] = (real32_T)cos(rtb_Deg2R_h_idx_0);
    5ebe:	3e 9a 91    	mov.w     [w14+438], w4
    5ec0:	ce 9a 91    	mov.w     [w14+440], w5
    5ec2:	44 a7 98    	mov.w     w4, [w14+200]
    5ec4:	55 a7 98    	mov.w     w5, [w14+202]

00005ec6 <.L0>:
    tmp[5] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)sin(rtb_Product3_bo);
    5ec6:	7e 89 91    	mov.w     [w14+414], w2
    5ec8:	8e 91 91    	mov.w     [w14+416], w3
    5eca:	4e 38 91    	mov.w     [w14+376], w0
    5ecc:	de 38 91    	mov.w     [w14+378], w1
    5ece:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ed0:	00 00 00 
    5ed2:	40 37 99    	mov.w     w0, [w14+360]
    5ed4:	51 37 99    	mov.w     w1, [w14+362]
    5ed6:	60 a7 98    	mov.w     w0, [w14+204]
    5ed8:	71 a7 98    	mov.w     w1, [w14+206]

00005eda <.L0>:
    tmp[6] = (real32_T)sin(rtb_Product3_bo);
    5eda:	7e 8a 91    	mov.w     [w14+414], w4
    5edc:	8e 92 91    	mov.w     [w14+416], w5
    5ede:	04 af 98    	mov.w     w4, [w14+208]
    5ee0:	15 af 98    	mov.w     w5, [w14+210]

00005ee2 <.L0>:
    tmp[7] = 0.0F;
    5ee2:	60 00 b8    	mul.uu    w0, #0x0, w0
    5ee4:	20 af 98    	mov.w     w0, [w14+212]
    5ee6:	31 af 98    	mov.w     w1, [w14+214]

00005ee8 <.L0>:
    tmp[8] = (real32_T)cos(rtb_Product3_bo);
    5ee8:	7e 90 91    	mov.w     [w14+430], w0
    5eea:	8e 98 91    	mov.w     [w14+432], w1
    5eec:	40 af 98    	mov.w     w0, [w14+216]
    5eee:	51 af 98    	mov.w     w1, [w14+218]

00005ef0 <.L0>:

    /* Sum: '<S403>/Sum1' incorporates:
     *  Product: '<S405>/Product1'
     */
    rtb_Deg2R1 -= AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    5ef0:	72 bf 80    	mov.w     0x17ee, w2
    5ef2:	83 bf 80    	mov.w     0x17f0, w3
    5ef4:	1e 98 91    	mov.w     [w14+434], w0
    5ef6:	ae 98 91    	mov.w     [w14+436], w1
    5ef8:	90 14 02    	call      0x1490 <___subsf3>
    5efa:	00 00 00 
    5efc:	10 9f 99    	mov.w     w0, [w14+434]
    5efe:	21 9f 99    	mov.w     w1, [w14+436]

00005f00 <.L0>:
    5f00:	5e a1 91    	mov.w     [w14+458], w2
    5f02:	ee a1 91    	mov.w     [w14+460], w3
    5f04:	0a 00 be    	mov.d     w10, w0
    5f06:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5f08:	00 00 00 

00005f0a <.L0>:
    rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe -
    5f0a:	92 bf 80    	mov.w     0x17f2, w2
    5f0c:	a3 bf 80    	mov.w     0x17f4, w3
    5f0e:	90 14 02    	call      0x1490 <___subsf3>
    5f10:	00 00 00 
    5f12:	50 97 99    	mov.w     w0, [w14+426]
    5f14:	61 97 99    	mov.w     w1, [w14+428]

00005f16 <.L0>:
      AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    rtb_Sum1_mzp = rtb_Ze_b - AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    5f16:	b2 bf 80    	mov.w     0x17f6, w2
    5f18:	c3 bf 80    	mov.w     0x17f8, w3
    5f1a:	08 00 be    	mov.d     w8, w0
    5f1c:	90 14 02    	call      0x1490 <___subsf3>
    5f1e:	00 00 00 
    5f20:	00 06 be    	mov.d     w0, w12
    5f22:	85 0b 20    	mov.w     #0xb8, w5
    5f24:	8e 82 42    	add.w     w5, w14, w5
    5f26:	f4 82 42    	add.w     w5, #0x14, w5
    5f28:	55 a7 99    	mov.w     w5, [w14+458]
    5f2a:	80 0b 20    	mov.w     #0xb8, w0
    5f2c:	0e 00 40    	add.w     w0, w14, w0
    5f2e:	68 00 40    	add.w     w0, #0x8, w0
    5f30:	50 b7 99    	mov.w     w0, [w14+490]
    5f32:	81 0b 20    	mov.w     #0xb8, w1
    5f34:	8e 80 40    	add.w     w1, w14, w1
    5f36:	e4 80 50    	sub.w     w1, #0x4, w1
    5f38:	11 a7 99    	mov.w     w1, [w14+450]
    5f3a:	82 0d 20    	mov.w     #0xd8, w2
    5f3c:	02 01 47    	add.w     w14, w2, w2
    5f3e:	72 af 99    	mov.w     w2, [w14+478]
    5f40:	82 01 78    	mov.w     w2, w3
    5f42:	13 af 99    	mov.w     w3, [w14+466]

00005f44 <.L0>:

    /* Product: '<S405>/Product1' incorporates:
     *  Gain: '<S403>/UEN 2 NEU'
     */
    for (i = 0; i < 3; i++) {
    5f44:	00 04 eb    	clr.w     w8
    5f46:	48 8f 99    	mov.w     w8, [w14+408]

00005f48 <.L0>:
      tmp_0[i] = tmp[i + 6] * rtb_Sum1_mzp + (tmp[i + 3] *
    5f48:	5e a2 91    	mov.w     [w14+458], w4
    5f4a:	54 01 be    	mov.d     [++w4], w2
    5f4c:	54 a7 99    	mov.w     w4, [w14+458]
    5f4e:	0c 00 be    	mov.d     w12, w0
    5f50:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5f52:	00 00 00 
    5f54:	00 05 be    	mov.d     w0, w10
    5f56:	de b2 91    	mov.w     [w14+490], w5
    5f58:	55 01 be    	mov.d     [++w5], w2
    5f5a:	55 b7 99    	mov.w     w5, [w14+490]
    5f5c:	5e 90 91    	mov.w     [w14+426], w0
    5f5e:	ee 90 91    	mov.w     [w14+428], w1
    5f60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5f62:	00 00 00 
    5f64:	00 04 be    	mov.d     w0, w8

00005f66 <.L0>:
        rtb_RhhcosphisinlambYe + tmp[i] * rtb_Deg2R1);
    5f66:	1e a0 91    	mov.w     [w14+450], w0
    5f68:	50 01 be    	mov.d     [++w0], w2
    5f6a:	10 a7 99    	mov.w     w0, [w14+450]
    5f6c:	1e 98 91    	mov.w     [w14+434], w0
    5f6e:	ae 98 91    	mov.w     [w14+436], w1
    5f70:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5f72:	00 00 00 
    5f74:	00 01 be    	mov.d     w0, w2
    5f76:	08 00 be    	mov.d     w8, w0
    5f78:	92 14 02    	call      0x1492 <___addsf3>
    5f7a:	00 00 00 
    5f7c:	00 01 be    	mov.d     w0, w2

00005f7e <.L0>:
    5f7e:	0a 00 be    	mov.d     w10, w0
    5f80:	92 14 02    	call      0x1492 <___addsf3>
    5f82:	00 00 00 
    5f84:	1e a9 91    	mov.w     [w14+466], w2
    5f86:	00 a9 be    	mov.d     w0, [++w2]
    5f88:	12 af 99    	mov.w     w2, [w14+466]

00005f8a <.L0>:
    5f8a:	ce 89 91    	mov.w     [w14+408], w3
    5f8c:	83 01 e8    	inc.w     w3, w3
    5f8e:	43 8f 99    	mov.w     w3, [w14+408]
    5f90:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    5f92:	da ff 3a    	bra       NZ, 0x5f48 <.L0> <.L148>
    }

    /* Gain: '<S403>/UEN 2 NEU' */
    for (i = 0; i < 3; i++) {
      AUAV_V3_TestSensors_B.WP0L2IPT1[i] = 0.0F;
      AUAV_V3_TestSensors_B.WP0L2IPT1[i] +=
        AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0];
    5f94:	6e ad 90    	mov.w     [w14+220], w10
    5f96:	fe ad 90    	mov.w     [w14+222], w11
      AUAV_V3_TestSensors_B.WP0L2IPT1[i] +=
        AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1];
    5f98:	0e b6 90    	mov.w     [w14+224], w12
    5f9a:	9e b6 90    	mov.w     [w14+226], w13
      AUAV_V3_TestSensors_B.WP0L2IPT1[i] +=
        AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0[2];
    5f9c:	2e b2 90    	mov.w     [w14+228], w4
    5f9e:	be b2 90    	mov.w     [w14+230], w5
    5fa0:	24 8f 99    	mov.w     w4, [w14+404]
    5fa2:	35 8f 99    	mov.w     w5, [w14+406]
    5fa4:	c5 73 2c    	mov.w     #0xc73c, w5
    5fa6:	15 af 99    	mov.w     w5, [w14+466]
    5fa8:	6c 80 42    	add.w     w5, #0xc, w0
    5faa:	50 b7 99    	mov.w     w0, [w14+490]
    5fac:	ec 00 40    	add.w     w0, #0xc, w1
    5fae:	11 a7 99    	mov.w     w1, [w14+450]
    5fb0:	62 85 21    	mov.w     #0x1856, w2
    5fb2:	12 9f 99    	mov.w     w2, [w14+434]
    5fb4:	81 01 78    	mov.w     w1, w3
    5fb6:	53 97 99    	mov.w     w3, [w14+426]
    5fb8:	00 02 78    	mov.w     w0, w4
    5fba:	54 a7 99    	mov.w     w4, [w14+458]
    5fbc:	45 8f 99    	mov.w     w5, [w14+408]
    5fbe:	00 04 eb    	clr.w     w8
    5fc0:	68 3f 99    	mov.w     w8, [w14+380]

00005fc2 <.L0>:
    5fc2:	4e 88 91    	mov.w     [w14+408], w0
    5fc4:	50 01 be    	mov.d     [++w0], w2
    5fc6:	40 8f 99    	mov.w     w0, [w14+408]
    5fc8:	0a 00 be    	mov.d     w10, w0
    5fca:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5fcc:	00 00 00 

00005fce <.L0>:
    5fce:	60 11 b8    	mul.uu    w2, #0x0, w2
    5fd0:	92 14 02    	call      0x1492 <___addsf3>
    5fd2:	00 00 00 
    5fd4:	00 04 be    	mov.d     w0, w8

00005fd6 <.L0>:
    5fd6:	de a0 91    	mov.w     [w14+458], w1
    5fd8:	51 01 be    	mov.d     [++w1], w2
    5fda:	51 a7 99    	mov.w     w1, [w14+458]
    5fdc:	0c 00 be    	mov.d     w12, w0
    5fde:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5fe0:	00 00 00 
    5fe2:	00 01 be    	mov.d     w0, w2

00005fe4 <.L0>:
    5fe4:	08 00 be    	mov.d     w8, w0
    5fe6:	92 14 02    	call      0x1492 <___addsf3>
    5fe8:	00 00 00 
    5fea:	00 04 be    	mov.d     w0, w8

00005fec <.L0>:
    5fec:	5e 92 91    	mov.w     [w14+426], w4
    5fee:	54 01 be    	mov.d     [++w4], w2
    5ff0:	54 97 99    	mov.w     w4, [w14+426]
    5ff2:	2e 88 91    	mov.w     [w14+404], w0
    5ff4:	be 88 91    	mov.w     [w14+406], w1
    5ff6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    5ff8:	00 00 00 
    5ffa:	00 01 be    	mov.d     w0, w2

00005ffc <.L0>:
    5ffc:	08 00 be    	mov.d     w8, w0
    5ffe:	92 14 02    	call      0x1492 <___addsf3>
    6000:	00 00 00 
    6002:	9e 9a 91    	mov.w     [w14+434], w5
    6004:	80 aa be    	mov.d     w0, [++w5]
    6006:	15 9f 99    	mov.w     w5, [w14+434]

00006008 <.L0>:
    6008:	6e 38 91    	mov.w     [w14+380], w0
    600a:	00 00 e8    	inc.w     w0, w0
    600c:	60 3f 99    	mov.w     w0, [w14+380]
    600e:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    6010:	d8 ff 3a    	bra       NZ, 0x5fc2 <.L0> <.L149>

00006012 <.L0>:
    }

    /* Gain: '<S422>/Deg2R' */
    rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_0;
    rtb_Product3_bo = 0.0174532924F * rtb_IC4_idx_1;

    /* S-Function (MCHP_C_function_Call): '<S384>/Get WP Coord navsupport.c [updated 5.1.16]' */
    getWP(
    6012:	61 84 21    	mov.w     #0x1846, w1
    6014:	20 c0 b3    	mov.b     #0x2, w0
    6016:	ae f3 02    	call      0xf3ae <_getWP>
    6018:	00 00 00 

0000601a <.L0>:
          ((uint8_T)2U)
          , &AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_o[0]
          );

    /* Gain: '<S423>/Deg2R' incorporates:
     *  Constant: '<S381>/Constant1'
     */
    rtb_cosphi = 0.0174532924F *
    601a:	52 a3 2f    	mov.w     #0xfa35, w2
    601c:	e3 c8 23    	mov.w     #0x3c8e, w3
    601e:	30 c2 80    	mov.w     0x1846, w0
    6020:	41 c2 80    	mov.w     0x1848, w1
    6022:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6024:	00 00 00 
    6026:	00 04 be    	mov.d     w0, w8

00006028 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_o[0];

    /* Trigonometry: '<S423>/sin(phi)' */
    rtb_Ze_b = (real32_T)sin(rtb_cosphi);
    6028:	b6 1d 02    	call      0x1db6 <_sinf>
    602a:	00 00 00 
    602c:	00 01 be    	mov.d     w0, w2
    602e:	50 a7 99    	mov.w     w0, [w14+458]
    6030:	61 a7 99    	mov.w     w1, [w14+460]

00006032 <.L0>:

    /* Sum: '<S423>/Sum1' incorporates:
     *  Constant: '<S423>/const'
     *  Product: '<S423>/Product1'
     *  Product: '<S423>/sin(phi)^2'
     */
    rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    6032:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6034:	00 00 00 
    6036:	02 b8 25    	mov.w     #0x5b80, w2
    6038:	b3 bd 23    	mov.w     #0x3bdb, w3
    603a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    603c:	00 00 00 
    603e:	00 01 be    	mov.d     w0, w2
    6040:	00 00 20    	mov.w     #0x0, w0
    6042:	01 f8 23    	mov.w     #0x3f80, w1
    6044:	90 14 02    	call      0x1490 <___subsf3>
    6046:	00 00 00 
    6048:	00 05 be    	mov.d     w0, w10

0000604a <.L0>:

    /* Fcn: '<S423>/f' */
    if (rtb_Sum1_mzp < 0.0F) {
    604a:	60 11 b8    	mul.uu    w2, #0x0, w2
    604c:	8c 18 02    	call      0x188c <___eqsf2>
    604e:	00 00 00 
    6050:	00 00 e0    	cp0.w     w0
    6052:	07 00 3d    	bra       GE, 0x6062 <.L0> <.L0> <.L603>

00006054 <.L0>:
      rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    6054:	0a 00 be    	mov.d     w10, w0
    6056:	01 f0 a2    	btg.w     w1, #0xf
    6058:	ba 1d 02    	call      0x1dba <_sqrtf>
    605a:	00 00 00 
    605c:	00 01 be    	mov.d     w0, w2
    605e:	03 f0 a2    	btg.w     w3, #0xf
    6060:	04 00 37    	bra       0x606a <.L0> <.L0> <.L152>

00006062 <.L0>:
    } else {
      rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    6062:	0a 00 be    	mov.d     w10, w0
    6064:	ba 1d 02    	call      0x1dba <_sqrtf>
    6066:	00 00 00 
    6068:	00 01 be    	mov.d     w0, w2

0000606a <.L0>:
    }

    /* End of Fcn: '<S423>/f' */

    /* Product: '<S423>/Rh' incorporates:
     *  Constant: '<S423>/Re=equatorial radius'
     */
    rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    606a:	20 53 2a    	mov.w     #0xa532, w0
    606c:	21 ac 24    	mov.w     #0x4ac2, w1
    606e:	26 17 02    	call      0x1726 <___divsf3>
    6070:	00 00 00 
    6072:	50 97 99    	mov.w     w0, [w14+426]
    6074:	61 97 99    	mov.w     w1, [w14+428]

00006076 <.L0>:

    /* Sum: '<S423>/Sum2' */
    rtb_RhhcosphicoslambXe =
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_o[2] + rtb_Sum1_mzp;

    /* Trigonometry: '<S423>/cos(phi)' */
    rtb_cosphi = (real32_T)cos(rtb_cosphi);
    6076:	08 00 be    	mov.d     w8, w0
    6078:	22 17 02    	call      0x1722 <_cosf>
    607a:	00 00 00 
    607c:	00 05 be    	mov.d     w0, w10

0000607e <.L0>:

    /* Gain: '<S423>/Deg2R1' */
    rtb_RhhcosphisinlambYe = 0.0174532924F *
    607e:	52 a3 2f    	mov.w     #0xfa35, w2
    6080:	e3 c8 23    	mov.w     #0x3c8e, w3
    6082:	50 c2 80    	mov.w     0x184a, w0
    6084:	61 c2 80    	mov.w     0x184c, w1
    6086:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6088:	00 00 00 
    608a:	00 04 be    	mov.d     w0, w8

0000608c <.L0>:
    608c:	5e 91 91    	mov.w     [w14+426], w2
    608e:	ee 91 91    	mov.w     [w14+428], w3
    6090:	70 c2 80    	mov.w     0x184e, w0
    6092:	81 c2 80    	mov.w     0x1850, w1
    6094:	92 14 02    	call      0x1492 <___addsf3>
    6096:	00 00 00 

00006098 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_o[1];

    /* Product: '<S423>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
     *  Trigonometry: '<S423>/cos(lamb)'
     */
    rtb_Deg2R1 = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)cos
    6098:	0a 01 be    	mov.d     w10, w2
    609a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    609c:	00 00 00 
    609e:	00 05 be    	mov.d     w0, w10
    60a0:	08 00 be    	mov.d     w8, w0
    60a2:	22 17 02    	call      0x1722 <_cosf>
    60a4:	00 00 00 
    60a6:	00 01 be    	mov.d     w0, w2
    60a8:	0a 00 be    	mov.d     w10, w0
    60aa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    60ac:	00 00 00 
    60ae:	00 06 be    	mov.d     w0, w12

000060b0 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S423>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
     *  Trigonometry: '<S423>/sin(lamb)'
     */
    rtb_RhhcosphicoslambXe = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)sin
    60b0:	08 00 be    	mov.d     w8, w0
    60b2:	b6 1d 02    	call      0x1db6 <_sinf>
    60b4:	00 00 00 
    60b6:	40 8f 99    	mov.w     w0, [w14+408]
    60b8:	51 8f 99    	mov.w     w1, [w14+410]

000060ba <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S423>/Ze' incorporates:
     *  Product: '<S423>/Rh(1-e^2)'
     *  Sum: '<S423>/Sum4'
     */
    rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp +
    60ba:	92 94 24    	mov.w     #0x4949, w2
    60bc:	e3 f7 23    	mov.w     #0x3f7e, w3
    60be:	5e 90 91    	mov.w     [w14+426], w0
    60c0:	ee 90 91    	mov.w     [w14+428], w1
    60c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    60c4:	00 00 00 
    60c6:	00 01 be    	mov.d     w0, w2
    60c8:	70 c2 80    	mov.w     0x184e, w0
    60ca:	81 c2 80    	mov.w     0x1850, w1
    60cc:	92 14 02    	call      0x1492 <___addsf3>
    60ce:	00 00 00 
    60d0:	5e a1 91    	mov.w     [w14+458], w2
    60d2:	ee a1 91    	mov.w     [w14+460], w3
    60d4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    60d6:	00 00 00 
    60d8:	00 04 be    	mov.d     w0, w8

000060da <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_o[2];

    /* SignalConversion: '<S422>/TmpSignal ConversionAtProduct1Inport1' incorporates:
     *  Fcn: '<S425>/11'
     *  Fcn: '<S425>/12'
     *  Fcn: '<S425>/13'
     *  Fcn: '<S425>/21'
     *  Fcn: '<S425>/22'
     *  Fcn: '<S425>/23'
     *  Fcn: '<S425>/31'
     *  Fcn: '<S425>/32'
     *  Fcn: '<S425>/33'
     */
    tmp_1[0] = (real32_T)cos(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    60da:	2e 3a 91    	mov.w     [w14+372], w4
    60dc:	be 3a 91    	mov.w     [w14+374], w5
    60de:	44 b7 98    	mov.w     w4, [w14+232]
    60e0:	55 b7 98    	mov.w     w5, [w14+234]
    tmp_1[1] = -(real32_T)sin(rtb_Deg2R_h_idx_0);
    60e2:	4e 38 91    	mov.w     [w14+376], w0
    60e4:	de 38 91    	mov.w     [w14+378], w1
    60e6:	60 b7 98    	mov.w     w0, [w14+236]
    60e8:	71 b7 98    	mov.w     w1, [w14+238]
    tmp_1[2] = -(real32_T)sin(rtb_Product3_bo) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    60ea:	0e 39 91    	mov.w     [w14+368], w2
    60ec:	9e 39 91    	mov.w     [w14+370], w3
    60ee:	02 bf 98    	mov.w     w2, [w14+240]
    60f0:	13 bf 98    	mov.w     w3, [w14+242]
    tmp_1[3] = (real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    60f2:	6e 32 91    	mov.w     [w14+364], w4
    60f4:	fe 32 91    	mov.w     [w14+366], w5
    60f6:	24 bf 98    	mov.w     w4, [w14+244]
    60f8:	35 bf 98    	mov.w     w5, [w14+246]
    tmp_1[4] = (real32_T)cos(rtb_Deg2R_h_idx_0);
    60fa:	3e 98 91    	mov.w     [w14+438], w0
    60fc:	ce 98 91    	mov.w     [w14+440], w1
    60fe:	40 bf 98    	mov.w     w0, [w14+248]
    6100:	51 bf 98    	mov.w     w1, [w14+250]
    tmp_1[5] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)sin(rtb_Product3_bo);
    6102:	4e 31 91    	mov.w     [w14+360], w2
    6104:	de 31 91    	mov.w     [w14+362], w3
    6106:	62 bf 98    	mov.w     w2, [w14+252]
    6108:	73 bf 98    	mov.w     w3, [w14+254]
    tmp_1[6] = (real32_T)sin(rtb_Product3_bo);
    610a:	7e 8a 91    	mov.w     [w14+414], w4
    610c:	8e 92 91    	mov.w     [w14+416], w5
    610e:	04 07 99    	mov.w     w4, [w14+256]
    6110:	15 07 99    	mov.w     w5, [w14+258]
    tmp_1[7] = 0.0F;
    6112:	60 00 b8    	mul.uu    w0, #0x0, w0
    6114:	20 07 99    	mov.w     w0, [w14+260]
    6116:	31 07 99    	mov.w     w1, [w14+262]
    tmp_1[8] = (real32_T)cos(rtb_Product3_bo);
    6118:	7e 90 91    	mov.w     [w14+430], w0
    611a:	8e 98 91    	mov.w     [w14+432], w1
    611c:	40 07 99    	mov.w     w0, [w14+264]
    611e:	51 07 99    	mov.w     w1, [w14+266]

00006120 <.L0>:

    /* Sum: '<S420>/Sum1' incorporates:
     *  Product: '<S422>/Product1'
     */
    rtb_Deg2R1 -= AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    6120:	72 bf 80    	mov.w     0x17ee, w2
    6122:	83 bf 80    	mov.w     0x17f0, w3
    6124:	0c 00 be    	mov.d     w12, w0
    6126:	90 14 02    	call      0x1490 <___subsf3>
    6128:	00 00 00 
    612a:	20 8f 99    	mov.w     w0, [w14+404]
    612c:	31 8f 99    	mov.w     w1, [w14+406]

0000612e <.L0>:
    612e:	4e 89 91    	mov.w     [w14+408], w2
    6130:	de 89 91    	mov.w     [w14+410], w3
    6132:	0a 00 be    	mov.d     w10, w0
    6134:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6136:	00 00 00 

00006138 <.L0>:
    rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe -
    6138:	92 bf 80    	mov.w     0x17f2, w2
    613a:	a3 bf 80    	mov.w     0x17f4, w3
    613c:	90 14 02    	call      0x1490 <___subsf3>
    613e:	00 00 00 
    6140:	60 3f 99    	mov.w     w0, [w14+380]
    6142:	71 3f 99    	mov.w     w1, [w14+382]

00006144 <.L0>:
      AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    rtb_Sum1_mzp = rtb_Ze_b - AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    6144:	b2 bf 80    	mov.w     0x17f6, w2
    6146:	c3 bf 80    	mov.w     0x17f8, w3
    6148:	08 00 be    	mov.d     w8, w0
    614a:	90 14 02    	call      0x1490 <___subsf3>
    614c:	00 00 00 
    614e:	00 06 be    	mov.d     w0, w12
    6150:	85 0e 20    	mov.w     #0xe8, w5
    6152:	8e 82 42    	add.w     w5, w14, w5
    6154:	f4 82 42    	add.w     w5, #0x14, w5
    6156:	15 9f 99    	mov.w     w5, [w14+434]
    6158:	80 0e 20    	mov.w     #0xe8, w0
    615a:	0e 00 40    	add.w     w0, w14, w0
    615c:	68 00 40    	add.w     w0, #0x8, w0
    615e:	50 a7 99    	mov.w     w0, [w14+458]
    6160:	81 0e 20    	mov.w     #0xe8, w1
    6162:	8e 80 40    	add.w     w1, w14, w1
    6164:	e4 80 50    	sub.w     w1, #0x4, w1
    6166:	41 8f 99    	mov.w     w1, [w14+408]
    6168:	7e a9 91    	mov.w     [w14+478], w2
    616a:	52 97 99    	mov.w     w2, [w14+426]

0000616c <.L0>:

    /* Product: '<S422>/Product1' incorporates:
     *  Gain: '<S420>/UEN 2 NEU'
     */
    for (i = 0; i < 3; i++) {
    616c:	00 04 eb    	clr.w     w8
    616e:	78 b7 99    	mov.w     w8, [w14+494]

00006170 <.L0>:
      tmp_0[i] = tmp_1[i + 6] * rtb_Sum1_mzp + (tmp_1[i + 3] *
    6170:	1e 9a 91    	mov.w     [w14+434], w4
    6172:	54 01 be    	mov.d     [++w4], w2
    6174:	14 9f 99    	mov.w     w4, [w14+434]
    6176:	0c 00 be    	mov.d     w12, w0
    6178:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    617a:	00 00 00 
    617c:	00 05 be    	mov.d     w0, w10
    617e:	de a2 91    	mov.w     [w14+458], w5
    6180:	55 01 be    	mov.d     [++w5], w2
    6182:	55 a7 99    	mov.w     w5, [w14+458]
    6184:	6e 38 91    	mov.w     [w14+380], w0
    6186:	fe 38 91    	mov.w     [w14+382], w1
    6188:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    618a:	00 00 00 
    618c:	00 04 be    	mov.d     w0, w8

0000618e <.L0>:
        rtb_RhhcosphisinlambYe + tmp_1[i] * rtb_Deg2R1);
    618e:	4e 88 91    	mov.w     [w14+408], w0
    6190:	50 01 be    	mov.d     [++w0], w2
    6192:	40 8f 99    	mov.w     w0, [w14+408]
    6194:	2e 88 91    	mov.w     [w14+404], w0
    6196:	be 88 91    	mov.w     [w14+406], w1
    6198:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    619a:	00 00 00 
    619c:	00 01 be    	mov.d     w0, w2
    619e:	08 00 be    	mov.d     w8, w0
    61a0:	92 14 02    	call      0x1492 <___addsf3>
    61a2:	00 00 00 
    61a4:	00 01 be    	mov.d     w0, w2

000061a6 <.L0>:
    61a6:	0a 00 be    	mov.d     w10, w0
    61a8:	92 14 02    	call      0x1492 <___addsf3>
    61aa:	00 00 00 
    61ac:	5e 91 91    	mov.w     [w14+426], w2
    61ae:	00 a9 be    	mov.d     w0, [++w2]
    61b0:	52 97 99    	mov.w     w2, [w14+426]

000061b2 <.L0>:
    61b2:	fe b1 91    	mov.w     [w14+494], w3
    61b4:	83 01 e8    	inc.w     w3, w3
    61b6:	73 b7 99    	mov.w     w3, [w14+494]
    61b8:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    61ba:	da ff 3a    	bra       NZ, 0x6170 <.L0> <.L153>
    }

    /* Gain: '<S420>/UEN 2 NEU' */
    for (i = 0; i < 3; i++) {
      rtb_P32[i] = AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0[2] +
    61bc:	2e b6 90    	mov.w     [w14+228], w12
    61be:	be b6 90    	mov.w     [w14+230], w13
        (AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1] +
    61c0:	0e b2 90    	mov.w     [w14+224], w4
    61c2:	9e b2 90    	mov.w     [w14+226], w5
    61c4:	24 8f 99    	mov.w     w4, [w14+404]
    61c6:	35 8f 99    	mov.w     w5, [w14+406]
         AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0]);
    61c8:	6e a8 90    	mov.w     [w14+220], w0
    61ca:	fe a8 90    	mov.w     [w14+222], w1
    61cc:	60 3f 99    	mov.w     w0, [w14+380]
    61ce:	71 3f 99    	mov.w     w1, [w14+382]
    61d0:	41 08 20    	mov.w     #0x84, w1
    61d2:	81 00 47    	add.w     w14, w1, w1
    61d4:	51 97 99    	mov.w     w1, [w14+426]
    61d6:	1e a9 91    	mov.w     [w14+466], w2
    61d8:	42 8f 99    	mov.w     w2, [w14+408]
    61da:	de b1 91    	mov.w     [w14+490], w3
    61dc:	13 9f 99    	mov.w     w3, [w14+434]
    61de:	1e a2 91    	mov.w     [w14+450], w4
    61e0:	54 a7 99    	mov.w     w4, [w14+458]
    61e2:	00 04 eb    	clr.w     w8
    61e4:	78 b7 99    	mov.w     w8, [w14+494]

000061e6 <.L0>:
    61e6:	de a2 91    	mov.w     [w14+458], w5
    61e8:	55 01 be    	mov.d     [++w5], w2
    61ea:	55 a7 99    	mov.w     w5, [w14+458]
    61ec:	0c 00 be    	mov.d     w12, w0
    61ee:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    61f0:	00 00 00 
    61f2:	00 05 be    	mov.d     w0, w10

000061f4 <.L0>:
    61f4:	1e 98 91    	mov.w     [w14+434], w0
    61f6:	50 01 be    	mov.d     [++w0], w2
    61f8:	10 9f 99    	mov.w     w0, [w14+434]
    61fa:	2e 88 91    	mov.w     [w14+404], w0
    61fc:	be 88 91    	mov.w     [w14+406], w1
    61fe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6200:	00 00 00 
    6202:	00 04 be    	mov.d     w0, w8

00006204 <.L0>:
    6204:	ce 88 91    	mov.w     [w14+408], w1
    6206:	51 01 be    	mov.d     [++w1], w2
    6208:	41 8f 99    	mov.w     w1, [w14+408]
    620a:	6e 38 91    	mov.w     [w14+380], w0
    620c:	fe 38 91    	mov.w     [w14+382], w1
    620e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6210:	00 00 00 
    6212:	00 01 be    	mov.d     w0, w2

00006214 <.L0>:
    6214:	08 00 be    	mov.d     w8, w0
    6216:	92 14 02    	call      0x1492 <___addsf3>
    6218:	00 00 00 
    621a:	00 01 be    	mov.d     w0, w2

0000621c <.L0>:
    621c:	0a 00 be    	mov.d     w10, w0
    621e:	92 14 02    	call      0x1492 <___addsf3>
    6220:	00 00 00 
    6222:	5e 91 91    	mov.w     [w14+426], w2
    6224:	00 a9 be    	mov.d     w0, [++w2]
    6226:	52 97 99    	mov.w     w2, [w14+426]

00006228 <.L0>:
    6228:	fe b1 91    	mov.w     [w14+494], w3
    622a:	83 01 e8    	inc.w     w3, w3
    622c:	73 b7 99    	mov.w     w3, [w14+494]
    622e:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    6230:	da ff 3a    	bra       NZ, 0x61e6 <.L0> <.L154>

00006232 <.L0>:
    }

    /* Sum: '<S382>/Add' incorporates:
     *  Gain: '<S420>/UEN 2 NEU'
     */
    rtb_Product3_j0[0] = rtb_P32[0] - AUAV_V3_TestSensors_B.WP0L2IPT1[0];
    6232:	d2 c2 80    	mov.w     0x185a, w2
    6234:	e3 c2 80    	mov.w     0x185c, w3
    6236:	4e 80 90    	mov.w     [w14+136], w0
    6238:	de 80 90    	mov.w     [w14+138], w1
    623a:	90 14 02    	call      0x1490 <___subsf3>
    623c:	00 00 00 
    623e:	00 8f be    	mov.d     w0, [w14]

00006240 <.L0>:
    rtb_Product3_j0[1] = rtb_P32[1] - AUAV_V3_TestSensors_B.WP0L2IPT1[1];
    6240:	f2 c2 80    	mov.w     0x185e, w2
    6242:	03 c3 80    	mov.w     0x1860, w3
    6244:	6e 80 90    	mov.w     [w14+140], w0
    6246:	fe 80 90    	mov.w     [w14+142], w1
    6248:	90 14 02    	call      0x1490 <___subsf3>
    624a:	00 00 00 
    624c:	20 07 98    	mov.w     w0, [w14+4]
    624e:	31 07 98    	mov.w     w1, [w14+6]

00006250 <.L0>:
    rtb_Product3_j0[2] = rtb_P32[2] - AUAV_V3_TestSensors_B.WP0L2IPT1[2];
    6250:	12 c3 80    	mov.w     0x1862, w2
    6252:	23 c3 80    	mov.w     0x1864, w3
    6254:	0e 88 90    	mov.w     [w14+144], w0
    6256:	9e 88 90    	mov.w     [w14+146], w1
    6258:	90 14 02    	call      0x1490 <___subsf3>
    625a:	00 00 00 
    625c:	40 07 98    	mov.w     w0, [w14+8]
    625e:	51 07 98    	mov.w     w1, [w14+10]

00006260 <.L0>:

    /* MATLAB Function: '<S389>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(rtb_Product3_j0,
    6260:	c1 cd 21    	mov.w     #0x1cdc, w1
    6262:	0e 00 78    	mov.w     w14, w0
    6264:	8a f6 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00006266 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_e);

    /* MATLAB Function: '<S390>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_e.xDoty,
    6266:	82 cd 21    	mov.w     #0x1cd8, w2
    6268:	e0 e6 80    	mov.w     0x1cdc, w0
    626a:	f1 e6 80    	mov.w     0x1cde, w1
    626c:	74 f6 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

0000626e <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_nb);

    /* S-Function (MCHP_C_function_Call): '<S390>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a5 = mySqrt(
    626e:	c0 e6 80    	mov.w     0x1cd8, w0
    6270:	d1 e6 80    	mov.w     0x1cda, w1
    6272:	16 10 02    	call      0x11016 <_mySqrt>
    6274:	01 00 00 
    6276:	00 04 be    	mov.d     w0, w8
    6278:	90 c2 88    	mov.w     w0, 0x1852
    627a:	a1 c2 88    	mov.w     w1, 0x1854

0000627c <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_nb.zpVal
      );

    /* Saturate: '<S385>/Zero Bound' */
    if (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a5 <= 0.001F) {
    627c:	f2 26 21    	mov.w     #0x126f, w2
    627e:	33 a8 23    	mov.w     #0x3a83, w3
    6280:	8c 18 02    	call      0x188c <___eqsf2>
    6282:	00 00 00 
    6284:	00 00 e0    	cp0.w     w0
    6286:	02 00 3c    	bra       GT, 0x628c <.L0> <.L155>

00006288 <.L0>:
      rtb_Sum1_mzp = 0.001F;
    6288:	f8 26 21    	mov.w     #0x126f, w8
    628a:	39 a8 23    	mov.w     #0x3a83, w9

0000628c <.L0>:
    } else {
      rtb_Sum1_mzp = AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a5;
    }

    /* End of Saturate: '<S385>/Zero Bound' */
    rtb_Product3_j0[0] /= rtb_Sum1_mzp;
    628c:	08 01 be    	mov.d     w8, w2
    628e:	1e 00 be    	mov.d     [w14], w0
    6290:	26 17 02    	call      0x1726 <___divsf3>
    6292:	00 00 00 
    6294:	00 8f be    	mov.d     w0, [w14]

00006296 <.L0>:
    rtb_Product3_j0[1] /= rtb_Sum1_mzp;
    6296:	08 01 be    	mov.d     w8, w2
    6298:	2e 00 90    	mov.w     [w14+4], w0
    629a:	be 00 90    	mov.w     [w14+6], w1
    629c:	26 17 02    	call      0x1726 <___divsf3>
    629e:	00 00 00 
    62a0:	20 07 98    	mov.w     w0, [w14+4]
    62a2:	31 07 98    	mov.w     w1, [w14+6]

000062a4 <.L0>:

    /* Product: '<S385>/Divide' */
    rtb_Sum1_mzp = rtb_Product3_j0[2] / rtb_Sum1_mzp;
    62a4:	08 01 be    	mov.d     w8, w2
    62a6:	4e 00 90    	mov.w     [w14+8], w0
    62a8:	de 00 90    	mov.w     [w14+10], w1
    62aa:	26 17 02    	call      0x1726 <___divsf3>
    62ac:	00 00 00 
    62ae:	00 04 be    	mov.d     w0, w8

000062b0 <.L0>:
    rtb_Product3_j0[2] = rtb_Sum1_mzp;
    62b0:	40 07 98    	mov.w     w0, [w14+8]
    62b2:	51 07 98    	mov.w     w1, [w14+10]

000062b4 <.L0>:

    /* MATLAB Function: '<S382>/Select N  Terms' incorporates:
     *  Product: '<S385>/Divide'
     */
    AUAV_V3_TestS_SelectNTerms(rtb_Product3_j0,
    62b4:	41 cc 21    	mov.w     #0x1cc4, w1
    62b6:	0e 00 78    	mov.w     w14, w0
    62b8:	b5 f6 07    	rcall     0x5024 <_AUAV_V3_TestS_SelectNTerms> <L0> <.LFB1485> <.LFE1484>

000062ba <.L0>:
      &AUAV_V3_TestSensors_B.sf_SelectNTerms_f);

    /* MATLAB Function: '<S396>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.sf_SelectNTerms_f.N,
    62ba:	41 cd 21    	mov.w     #0x1cd4, w1
    62bc:	70 80 50    	sub.w     w1, #0x10, w0
    62be:	5d f6 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

000062c0 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_l);

    /* MATLAB Function: '<S397>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_l.xDoty,
    62c0:	02 cd 21    	mov.w     #0x1cd0, w2
    62c2:	a0 e6 80    	mov.w     0x1cd4, w0
    62c4:	b1 e6 80    	mov.w     0x1cd6, w1
    62c6:	47 f6 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

000062c8 <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_j);

    /* S-Function (MCHP_C_function_Call): '<S397>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_i = mySqrt(
    62c8:	80 e6 80    	mov.w     0x1cd0, w0
    62ca:	91 e6 80    	mov.w     0x1cd2, w1
    62cc:	16 10 02    	call      0x11016 <_mySqrt>
    62ce:	01 00 00 
    62d0:	b0 c2 88    	mov.w     w0, 0x1856
    62d2:	c1 c2 88    	mov.w     w1, 0x1858

000062d4 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_j.zpVal
      );

    /* Sum: '<S304>/Subtract' incorporates:
     *  Constant: '<S304>/Constant5'
     *  Product: '<S304>/Product'
     */
    AUAV_V3_TestSensors_B.WP0L2IPT1[0] -= rtb_Product_lf * rtb_Product3_j0[0] *
    62d4:	aa 85 21    	mov.w     #0x185a, w10
    62d6:	1e 01 be    	mov.d     [w14], w2
    62d8:	5e a8 91    	mov.w     [w14+474], w0
    62da:	ee a8 91    	mov.w     [w14+476], w1
    62dc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    62de:	00 00 00 
    62e0:	00 01 be    	mov.d     w0, w2
    62e2:	92 14 02    	call      0x1492 <___addsf3>
    62e4:	00 00 00 
    62e6:	00 01 be    	mov.d     w0, w2
    62e8:	1a 00 be    	mov.d     [w10], w0
    62ea:	90 14 02    	call      0x1490 <___subsf3>
    62ec:	00 00 00 
    62ee:	00 8d be    	mov.d     w0, [w10]

000062f0 <.L0>:
      2.0F;
    AUAV_V3_TestSensors_B.WP0L2IPT1[1] -= rtb_Product_lf * rtb_Product3_j0[1] *
    62f0:	e4 05 45    	add.w     w10, #0x4, w11
    62f2:	2e 01 90    	mov.w     [w14+4], w2
    62f4:	be 01 90    	mov.w     [w14+6], w3
    62f6:	5e a8 91    	mov.w     [w14+474], w0
    62f8:	ee a8 91    	mov.w     [w14+476], w1
    62fa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    62fc:	00 00 00 
    62fe:	00 01 be    	mov.d     w0, w2
    6300:	92 14 02    	call      0x1492 <___addsf3>
    6302:	00 00 00 
    6304:	00 01 be    	mov.d     w0, w2
    6306:	1b 00 be    	mov.d     [w11], w0
    6308:	90 14 02    	call      0x1490 <___subsf3>
    630a:	00 00 00 
    630c:	80 8d be    	mov.d     w0, [w11]

0000630e <.L0>:
      2.0F;
    AUAV_V3_TestSensors_B.WP0L2IPT1[2] -= rtb_Product_lf * rtb_Sum1_mzp * 2.0F;
    630e:	e4 85 45    	add.w     w11, #0x4, w11
    6310:	08 01 be    	mov.d     w8, w2
    6312:	5e a8 91    	mov.w     [w14+474], w0
    6314:	ee a8 91    	mov.w     [w14+476], w1
    6316:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6318:	00 00 00 
    631a:	00 01 be    	mov.d     w0, w2
    631c:	92 14 02    	call      0x1492 <___addsf3>
    631e:	00 00 00 
    6320:	00 01 be    	mov.d     w0, w2
    6322:	1b 00 be    	mov.d     [w11], w0
    6324:	90 14 02    	call      0x1490 <___subsf3>
    6326:	00 00 00 
    6328:	80 8d be    	mov.d     w0, [w11]

0000632a <.L0>:

    /* End of Outputs for SubSystem: '<S187>/On WP Enable' */

    /* MATLAB Function: '<S187>/Zero out Z2' */
    AUAV_V3_TestSens_ZerooutZ1(AUAV_V3_TestSensors_B.WP0L2IPT1,
    632a:	01 cb 21    	mov.w     #0x1cb0, w1
    632c:	0a 00 78    	mov.w     w10, w0
    632e:	4b f6 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00006330 <.L0>:
      &AUAV_V3_TestSensors_B.sf_ZerooutZ2_j);

    /* Sum: '<S187>/Add' */
    AUAV_V3_TestSensors_B.Merge_o[0] = AUAV_V3_TestSensors_B.sf_ZerooutZ2_j.P[0]
    6330:	08 f3 2f    	mov.w     #0xff30, w8
    6332:	0a 04 44    	add.w     w8, w10, w8

00006334 <.L0>:
      - AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    6334:	62 e1 80    	mov.w     0x1c2c, w2
    6336:	73 e1 80    	mov.w     0x1c2e, w3
    6338:	80 e5 80    	mov.w     0x1cb0, w0
    633a:	91 e5 80    	mov.w     0x1cb2, w1
    633c:	90 14 02    	call      0x1490 <___subsf3>
    633e:	00 00 00 

00006340 <.L0>:
    6340:	00 8c be    	mov.d     w0, [w8]

00006342 <.L0>:
    AUAV_V3_TestSensors_B.Merge_o[1] = AUAV_V3_TestSensors_B.sf_ZerooutZ2_j.P[1]
      - AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    6342:	82 e1 80    	mov.w     0x1c30, w2
    6344:	93 e1 80    	mov.w     0x1c32, w3
    6346:	a0 e5 80    	mov.w     0x1cb4, w0
    6348:	b1 e5 80    	mov.w     0x1cb6, w1
    634a:	90 14 02    	call      0x1490 <___subsf3>
    634c:	00 00 00 

0000634e <.L0>:
    634e:	70 bc 88    	mov.w     w0, 0x178e
    6350:	81 bc 88    	mov.w     w1, 0x1790

00006352 <.L0>:
    AUAV_V3_TestSensors_B.Merge_o[2] = AUAV_V3_TestSensors_B.sf_ZerooutZ2_j.P[2]
      - AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
    6352:	a2 e1 80    	mov.w     0x1c34, w2
    6354:	b3 e1 80    	mov.w     0x1c36, w3
    6356:	c0 e5 80    	mov.w     0x1cb8, w0
    6358:	d1 e5 80    	mov.w     0x1cba, w1
    635a:	90 14 02    	call      0x1490 <___subsf3>
    635c:	00 00 00 

0000635e <.L0>:
    635e:	90 bc 88    	mov.w     w0, 0x1792
    6360:	a1 bc 88    	mov.w     w1, 0x1794

00006362 <.L0>:

    /* MATLAB Function: '<S436>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.Merge_o,
    6362:	01 cc 21    	mov.w     #0x1cc0, w1
    6364:	08 00 78    	mov.w     w8, w0
    6366:	09 f6 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00006368 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_d);

    /* MATLAB Function: '<S437>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_d.xDoty,
    6368:	c2 cb 21    	mov.w     #0x1cbc, w2
    636a:	00 e6 80    	mov.w     0x1cc0, w0
    636c:	11 e6 80    	mov.w     0x1cc2, w1
    636e:	f3 f5 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006370 <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_lj);

    /* S-Function (MCHP_C_function_Call): '<S437>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_b = mySqrt(
    6370:	e0 e5 80    	mov.w     0x1cbc, w0
    6372:	f1 e5 80    	mov.w     0x1cbe, w1
    6374:	16 10 02    	call      0x11016 <_mySqrt>
    6376:	01 00 00 
    6378:	00 04 be    	mov.d     w0, w8
    637a:	70 c1 88    	mov.w     w0, 0x182e
    637c:	81 c1 88    	mov.w     w1, 0x1830

0000637e <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_lj.zpVal
      );

    /* MATLAB Function: '<S187>/Embedded MATLAB Function' incorporates:
     *  Gain: '<S187>/Gain'
     *  RelationalOperator: '<S187>/Relational Operator'
     */
    /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Normal WP  Navigation/Embedded MATLAB Function': '<S302>:1' */
    /*  This functions keeps track if the IP has been reached and if so */
    /*  it disables homing of IP until WP is reset */
    /*  initialize the persistent and the return value to 1 */
    /*  so WP, and not homing, is active by default */
    /*  this is just turned on for one sample  */
    /*  inmediatley upon enabling the navigation. */
    /*  Reset the flag the the IP was reached */
    if (rtb_DataTypeConversion2_fi != 0) {
    637e:	2e e2 93    	mov.b     [w14+482], w4
    6380:	04 04 e0    	cp0.b     w4
    6382:	02 00 32    	bra       Z, 0x6388 <.L0> <.L157>
      /* '<S302>:1:19' */
      AUAV_V3_TestSensors_DWork.persistentDidReachIP = 0U;
    6384:	d0 ff 21    	mov.w     #0x1ffd, w0
    6386:	00 48 eb    	clr.b     [w0]

00006388 <.L0>:
    }

    /*  Once the IP is reached the the persistent variable */
    /*  preserves the values until reset */
    if (0.4F * rtb_Product_lf >
    6388:	d2 cc 2c    	mov.w     #0xcccd, w2
    638a:	c3 ec 23    	mov.w     #0x3ecc, w3
    638c:	5e a8 91    	mov.w     [w14+474], w0
    638e:	ee a8 91    	mov.w     [w14+476], w1
    6390:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6392:	00 00 00 
    6394:	00 01 be    	mov.d     w0, w2
    6396:	08 00 be    	mov.d     w8, w0
    6398:	8c 18 02    	call      0x188c <___eqsf2>
    639a:	00 00 00 
    639c:	00 00 e0    	cp0.w     w0
    639e:	03 00 3d    	bra       GE, 0x63a6 <.L158>

000063a0 <.L0>:
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_b) {
      /* '<S302>:1:24' */
      /* '<S302>:1:25' */
      AUAV_V3_TestSensors_DWork.persistentDidReachIP = 1U;
    63a0:	11 c0 b3    	mov.b     #0x1, w1
    63a2:	d0 ff 21    	mov.w     #0x1ffd, w0
    63a4:	01 48 78    	mov.b     w1, [w0]

000063a6 <.L158>:
    }

    /* InitialCondition: '<S187>/IC' incorporates:
     *  MATLAB Function: '<S187>/Embedded MATLAB Function'
     */
    /* '<S302>:1:28' */
    if (AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_m) {
    63a6:	60 00 22    	mov.w     #0x2006, w0
    63a8:	10 04 e0    	cp0.b     [w0]
    63aa:	05 00 32    	bra       Z, 0x63b6 <.L160>
      AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_m = false;
    63ac:	80 40 eb    	clr.b     w1
    63ae:	01 48 78    	mov.b     w1, [w0]
      AUAV_V3_TestSensors_B.IC = 0U;
    63b0:	b0 a9 21    	mov.w     #0x1a9b, w0
    63b2:	01 48 78    	mov.b     w1, [w0]
    63b4:	03 00 37    	bra       0x63bc <.L161>

000063b6 <.L160>:
    } else {
      AUAV_V3_TestSensors_B.IC = AUAV_V3_TestSensors_DWork.persistentDidReachIP;
    63b6:	d1 ff 21    	mov.w     #0x1ffd, w1
    63b8:	b0 a9 21    	mov.w     #0x1a9b, w0
    63ba:	11 48 78    	mov.b     [w1], [w0]

000063bc <.L161>:
    }

    /* End of InitialCondition: '<S187>/IC' */

    /* MATLAB Function: '<S187>/computeCurrentWP' incorporates:
     *  DataStoreRead: '<Root>/Get Max WP'
     *  Delay: '<S187>/Integer Delay'
     */
    /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Normal WP  Navigation/computeCurrentWP': '<S307>:1' */
    /*  This functions keeps track if the IP has been reached and if so */
    /*  it disables homing of IP until WP is reset */
    /*  initialize the persistent and the return value to 1 */
    /*  so WP, and not homing, is active by default */
    if (AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_im != 0) {
    63bc:	80 ff 21    	mov.w     #0x1ff8, w0
    63be:	10 04 e0    	cp0.b     [w0]
    63c0:	12 00 32    	bra       Z, 0x63e6 <.L162>
      /* '<S307>:1:16' */
      AUAV_V3_TestSensors_DWork.fromWp = AUAV_V3_TestSensors_DWork.toWp;
    63c2:	64 00 40    	add.w     w0, #0x4, w0
    63c4:	90 40 78    	mov.b     [w0], w1
    63c6:	00 00 e9    	dec.w     w0, w0
    63c8:	01 48 78    	mov.b     w1, [w0]

      /* '<S307>:1:17' */
      rtb_u2deg = AUAV_V3_TestSensors_DWork.toWp + 1U;
    63ca:	01 80 fb    	ze        w1, w0
    63cc:	80 00 e8    	inc.w     w0, w1
      if (rtb_u2deg > 255U) {
        rtb_u2deg = 255U;
      }

      AUAV_V3_TestSensors_DWork.toWp = (uint8_T)rtb_u2deg;
    63ce:	f0 0f 20    	mov.w     #0xff, w0
    63d0:	80 8f 50    	sub.w     w1, w0, [w15]
    63d2:	01 00 36    	bra       LEU, 0x63d6 <.L163>
    63d4:	80 00 78    	mov.w     w0, w1

000063d6 <.L163>:
    63d6:	c0 ff 21    	mov.w     #0x1ffc, w0
    63d8:	01 48 78    	mov.b     w1, [w0]
      if (AUAV_V3_TestSensors_DWork.toWp > mlWpValues.wpCount) {
    63da:	80 23 21    	mov.w     #0x1238, w0
    63dc:	90 cf 10    	subr.b    w1, [w0], [w15]
    63de:	03 00 31    	bra       C, 0x63e6 <.L162>
        /* '<S307>:1:18' */
        /* '<S307>:1:19' */
        AUAV_V3_TestSensors_DWork.toWp = 1U;
    63e0:	11 c0 b3    	mov.b     #0x1, w1
    63e2:	c0 ff 21    	mov.w     #0x1ffc, w0
    63e4:	01 48 78    	mov.b     w1, [w0]

000063e6 <.L162>:
      }
    }

    /*  this is jturned on long as we have not reached IP  */
    if (!(AUAV_V3_TestSensors_B.IC != 0)) {
    63e6:	b0 a9 21    	mov.w     #0x1a9b, w0
    63e8:	10 04 e0    	cp0.b     [w0]
    63ea:	06 00 3a    	bra       NZ, 0x63f8 <.L164>
      /* '<S307>:1:25' */
      /* '<S307>:1:26' */
      AUAV_V3_TestSensors_DWork.fromWp = 1U;
    63ec:	11 c0 b3    	mov.b     #0x1, w1
    63ee:	b0 ff 21    	mov.w     #0x1ffb, w0
    63f0:	01 48 78    	mov.b     w1, [w0]

      /* '<S307>:1:27' */
      AUAV_V3_TestSensors_DWork.toWp = 2U;
    63f2:	21 c0 b3    	mov.b     #0x2, w1
    63f4:	00 00 e8    	inc.w     w0, w0
    63f6:	01 48 78    	mov.b     w1, [w0]

000063f8 <.L164>:
    }

    /* '<S307>:1:32' */
    AUAV_V3_TestSensors_B.WP0 = AUAV_V3_TestSensors_DWork.fromWp;
    63f8:	b0 ff 21    	mov.w     #0x1ffb, w0
    63fa:	10 41 78    	mov.b     [w0], w2
    63fc:	c0 a9 21    	mov.w     #0x1a9c, w0
    63fe:	02 48 78    	mov.b     w2, [w0]

    /* '<S307>:1:33' */
    AUAV_V3_TestSensors_B.WP1 = AUAV_V3_TestSensors_DWork.toWp;
    6400:	c1 ff 21    	mov.w     #0x1ffc, w1
    6402:	00 00 e8    	inc.w     w0, w0
    6404:	11 48 78    	mov.b     [w1], [w0]

00006406 <.L0>:

    /* End of MATLAB Function: '<S187>/computeCurrentWP' */

    /* Outputs for Enabled SubSystem: '<S187>/Get Frenet' incorporates:
     *  EnablePort: '<S303>/Enable'
     */
    /* Gain: '<S350>/Deg2R' */
    rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_0;
    rtb_Product3_bo = 0.0174532924F * rtb_IC4_idx_1;

    /* S-Function (MCHP_C_function_Call): '<S328>/Get WP Coord navsupport.c [updated 5.1.16]' */
    getWP(
    6406:	91 dc 2f    	mov.w     #0xfdc9, w1
    6408:	80 80 40    	add.w     w1, w0, w1
    640a:	02 40 78    	mov.b     w2, w0
    640c:	ae f3 02    	call      0xf3ae <_getWP>
    640e:	00 00 00 

00006410 <.L0>:
          AUAV_V3_TestSensors_B.WP0
          , &AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_d[0]
          );

    /* Gain: '<S351>/Deg2R' */
    rtb_cosphi = 0.0174532924F *
    6410:	52 a3 2f    	mov.w     #0xfa35, w2
    6412:	e3 c8 23    	mov.w     #0x3c8e, w3
    6414:	30 c3 80    	mov.w     0x1866, w0
    6416:	41 c3 80    	mov.w     0x1868, w1
    6418:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    641a:	00 00 00 
    641c:	00 04 be    	mov.d     w0, w8

0000641e <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_d[0];

    /* Trigonometry: '<S351>/sin(phi)' */
    rtb_Ze_b = (real32_T)sin(rtb_cosphi);
    641e:	b6 1d 02    	call      0x1db6 <_sinf>
    6420:	00 00 00 
    6422:	00 01 be    	mov.d     w0, w2
    6424:	10 b7 99    	mov.w     w0, [w14+482]
    6426:	21 b7 99    	mov.w     w1, [w14+484]

00006428 <.L0>:

    /* Sum: '<S351>/Sum1' incorporates:
     *  Constant: '<S351>/const'
     *  Product: '<S351>/Product1'
     *  Product: '<S351>/sin(phi)^2'
     */
    rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    6428:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    642a:	00 00 00 
    642c:	02 b8 25    	mov.w     #0x5b80, w2
    642e:	b3 bd 23    	mov.w     #0x3bdb, w3
    6430:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6432:	00 00 00 
    6434:	00 01 be    	mov.d     w0, w2
    6436:	00 00 20    	mov.w     #0x0, w0
    6438:	01 f8 23    	mov.w     #0x3f80, w1
    643a:	90 14 02    	call      0x1490 <___subsf3>
    643c:	00 00 00 
    643e:	00 05 be    	mov.d     w0, w10

00006440 <.L0>:

    /* Fcn: '<S351>/f' */
    if (rtb_Sum1_mzp < 0.0F) {
    6440:	60 11 b8    	mul.uu    w2, #0x0, w2
    6442:	8c 18 02    	call      0x188c <___eqsf2>
    6444:	00 00 00 
    6446:	00 00 e0    	cp0.w     w0
    6448:	07 00 3d    	bra       GE, 0x6458 <.L0> <.L0> <.L604>

0000644a <.L0>:
      rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    644a:	0a 00 be    	mov.d     w10, w0
    644c:	01 f0 a2    	btg.w     w1, #0xf
    644e:	ba 1d 02    	call      0x1dba <_sqrtf>
    6450:	00 00 00 
    6452:	00 01 be    	mov.d     w0, w2
    6454:	03 f0 a2    	btg.w     w3, #0xf
    6456:	04 00 37    	bra       0x6460 <.L0> <.L0> <.L167>

00006458 <.L0>:
    } else {
      rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    6458:	0a 00 be    	mov.d     w10, w0
    645a:	ba 1d 02    	call      0x1dba <_sqrtf>
    645c:	00 00 00 
    645e:	00 01 be    	mov.d     w0, w2

00006460 <.L0>:
    }

    /* End of Fcn: '<S351>/f' */

    /* Product: '<S351>/Rh' incorporates:
     *  Constant: '<S351>/Re=equatorial radius'
     */
    rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    6460:	20 53 2a    	mov.w     #0xa532, w0
    6462:	21 ac 24    	mov.w     #0x4ac2, w1
    6464:	26 17 02    	call      0x1726 <___divsf3>
    6466:	00 00 00 
    6468:	10 9f 99    	mov.w     w0, [w14+434]
    646a:	21 9f 99    	mov.w     w1, [w14+436]

0000646c <.L0>:

    /* Sum: '<S351>/Sum2' */
    rtb_RhhcosphicoslambXe =
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_d[2] + rtb_Sum1_mzp;

    /* Trigonometry: '<S351>/cos(phi)' */
    rtb_cosphi = (real32_T)cos(rtb_cosphi);
    646c:	08 00 be    	mov.d     w8, w0
    646e:	22 17 02    	call      0x1722 <_cosf>
    6470:	00 00 00 
    6472:	00 05 be    	mov.d     w0, w10

00006474 <.L0>:

    /* Gain: '<S351>/Deg2R1' */
    rtb_RhhcosphisinlambYe = 0.0174532924F *
    6474:	52 a3 2f    	mov.w     #0xfa35, w2
    6476:	e3 c8 23    	mov.w     #0x3c8e, w3
    6478:	50 c3 80    	mov.w     0x186a, w0
    647a:	61 c3 80    	mov.w     0x186c, w1
    647c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    647e:	00 00 00 
    6480:	00 04 be    	mov.d     w0, w8

00006482 <.L0>:
    6482:	1e 99 91    	mov.w     [w14+434], w2
    6484:	ae 99 91    	mov.w     [w14+436], w3
    6486:	70 c3 80    	mov.w     0x186e, w0
    6488:	81 c3 80    	mov.w     0x1870, w1
    648a:	92 14 02    	call      0x1492 <___addsf3>
    648c:	00 00 00 

0000648e <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_d[1];

    /* Product: '<S351>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
     *  Trigonometry: '<S351>/cos(lamb)'
     */
    rtb_Deg2R1 = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)cos
    648e:	0a 01 be    	mov.d     w10, w2
    6490:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6492:	00 00 00 
    6494:	00 05 be    	mov.d     w0, w10
    6496:	08 00 be    	mov.d     w8, w0
    6498:	22 17 02    	call      0x1722 <_cosf>
    649a:	00 00 00 
    649c:	00 01 be    	mov.d     w0, w2
    649e:	0a 00 be    	mov.d     w10, w0
    64a0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    64a2:	00 00 00 
    64a4:	00 06 be    	mov.d     w0, w12

000064a6 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S351>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
     *  Trigonometry: '<S351>/sin(lamb)'
     */
    rtb_RhhcosphicoslambXe = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)sin
    64a6:	08 00 be    	mov.d     w8, w0
    64a8:	b6 1d 02    	call      0x1db6 <_sinf>
    64aa:	00 00 00 
    64ac:	50 97 99    	mov.w     w0, [w14+426]
    64ae:	61 97 99    	mov.w     w1, [w14+428]

000064b0 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S351>/Ze' incorporates:
     *  Product: '<S351>/Rh(1-e^2)'
     *  Sum: '<S351>/Sum4'
     */
    rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp +
    64b0:	92 94 24    	mov.w     #0x4949, w2
    64b2:	e3 f7 23    	mov.w     #0x3f7e, w3
    64b4:	1e 98 91    	mov.w     [w14+434], w0
    64b6:	ae 98 91    	mov.w     [w14+436], w1
    64b8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    64ba:	00 00 00 
    64bc:	00 01 be    	mov.d     w0, w2
    64be:	70 c3 80    	mov.w     0x186e, w0
    64c0:	81 c3 80    	mov.w     0x1870, w1
    64c2:	92 14 02    	call      0x1492 <___addsf3>
    64c4:	00 00 00 
    64c6:	1e b1 91    	mov.w     [w14+482], w2
    64c8:	ae b1 91    	mov.w     [w14+484], w3
    64ca:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    64cc:	00 00 00 
    64ce:	00 04 be    	mov.d     w0, w8

000064d0 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_d[2];

    /* SignalConversion: '<S350>/TmpSignal ConversionAtProduct1Inport1' incorporates:
     *  Fcn: '<S353>/11'
     *  Fcn: '<S353>/12'
     *  Fcn: '<S353>/13'
     *  Fcn: '<S353>/21'
     *  Fcn: '<S353>/22'
     *  Fcn: '<S353>/23'
     *  Fcn: '<S353>/31'
     *  Fcn: '<S353>/32'
     *  Fcn: '<S353>/33'
     */
    tmp_2[0] = (real32_T)cos(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    64d0:	2e 3a 91    	mov.w     [w14+372], w4
    64d2:	be 3a 91    	mov.w     [w14+374], w5
    64d4:	64 07 99    	mov.w     w4, [w14+268]
    64d6:	75 07 99    	mov.w     w5, [w14+270]
    tmp_2[1] = -(real32_T)sin(rtb_Deg2R_h_idx_0);
    64d8:	4e 38 91    	mov.w     [w14+376], w0
    64da:	de 38 91    	mov.w     [w14+378], w1
    64dc:	00 0f 99    	mov.w     w0, [w14+272]
    64de:	11 0f 99    	mov.w     w1, [w14+274]
    tmp_2[2] = -(real32_T)sin(rtb_Product3_bo) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    64e0:	0e 39 91    	mov.w     [w14+368], w2
    64e2:	9e 39 91    	mov.w     [w14+370], w3
    64e4:	22 0f 99    	mov.w     w2, [w14+276]
    64e6:	33 0f 99    	mov.w     w3, [w14+278]
    tmp_2[3] = (real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    64e8:	6e 32 91    	mov.w     [w14+364], w4
    64ea:	fe 32 91    	mov.w     [w14+366], w5
    64ec:	44 0f 99    	mov.w     w4, [w14+280]
    64ee:	55 0f 99    	mov.w     w5, [w14+282]
    tmp_2[4] = (real32_T)cos(rtb_Deg2R_h_idx_0);
    64f0:	3e 98 91    	mov.w     [w14+438], w0
    64f2:	ce 98 91    	mov.w     [w14+440], w1
    64f4:	60 0f 99    	mov.w     w0, [w14+284]
    64f6:	71 0f 99    	mov.w     w1, [w14+286]
    tmp_2[5] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)sin(rtb_Product3_bo);
    64f8:	4e 31 91    	mov.w     [w14+360], w2
    64fa:	de 31 91    	mov.w     [w14+362], w3
    64fc:	02 17 99    	mov.w     w2, [w14+288]
    64fe:	13 17 99    	mov.w     w3, [w14+290]
    tmp_2[6] = (real32_T)sin(rtb_Product3_bo);
    6500:	7e 8a 91    	mov.w     [w14+414], w4
    6502:	8e 92 91    	mov.w     [w14+416], w5
    6504:	24 17 99    	mov.w     w4, [w14+292]
    6506:	35 17 99    	mov.w     w5, [w14+294]
    tmp_2[7] = 0.0F;
    6508:	60 00 b8    	mul.uu    w0, #0x0, w0
    650a:	40 17 99    	mov.w     w0, [w14+296]
    650c:	51 17 99    	mov.w     w1, [w14+298]
    tmp_2[8] = (real32_T)cos(rtb_Product3_bo);
    650e:	7e 90 91    	mov.w     [w14+430], w0
    6510:	8e 98 91    	mov.w     [w14+432], w1
    6512:	60 17 99    	mov.w     w0, [w14+300]
    6514:	71 17 99    	mov.w     w1, [w14+302]

00006516 <.L0>:

    /* Sum: '<S348>/Sum1' incorporates:
     *  Product: '<S350>/Product1'
     */
    rtb_Deg2R1 -= AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    6516:	72 bf 80    	mov.w     0x17ee, w2
    6518:	83 bf 80    	mov.w     0x17f0, w3
    651a:	0c 00 be    	mov.d     w12, w0
    651c:	90 14 02    	call      0x1490 <___subsf3>
    651e:	00 00 00 
    6520:	40 8f 99    	mov.w     w0, [w14+408]
    6522:	51 8f 99    	mov.w     w1, [w14+410]

00006524 <.L0>:
    6524:	5e 91 91    	mov.w     [w14+426], w2
    6526:	ee 91 91    	mov.w     [w14+428], w3
    6528:	0a 00 be    	mov.d     w10, w0
    652a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    652c:	00 00 00 

0000652e <.L0>:
    rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe -
    652e:	92 bf 80    	mov.w     0x17f2, w2
    6530:	a3 bf 80    	mov.w     0x17f4, w3
    6532:	90 14 02    	call      0x1490 <___subsf3>
    6534:	00 00 00 
    6536:	20 8f 99    	mov.w     w0, [w14+404]
    6538:	31 8f 99    	mov.w     w1, [w14+406]

0000653a <.L0>:
      AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    rtb_Sum1_mzp = rtb_Ze_b - AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    653a:	b2 bf 80    	mov.w     0x17f6, w2
    653c:	c3 bf 80    	mov.w     0x17f8, w3
    653e:	08 00 be    	mov.d     w8, w0
    6540:	90 14 02    	call      0x1490 <___subsf3>
    6542:	00 00 00 
    6544:	00 06 be    	mov.d     w0, w12
    6546:	c5 10 20    	mov.w     #0x10c, w5
    6548:	8e 82 42    	add.w     w5, w14, w5
    654a:	f4 82 42    	add.w     w5, #0x14, w5
    654c:	15 b7 99    	mov.w     w5, [w14+482]
    654e:	c0 10 20    	mov.w     #0x10c, w0
    6550:	0e 00 40    	add.w     w0, w14, w0
    6552:	68 00 40    	add.w     w0, #0x8, w0
    6554:	50 a7 99    	mov.w     w0, [w14+458]
    6556:	c1 10 20    	mov.w     #0x10c, w1
    6558:	8e 80 40    	add.w     w1, w14, w1
    655a:	e4 80 50    	sub.w     w1, #0x4, w1
    655c:	51 97 99    	mov.w     w1, [w14+426]
    655e:	7e a9 91    	mov.w     [w14+478], w2
    6560:	12 9f 99    	mov.w     w2, [w14+434]

00006562 <.L0>:

    /* Product: '<S350>/Product1' incorporates:
     *  Gain: '<S348>/UEN 2 NEU'
     */
    for (i = 0; i < 3; i++) {
    6562:	00 04 eb    	clr.w     w8
    6564:	68 3f 99    	mov.w     w8, [w14+380]

00006566 <.L0>:
      tmp_0[i] = tmp_2[i + 6] * rtb_Sum1_mzp + (tmp_2[i + 3] *
    6566:	1e b2 91    	mov.w     [w14+482], w4
    6568:	54 01 be    	mov.d     [++w4], w2
    656a:	14 b7 99    	mov.w     w4, [w14+482]
    656c:	0c 00 be    	mov.d     w12, w0
    656e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6570:	00 00 00 
    6572:	00 05 be    	mov.d     w0, w10
    6574:	de a2 91    	mov.w     [w14+458], w5
    6576:	55 01 be    	mov.d     [++w5], w2
    6578:	55 a7 99    	mov.w     w5, [w14+458]
    657a:	2e 88 91    	mov.w     [w14+404], w0
    657c:	be 88 91    	mov.w     [w14+406], w1
    657e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6580:	00 00 00 
    6582:	00 04 be    	mov.d     w0, w8

00006584 <.L0>:
        rtb_RhhcosphisinlambYe + tmp_2[i] * rtb_Deg2R1);
    6584:	5e 90 91    	mov.w     [w14+426], w0
    6586:	50 01 be    	mov.d     [++w0], w2
    6588:	50 97 99    	mov.w     w0, [w14+426]
    658a:	4e 88 91    	mov.w     [w14+408], w0
    658c:	de 88 91    	mov.w     [w14+410], w1
    658e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6590:	00 00 00 
    6592:	00 01 be    	mov.d     w0, w2
    6594:	08 00 be    	mov.d     w8, w0
    6596:	92 14 02    	call      0x1492 <___addsf3>
    6598:	00 00 00 
    659a:	00 01 be    	mov.d     w0, w2

0000659c <.L0>:
    659c:	0a 00 be    	mov.d     w10, w0
    659e:	92 14 02    	call      0x1492 <___addsf3>
    65a0:	00 00 00 
    65a2:	1e 99 91    	mov.w     [w14+434], w2
    65a4:	00 a9 be    	mov.d     w0, [++w2]
    65a6:	12 9f 99    	mov.w     w2, [w14+434]

000065a8 <.L0>:
    65a8:	ee 39 91    	mov.w     [w14+380], w3
    65aa:	83 01 e8    	inc.w     w3, w3
    65ac:	63 3f 99    	mov.w     w3, [w14+380]
    65ae:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    65b0:	da ff 3a    	bra       NZ, 0x6566 <.L0> <.L168>
    }

    /* Gain: '<S348>/UEN 2 NEU' */
    for (i = 0; i < 3; i++) {
      rtb_Product3_j0[i] = AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0[2]
    65b2:	2e b6 90    	mov.w     [w14+228], w12
    65b4:	be b6 90    	mov.w     [w14+230], w13
        + (AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1] +
    65b6:	0e b2 90    	mov.w     [w14+224], w4
    65b8:	9e b2 90    	mov.w     [w14+226], w5
    65ba:	44 8f 99    	mov.w     w4, [w14+408]
    65bc:	55 8f 99    	mov.w     w5, [w14+410]
           AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0]);
    65be:	6e a8 90    	mov.w     [w14+220], w0
    65c0:	fe a8 90    	mov.w     [w14+222], w1
    65c2:	20 8f 99    	mov.w     w0, [w14+404]
    65c4:	31 8f 99    	mov.w     w1, [w14+406]
    65c6:	e4 00 57    	sub.w     w14, #0x4, w1
    65c8:	11 9f 99    	mov.w     w1, [w14+434]
    65ca:	1e a9 91    	mov.w     [w14+466], w2
    65cc:	52 97 99    	mov.w     w2, [w14+426]
    65ce:	de b1 91    	mov.w     [w14+490], w3
    65d0:	53 a7 99    	mov.w     w3, [w14+458]
    65d2:	1e a2 91    	mov.w     [w14+450], w4
    65d4:	14 b7 99    	mov.w     w4, [w14+482]
    65d6:	00 04 eb    	clr.w     w8
    65d8:	68 3f 99    	mov.w     w8, [w14+380]

000065da <.L0>:
    65da:	9e b2 91    	mov.w     [w14+482], w5
    65dc:	55 01 be    	mov.d     [++w5], w2
    65de:	15 b7 99    	mov.w     w5, [w14+482]
    65e0:	0c 00 be    	mov.d     w12, w0
    65e2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    65e4:	00 00 00 
    65e6:	00 05 be    	mov.d     w0, w10

000065e8 <.L0>:
    65e8:	5e a0 91    	mov.w     [w14+458], w0
    65ea:	50 01 be    	mov.d     [++w0], w2
    65ec:	50 a7 99    	mov.w     w0, [w14+458]
    65ee:	4e 88 91    	mov.w     [w14+408], w0
    65f0:	de 88 91    	mov.w     [w14+410], w1
    65f2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    65f4:	00 00 00 
    65f6:	00 04 be    	mov.d     w0, w8

000065f8 <.L0>:
    65f8:	de 90 91    	mov.w     [w14+426], w1
    65fa:	51 01 be    	mov.d     [++w1], w2
    65fc:	51 97 99    	mov.w     w1, [w14+426]
    65fe:	2e 88 91    	mov.w     [w14+404], w0
    6600:	be 88 91    	mov.w     [w14+406], w1
    6602:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6604:	00 00 00 
    6606:	00 01 be    	mov.d     w0, w2

00006608 <.L0>:
    6608:	08 00 be    	mov.d     w8, w0
    660a:	92 14 02    	call      0x1492 <___addsf3>
    660c:	00 00 00 
    660e:	00 01 be    	mov.d     w0, w2
    6610:	0a 00 be    	mov.d     w10, w0
    6612:	92 14 02    	call      0x1492 <___addsf3>
    6614:	00 00 00 

00006616 <.L0>:
    6616:	1e 99 91    	mov.w     [w14+434], w2
    6618:	00 a9 be    	mov.d     w0, [++w2]
    661a:	12 9f 99    	mov.w     w2, [w14+434]
    661c:	ee 39 91    	mov.w     [w14+380], w3
    661e:	83 01 e8    	inc.w     w3, w3
    6620:	63 3f 99    	mov.w     w3, [w14+380]
    6622:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    6624:	da ff 3a    	bra       NZ, 0x65da <.L0> <.L169>

00006626 <.L0>:
    }

    /* Gain: '<S367>/Deg2R' */
    rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_0;
    rtb_Product3_bo = 0.0174532924F * rtb_IC4_idx_1;

    /* S-Function (MCHP_C_function_Call): '<S329>/Get WP Coord navsupport.c [updated 5.1.16]' */
    getWP(
    6626:	21 87 21    	mov.w     #0x1872, w1
    6628:	b0 22 20    	mov.w     #0x22b, w0
    662a:	01 00 40    	add.w     w0, w1, w0
    662c:	10 40 78    	mov.b     [w0], w0
    662e:	ae f3 02    	call      0xf3ae <_getWP>
    6630:	00 00 00 

00006632 <.L0>:
          AUAV_V3_TestSensors_B.WP1
          , &AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_b[0]
          );

    /* Gain: '<S368>/Deg2R' */
    rtb_cosphi = 0.0174532924F *
    6632:	52 a3 2f    	mov.w     #0xfa35, w2
    6634:	e3 c8 23    	mov.w     #0x3c8e, w3
    6636:	90 c3 80    	mov.w     0x1872, w0
    6638:	a1 c3 80    	mov.w     0x1874, w1
    663a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    663c:	00 00 00 
    663e:	00 04 be    	mov.d     w0, w8

00006640 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_b[0];

    /* Trigonometry: '<S368>/sin(phi)' */
    rtb_Ze_b = (real32_T)sin(rtb_cosphi);
    6640:	b6 1d 02    	call      0x1db6 <_sinf>
    6642:	00 00 00 
    6644:	10 b7 99    	mov.w     w0, [w14+482]
    6646:	21 b7 99    	mov.w     w1, [w14+484]

00006648 <.L0>:

    /* Sum: '<S368>/Sum1' incorporates:
     *  Constant: '<S368>/const'
     *  Product: '<S368>/Product1'
     *  Product: '<S368>/sin(phi)^2'
     */
    rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    6648:	00 01 be    	mov.d     w0, w2
    664a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    664c:	00 00 00 
    664e:	02 b8 25    	mov.w     #0x5b80, w2
    6650:	b3 bd 23    	mov.w     #0x3bdb, w3
    6652:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6654:	00 00 00 
    6656:	00 01 be    	mov.d     w0, w2
    6658:	00 00 20    	mov.w     #0x0, w0
    665a:	01 f8 23    	mov.w     #0x3f80, w1
    665c:	90 14 02    	call      0x1490 <___subsf3>
    665e:	00 00 00 
    6660:	00 05 be    	mov.d     w0, w10

00006662 <.L0>:

    /* Fcn: '<S368>/f' */
    if (rtb_Sum1_mzp < 0.0F) {
    6662:	60 11 b8    	mul.uu    w2, #0x0, w2
    6664:	8c 18 02    	call      0x188c <___eqsf2>
    6666:	00 00 00 
    6668:	00 00 e0    	cp0.w     w0
    666a:	07 00 3d    	bra       GE, 0x667a <.L0> <.L0> <.L605>

0000666c <.L0>:
      rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    666c:	0a 00 be    	mov.d     w10, w0
    666e:	01 f0 a2    	btg.w     w1, #0xf
    6670:	ba 1d 02    	call      0x1dba <_sqrtf>
    6672:	00 00 00 
    6674:	00 01 be    	mov.d     w0, w2
    6676:	03 f0 a2    	btg.w     w3, #0xf
    6678:	04 00 37    	bra       0x6682 <.L0> <.L0> <.L172>

0000667a <.L0>:
    } else {
      rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    667a:	0a 00 be    	mov.d     w10, w0
    667c:	ba 1d 02    	call      0x1dba <_sqrtf>
    667e:	00 00 00 
    6680:	00 01 be    	mov.d     w0, w2

00006682 <.L0>:
    }

    /* End of Fcn: '<S368>/f' */

    /* Product: '<S368>/Rh' incorporates:
     *  Constant: '<S368>/Re=equatorial radius'
     */
    rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    6682:	20 53 2a    	mov.w     #0xa532, w0
    6684:	21 ac 24    	mov.w     #0x4ac2, w1
    6686:	26 17 02    	call      0x1726 <___divsf3>
    6688:	00 00 00 
    668a:	10 9f 99    	mov.w     w0, [w14+434]
    668c:	21 9f 99    	mov.w     w1, [w14+436]

0000668e <.L0>:

    /* Sum: '<S368>/Sum2' */
    rtb_RhhcosphicoslambXe =
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_b[2] + rtb_Sum1_mzp;

    /* Trigonometry: '<S368>/cos(phi)' */
    rtb_cosphi = (real32_T)cos(rtb_cosphi);
    668e:	08 00 be    	mov.d     w8, w0
    6690:	22 17 02    	call      0x1722 <_cosf>
    6692:	00 00 00 
    6694:	00 05 be    	mov.d     w0, w10

00006696 <.L0>:

    /* Gain: '<S368>/Deg2R1' */
    rtb_RhhcosphisinlambYe = 0.0174532924F *
    6696:	52 a3 2f    	mov.w     #0xfa35, w2
    6698:	e3 c8 23    	mov.w     #0x3c8e, w3
    669a:	b0 c3 80    	mov.w     0x1876, w0
    669c:	c1 c3 80    	mov.w     0x1878, w1
    669e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    66a0:	00 00 00 
    66a2:	00 04 be    	mov.d     w0, w8

000066a4 <.L0>:
    66a4:	1e 99 91    	mov.w     [w14+434], w2
    66a6:	ae 99 91    	mov.w     [w14+436], w3
    66a8:	d0 c3 80    	mov.w     0x187a, w0
    66aa:	e1 c3 80    	mov.w     0x187c, w1
    66ac:	92 14 02    	call      0x1492 <___addsf3>
    66ae:	00 00 00 

000066b0 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_b[1];

    /* Product: '<S368>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
     *  Trigonometry: '<S368>/cos(lamb)'
     */
    rtb_Deg2R1 = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)cos
    66b0:	0a 01 be    	mov.d     w10, w2
    66b2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    66b4:	00 00 00 
    66b6:	00 05 be    	mov.d     w0, w10
    66b8:	08 00 be    	mov.d     w8, w0
    66ba:	22 17 02    	call      0x1722 <_cosf>
    66bc:	00 00 00 
    66be:	00 01 be    	mov.d     w0, w2
    66c0:	0a 00 be    	mov.d     w10, w0
    66c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    66c4:	00 00 00 
    66c6:	00 06 be    	mov.d     w0, w12

000066c8 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S368>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
     *  Trigonometry: '<S368>/sin(lamb)'
     */
    rtb_RhhcosphicoslambXe = rtb_RhhcosphicoslambXe * rtb_cosphi * (real32_T)sin
    66c8:	08 00 be    	mov.d     w8, w0
    66ca:	b6 1d 02    	call      0x1db6 <_sinf>
    66cc:	00 00 00 
    66ce:	50 97 99    	mov.w     w0, [w14+426]
    66d0:	61 97 99    	mov.w     w1, [w14+428]

000066d2 <.L0>:
      (rtb_RhhcosphisinlambYe);

    /* Product: '<S368>/Ze' incorporates:
     *  Product: '<S368>/Rh(1-e^2)'
     *  Sum: '<S368>/Sum4'
     */
    rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp +
    66d2:	92 94 24    	mov.w     #0x4949, w2
    66d4:	e3 f7 23    	mov.w     #0x3f7e, w3
    66d6:	1e 98 91    	mov.w     [w14+434], w0
    66d8:	ae 98 91    	mov.w     [w14+436], w1
    66da:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    66dc:	00 00 00 
    66de:	00 01 be    	mov.d     w0, w2
    66e0:	d0 c3 80    	mov.w     0x187a, w0
    66e2:	e1 c3 80    	mov.w     0x187c, w1
    66e4:	92 14 02    	call      0x1492 <___addsf3>
    66e6:	00 00 00 
    66e8:	1e b1 91    	mov.w     [w14+482], w2
    66ea:	ae b1 91    	mov.w     [w14+484], w3
    66ec:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    66ee:	00 00 00 
    66f0:	00 04 be    	mov.d     w0, w8

000066f2 <.L0>:
      AUAV_V3_TestSensors_B.GetWPCoordnavsupportcupdated5_b[2];

    /* SignalConversion: '<S367>/TmpSignal ConversionAtProduct1Inport1' incorporates:
     *  Fcn: '<S370>/11'
     *  Fcn: '<S370>/12'
     *  Fcn: '<S370>/13'
     *  Fcn: '<S370>/21'
     *  Fcn: '<S370>/22'
     *  Fcn: '<S370>/23'
     *  Fcn: '<S370>/31'
     *  Fcn: '<S370>/32'
     *  Fcn: '<S370>/33'
     */
    tmp_3[0] = (real32_T)cos(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    66f2:	2e 38 91    	mov.w     [w14+372], w0
    66f4:	be 38 91    	mov.w     [w14+374], w1
    66f6:	00 1f 99    	mov.w     w0, [w14+304]
    66f8:	11 1f 99    	mov.w     w1, [w14+306]
    tmp_3[1] = -(real32_T)sin(rtb_Deg2R_h_idx_0);
    66fa:	4e 39 91    	mov.w     [w14+376], w2
    66fc:	de 39 91    	mov.w     [w14+378], w3
    66fe:	22 1f 99    	mov.w     w2, [w14+308]
    6700:	33 1f 99    	mov.w     w3, [w14+310]
    tmp_3[2] = -(real32_T)sin(rtb_Product3_bo) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    6702:	0e 3a 91    	mov.w     [w14+368], w4
    6704:	9e 3a 91    	mov.w     [w14+370], w5
    6706:	44 1f 99    	mov.w     w4, [w14+312]
    6708:	55 1f 99    	mov.w     w5, [w14+314]
    tmp_3[3] = (real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_Product3_bo);
    670a:	6e 30 91    	mov.w     [w14+364], w0
    670c:	fe 30 91    	mov.w     [w14+366], w1
    670e:	60 1f 99    	mov.w     w0, [w14+316]
    6710:	71 1f 99    	mov.w     w1, [w14+318]
    tmp_3[4] = (real32_T)cos(rtb_Deg2R_h_idx_0);
    6712:	3e 99 91    	mov.w     [w14+438], w2
    6714:	ce 99 91    	mov.w     [w14+440], w3
    6716:	02 27 99    	mov.w     w2, [w14+320]
    6718:	13 27 99    	mov.w     w3, [w14+322]
    tmp_3[5] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)sin(rtb_Product3_bo);
    671a:	4e 32 91    	mov.w     [w14+360], w4
    671c:	de 32 91    	mov.w     [w14+362], w5
    671e:	24 27 99    	mov.w     w4, [w14+324]
    6720:	35 27 99    	mov.w     w5, [w14+326]
    tmp_3[6] = (real32_T)sin(rtb_Product3_bo);
    6722:	7e 88 91    	mov.w     [w14+414], w0
    6724:	8e 90 91    	mov.w     [w14+416], w1
    6726:	40 27 99    	mov.w     w0, [w14+328]
    6728:	51 27 99    	mov.w     w1, [w14+330]
    tmp_3[7] = 0.0F;
    672a:	60 00 b8    	mul.uu    w0, #0x0, w0
    672c:	60 27 99    	mov.w     w0, [w14+332]
    672e:	71 27 99    	mov.w     w1, [w14+334]
    tmp_3[8] = (real32_T)cos(rtb_Product3_bo);
    6730:	7e 91 91    	mov.w     [w14+430], w2
    6732:	8e 99 91    	mov.w     [w14+432], w3
    6734:	02 2f 99    	mov.w     w2, [w14+336]
    6736:	13 2f 99    	mov.w     w3, [w14+338]

00006738 <.L0>:

    /* Sum: '<S365>/Sum1' incorporates:
     *  Product: '<S367>/Product1'
     */
    rtb_Deg2R1 -= AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    6738:	72 bf 80    	mov.w     0x17ee, w2
    673a:	83 bf 80    	mov.w     0x17f0, w3
    673c:	0c 00 be    	mov.d     w12, w0
    673e:	90 14 02    	call      0x1490 <___subsf3>
    6740:	00 00 00 
    6742:	70 97 99    	mov.w     w0, [w14+430]
    6744:	01 9f 99    	mov.w     w1, [w14+432]

00006746 <.L0>:
    6746:	5e 91 91    	mov.w     [w14+426], w2
    6748:	ee 91 91    	mov.w     [w14+428], w3
    674a:	0a 00 be    	mov.d     w10, w0
    674c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    674e:	00 00 00 

00006750 <.L0>:
    rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe -
    6750:	92 bf 80    	mov.w     0x17f2, w2
    6752:	a3 bf 80    	mov.w     0x17f4, w3
    6754:	90 14 02    	call      0x1490 <___subsf3>
    6756:	00 00 00 
    6758:	70 8f 99    	mov.w     w0, [w14+414]
    675a:	01 97 99    	mov.w     w1, [w14+416]

0000675c <.L0>:
      AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    rtb_Sum1_mzp = rtb_Ze_b - AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];
    675c:	b2 bf 80    	mov.w     0x17f6, w2
    675e:	c3 bf 80    	mov.w     0x17f8, w3
    6760:	08 00 be    	mov.d     w8, w0
    6762:	90 14 02    	call      0x1490 <___subsf3>
    6764:	00 00 00 
    6766:	00 06 be    	mov.d     w0, w12
    6768:	03 13 20    	mov.w     #0x130, w3
    676a:	8e 81 41    	add.w     w3, w14, w3
    676c:	f4 81 41    	add.w     w3, #0x14, w3
    676e:	33 9f 99    	mov.w     w3, [w14+438]
    6770:	04 13 20    	mov.w     #0x130, w4
    6772:	0e 02 42    	add.w     w4, w14, w4
    6774:	68 02 42    	add.w     w4, #0x8, w4
    6776:	14 b7 99    	mov.w     w4, [w14+482]
    6778:	05 13 20    	mov.w     #0x130, w5
    677a:	8e 82 42    	add.w     w5, w14, w5
    677c:	e4 82 52    	sub.w     w5, #0x4, w5
    677e:	55 a7 99    	mov.w     w5, [w14+458]

00006780 <.L0>:

    /* Product: '<S367>/Product1' incorporates:
     *  Gain: '<S365>/UEN 2 NEU'
     */
    for (i = 0; i < 3; i++) {
    6780:	00 04 eb    	clr.w     w8
    6782:	18 9f 99    	mov.w     w8, [w14+434]

00006784 <.L0>:
      tmp_0[i] = tmp_3[i + 6] * rtb_Sum1_mzp + (tmp_3[i + 3] *
    6784:	3e 98 91    	mov.w     [w14+438], w0
    6786:	50 01 be    	mov.d     [++w0], w2
    6788:	30 9f 99    	mov.w     w0, [w14+438]
    678a:	0c 00 be    	mov.d     w12, w0
    678c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    678e:	00 00 00 
    6790:	00 05 be    	mov.d     w0, w10
    6792:	9e b0 91    	mov.w     [w14+482], w1
    6794:	51 01 be    	mov.d     [++w1], w2
    6796:	11 b7 99    	mov.w     w1, [w14+482]
    6798:	7e 88 91    	mov.w     [w14+414], w0
    679a:	8e 90 91    	mov.w     [w14+416], w1
    679c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    679e:	00 00 00 
    67a0:	00 04 be    	mov.d     w0, w8

000067a2 <.L0>:
        rtb_RhhcosphisinlambYe + tmp_3[i] * rtb_Deg2R1);
    67a2:	5e a2 91    	mov.w     [w14+458], w4
    67a4:	54 01 be    	mov.d     [++w4], w2
    67a6:	54 a7 99    	mov.w     w4, [w14+458]
    67a8:	7e 90 91    	mov.w     [w14+430], w0
    67aa:	8e 98 91    	mov.w     [w14+432], w1
    67ac:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    67ae:	00 00 00 
    67b0:	00 01 be    	mov.d     w0, w2
    67b2:	08 00 be    	mov.d     w8, w0
    67b4:	92 14 02    	call      0x1492 <___addsf3>
    67b6:	00 00 00 
    67b8:	00 01 be    	mov.d     w0, w2

000067ba <.L0>:
    67ba:	0a 00 be    	mov.d     w10, w0
    67bc:	92 14 02    	call      0x1492 <___addsf3>
    67be:	00 00 00 
    67c0:	fe aa 91    	mov.w     [w14+478], w5
    67c2:	80 aa be    	mov.d     w0, [++w5]
    67c4:	75 af 99    	mov.w     w5, [w14+478]

000067c6 <.L0>:
    67c6:	1e 98 91    	mov.w     [w14+434], w0
    67c8:	00 00 e8    	inc.w     w0, w0
    67ca:	10 9f 99    	mov.w     w0, [w14+434]
    67cc:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    67ce:	da ff 3a    	bra       NZ, 0x6784 <.L0> <.L173>
    }

    /* Gain: '<S365>/UEN 2 NEU' */
    for (i = 0; i < 3; i++) {
      rtb_Product2_c[i] = AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0[2]
    67d0:	2e b6 90    	mov.w     [w14+228], w12
    67d2:	be b6 90    	mov.w     [w14+230], w13
        + (AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1] +
    67d4:	0e b1 90    	mov.w     [w14+224], w2
    67d6:	9e b1 90    	mov.w     [w14+226], w3
    67d8:	12 b7 99    	mov.w     w2, [w14+482]
    67da:	23 b7 99    	mov.w     w3, [w14+484]
           AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0]);
    67dc:	6e aa 90    	mov.w     [w14+220], w4
    67de:	fe aa 90    	mov.w     [w14+222], w5
    67e0:	54 a7 99    	mov.w     w4, [w14+458]
    67e2:	65 a7 99    	mov.w     w5, [w14+460]
    67e4:	c5 02 20    	mov.w     #0x2c, w5
    67e6:	85 02 47    	add.w     w14, w5, w5
    67e8:	75 af 99    	mov.w     w5, [w14+478]
    67ea:	00 04 eb    	clr.w     w8
    67ec:	38 9f 99    	mov.w     w8, [w14+438]

000067ee <.L0>:
    67ee:	1e a0 91    	mov.w     [w14+450], w0
    67f0:	50 01 be    	mov.d     [++w0], w2
    67f2:	10 a7 99    	mov.w     w0, [w14+450]
    67f4:	0c 00 be    	mov.d     w12, w0
    67f6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    67f8:	00 00 00 
    67fa:	00 05 be    	mov.d     w0, w10

000067fc <.L0>:
    67fc:	de b0 91    	mov.w     [w14+490], w1
    67fe:	51 01 be    	mov.d     [++w1], w2
    6800:	51 b7 99    	mov.w     w1, [w14+490]
    6802:	1e b0 91    	mov.w     [w14+482], w0
    6804:	ae b0 91    	mov.w     [w14+484], w1
    6806:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6808:	00 00 00 
    680a:	00 04 be    	mov.d     w0, w8

0000680c <.L0>:
    680c:	1e aa 91    	mov.w     [w14+466], w4
    680e:	54 01 be    	mov.d     [++w4], w2
    6810:	14 af 99    	mov.w     w4, [w14+466]
    6812:	5e a0 91    	mov.w     [w14+458], w0
    6814:	ee a0 91    	mov.w     [w14+460], w1
    6816:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6818:	00 00 00 
    681a:	00 01 be    	mov.d     w0, w2

0000681c <.L0>:
    681c:	08 00 be    	mov.d     w8, w0
    681e:	92 14 02    	call      0x1492 <___addsf3>
    6820:	00 00 00 
    6822:	00 01 be    	mov.d     w0, w2
    6824:	0a 00 be    	mov.d     w10, w0
    6826:	92 14 02    	call      0x1492 <___addsf3>
    6828:	00 00 00 

0000682a <.L0>:
    682a:	fe aa 91    	mov.w     [w14+478], w5
    682c:	80 aa be    	mov.d     w0, [++w5]
    682e:	75 af 99    	mov.w     w5, [w14+478]
    6830:	3e 98 91    	mov.w     [w14+438], w0
    6832:	00 00 e8    	inc.w     w0, w0
    6834:	30 9f 99    	mov.w     w0, [w14+438]
    6836:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    6838:	da ff 3a    	bra       NZ, 0x67ee <.L0> <.L174>

0000683a <.L0>:
    }

    rtb_Product3_j0[0] = rtb_Product2_c[0] - rtb_Product3_j0[0];
    683a:	1e 01 be    	mov.d     [w14], w2
    683c:	0e 18 90    	mov.w     [w14+48], w0
    683e:	9e 18 90    	mov.w     [w14+50], w1
    6840:	90 14 02    	call      0x1490 <___subsf3>
    6842:	00 00 00 
    6844:	00 8f be    	mov.d     w0, [w14]

00006846 <.L0>:
    rtb_Product3_j0[1] = rtb_Product2_c[1] - rtb_Product3_j0[1];
    6846:	2e 01 90    	mov.w     [w14+4], w2
    6848:	be 01 90    	mov.w     [w14+6], w3
    684a:	2e 18 90    	mov.w     [w14+52], w0
    684c:	be 18 90    	mov.w     [w14+54], w1
    684e:	90 14 02    	call      0x1490 <___subsf3>
    6850:	00 00 00 
    6852:	20 07 98    	mov.w     w0, [w14+4]
    6854:	31 07 98    	mov.w     w1, [w14+6]

00006856 <.L0>:
    rtb_Product3_j0[2] = rtb_Product2_c[2] - rtb_Product3_j0[2];
    6856:	4e 01 90    	mov.w     [w14+8], w2
    6858:	de 01 90    	mov.w     [w14+10], w3
    685a:	4e 18 90    	mov.w     [w14+56], w0
    685c:	de 18 90    	mov.w     [w14+58], w1
    685e:	90 14 02    	call      0x1490 <___subsf3>
    6860:	00 00 00 
    6862:	40 07 98    	mov.w     w0, [w14+8]
    6864:	51 07 98    	mov.w     w1, [w14+10]

00006866 <.L0>:

    /* MATLAB Function: '<S334>/Embedded MATLAB Function' incorporates:
     *  Sum: '<S324>/Add'
     */
    A_EmbeddedMATLABFunction_b(rtb_Product3_j0,
    6866:	c1 d1 21    	mov.w     #0x1d1c, w1
    6868:	0e 00 78    	mov.w     w14, w0
    686a:	87 f3 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

0000686c <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ih);

    /* MATLAB Function: '<S335>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ih.xDoty,
    686c:	82 d1 21    	mov.w     #0x1d18, w2
    686e:	e0 e8 80    	mov.w     0x1d1c, w0
    6870:	f1 e8 80    	mov.w     0x1d1e, w1
    6872:	71 f3 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006874 <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_bi);

    /* S-Function (MCHP_C_function_Call): '<S335>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_pr = mySqrt(
    6874:	c0 e8 80    	mov.w     0x1d18, w0
    6876:	d1 e8 80    	mov.w     0x1d1a, w1
    6878:	16 10 02    	call      0x11016 <_mySqrt>
    687a:	01 00 00 
    687c:	00 04 be    	mov.d     w0, w8
    687e:	f0 c3 88    	mov.w     w0, 0x187e
    6880:	01 c4 88    	mov.w     w1, 0x1880

00006882 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_bi.zpVal
      );

    /* Saturate: '<S330>/Zero Bound' */
    if (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_pr <= 0.001F) {
    6882:	f2 26 21    	mov.w     #0x126f, w2
    6884:	33 a8 23    	mov.w     #0x3a83, w3
    6886:	8c 18 02    	call      0x188c <___eqsf2>
    6888:	00 00 00 
    688a:	00 00 e0    	cp0.w     w0
    688c:	02 00 3c    	bra       GT, 0x6892 <.L0> <.L175>

0000688e <.L0>:
      rtb_RhhcosphisinlambYe = 0.001F;
    688e:	f8 26 21    	mov.w     #0x126f, w8
    6890:	39 a8 23    	mov.w     #0x3a83, w9

00006892 <.L0>:
    } else {
      rtb_RhhcosphisinlambYe =
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_pr;
    }

    /* End of Saturate: '<S330>/Zero Bound' */
    rtb_Product3_j0[0] /= rtb_RhhcosphisinlambYe;
    6892:	08 01 be    	mov.d     w8, w2
    6894:	1e 00 be    	mov.d     [w14], w0
    6896:	26 17 02    	call      0x1726 <___divsf3>
    6898:	00 00 00 
    689a:	00 8f be    	mov.d     w0, [w14]

0000689c <.L0>:
    rtb_Product3_j0[1] /= rtb_RhhcosphisinlambYe;
    689c:	08 01 be    	mov.d     w8, w2
    689e:	2e 00 90    	mov.w     [w14+4], w0
    68a0:	be 00 90    	mov.w     [w14+6], w1
    68a2:	26 17 02    	call      0x1726 <___divsf3>
    68a4:	00 00 00 
    68a6:	20 07 98    	mov.w     w0, [w14+4]
    68a8:	31 07 98    	mov.w     w1, [w14+6]

000068aa <.L0>:
    rtb_Product3_j0[2] /= rtb_RhhcosphisinlambYe;
    68aa:	08 01 be    	mov.d     w8, w2
    68ac:	4e 00 90    	mov.w     [w14+8], w0
    68ae:	de 00 90    	mov.w     [w14+10], w1
    68b0:	26 17 02    	call      0x1726 <___divsf3>
    68b2:	00 00 00 
    68b4:	40 07 98    	mov.w     w0, [w14+8]
    68b6:	51 07 98    	mov.w     w1, [w14+10]

000068b8 <.L0>:

    /* MATLAB Function: '<S324>/Select N  Terms' incorporates:
     *  Product: '<S330>/Divide'
     */
    AUAV_V3_TestS_SelectNTerms(rtb_Product3_j0,
    68b8:	41 d0 21    	mov.w     #0x1d04, w1
    68ba:	0e 00 78    	mov.w     w14, w0
    68bc:	b3 f3 07    	rcall     0x5024 <_AUAV_V3_TestS_SelectNTerms> <L0> <.LFB1485> <.LFE1484>

000068be <.L0>:
      &AUAV_V3_TestSensors_B.sf_SelectNTerms);

    /* MATLAB Function: '<S341>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.sf_SelectNTerms.N,
    68be:	41 d1 21    	mov.w     #0x1d14, w1
    68c0:	70 80 50    	sub.w     w1, #0x10, w0
    68c2:	5b f3 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

000068c4 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b1);

    /* MATLAB Function: '<S342>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b1.xDoty,
    68c4:	02 d1 21    	mov.w     #0x1d10, w2
    68c6:	a0 e8 80    	mov.w     0x1d14, w0
    68c8:	b1 e8 80    	mov.w     0x1d16, w1
    68ca:	45 f3 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

000068cc <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_n);

    /* S-Function (MCHP_C_function_Call): '<S342>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m4 = mySqrt(
    68cc:	80 e8 80    	mov.w     0x1d10, w0
    68ce:	91 e8 80    	mov.w     0x1d12, w1
    68d0:	16 10 02    	call      0x11016 <_mySqrt>
    68d2:	01 00 00 
    68d4:	00 04 be    	mov.d     w0, w8
    68d6:	10 c4 88    	mov.w     w0, 0x1882
    68d8:	21 c4 88    	mov.w     w1, 0x1884

000068da <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_n.zpVal
      );

    /* Saturate: '<S331>/Zero Bound' */
    if (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m4 <= 0.001F) {
    68da:	f2 26 21    	mov.w     #0x126f, w2
    68dc:	33 a8 23    	mov.w     #0x3a83, w3
    68de:	8c 18 02    	call      0x188c <___eqsf2>
    68e0:	00 00 00 
    68e2:	00 00 e0    	cp0.w     w0
    68e4:	02 00 3c    	bra       GT, 0x68ea <.L0> <.L177>

000068e6 <.L0>:
      rtb_RhhcosphisinlambYe = 0.001F;
    68e6:	f8 26 21    	mov.w     #0x126f, w8
    68e8:	39 a8 23    	mov.w     #0x3a83, w9

000068ea <.L0>:
    } else {
      rtb_RhhcosphisinlambYe =
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m4;
    }

    /* End of Saturate: '<S331>/Zero Bound' */

    /* Product: '<S331>/Divide' */
    rtb_Merge_m[0] = AUAV_V3_TestSensors_B.sf_SelectNTerms.N[0] /
    68ea:	08 01 be    	mov.d     w8, w2
    68ec:	20 e8 80    	mov.w     0x1d04, w0
    68ee:	31 e8 80    	mov.w     0x1d06, w1
    68f0:	26 17 02    	call      0x1726 <___divsf3>
    68f2:	00 00 00 
    68f4:	60 3f 98    	mov.w     w0, [w14+124]
    68f6:	71 3f 98    	mov.w     w1, [w14+126]

000068f8 <.L0>:
      rtb_RhhcosphisinlambYe;
    rtb_Merge_m[1] = AUAV_V3_TestSensors_B.sf_SelectNTerms.N[1] /
    68f8:	08 01 be    	mov.d     w8, w2
    68fa:	40 e8 80    	mov.w     0x1d08, w0
    68fc:	51 e8 80    	mov.w     0x1d0a, w1
    68fe:	26 17 02    	call      0x1726 <___divsf3>
    6900:	00 00 00 
    6902:	00 87 98    	mov.w     w0, [w14+128]
    6904:	11 87 98    	mov.w     w1, [w14+130]

00006906 <.L0>:
      rtb_RhhcosphisinlambYe;
    rtb_Merge_m[2] = AUAV_V3_TestSensors_B.sf_SelectNTerms.N[2] /
    6906:	08 01 be    	mov.d     w8, w2
    6908:	60 e8 80    	mov.w     0x1d0c, w0
    690a:	71 e8 80    	mov.w     0x1d0e, w1
    690c:	26 17 02    	call      0x1726 <___divsf3>
    690e:	00 00 00 
    6910:	20 87 98    	mov.w     w0, [w14+132]
    6912:	31 87 98    	mov.w     w1, [w14+134]

00006914 <.L0>:
      rtb_RhhcosphisinlambYe;

    /* Delay: '<S303>/Integer Delay1' */
    AUAV_V3_TestSensors_B.Merge1 =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_gn;
    6914:	c8 e5 21    	mov.w     #0x1e5c, w8
    6916:	18 01 be    	mov.d     [w8], w2
    6918:	b2 bd 88    	mov.w     w2, 0x17b6
    691a:	c3 bd 88    	mov.w     w3, 0x17b8

0000691c <.L0>:

    /* MATLAB Function: '<S303>/Zero out Z1' */
    AUAV_V3_TestSens_ZerooutZ1(rtb_Merge_m,
    691c:	81 cf 21    	mov.w     #0x1cf8, w1
    691e:	c0 07 20    	mov.w     #0x7c, w0
    6920:	0e 00 40    	add.w     w0, w14, w0
    6922:	51 f3 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00006924 <.L0>:
      &AUAV_V3_TestSensors_B.sf_ZerooutZ1_j);

    /* MATLAB Function: '<S303>/Zero out Z2' */
    AUAV_V3_TestSens_ZerooutZ1(rtb_Product3_j0,
    6924:	c1 ce 21    	mov.w     #0x1cec, w1
    6926:	0e 00 78    	mov.w     w14, w0
    6928:	4e f3 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

0000692a <.L0>:
      &AUAV_V3_TestSensors_B.sf_ZerooutZ2_e);

    /* MATLAB Function: '<S303>/Zero out Z3' */
    AUAV_V3_TestSens_ZerooutZ1(rtb_Product2_c,
    692a:	01 ce 21    	mov.w     #0x1ce0, w1
    692c:	00 03 20    	mov.w     #0x30, w0
    692e:	0e 00 40    	add.w     w0, w14, w0
    6930:	4a f3 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00006932 <.L0>:
      &AUAV_V3_TestSensors_B.sf_ZerooutZ3);

    /* Product: '<S303>/Product1' incorporates:
     *  DataStoreRead: '<Root>/PAR_NAV_L2_BASE PAR_NAV_PRETURN_K PAR_NAV_SSCOMP_ON'
     */
    AUAV_V3_TestSensors_B.Product1 = mlParamInterface.param[20] *
    6932:	32 bc 80    	mov.w     0x1786, w2
    6934:	43 bc 80    	mov.w     0x1788, w3
    6936:	50 95 80    	mov.w     0x12aa, w0
    6938:	61 95 80    	mov.w     0x12ac, w1
    693a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    693c:	00 00 00 
    693e:	30 c4 88    	mov.w     w0, 0x1886
    6940:	41 c4 88    	mov.w     w1, 0x1888

00006942 <.L0>:
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116;

    /* Update for Delay: '<S303>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_gn = rtb_Product2_c[2];
    6942:	4e 1a 90    	mov.w     [w14+56], w4
    6944:	de 1a 90    	mov.w     [w14+58], w5
    6946:	04 8c be    	mov.d     w4, [w8]

    /* End of Outputs for SubSystem: '<S187>/Get Frenet' */

    /* Sum: '<S301>/Subtract' */
    rtb_Product3_j0[0] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0] -
    6948:	c8 c2 21    	mov.w     #0x1c2c, w8
      AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[0];
    694a:	49 0b 20    	mov.w     #0xb4, w9
    694c:	88 84 44    	add.w     w9, w8, w9

0000694e <.L0>:
    694e:	19 01 be    	mov.d     [w9], w2
    6950:	18 00 be    	mov.d     [w8], w0
    6952:	90 14 02    	call      0x1490 <___subsf3>
    6954:	00 00 00 
    6956:	00 8f be    	mov.d     w0, [w14]

00006958 <.L0>:
    rtb_Product3_j0[1] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1] -
    6958:	64 05 44    	add.w     w8, #0x4, w10
      AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[1];
    695a:	64 86 44    	add.w     w9, #0x4, w12

0000695c <.L0>:
    695c:	1c 01 be    	mov.d     [w12], w2
    695e:	1a 00 be    	mov.d     [w10], w0
    6960:	90 14 02    	call      0x1490 <___subsf3>
    6962:	00 00 00 
    6964:	20 07 98    	mov.w     w0, [w14+4]
    6966:	31 07 98    	mov.w     w1, [w14+6]

00006968 <.L0>:
    rtb_Product3_j0[2] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2] -
    6968:	e8 06 44    	add.w     w8, #0x8, w13
      AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[2];
    696a:	e8 85 44    	add.w     w9, #0x8, w11

0000696c <.L0>:
    696c:	1b 01 be    	mov.d     [w11], w2
    696e:	1d 00 be    	mov.d     [w13], w0
    6970:	90 14 02    	call      0x1490 <___subsf3>
    6972:	00 00 00 
    6974:	40 07 98    	mov.w     w0, [w14+8]
    6976:	51 07 98    	mov.w     w1, [w14+10]

00006978 <.L0>:

    /* MATLAB Function: '<S309>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_k(rtb_Product3_j0,
    6978:	82 0f 20    	mov.w     #0xf8, w2
    697a:	08 01 41    	add.w     w2, w8, w2
    697c:	f8 80 44    	add.w     w9, #0x18, w1
    697e:	0e 00 78    	mov.w     w14, w0
    6980:	2c f3 07    	rcall     0x4fda <_A_EmbeddedMATLABFunction_k> <L0> <.LFB1484> <.LFE1483>

00006982 <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ1_j.P,
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_o);

    /* S-Function (MCHP_C_function_Call): '<S310>/myAbs() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_i = myAbs(
    6982:	20 e9 80    	mov.w     0x1d24, w0
    6984:	31 e9 80    	mov.w     0x1d26, w1
    6986:	1c 10 02    	call      0x1101c <_myAbs>
    6988:	01 00 00 
    698a:	90 c1 88    	mov.w     w0, 0x1832
    698c:	a1 c1 88    	mov.w     w1, 0x1834

0000698e <.L0>:
      AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_o.xDoty
      );

    /* Sum: '<S308>/Subtract' */
    rtb_Product2_c[0] = AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[0] -
    698e:	18 01 be    	mov.d     [w8], w2
    6990:	19 00 be    	mov.d     [w9], w0
    6992:	90 14 02    	call      0x1490 <___subsf3>
    6994:	00 00 00 
    6996:	00 1f 98    	mov.w     w0, [w14+48]
    6998:	11 1f 98    	mov.w     w1, [w14+50]

0000699a <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    rtb_Product2_c[1] = AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[1] -
    699a:	1a 01 be    	mov.d     [w10], w2
    699c:	1c 00 be    	mov.d     [w12], w0
    699e:	90 14 02    	call      0x1490 <___subsf3>
    69a0:	00 00 00 
    69a2:	20 1f 98    	mov.w     w0, [w14+52]
    69a4:	31 1f 98    	mov.w     w1, [w14+54]

000069a6 <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    rtb_Product2_c[2] = AUAV_V3_TestSensors_B.sf_ZerooutZ3.P[2] -
    69a6:	1d 01 be    	mov.d     [w13], w2
    69a8:	1b 00 be    	mov.d     [w11], w0
    69aa:	90 14 02    	call      0x1490 <___subsf3>
    69ac:	00 00 00 
    69ae:	40 1f 98    	mov.w     w0, [w14+56]
    69b0:	51 1f 98    	mov.w     w1, [w14+58]

000069b2 <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];

    /* MATLAB Function: '<S316>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_k(rtb_Product2_c,
    69b2:	c2 0f 20    	mov.w     #0xfc, w2
    69b4:	08 01 41    	add.w     w2, w8, w2
    69b6:	ec 80 44    	add.w     w9, #0xc, w1
    69b8:	00 03 20    	mov.w     #0x30, w0
    69ba:	0e 00 40    	add.w     w0, w14, w0
    69bc:	0e f3 07    	rcall     0x4fda <_A_EmbeddedMATLABFunction_k> <L0> <.LFB1484> <.LFE1483>

000069be <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ2_e.P,
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_k);

    /* Switch: '<S315>/Switch3' incorporates:
     *  RelationalOperator: '<S315>/Relational Operator2'
     */
    if ((AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_k.xDoty ==
         AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_k.xDoty) > 0) {
    69be:	48 e9 80    	mov.w     0x1d28, w8
    69c0:	59 e9 80    	mov.w     0x1d2a, w9

000069c2 <.L0>:
    69c2:	08 01 be    	mov.d     w8, w2
    69c4:	08 00 be    	mov.d     w8, w0
    69c6:	8c 18 02    	call      0x188c <___eqsf2>
    69c8:	00 00 00 
    69ca:	00 00 e0    	cp0.w     w0
    69cc:	02 00 3a    	bra       NZ, 0x69d2 <.L0> <.L179>

000069ce <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_p =
    69ce:	c8 f2 88    	mov.w     w8, 0x1e58
    69d0:	d9 f2 88    	mov.w     w9, 0x1e5a

000069d2 <.L0>:
        AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_k.xDoty;
    }

    /* End of Switch: '<S315>/Switch3' */

    /* Product: '<S301>/Divide' incorporates:
     *  Constant: '<S301>/Constant4'
     */
    rtb_Sum1_mzp = AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_i /
    69d2:	98 c1 80    	mov.w     0x1832, w8
    69d4:	a9 c1 80    	mov.w     0x1834, w9
    69d6:	a2 d3 2c    	mov.w     #0xcd3a, w2
    69d8:	33 f1 23    	mov.w     #0x3f13, w3
    69da:	08 00 be    	mov.d     w8, w0
    69dc:	26 17 02    	call      0x1726 <___divsf3>
    69de:	00 00 00 
    69e0:	00 06 be    	mov.d     w0, w12

000069e2 <.L0>:
      0.577350259F;

    /* Switch: '<S314>/Switch' incorporates:
     *  Product: '<S301>/Divide1'
     *  RelationalOperator: '<S314>/Relational Operator'
     */
    if (rtb_Product_lf < rtb_Sum1_mzp) {
    69e2:	00 01 be    	mov.d     w0, w2
    69e4:	5e a8 91    	mov.w     [w14+474], w0
    69e6:	ee a8 91    	mov.w     [w14+476], w1
    69e8:	8c 18 02    	call      0x188c <___eqsf2>
    69ea:	00 00 00 
    69ec:	00 00 e0    	cp0.w     w0
    69ee:	02 00 3d    	bra       GE, 0x69f4 <.L0> <.L181>

000069f0 <.L0>:
      rtb_Sum1_mzp = rtb_Product_lf;
    69f0:	5e ae 91    	mov.w     [w14+474], w12
    69f2:	ee ae 91    	mov.w     [w14+476], w13

000069f4 <.L0>:
    }

    /* End of Switch: '<S314>/Switch' */

    /* MATLAB Function: '<S311>/negprotect' incorporates:
     *  Product: '<S301>/Product'
     *  Product: '<S301>/Product1'
     *  Sum: '<S301>/Add'
     */
    AUAV_V3_TestS_negprotect_l(rtb_Product_lf * rtb_Product_lf -
    69f4:	5e a9 91    	mov.w     [w14+474], w2
    69f6:	ee a9 91    	mov.w     [w14+476], w3
    69f8:	02 00 be    	mov.d     w2, w0
    69fa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    69fc:	00 00 00 
    69fe:	00 05 be    	mov.d     w0, w10

00006a00 <.L0>:
      AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_i *
    6a00:	08 01 be    	mov.d     w8, w2
    6a02:	08 00 be    	mov.d     w8, w0
    6a04:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6a06:	00 00 00 
    6a08:	00 01 be    	mov.d     w0, w2

00006a0a <.L0>:
    6a0a:	0a 00 be    	mov.d     w10, w0
    6a0c:	90 14 02    	call      0x1490 <___subsf3>
    6a0e:	00 00 00 
    6a10:	02 d2 21    	mov.w     #0x1d20, w2
    6a12:	a1 f2 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006a14 <.L0>:
      AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_i,
      &AUAV_V3_TestSensors_B.sf_negprotect_p);

    /* S-Function (MCHP_C_function_Call): '<S311>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_d = mySqrt(
    6a14:	00 e9 80    	mov.w     0x1d20, w0
    6a16:	11 e9 80    	mov.w     0x1d22, w1
    6a18:	16 10 02    	call      0x11016 <_mySqrt>
    6a1a:	01 00 00 
    6a1c:	00 04 be    	mov.d     w0, w8
    6a1e:	b0 c1 88    	mov.w     w0, 0x1836
    6a20:	c1 c1 88    	mov.w     w1, 0x1838

00006a22 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_p.zpVal
      );

    /* Switch: '<S187>/Switch' incorporates:
     *  Product: '<S301>/Product2'
     *  Sum: '<S301>/Add3'
     *  Switch: '<S187>/Switch1'
     */
    if (AUAV_V3_TestSensors_B.IC > 0) {
    6a22:	b0 a9 21    	mov.w     #0x1a9b, w0
    6a24:	10 04 e0    	cp0.b     [w0]
    6a26:	57 00 32    	bra       Z, 0x6ad6 <.L182>

00006a28 <.L0>:
      /* Switch: '<S313>/Switch' incorporates:
       *  RelationalOperator: '<S301>/Relational Operator'
       *  RelationalOperator: '<S313>/Relational Operator'
       *  Switch: '<S301>/Switch1'
       */
      if ((!(AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_i > rtb_Product_lf))
    6a28:	1a c0 b3    	mov.b     #0x1, w10
    6a2a:	5e a9 91    	mov.w     [w14+474], w2
    6a2c:	ee a9 91    	mov.w     [w14+476], w3
    6a2e:	90 c1 80    	mov.w     0x1832, w0
    6a30:	a1 c1 80    	mov.w     0x1834, w1
    6a32:	90 18 02    	call      0x1890 <___gesf2>
    6a34:	00 00 00 
    6a36:	00 00 e0    	cp0.w     w0
    6a38:	01 00 3c    	bra       GT, 0x6a3c <.L184>
    6a3a:	00 45 eb    	clr.b     w10

00006a3c <.L184>:
    6a3c:	0a 04 e0    	cp0.b     w10
    6a3e:	0b 00 3a    	bra       NZ, 0x6a56 <.L0> <.L183>

00006a40 <.L0>:
          && (!(rtb_Sum1_mzp > AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_d)))
    6a40:	1a c0 b3    	mov.b     #0x1, w10
    6a42:	08 01 be    	mov.d     w8, w2
    6a44:	0c 00 be    	mov.d     w12, w0
    6a46:	90 18 02    	call      0x1890 <___gesf2>
    6a48:	00 00 00 
    6a4a:	00 00 e0    	cp0.w     w0
    6a4c:	01 00 3c    	bra       GT, 0x6a50 <.L185>
    6a4e:	00 45 eb    	clr.b     w10

00006a50 <.L185>:
    6a50:	0a 04 e0    	cp0.b     w10
    6a52:	01 00 3a    	bra       NZ, 0x6a56 <.L0> <.L183>

00006a54 <.L0>:
      {
        rtb_Sum1_mzp = AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_d;
    6a54:	08 06 be    	mov.d     w8, w12

00006a56 <.L0>:
      }

      /* End of Switch: '<S313>/Switch' */

      /* Sum: '<S301>/Add1' */
      rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_p
    6a56:	ca f2 80    	mov.w     0x1e58, w10
    6a58:	db f2 80    	mov.w     0x1e5a, w11
    6a5a:	0c 01 be    	mov.d     w12, w2
    6a5c:	0a 00 be    	mov.d     w10, w0
    6a5e:	90 14 02    	call      0x1490 <___subsf3>
    6a60:	00 00 00 
    6a62:	00 04 be    	mov.d     w0, w8

00006a64 <.L0>:
        - rtb_Sum1_mzp;

      /* Switch: '<S312>/Switch' incorporates:
       *  Constant: '<S301>/Constant1'
       *  RelationalOperator: '<S312>/Relational Operator'
       */
      if (!(rtb_RhhcosphisinlambYe > 0.0F)) {
    6a64:	1c c0 b3    	mov.b     #0x1, w12
    6a66:	60 11 b8    	mul.uu    w2, #0x0, w2
    6a68:	90 18 02    	call      0x1890 <___gesf2>
    6a6a:	00 00 00 
    6a6c:	00 00 e0    	cp0.w     w0
    6a6e:	01 00 3c    	bra       GT, 0x6a72 <.L187>
    6a70:	00 46 eb    	clr.b     w12

00006a72 <.L187>:
    6a72:	0c 04 e0    	cp0.b     w12
    6a74:	01 00 3a    	bra       NZ, 0x6a78 <.L0> <.L186>

00006a76 <.L0>:
        rtb_RhhcosphisinlambYe = 0.0F;
    6a76:	60 44 b8    	mul.uu    w8, #0x0, w8

00006a78 <.L0>:
      }

      /* End of Switch: '<S312>/Switch' */
      AUAV_V3_TestSensors_B.Merge_o[0] = (0.0F - rtb_RhhcosphisinlambYe *
    6a78:	62 e7 80    	mov.w     0x1cec, w2
    6a7a:	73 e7 80    	mov.w     0x1cee, w3
    6a7c:	08 00 be    	mov.d     w8, w0
    6a7e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6a80:	00 00 00 
    6a82:	00 01 be    	mov.d     w0, w2
    6a84:	60 00 b8    	mul.uu    w0, #0x0, w0
    6a86:	90 14 02    	call      0x1490 <___subsf3>
    6a88:	00 00 00 

00006a8a <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_e.P[0]) - rtb_Product3_j0[0];
    6a8a:	1e 01 be    	mov.d     [w14], w2
    6a8c:	90 14 02    	call      0x1490 <___subsf3>
    6a8e:	00 00 00 

00006a90 <.L0>:
    6a90:	50 bc 88    	mov.w     w0, 0x178a
    6a92:	61 bc 88    	mov.w     w1, 0x178c

00006a94 <.L0>:
      AUAV_V3_TestSensors_B.Merge_o[1] = (0.0F - rtb_RhhcosphisinlambYe *
    6a94:	82 e7 80    	mov.w     0x1cf0, w2
    6a96:	93 e7 80    	mov.w     0x1cf2, w3
    6a98:	08 00 be    	mov.d     w8, w0
    6a9a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6a9c:	00 00 00 
    6a9e:	00 01 be    	mov.d     w0, w2
    6aa0:	60 00 b8    	mul.uu    w0, #0x0, w0
    6aa2:	90 14 02    	call      0x1490 <___subsf3>
    6aa4:	00 00 00 

00006aa6 <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_e.P[1]) - rtb_Product3_j0[1];
    6aa6:	2e 01 90    	mov.w     [w14+4], w2
    6aa8:	be 01 90    	mov.w     [w14+6], w3
    6aaa:	90 14 02    	call      0x1490 <___subsf3>
    6aac:	00 00 00 

00006aae <.L0>:
    6aae:	70 bc 88    	mov.w     w0, 0x178e
    6ab0:	81 bc 88    	mov.w     w1, 0x1790

00006ab2 <.L0>:
      AUAV_V3_TestSensors_B.Merge_o[2] = (0.0F - rtb_RhhcosphisinlambYe *
    6ab2:	a2 e7 80    	mov.w     0x1cf4, w2
    6ab4:	b3 e7 80    	mov.w     0x1cf6, w3
    6ab6:	08 00 be    	mov.d     w8, w0
    6ab8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6aba:	00 00 00 
    6abc:	00 01 be    	mov.d     w0, w2
    6abe:	60 00 b8    	mul.uu    w0, #0x0, w0
    6ac0:	90 14 02    	call      0x1490 <___subsf3>
    6ac2:	00 00 00 

00006ac4 <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_e.P[2]) - rtb_Product3_j0[2];
    6ac4:	4e 01 90    	mov.w     [w14+8], w2
    6ac6:	de 01 90    	mov.w     [w14+10], w3
    6ac8:	90 14 02    	call      0x1490 <___subsf3>
    6aca:	00 00 00 

00006acc <.L0>:
    6acc:	90 bc 88    	mov.w     w0, 0x1792
    6ace:	a1 bc 88    	mov.w     w1, 0x1794
      AUAV_V3_TestSensors_B.Merge2 =
    6ad0:	3a bd 88    	mov.w     w10, 0x17a6
    6ad2:	4b bd 88    	mov.w     w11, 0x17a8
    6ad4:	04 00 37    	bra       0x6ade <.L0> <.L188>

00006ad6 <.L182>:
        AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_p;
    } else {
      AUAV_V3_TestSensors_B.Merge2 =
    6ad6:	70 c1 80    	mov.w     0x182e, w0
    6ad8:	81 c1 80    	mov.w     0x1830, w1
    6ada:	30 bd 88    	mov.w     w0, 0x17a6
    6adc:	41 bd 88    	mov.w     w1, 0x17a8

00006ade <.L0>:
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_b;
    }

    /* End of Switch: '<S187>/Switch' */

    /* Update for Delay: '<S187>/Integer Delay' incorporates:
     *  RelationalOperator: '<S301>/Switch Distance Less than?'
     */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_im = (uint8_T)
    6ade:	18 c0 b3    	mov.b     #0x1, w8
    6ae0:	32 c4 80    	mov.w     0x1886, w2
    6ae2:	43 c4 80    	mov.w     0x1888, w3
    6ae4:	c0 f2 80    	mov.w     0x1e58, w0
    6ae6:	d1 f2 80    	mov.w     0x1e5a, w1
    6ae8:	8c 18 02    	call      0x188c <___eqsf2>
    6aea:	00 00 00 
    6aec:	00 00 e0    	cp0.w     w0
    6aee:	01 00 35    	bra       LT, 0x6af2 <.L189>
    6af0:	00 44 eb    	clr.b     w8

00006af2 <.L189>:
    6af2:	80 ff 21    	mov.w     #0x1ff8, w0
    6af4:	08 48 78    	mov.b     w8, [w0]
    6af6:	67 03 37    	bra       0x71c6 <.L0> <.L143>

00006af8 <.L0>:
      (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_p <
       AUAV_V3_TestSensors_B.Product1);

    /* End of Outputs for SubSystem: '<S180>/Normal WP  Navigation' */
  } else if (rtb_Compare_j == 10) {
    6af8:	ea 4f 50    	sub.b     w0, #0xa, [w15]
    6afa:	2e 00 3a    	bra       NZ, 0x6b58 <.L190>
    /* Outputs for IfAction SubSystem: '<S180>/Line Segment' incorporates:
     *  ActionPort: '<S185>/Action Port'
     */
    /* Gain: '<S185>/Gain' */
    AUAV_V3_TestSensors_B.Merge_o[0] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    6afc:	60 e1 80    	mov.w     0x1c2c, w0
    6afe:	71 e1 80    	mov.w     0x1c2e, w1
    6b00:	00 02 be    	mov.d     w0, w4
    6b02:	05 f0 a2    	btg.w     w5, #0xf
    6b04:	54 bc 88    	mov.w     w4, 0x178a
    6b06:	65 bc 88    	mov.w     w5, 0x178c
    AUAV_V3_TestSensors_B.Merge_o[1] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    6b08:	82 e1 80    	mov.w     0x1c30, w2
    6b0a:	93 e1 80    	mov.w     0x1c32, w3
    6b0c:	03 f0 a2    	btg.w     w3, #0xf
    6b0e:	72 bc 88    	mov.w     w2, 0x178e
    6b10:	83 bc 88    	mov.w     w3, 0x1790
    AUAV_V3_TestSensors_B.Merge_o[2] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
    6b12:	a0 e1 80    	mov.w     0x1c34, w0
    6b14:	b1 e1 80    	mov.w     0x1c36, w1
    6b16:	01 f0 a2    	btg.w     w1, #0xf
    6b18:	90 bc 88    	mov.w     w0, 0x1792
    6b1a:	a1 bc 88    	mov.w     w1, 0x1794

    /* Gain: '<S185>/Gain1' */
    rtb_Product3_j0[0] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    6b1c:	04 8f be    	mov.d     w4, [w14]
    rtb_Product3_j0[1] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    6b1e:	22 07 98    	mov.w     w2, [w14+4]
    6b20:	33 07 98    	mov.w     w3, [w14+6]
    rtb_Product3_j0[2] = -AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
    6b22:	40 07 98    	mov.w     w0, [w14+8]
    6b24:	51 07 98    	mov.w     w1, [w14+10]

00006b26 <.L0>:

    /* MATLAB Function: '<S295>/Embedded MATLAB Function' */
    A_EmbeddedMATLABFunction_b(rtb_Product3_j0,
    6b26:	c1 ca 21    	mov.w     #0x1cac, w1
    6b28:	0e 00 78    	mov.w     w14, w0
    6b2a:	27 f2 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00006b2c <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_le);

    /* MATLAB Function: '<S296>/negprotect' */
    AUAV_V3_TestS_negprotect_l
      (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_le.xDoty,
    6b2c:	82 ca 21    	mov.w     #0x1ca8, w2
    6b2e:	60 e5 80    	mov.w     0x1cac, w0
    6b30:	71 e5 80    	mov.w     0x1cae, w1
    6b32:	11 f2 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006b34 <.L0>:
       &AUAV_V3_TestSensors_B.sf_negprotect_o4);

    /* S-Function (MCHP_C_function_Call): '<S296>/mySqrt() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_pu = mySqrt(
    6b34:	40 e5 80    	mov.w     0x1ca8, w0
    6b36:	51 e5 80    	mov.w     0x1caa, w1
    6b38:	16 10 02    	call      0x11016 <_mySqrt>
    6b3a:	01 00 00 
    6b3c:	50 c1 88    	mov.w     w0, 0x182a
    6b3e:	61 c1 88    	mov.w     w1, 0x182c

00006b40 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_o4.zpVal
      );

    /* SignalConversion: '<S299>/Numerical Unity' */
    AUAV_V3_TestSensors_B.Merge2 =
    6b40:	30 bd 88    	mov.w     w0, 0x17a6
    6b42:	41 bd 88    	mov.w     w1, 0x17a8
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_pu;
    AUAV_V3_TestSensors_B.Merge1 = mlMidLevelCommands.hCommand;
    6b44:	52 89 80    	mov.w     0x112a, w2
    6b46:	63 89 80    	mov.w     0x112c, w3
    6b48:	b2 bd 88    	mov.w     w2, 0x17b6
    6b4a:	c3 bd 88    	mov.w     w3, 0x17b8
    AUAV_V3_TestSensors_B.Merge3 = 0U;
    6b4c:	00 40 eb    	clr.b     w0
    6b4e:	91 a9 21    	mov.w     #0x1a99, w1
    6b50:	80 48 78    	mov.b     w0, [w1]
    AUAV_V3_TestSensors_B.Merge4 = 0U;
    6b52:	81 00 e8    	inc.w     w1, w1
    6b54:	80 48 78    	mov.b     w0, [w1]
    6b56:	37 03 37    	bra       0x71c6 <.L0> <.L143>

00006b58 <.L190>:

    /* End of Outputs for SubSystem: '<S180>/Line Segment' */
  } else {
    if (rtb_Compare_j == 9) {
    6b58:	e9 4f 50    	sub.b     w0, #0x9, [w15]
    6b5a:	35 03 3a    	bra       NZ, 0x71c6 <.L0> <.L143>

00006b5c <.L0>:
      /* Outputs for IfAction SubSystem: '<S180>/Circle Navigation' incorporates:
       *  ActionPort: '<S181>/Action Port'
       */
      rtb_IC4_idx_0 *= 0.0174532924F;
    6b5c:	52 a3 2f    	mov.w     #0xfa35, w2
    6b5e:	e3 c8 23    	mov.w     #0x3c8e, w3
    6b60:	0a 00 be    	mov.d     w10, w0
    6b62:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6b64:	00 00 00 
    6b66:	10 af 99    	mov.w     w0, [w14+466]
    6b68:	21 af 99    	mov.w     w1, [w14+468]

00006b6a <.L0>:

      /* Gain: '<S206>/Deg2R' */
      rtb_Deg2R_h_idx_0 = 0.0174532924F * rtb_IC4_idx_1;
    6b6a:	52 a3 2f    	mov.w     #0xfa35, w2
    6b6c:	e3 c8 23    	mov.w     #0x3c8e, w3
    6b6e:	0c 00 be    	mov.d     w12, w0
    6b70:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6b72:	00 00 00 
    6b74:	00 06 be    	mov.d     w0, w12

00006b76 <.L0>:

      /* Gain: '<S207>/Deg2R' incorporates:
       *  DataStoreRead: '<S72>/Get ISR Location'
       */
      rtb_RhhcosphicoslambXe = 0.0174532924F * mlISR.latitude;
    6b76:	52 a3 2f    	mov.w     #0xfa35, w2
    6b78:	e3 c8 23    	mov.w     #0x3c8e, w3
    6b7a:	80 a6 80    	mov.w     0x14d0, w0
    6b7c:	91 a6 80    	mov.w     0x14d2, w1
    6b7e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6b80:	00 00 00 
    6b82:	00 04 be    	mov.d     w0, w8

00006b84 <.L0>:

      /* Trigonometry: '<S207>/sin(phi)' */
      rtb_Ze_b = (real32_T)sin(rtb_RhhcosphicoslambXe);
    6b84:	b6 1d 02    	call      0x1db6 <_sinf>
    6b86:	00 00 00 
    6b88:	00 01 be    	mov.d     w0, w2
    6b8a:	70 af 99    	mov.w     w0, [w14+478]
    6b8c:	01 b7 99    	mov.w     w1, [w14+480]

00006b8e <.L0>:

      /* Sum: '<S207>/Sum1' incorporates:
       *  Constant: '<S207>/const'
       *  Product: '<S207>/Product1'
       *  Product: '<S207>/sin(phi)^2'
       */
      rtb_Sum1_mzp = 1.0F - rtb_Ze_b * rtb_Ze_b * 0.00669425726F;
    6b8e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6b90:	00 00 00 
    6b92:	02 b8 25    	mov.w     #0x5b80, w2
    6b94:	b3 bd 23    	mov.w     #0x3bdb, w3
    6b96:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6b98:	00 00 00 
    6b9a:	00 01 be    	mov.d     w0, w2
    6b9c:	00 00 20    	mov.w     #0x0, w0
    6b9e:	01 f8 23    	mov.w     #0x3f80, w1
    6ba0:	90 14 02    	call      0x1490 <___subsf3>
    6ba2:	00 00 00 
    6ba4:	00 05 be    	mov.d     w0, w10

00006ba6 <.L0>:

      /* Fcn: '<S207>/f' */
      if (rtb_Sum1_mzp < 0.0F) {
    6ba6:	60 11 b8    	mul.uu    w2, #0x0, w2
    6ba8:	8c 18 02    	call      0x188c <___eqsf2>
    6baa:	00 00 00 
    6bac:	00 00 e0    	cp0.w     w0
    6bae:	07 00 3d    	bra       GE, 0x6bbe <.L0> <.L0> <.L606>

00006bb0 <.L0>:
        rtb_Sum1_mzp = -(real32_T)sqrt(-rtb_Sum1_mzp);
    6bb0:	0a 00 be    	mov.d     w10, w0
    6bb2:	01 f0 a2    	btg.w     w1, #0xf
    6bb4:	ba 1d 02    	call      0x1dba <_sqrtf>
    6bb6:	00 00 00 
    6bb8:	00 01 be    	mov.d     w0, w2
    6bba:	03 f0 a2    	btg.w     w3, #0xf
    6bbc:	04 00 37    	bra       0x6bc6 <.L0> <.L0> <.L193>

00006bbe <.L0>:
      } else {
        rtb_Sum1_mzp = (real32_T)sqrt(rtb_Sum1_mzp);
    6bbe:	0a 00 be    	mov.d     w10, w0
    6bc0:	ba 1d 02    	call      0x1dba <_sqrtf>
    6bc2:	00 00 00 
    6bc4:	00 01 be    	mov.d     w0, w2

00006bc6 <.L0>:
      }

      /* End of Fcn: '<S207>/f' */

      /* Product: '<S207>/Rh' incorporates:
       *  Constant: '<S207>/Re=equatorial radius'
       */
      rtb_Sum1_mzp = 6.378137E+6F / rtb_Sum1_mzp;
    6bc6:	20 53 2a    	mov.w     #0xa532, w0
    6bc8:	21 ac 24    	mov.w     #0x4ac2, w1
    6bca:	26 17 02    	call      0x1726 <___divsf3>
    6bcc:	00 00 00 
    6bce:	70 97 99    	mov.w     w0, [w14+430]
    6bd0:	01 9f 99    	mov.w     w1, [w14+432]

00006bd2 <.L0>:

      /* Sum: '<S207>/Sum2' incorporates:
       *  DataStoreRead: '<S72>/Get ISR Location'
       */
      rtb_cosphi = mlISR.height + rtb_Sum1_mzp;

      /* Trigonometry: '<S207>/cos(phi)' */
      rtb_RhhcosphicoslambXe = (real32_T)cos(rtb_RhhcosphicoslambXe);
    6bd2:	08 00 be    	mov.d     w8, w0
    6bd4:	22 17 02    	call      0x1722 <_cosf>
    6bd6:	00 00 00 
    6bd8:	00 05 be    	mov.d     w0, w10

00006bda <.L0>:

      /* Gain: '<S207>/Deg2R1' incorporates:
       *  DataStoreRead: '<S72>/Get ISR Location'
       */
      rtb_RhhcosphisinlambYe = 0.0174532924F * mlISR.longitude;
    6bda:	52 a3 2f    	mov.w     #0xfa35, w2
    6bdc:	e3 c8 23    	mov.w     #0x3c8e, w3
    6bde:	a0 a6 80    	mov.w     0x14d4, w0
    6be0:	b1 a6 80    	mov.w     0x14d6, w1
    6be2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6be4:	00 00 00 
    6be6:	00 04 be    	mov.d     w0, w8

00006be8 <.L0>:
    6be8:	7e 91 91    	mov.w     [w14+430], w2
    6bea:	8e 99 91    	mov.w     [w14+432], w3
    6bec:	c0 a6 80    	mov.w     0x14d8, w0
    6bee:	d1 a6 80    	mov.w     0x14da, w1
    6bf0:	92 14 02    	call      0x1492 <___addsf3>
    6bf2:	00 00 00 

00006bf4 <.L0>:

      /* Product: '<S207>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
       *  Trigonometry: '<S207>/cos(lamb)'
       */
      rtb_Deg2R1 = rtb_cosphi * rtb_RhhcosphicoslambXe * (real32_T)cos
    6bf4:	0a 01 be    	mov.d     w10, w2
    6bf6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6bf8:	00 00 00 
    6bfa:	00 05 be    	mov.d     w0, w10
    6bfc:	08 00 be    	mov.d     w8, w0
    6bfe:	22 17 02    	call      0x1722 <_cosf>
    6c00:	00 00 00 
    6c02:	00 01 be    	mov.d     w0, w2
    6c04:	0a 00 be    	mov.d     w10, w0
    6c06:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6c08:	00 00 00 
    6c0a:	70 8f 99    	mov.w     w0, [w14+414]
    6c0c:	01 97 99    	mov.w     w1, [w14+416]

00006c0e <.L0>:
        (rtb_RhhcosphisinlambYe);

      /* Product: '<S207>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
       *  Trigonometry: '<S207>/sin(lamb)'
       */
      rtb_cosphi = rtb_cosphi * rtb_RhhcosphicoslambXe * (real32_T)sin
    6c0e:	08 00 be    	mov.d     w8, w0
    6c10:	b6 1d 02    	call      0x1db6 <_sinf>
    6c12:	00 00 00 
    6c14:	30 9f 99    	mov.w     w0, [w14+438]
    6c16:	41 9f 99    	mov.w     w1, [w14+440]

00006c18 <.L0>:
        (rtb_RhhcosphisinlambYe);

      /* Product: '<S207>/Ze' incorporates:
       *  DataStoreRead: '<S72>/Get ISR Location'
       *  Product: '<S207>/Rh(1-e^2)'
       *  Sum: '<S207>/Sum4'
       */
      rtb_Ze_b *= 0.993305743F * rtb_Sum1_mzp + mlISR.height;

      /* SignalConversion: '<S206>/TmpSignal ConversionAtProduct1Inport1' incorporates:
       *  Fcn: '<S209>/11'
       *  Fcn: '<S209>/12'
       *  Fcn: '<S209>/13'
       *  Fcn: '<S209>/21'
       *  Fcn: '<S209>/22'
       *  Fcn: '<S209>/23'
       *  Fcn: '<S209>/31'
       *  Fcn: '<S209>/32'
       *  Fcn: '<S209>/33'
       */
      tmp[0] = (real32_T)cos(rtb_IC4_idx_0) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    6c18:	1e a8 91    	mov.w     [w14+466], w0
    6c1a:	ae a8 91    	mov.w     [w14+468], w1
    6c1c:	22 17 02    	call      0x1722 <_cosf>
    6c1e:	00 00 00 
    6c20:	00 04 be    	mov.d     w0, w8
    6c22:	0c 00 be    	mov.d     w12, w0
    6c24:	22 17 02    	call      0x1722 <_cosf>
    6c26:	00 00 00 
    6c28:	00 01 be    	mov.d     w0, w2
    6c2a:	40 af 98    	mov.w     w0, [w14+216]
    6c2c:	51 af 98    	mov.w     w1, [w14+218]
    6c2e:	08 00 be    	mov.d     w8, w0
    6c30:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6c32:	00 00 00 
    6c34:	40 9f 98    	mov.w     w0, [w14+184]
    6c36:	51 9f 98    	mov.w     w1, [w14+186]

00006c38 <.L0>:
      tmp[1] = -(real32_T)sin(rtb_IC4_idx_0);
    6c38:	1e a8 91    	mov.w     [w14+466], w0
    6c3a:	ae a8 91    	mov.w     [w14+468], w1
    6c3c:	b6 1d 02    	call      0x1db6 <_sinf>
    6c3e:	00 00 00 
    6c40:	00 02 be    	mov.d     w0, w4
    6c42:	10 af 99    	mov.w     w0, [w14+466]
    6c44:	21 af 99    	mov.w     w1, [w14+468]
    6c46:	05 f0 a2    	btg.w     w5, #0xf
    6c48:	54 a7 99    	mov.w     w4, [w14+458]
    6c4a:	65 a7 99    	mov.w     w5, [w14+460]
    6c4c:	64 9f 98    	mov.w     w4, [w14+188]
    6c4e:	75 9f 98    	mov.w     w5, [w14+190]

00006c50 <.L0>:
      tmp[2] = -(real32_T)sin(rtb_Deg2R_h_idx_0) * (real32_T)cos(rtb_IC4_idx_0);
    6c50:	0c 00 be    	mov.d     w12, w0
    6c52:	b6 1d 02    	call      0x1db6 <_sinf>
    6c54:	00 00 00 
    6c56:	00 06 be    	mov.d     w0, w12
    6c58:	00 01 be    	mov.d     w0, w2
    6c5a:	03 f0 a2    	btg.w     w3, #0xf
    6c5c:	08 00 be    	mov.d     w8, w0
    6c5e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6c60:	00 00 00 
    6c62:	00 a7 98    	mov.w     w0, [w14+192]
    6c64:	11 a7 98    	mov.w     w1, [w14+194]

00006c66 <.L0>:
      tmp[3] = (real32_T)sin(rtb_IC4_idx_0) * (real32_T)cos(rtb_Deg2R_h_idx_0);
    6c66:	1e a9 91    	mov.w     [w14+466], w2
    6c68:	ae a9 91    	mov.w     [w14+468], w3
    6c6a:	4e a8 90    	mov.w     [w14+216], w0
    6c6c:	de a8 90    	mov.w     [w14+218], w1
    6c6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6c70:	00 00 00 
    6c72:	20 a7 98    	mov.w     w0, [w14+196]
    6c74:	31 a7 98    	mov.w     w1, [w14+198]

00006c76 <.L0>:
      tmp[4] = (real32_T)cos(rtb_IC4_idx_0);
    6c76:	48 a7 98    	mov.w     w8, [w14+200]
    6c78:	59 a7 98    	mov.w     w9, [w14+202]

00006c7a <.L0>:
      tmp[5] = -(real32_T)sin(rtb_IC4_idx_0) * (real32_T)sin(rtb_Deg2R_h_idx_0);
    6c7a:	0c 01 be    	mov.d     w12, w2
    6c7c:	5e a0 91    	mov.w     [w14+458], w0
    6c7e:	ee a0 91    	mov.w     [w14+460], w1
    6c80:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6c82:	00 00 00 
    6c84:	60 a7 98    	mov.w     w0, [w14+204]
    6c86:	71 a7 98    	mov.w     w1, [w14+206]

00006c88 <.L0>:
      tmp[6] = (real32_T)sin(rtb_Deg2R_h_idx_0);
    6c88:	0c af 98    	mov.w     w12, [w14+208]
    6c8a:	1d af 98    	mov.w     w13, [w14+210]
      tmp[7] = 0.0F;
    6c8c:	60 00 b8    	mul.uu    w0, #0x0, w0
    6c8e:	20 af 98    	mov.w     w0, [w14+212]
    6c90:	31 af 98    	mov.w     w1, [w14+214]

00006c92 <.L0>:
      tmp[8] = (real32_T)cos(rtb_Deg2R_h_idx_0);

      /* Sum: '<S204>/Sum1' incorporates:
       *  Product: '<S206>/Product1'
       */
      rtb_Deg2R1 -= AUAV_V3_TestSensors_B.DataTypeConversion1_l[0];
    6c92:	72 bf 80    	mov.w     0x17ee, w2
    6c94:	83 bf 80    	mov.w     0x17f0, w3
    6c96:	7e 88 91    	mov.w     [w14+414], w0
    6c98:	8e 90 91    	mov.w     [w14+416], w1
    6c9a:	90 14 02    	call      0x1490 <___subsf3>
    6c9c:	00 00 00 
    6c9e:	50 a7 99    	mov.w     w0, [w14+458]
    6ca0:	61 a7 99    	mov.w     w1, [w14+460]

00006ca2 <.L0>:
    6ca2:	3e 99 91    	mov.w     [w14+438], w2
    6ca4:	ce 99 91    	mov.w     [w14+440], w3
    6ca6:	0a 00 be    	mov.d     w10, w0
    6ca8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6caa:	00 00 00 

00006cac <.L0>:
      rtb_Sum1_mzp = rtb_cosphi - AUAV_V3_TestSensors_B.DataTypeConversion1_l[1];
    6cac:	92 bf 80    	mov.w     0x17f2, w2
    6cae:	a3 bf 80    	mov.w     0x17f4, w3
    6cb0:	90 14 02    	call      0x1490 <___subsf3>
    6cb2:	00 00 00 
    6cb4:	30 9f 99    	mov.w     w0, [w14+438]
    6cb6:	41 9f 99    	mov.w     w1, [w14+440]

00006cb8 <.L0>:
    6cb8:	92 94 24    	mov.w     #0x4949, w2
    6cba:	e3 f7 23    	mov.w     #0x3f7e, w3
    6cbc:	7e 90 91    	mov.w     [w14+430], w0
    6cbe:	8e 98 91    	mov.w     [w14+432], w1
    6cc0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6cc2:	00 00 00 
    6cc4:	00 01 be    	mov.d     w0, w2
    6cc6:	c0 a6 80    	mov.w     0x14d8, w0
    6cc8:	d1 a6 80    	mov.w     0x14da, w1
    6cca:	92 14 02    	call      0x1492 <___addsf3>
    6ccc:	00 00 00 
    6cce:	7e a9 91    	mov.w     [w14+478], w2
    6cd0:	8e b1 91    	mov.w     [w14+480], w3
    6cd2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6cd4:	00 00 00 

00006cd6 <.L0>:
      rtb_RhhcosphisinlambYe = rtb_Ze_b -
    6cd6:	b2 bf 80    	mov.w     0x17f6, w2
    6cd8:	c3 bf 80    	mov.w     0x17f8, w3
    6cda:	90 14 02    	call      0x1490 <___subsf3>
    6cdc:	00 00 00 
    6cde:	00 06 be    	mov.d     w0, w12
    6ce0:	85 0b 20    	mov.w     #0xb8, w5
    6ce2:	8e 82 42    	add.w     w5, w14, w5
    6ce4:	f4 82 42    	add.w     w5, #0x14, w5
    6ce6:	15 a7 99    	mov.w     w5, [w14+450]
    6ce8:	80 0b 20    	mov.w     #0xb8, w0
    6cea:	0e 00 40    	add.w     w0, w14, w0
    6cec:	68 00 40    	add.w     w0, #0x8, w0
    6cee:	10 af 99    	mov.w     w0, [w14+466]
    6cf0:	81 0b 20    	mov.w     #0xb8, w1
    6cf2:	8e 80 40    	add.w     w1, w14, w1
    6cf4:	e4 80 50    	sub.w     w1, #0x4, w1
    6cf6:	71 af 99    	mov.w     w1, [w14+478]
    6cf8:	82 0d 20    	mov.w     #0xd8, w2
    6cfa:	02 01 47    	add.w     w14, w2, w2
    6cfc:	12 b7 99    	mov.w     w2, [w14+482]

00006cfe <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion1_l[2];

      /* Product: '<S206>/Product1' incorporates:
       *  Gain: '<S204>/UEN 2 NEU'
       */
      for (i = 0; i < 3; i++) {
    6cfe:	00 04 eb    	clr.w     w8
    6d00:	18 9f 99    	mov.w     w8, [w14+434]

00006d02 <.L0>:
        tmp_0[i] = tmp[i + 6] * rtb_RhhcosphisinlambYe + (tmp[i + 3] *
    6d02:	1e a2 91    	mov.w     [w14+450], w4
    6d04:	54 01 be    	mov.d     [++w4], w2
    6d06:	14 a7 99    	mov.w     w4, [w14+450]
    6d08:	0c 00 be    	mov.d     w12, w0
    6d0a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6d0c:	00 00 00 
    6d0e:	00 05 be    	mov.d     w0, w10
    6d10:	9e aa 91    	mov.w     [w14+466], w5
    6d12:	55 01 be    	mov.d     [++w5], w2
    6d14:	15 af 99    	mov.w     w5, [w14+466]
    6d16:	3e 98 91    	mov.w     [w14+438], w0
    6d18:	ce 98 91    	mov.w     [w14+440], w1
    6d1a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6d1c:	00 00 00 
    6d1e:	00 04 be    	mov.d     w0, w8

00006d20 <.L0>:
          rtb_Sum1_mzp + tmp[i] * rtb_Deg2R1);
    6d20:	7e a8 91    	mov.w     [w14+478], w0
    6d22:	50 01 be    	mov.d     [++w0], w2
    6d24:	70 af 99    	mov.w     w0, [w14+478]
    6d26:	5e a0 91    	mov.w     [w14+458], w0
    6d28:	ee a0 91    	mov.w     [w14+460], w1
    6d2a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6d2c:	00 00 00 
    6d2e:	00 01 be    	mov.d     w0, w2
    6d30:	08 00 be    	mov.d     w8, w0
    6d32:	92 14 02    	call      0x1492 <___addsf3>
    6d34:	00 00 00 
    6d36:	00 01 be    	mov.d     w0, w2

00006d38 <.L0>:
    6d38:	0a 00 be    	mov.d     w10, w0
    6d3a:	92 14 02    	call      0x1492 <___addsf3>
    6d3c:	00 00 00 
    6d3e:	1e b1 91    	mov.w     [w14+482], w2
    6d40:	00 a9 be    	mov.d     w0, [++w2]
    6d42:	12 b7 99    	mov.w     w2, [w14+482]

00006d44 <.L0>:
    6d44:	9e 99 91    	mov.w     [w14+434], w3
    6d46:	83 01 e8    	inc.w     w3, w3
    6d48:	13 9f 99    	mov.w     w3, [w14+434]
    6d4a:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    6d4c:	da ff 3a    	bra       NZ, 0x6d02 <.L0> <.L194>
      }

      /* Gain: '<S204>/UEN 2 NEU' */
      for (i = 0; i < 3; i++) {
        rtb_Product3_j0[i] = AUAV_V3_TestSensors_ConstP.pooled62[i + 6] * tmp_0
          [2] + (AUAV_V3_TestSensors_ConstP.pooled62[i + 3] * tmp_0[1] +
    6d4e:	2e b6 90    	mov.w     [w14+228], w12
    6d50:	be b6 90    	mov.w     [w14+230], w13
    6d52:	0e b2 90    	mov.w     [w14+224], w4
    6d54:	9e b2 90    	mov.w     [w14+226], w5
    6d56:	54 a7 99    	mov.w     w4, [w14+458]
    6d58:	65 a7 99    	mov.w     w5, [w14+460]
                 AUAV_V3_TestSensors_ConstP.pooled62[i] * tmp_0[0]);
    6d5a:	6e a8 90    	mov.w     [w14+220], w0
    6d5c:	fe a8 90    	mov.w     [w14+222], w1
    6d5e:	30 9f 99    	mov.w     w0, [w14+438]
    6d60:	41 9f 99    	mov.w     w1, [w14+440]
    6d62:	41 75 2c    	mov.w     #0xc754, w1
    6d64:	11 a7 99    	mov.w     w1, [w14+450]
    6d66:	6c 81 50    	sub.w     w1, #0xc, w2
    6d68:	72 af 99    	mov.w     w2, [w14+478]
    6d6a:	f8 81 50    	sub.w     w1, #0x18, w3
    6d6c:	13 b7 99    	mov.w     w3, [w14+482]
    6d6e:	64 02 57    	sub.w     w14, #0x4, w4
    6d70:	14 af 99    	mov.w     w4, [w14+466]
    6d72:	00 04 eb    	clr.w     w8
    6d74:	18 9f 99    	mov.w     w8, [w14+434]

00006d76 <.L0>:
    6d76:	9e a2 91    	mov.w     [w14+450], w5
    6d78:	55 01 be    	mov.d     [++w5], w2
    6d7a:	15 a7 99    	mov.w     w5, [w14+450]
    6d7c:	0c 00 be    	mov.d     w12, w0
    6d7e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6d80:	00 00 00 
    6d82:	00 05 be    	mov.d     w0, w10

00006d84 <.L0>:
    6d84:	7e a8 91    	mov.w     [w14+478], w0
    6d86:	50 01 be    	mov.d     [++w0], w2
    6d88:	70 af 99    	mov.w     w0, [w14+478]
    6d8a:	5e a0 91    	mov.w     [w14+458], w0
    6d8c:	ee a0 91    	mov.w     [w14+460], w1
    6d8e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6d90:	00 00 00 
    6d92:	00 04 be    	mov.d     w0, w8

00006d94 <.L0>:
    6d94:	9e b0 91    	mov.w     [w14+482], w1
    6d96:	51 01 be    	mov.d     [++w1], w2
    6d98:	11 b7 99    	mov.w     w1, [w14+482]
    6d9a:	3e 98 91    	mov.w     [w14+438], w0
    6d9c:	ce 98 91    	mov.w     [w14+440], w1
    6d9e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6da0:	00 00 00 
    6da2:	00 01 be    	mov.d     w0, w2

00006da4 <.L0>:
    6da4:	08 00 be    	mov.d     w8, w0
    6da6:	92 14 02    	call      0x1492 <___addsf3>
    6da8:	00 00 00 
    6daa:	00 01 be    	mov.d     w0, w2
    6dac:	0a 00 be    	mov.d     w10, w0
    6dae:	92 14 02    	call      0x1492 <___addsf3>
    6db0:	00 00 00 

00006db2 <.L0>:
    6db2:	1e a9 91    	mov.w     [w14+466], w2
    6db4:	00 a9 be    	mov.d     w0, [++w2]
    6db6:	12 af 99    	mov.w     w2, [w14+466]
    6db8:	9e 99 91    	mov.w     [w14+434], w3
    6dba:	83 01 e8    	inc.w     w3, w3
    6dbc:	13 9f 99    	mov.w     w3, [w14+434]
    6dbe:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    6dc0:	da ff 3a    	bra       NZ, 0x6d76 <.L0> <.L195>

00006dc2 <.L0>:
    6dc2:	5e a9 91    	mov.w     [w14+474], w2
    6dc4:	ee a9 91    	mov.w     [w14+476], w3
    6dc6:	02 00 be    	mov.d     w2, w0
    6dc8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6dca:	00 00 00 
    6dcc:	5e b1 91    	mov.w     [w14+490], w2
    6dce:	ee b1 91    	mov.w     [w14+492], w3
    6dd0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6dd2:	00 00 00 
    6dd4:	a2 53 27    	mov.w     #0x753a, w2
    6dd6:	23 09 24    	mov.w     #0x4092, w3
    6dd8:	26 17 02    	call      0x1726 <___divsf3>
    6dda:	00 00 00 
    6ddc:	00 04 be    	mov.d     w0, w8

00006dde <.L0>:
      }

      /* Delay: '<S198>/Integer Delay1' */
      AUAV_V3_TestSensors_B.Merge1 =
    6dde:	84 f2 80    	mov.w     0x1e50, w4
    6de0:	95 f2 80    	mov.w     0x1e52, w5
    6de2:	b4 bd 88    	mov.w     w4, 0x17b6
    6de4:	c5 bd 88    	mov.w     w5, 0x17b8

00006de6 <.L0>:
        AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_a;

      /* MATLAB Function: '<S198>/Zero out Z2' */
      AUAV_V3_TestSens_ZerooutZ1(rtb_Product3_j0,
    6de6:	c1 c9 21    	mov.w     #0x1c9c, w1
    6de8:	0e 00 78    	mov.w     w14, w0
    6dea:	ed f0 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

00006dec <.L0>:
        &AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2);

      /* Sum: '<S181>/Sum1' */
      rtb_Product2_c[0] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0] -
    6dec:	e2 e4 80    	mov.w     0x1c9c, w2
    6dee:	f3 e4 80    	mov.w     0x1c9e, w3
    6df0:	60 e1 80    	mov.w     0x1c2c, w0
    6df2:	71 e1 80    	mov.w     0x1c2e, w1
    6df4:	90 14 02    	call      0x1490 <___subsf3>
    6df6:	00 00 00 
    6df8:	00 1f 98    	mov.w     w0, [w14+48]
    6dfa:	11 1f 98    	mov.w     w1, [w14+50]

00006dfc <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[0];
      rtb_Product2_c[1] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1] -
    6dfc:	02 e5 80    	mov.w     0x1ca0, w2
    6dfe:	13 e5 80    	mov.w     0x1ca2, w3
    6e00:	80 e1 80    	mov.w     0x1c30, w0
    6e02:	91 e1 80    	mov.w     0x1c32, w1
    6e04:	90 14 02    	call      0x1490 <___subsf3>
    6e06:	00 00 00 
    6e08:	20 1f 98    	mov.w     w0, [w14+52]
    6e0a:	31 1f 98    	mov.w     w1, [w14+54]

00006e0c <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[1];
      rtb_Product2_c[2] = AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2] -
    6e0c:	22 e5 80    	mov.w     0x1ca4, w2
    6e0e:	33 e5 80    	mov.w     0x1ca6, w3
    6e10:	a0 e1 80    	mov.w     0x1c34, w0
    6e12:	b1 e1 80    	mov.w     0x1c36, w1
    6e14:	90 14 02    	call      0x1490 <___subsf3>
    6e16:	00 00 00 
    6e18:	40 1f 98    	mov.w     w0, [w14+56]
    6e1a:	51 1f 98    	mov.w     w1, [w14+58]

00006e1c <.L0>:
        AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[2];

      /* MATLAB Function: '<S250>/Embedded MATLAB Function' */
      A_EmbeddedMATLABFunction_b(rtb_Product2_c,
    6e1c:	c1 c6 21    	mov.w     #0x1c6c, w1
    6e1e:	00 03 20    	mov.w     #0x30, w0
    6e20:	0e 00 40    	add.w     w0, w14, w0
    6e22:	ab f0 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00006e24 <.L0>:
        &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_c);

      /* MATLAB Function: '<S251>/negprotect' */
      AUAV_V3_TestS_negprotect_l
        (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_c.xDoty,
    6e24:	82 c6 21    	mov.w     #0x1c68, w2
    6e26:	60 e3 80    	mov.w     0x1c6c, w0
    6e28:	71 e3 80    	mov.w     0x1c6e, w1
    6e2a:	95 f0 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006e2c <.L0>:
         &AUAV_V3_TestSensors_B.sf_negprotect_lu);

      /* S-Function (MCHP_C_function_Call): '<S251>/mySqrt() apUtils.c [updated 5.1.16]' */
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a = mySqrt(
    6e2c:	40 e3 80    	mov.w     0x1c68, w0
    6e2e:	51 e3 80    	mov.w     0x1c6a, w1
    6e30:	16 10 02    	call      0x11016 <_mySqrt>
    6e32:	01 00 00 
    6e34:	a5 7f 21    	mov.w     #0x17fa, w5
    6e36:	80 8a be    	mov.d     w0, [w5]

00006e38 <.L0>:
        AUAV_V3_TestSensors_B.sf_negprotect_lu.zpVal
        );

      /* Product: '<S181>/Product' incorporates:
       *  DataStoreRead: '<Root>/PAR_NAV_L2_BASE PAR_NAV_PRETURN_K PAR_NAV_SSCOMP_ON'
       */
      rtb_RhhcosphisinlambYe = mlParamInterface.param[19] *
    6e38:	32 bc 80    	mov.w     0x1786, w2
    6e3a:	43 bc 80    	mov.w     0x1788, w3
    6e3c:	30 95 80    	mov.w     0x12a6, w0
    6e3e:	41 95 80    	mov.w     0x12a8, w1
    6e40:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6e42:	00 00 00 
    6e44:	00 05 be    	mov.d     w0, w10

00006e46 <.L0>:
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116;

      /* Sum: '<S181>/Sum2' */
      AUAV_V3_TestSensors_B.Sum2 = rtb_Product3_bo - rtb_RhhcosphisinlambYe;
    6e46:	00 01 be    	mov.d     w0, w2
    6e48:	08 00 be    	mov.d     w8, w0
    6e4a:	90 14 02    	call      0x1490 <___subsf3>
    6e4c:	00 00 00 
    6e4e:	f0 bf 88    	mov.w     w0, 0x17fe
    6e50:	01 c0 88    	mov.w     w1, 0x1800

00006e52 <.L0>:

      /* S-Function (MCHP_C_function_Call): '<S203>/myAbs() apUtils.c [updated 5.1.16]' */
      AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_a = myAbs(
    6e52:	1c 10 02    	call      0x1101c <_myAbs>
    6e54:	01 00 00 
    6e56:	00 06 be    	mov.d     w0, w12
    6e58:	10 c0 88    	mov.w     w0, 0x1802
    6e5a:	21 c0 88    	mov.w     w1, 0x1804
        AUAV_V3_TestSensors_B.Sum2
        );

      /* If: '<S181>/If' incorporates:
       *  Constant: '<S199>/RTB1'
       *  Constant: '<S200>/RTB1'
       *  Constant: '<S201>/RTB1'
       *  Product: '<S200>/Product6'
       *  Product: '<S200>/Product7'
       *  Sum: '<S181>/Sum'
       *  Sum: '<S200>/Subtract3'
       *  Sum: '<S200>/Subtract6'
       */
      if (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a >
    6e5c:	a1 7f 21    	mov.w     #0x17fa, w1
    6e5e:	11 00 be    	mov.d     [w1], w0
    6e60:	70 af 99    	mov.w     w0, [w14+478]
    6e62:	01 b7 99    	mov.w     w1, [w14+480]

00006e64 <.L0>:
          rtb_RhhcosphisinlambYe + rtb_Product3_bo) {
    6e64:	08 01 be    	mov.d     w8, w2
    6e66:	0a 00 be    	mov.d     w10, w0
    6e68:	92 14 02    	call      0x1492 <___addsf3>
    6e6a:	00 00 00 
    6e6c:	00 01 be    	mov.d     w0, w2

00006e6e <.L0>:
    6e6e:	7e a8 91    	mov.w     [w14+478], w0
    6e70:	8e b0 91    	mov.w     [w14+480], w1
    6e72:	90 18 02    	call      0x1890 <___gesf2>
    6e74:	00 00 00 
    6e76:	00 00 e0    	cp0.w     w0
    6e78:	1b 00 34    	bra       LE, 0x6eb0 <.L0> <.L607>

00006e7a <.L0>:
        /* Outputs for IfAction SubSystem: '<S181>/No intersection,  Navigate to ISR' incorporates:
         *  ActionPort: '<S201>/Action Port'
         */
        /* Sum: '<S201>/Subtract' */
        AUAV_V3_TestSensors_B.Merge_o[0] =
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[0] -
    6e7a:	62 e1 80    	mov.w     0x1c2c, w2
    6e7c:	73 e1 80    	mov.w     0x1c2e, w3
    6e7e:	e0 e4 80    	mov.w     0x1c9c, w0
    6e80:	f1 e4 80    	mov.w     0x1c9e, w1
    6e82:	90 14 02    	call      0x1490 <___subsf3>
    6e84:	00 00 00 

00006e86 <.L0>:
    6e86:	50 bc 88    	mov.w     w0, 0x178a
    6e88:	61 bc 88    	mov.w     w1, 0x178c

00006e8a <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
        AUAV_V3_TestSensors_B.Merge_o[1] =
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[1] -
    6e8a:	82 e1 80    	mov.w     0x1c30, w2
    6e8c:	93 e1 80    	mov.w     0x1c32, w3
    6e8e:	00 e5 80    	mov.w     0x1ca0, w0
    6e90:	11 e5 80    	mov.w     0x1ca2, w1
    6e92:	90 14 02    	call      0x1490 <___subsf3>
    6e94:	00 00 00 

00006e96 <.L0>:
    6e96:	70 bc 88    	mov.w     w0, 0x178e
    6e98:	81 bc 88    	mov.w     w1, 0x1790

00006e9a <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
        AUAV_V3_TestSensors_B.Merge_o[2] =
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[2] -
    6e9a:	a2 e1 80    	mov.w     0x1c34, w2
    6e9c:	b3 e1 80    	mov.w     0x1c36, w3
    6e9e:	20 e5 80    	mov.w     0x1ca4, w0
    6ea0:	31 e5 80    	mov.w     0x1ca6, w1
    6ea2:	90 14 02    	call      0x1490 <___subsf3>
    6ea4:	00 00 00 

00006ea6 <.L0>:
    6ea6:	90 bc 88    	mov.w     w0, 0x1792
    6ea8:	a1 bc 88    	mov.w     w1, 0x1794
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
        AUAV_V3_TestSensors_B.Merge3 = 0U;
    6eaa:	90 a9 21    	mov.w     #0x1a99, w0
    6eac:	00 48 eb    	clr.b     [w0]
    6eae:	80 01 37    	bra       0x71b0 <.L198>

00006eb0 <.L0>:

        /* End of Outputs for SubSystem: '<S181>/No intersection,  Navigate to ISR' */
      } else if (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a <
    6eb0:	7e a9 91    	mov.w     [w14+478], w2
    6eb2:	8e b1 91    	mov.w     [w14+480], w3
    6eb4:	0c 00 be    	mov.d     w12, w0
    6eb6:	90 18 02    	call      0x1890 <___gesf2>
    6eb8:	00 00 00 
    6eba:	00 00 e0    	cp0.w     w0
    6ebc:	1f 00 34    	bra       LE, 0x6efc <.L0> <.L608>

00006ebe <.L0>:
                 AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_a) {
        /* Outputs for IfAction SubSystem: '<S181>/Inside the Circle,  Keep Straight until  intersection' incorporates:
         *  ActionPort: '<S199>/Action Port'
         */
        /* Sum: '<S199>/Subtract' incorporates:
         *  MATLAB Function: '<S199>/Compute Head of Circle'
         */
        /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Circle Navigation/Inside the Circle,  Keep Straight until  intersection/Compute Head of Circle': '<S211>:1' */
        /* % Compute the top coordinate of the circle */
        /*  using the circle's parametric equations: */
        /*   x = a + r cos (t) */
        /*   y = b + r sin (t) */
        /*  */
        /*  @ t =0 */
        /* '<S211>:1:9' */
        /* '<S211>:1:11' */
        /* '<S211>:1:12' */
        /* '<S211>:1:13' */
        AUAV_V3_TestSensors_B.Merge_o[0] = (real32_T)((real_T)
          (AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[0] + rtb_Product3_bo) -
    6ebe:	e2 e4 80    	mov.w     0x1c9c, w2
    6ec0:	f3 e4 80    	mov.w     0x1c9e, w3
    6ec2:	08 00 be    	mov.d     w8, w0
    6ec4:	92 14 02    	call      0x1492 <___addsf3>
    6ec6:	00 00 00 

00006ec8 <.L0>:
    6ec8:	62 e1 80    	mov.w     0x1c2c, w2
    6eca:	73 e1 80    	mov.w     0x1c2e, w3
    6ecc:	90 14 02    	call      0x1490 <___subsf3>
    6ece:	00 00 00 
    6ed0:	50 bc 88    	mov.w     w0, 0x178a
    6ed2:	61 bc 88    	mov.w     w1, 0x178c

00006ed4 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0]);
        AUAV_V3_TestSensors_B.Merge_o[1] = (real32_T)((real_T)
    6ed4:	82 e1 80    	mov.w     0x1c30, w2
    6ed6:	93 e1 80    	mov.w     0x1c32, w3
    6ed8:	00 e5 80    	mov.w     0x1ca0, w0
    6eda:	11 e5 80    	mov.w     0x1ca2, w1
    6edc:	90 14 02    	call      0x1490 <___subsf3>
    6ede:	00 00 00 
    6ee0:	70 bc 88    	mov.w     w0, 0x178e
    6ee2:	81 bc 88    	mov.w     w1, 0x1790

00006ee4 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[1] -
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1]);
        AUAV_V3_TestSensors_B.Merge_o[2] = (real32_T)((real_T)
    6ee4:	a2 e1 80    	mov.w     0x1c34, w2
    6ee6:	b3 e1 80    	mov.w     0x1c36, w3
    6ee8:	20 e5 80    	mov.w     0x1ca4, w0
    6eea:	31 e5 80    	mov.w     0x1ca6, w1
    6eec:	90 14 02    	call      0x1490 <___subsf3>
    6eee:	00 00 00 
    6ef0:	90 bc 88    	mov.w     w0, 0x1792
    6ef2:	a1 bc 88    	mov.w     w1, 0x1794

00006ef4 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[2] -
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2]);
        AUAV_V3_TestSensors_B.Merge3 = 1U;
    6ef4:	11 c0 b3    	mov.b     #0x1, w1
    6ef6:	90 a9 21    	mov.w     #0x1a99, w0
    6ef8:	01 48 78    	mov.b     w1, [w0]
    6efa:	5a 01 37    	bra       0x71b0 <.L198>

00006efc <.L0>:

        /* End of Outputs for SubSystem: '<S181>/Inside the Circle,  Keep Straight until  intersection' */
      } else {
        /* Outputs for IfAction SubSystem: '<S181>/Intersection. Circular Navigation' incorporates:
         *  ActionPort: '<S200>/Action Port'
         */
        /* Product: '<S200>/Product' */
        rtb_Sum1_mzp = rtb_Product3_bo * rtb_Product3_bo;
    6efc:	08 01 be    	mov.d     w8, w2
    6efe:	08 00 be    	mov.d     w8, w0
    6f00:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6f02:	00 00 00 
    6f04:	00 06 be    	mov.d     w0, w12

00006f06 <.L0>:

        /* MATLAB Function: '<S200>/negprotect2' incorporates:
         *  Sum: '<S200>/Subtract1'
         */
        AUAV_V3_TestSe_negprotect3
          (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a +
    6f06:	7e a9 91    	mov.w     [w14+478], w2
    6f08:	8e b1 91    	mov.w     [w14+480], w3
    6f0a:	02 00 be    	mov.d     w2, w0
    6f0c:	92 14 02    	call      0x1492 <___addsf3>
    6f0e:	00 00 00 
    6f10:	02 c7 21    	mov.w     #0x1c70, w2
    6f12:	93 f0 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

00006f14 <.L0>:
           AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a,
           &AUAV_V3_TestSensors_B.sf_negprotect2);

        /* Product: '<S200>/Product3' incorporates:
         *  Product: '<S200>/Product1'
         *  Product: '<S200>/Product2'
         *  Sum: '<S200>/Subtract'
         */
        rtb_RhhcosphisinlambYe = ((rtb_Sum1_mzp - rtb_RhhcosphisinlambYe *
          rtb_RhhcosphisinlambYe) +
          AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a *
          AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a) /
    6f14:	a3 7f 21    	mov.w     #0x17fa, w3
    6f16:	13 01 be    	mov.d     [w3], w2
    6f18:	62 bf 99    	mov.w     w2, [w14+508]
    6f1a:	73 bf 99    	mov.w     w3, [w14+510]

00006f1c <.L0>:
    6f1c:	0a 01 be    	mov.d     w10, w2
    6f1e:	0a 00 be    	mov.d     w10, w0
    6f20:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6f22:	00 00 00 
    6f24:	00 01 be    	mov.d     w0, w2
    6f26:	0c 00 be    	mov.d     w12, w0
    6f28:	90 14 02    	call      0x1490 <___subsf3>
    6f2a:	00 00 00 
    6f2c:	00 05 be    	mov.d     w0, w10

00006f2e <.L0>:
    6f2e:	6e b9 91    	mov.w     [w14+508], w2
    6f30:	fe b9 91    	mov.w     [w14+510], w3
    6f32:	02 00 be    	mov.d     w2, w0
    6f34:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6f36:	00 00 00 
    6f38:	00 01 be    	mov.d     w0, w2

00006f3a <.L0>:
    6f3a:	0a 00 be    	mov.d     w10, w0
    6f3c:	92 14 02    	call      0x1492 <___addsf3>
    6f3e:	00 00 00 

00006f40 <.L0>:
    6f40:	82 e3 80    	mov.w     0x1c70, w2
    6f42:	93 e3 80    	mov.w     0x1c72, w3
    6f44:	26 17 02    	call      0x1726 <___divsf3>
    6f46:	00 00 00 
    6f48:	00 05 be    	mov.d     w0, w10

00006f4a <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect2.zpVal;

        /* MATLAB Function: '<S217>/negprotect' incorporates:
         *  Product: '<S200>/Product4'
         *  Sum: '<S200>/Subtract2'
         */
        AUAV_V3_TestS_negprotect_l(rtb_Sum1_mzp - rtb_RhhcosphisinlambYe *
    6f4a:	00 01 be    	mov.d     w0, w2
    6f4c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6f4e:	00 00 00 
    6f50:	00 01 be    	mov.d     w0, w2
    6f52:	0c 00 be    	mov.d     w12, w0
    6f54:	90 14 02    	call      0x1490 <___subsf3>
    6f56:	00 00 00 
    6f58:	82 c7 21    	mov.w     #0x1c78, w2
    6f5a:	fd ef 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00006f5c <.L0>:
          rtb_RhhcosphisinlambYe, &AUAV_V3_TestSensors_B.sf_negprotect_ne);

        /* S-Function (MCHP_C_function_Call): '<S217>/mySqrt() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m = mySqrt(
    6f5c:	c0 e3 80    	mov.w     0x1c78, w0
    6f5e:	d1 e3 80    	mov.w     0x1c7a, w1
    6f60:	16 10 02    	call      0x11016 <_mySqrt>
    6f62:	01 00 00 
    6f64:	64 80 21    	mov.w     #0x1806, w4
    6f66:	00 8a be    	mov.d     w0, [w4]

00006f68 <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect_ne.zpVal
          );

        /* MATLAB Function: '<S200>/negprotect1' */
        AUAV_V3_TestSe_negprotect3
          (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_a,
    6f68:	42 c7 21    	mov.w     #0x1c74, w2
    6f6a:	ec 02 52    	sub.w     w4, #0xc, w5
    6f6c:	15 00 be    	mov.d     [w5], w0
    6f6e:	65 f0 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

00006f70 <.L0>:
           &AUAV_V3_TestSensors_B.sf_negprotect1);
        rtb_Product2_c[0] /= AUAV_V3_TestSensors_B.sf_negprotect1.zpVal;
    6f70:	ac e3 80    	mov.w     0x1c74, w12
    6f72:	bd e3 80    	mov.w     0x1c76, w13
    6f74:	0c 01 be    	mov.d     w12, w2
    6f76:	0e 18 90    	mov.w     [w14+48], w0
    6f78:	9e 18 90    	mov.w     [w14+50], w1
    6f7a:	26 17 02    	call      0x1726 <___divsf3>
    6f7c:	00 00 00 
    6f7e:	50 b7 99    	mov.w     w0, [w14+490]
    6f80:	61 b7 99    	mov.w     w1, [w14+492]

00006f82 <.L0>:
        rtb_Product2_c[1] /= AUAV_V3_TestSensors_B.sf_negprotect1.zpVal;
    6f82:	0c 01 be    	mov.d     w12, w2
    6f84:	2e 18 90    	mov.w     [w14+52], w0
    6f86:	be 18 90    	mov.w     [w14+54], w1
    6f88:	26 17 02    	call      0x1726 <___divsf3>
    6f8a:	00 00 00 
    6f8c:	10 b7 99    	mov.w     w0, [w14+482]
    6f8e:	21 b7 99    	mov.w     w1, [w14+484]

00006f90 <.L0>:

        /* Product: '<S200>/Product5' incorporates:
         *  Product: '<S200>/Product6'
         */
        rtb_Merge_m[0] = AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m *
    6f90:	65 80 21    	mov.w     #0x1806, w5
    6f92:	15 06 be    	mov.d     [w5], w12
    6f94:	0c 01 be    	mov.d     w12, w2
    6f96:	5e b0 91    	mov.w     [w14+490], w0
    6f98:	ee b0 91    	mov.w     [w14+492], w1
    6f9a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6f9c:	00 00 00 
    6f9e:	70 af 99    	mov.w     w0, [w14+478]
    6fa0:	01 b7 99    	mov.w     w1, [w14+480]
    6fa2:	60 3f 98    	mov.w     w0, [w14+124]
    6fa4:	71 3f 98    	mov.w     w1, [w14+126]

00006fa6 <.L0>:
          rtb_Product2_c[0];
        rtb_Merge_m[1] = AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_m *
    6fa6:	0c 01 be    	mov.d     w12, w2
    6fa8:	1e b0 91    	mov.w     [w14+482], w0
    6faa:	ae b0 91    	mov.w     [w14+484], w1
    6fac:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6fae:	00 00 00 
    6fb0:	00 06 be    	mov.d     w0, w12
    6fb2:	00 87 98    	mov.w     w0, [w14+128]
    6fb4:	11 87 98    	mov.w     w1, [w14+130]

00006fb6 <.L0>:
          rtb_Product2_c[1];
        rtb_Product2_c[0] = rtb_Product2_c[0] * rtb_RhhcosphisinlambYe +
    6fb6:	5e b1 91    	mov.w     [w14+490], w2
    6fb8:	ee b1 91    	mov.w     [w14+492], w3
    6fba:	0a 00 be    	mov.d     w10, w0
    6fbc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6fbe:	00 00 00 
    6fc0:	e2 e4 80    	mov.w     0x1c9c, w2
    6fc2:	f3 e4 80    	mov.w     0x1c9e, w3
    6fc4:	92 14 02    	call      0x1492 <___addsf3>
    6fc6:	00 00 00 
    6fc8:	50 b7 99    	mov.w     w0, [w14+490]
    6fca:	61 b7 99    	mov.w     w1, [w14+492]
    6fcc:	00 1f 98    	mov.w     w0, [w14+48]
    6fce:	11 1f 98    	mov.w     w1, [w14+50]

00006fd0 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[0];
        rtb_Product2_c[1] = rtb_Product2_c[1] * rtb_RhhcosphisinlambYe +
    6fd0:	1e b1 91    	mov.w     [w14+482], w2
    6fd2:	ae b1 91    	mov.w     [w14+484], w3
    6fd4:	0a 00 be    	mov.d     w10, w0
    6fd6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    6fd8:	00 00 00 
    6fda:	02 e5 80    	mov.w     0x1ca0, w2
    6fdc:	13 e5 80    	mov.w     0x1ca2, w3
    6fde:	92 14 02    	call      0x1492 <___addsf3>
    6fe0:	00 00 00 
    6fe2:	00 05 be    	mov.d     w0, w10
    6fe4:	20 1f 98    	mov.w     w0, [w14+52]
    6fe6:	31 1f 98    	mov.w     w1, [w14+54]

00006fe8 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2_h2.P[1];

        /* MATLAB Function: '<S200>/Embedded MATLAB Function' incorporates:
         *  Product: '<S200>/Product7'
         *  Sum: '<S200>/Subtract3'
         */
        /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/Circle Navigation/Intersection. Circular Navigation/Embedded MATLAB Function': '<S214>:1' */
        /*  This block supports an embeddable subset of the MATLAB language. */
        /*  See the help menu for details.  */
        /* '<S214>:1:5' */
        AUAV_V3_TestSensors_B.Merge_o[0] = 0.0F;
        AUAV_V3_TestSensors_B.Merge_o[1] = 0.0F;
        AUAV_V3_TestSensors_B.Merge_o[2] = 0.0F;
    6fe8:	60 00 b8    	mul.uu    w0, #0x0, w0
    6fea:	90 bc 88    	mov.w     w0, 0x1792
    6fec:	a1 bc 88    	mov.w     w1, 0x1794

00006fee <.L0>:

        /* '<S214>:1:6' */
        /* '<S214>:1:8' */
        AUAV_V3_TestSensors_B.Merge_o[0] = rtb_Product2_c[0] + rtb_Merge_m[1];
    6fee:	5e b1 91    	mov.w     [w14+490], w2
    6ff0:	ee b1 91    	mov.w     [w14+492], w3
    6ff2:	0c 00 be    	mov.d     w12, w0
    6ff4:	92 14 02    	call      0x1492 <___addsf3>
    6ff6:	00 00 00 
    6ff8:	50 bc 88    	mov.w     w0, 0x178a
    6ffa:	61 bc 88    	mov.w     w1, 0x178c

00006ffc <.L0>:

        /* '<S214>:1:9' */
        rtb_P32[0] = rtb_Product2_c[0] - rtb_Merge_m[1];

        /* '<S214>:1:11' */
        AUAV_V3_TestSensors_B.Merge_o[1] = rtb_Product2_c[1] - rtb_Merge_m[0];
    6ffc:	7e a9 91    	mov.w     [w14+478], w2
    6ffe:	8e b1 91    	mov.w     [w14+480], w3
    7000:	0a 00 be    	mov.d     w10, w0
    7002:	90 14 02    	call      0x1490 <___subsf3>
    7004:	00 00 00 
    7006:	70 bc 88    	mov.w     w0, 0x178e
    7008:	81 bc 88    	mov.w     w1, 0x1790

0000700a <.L0>:
    700a:	0c 01 be    	mov.d     w12, w2
    700c:	5e b0 91    	mov.w     [w14+490], w0
    700e:	ee b0 91    	mov.w     [w14+492], w1
    7010:	90 14 02    	call      0x1490 <___subsf3>
    7012:	00 00 00 

00007014 <.L0>:

        /* '<S214>:1:12' */
        rtb_P32[1] = rtb_Product2_c[1] + rtb_Merge_m[0];
        rtb_P32[0] -= AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
    7014:	62 e1 80    	mov.w     0x1c2c, w2
    7016:	73 e1 80    	mov.w     0x1c2e, w3
    7018:	90 14 02    	call      0x1490 <___subsf3>
    701a:	00 00 00 
    701c:	40 87 98    	mov.w     w0, [w14+136]
    701e:	51 87 98    	mov.w     w1, [w14+138]

00007020 <.L0>:
    7020:	0a 01 be    	mov.d     w10, w2
    7022:	7e a8 91    	mov.w     [w14+478], w0
    7024:	8e b0 91    	mov.w     [w14+480], w1
    7026:	92 14 02    	call      0x1492 <___addsf3>
    7028:	00 00 00 

0000702a <.L0>:
        rtb_P32[1] -= AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
    702a:	82 e1 80    	mov.w     0x1c30, w2
    702c:	93 e1 80    	mov.w     0x1c32, w3
    702e:	90 14 02    	call      0x1490 <___subsf3>
    7030:	00 00 00 
    7032:	60 87 98    	mov.w     w0, [w14+140]
    7034:	71 87 98    	mov.w     w1, [w14+142]

00007036 <.L0>:
        rtb_P32[2] = 0.0F - AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
    7036:	a2 e1 80    	mov.w     0x1c34, w2
    7038:	b3 e1 80    	mov.w     0x1c36, w3
    703a:	60 00 b8    	mul.uu    w0, #0x0, w0
    703c:	90 14 02    	call      0x1490 <___subsf3>
    703e:	00 00 00 
    7040:	00 8f 98    	mov.w     w0, [w14+144]
    7042:	11 8f 98    	mov.w     w1, [w14+146]

00007044 <.L0>:

        /* MATLAB Function: '<S221>/Embedded MATLAB Function' incorporates:
         *  Sum: '<S200>/Subtract6'
         */
        A_EmbeddedMATLABFunction_k(AUAV_V3_TestSensors_B.sf_ZerooutZ1.P, rtb_P32,
    7044:	02 c9 21    	mov.w     #0x1c90, w2
    7046:	81 08 20    	mov.w     #0x88, w1
    7048:	8e 80 40    	add.w     w1, w14, w1
    704a:	80 fa 2f    	mov.w     #0xffa8, w0
    704c:	02 00 40    	add.w     w0, w2, w0
    704e:	c5 ef 07    	rcall     0x4fda <_A_EmbeddedMATLABFunction_k> <L0> <.LFB1484> <.LFE1483>

00007050 <.L0>:
          &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_p);

        /* MATLAB Function: '<S224>/Embedded MATLAB Function' */
        A_EmbeddedMATLABFunction_b(rtb_P32,
    7050:	81 c9 21    	mov.w     #0x1c98, w1
    7052:	80 08 20    	mov.w     #0x88, w0
    7054:	0e 00 40    	add.w     w0, w14, w0
    7056:	91 ef 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

00007058 <.L0>:
          &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_bp);

        /* MATLAB Function: '<S225>/negprotect' */
        AUAV_V3_TestS_negprotect_l
          (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_bp.xDoty,
    7058:	42 c9 21    	mov.w     #0x1c94, w2
    705a:	c0 e4 80    	mov.w     0x1c98, w0
    705c:	d1 e4 80    	mov.w     0x1c9a, w1
    705e:	7b ef 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00007060 <.L0>:
           &AUAV_V3_TestSensors_B.sf_negprotect_c);

        /* S-Function (MCHP_C_function_Call): '<S225>/mySqrt() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_j = mySqrt(
    7060:	a0 e4 80    	mov.w     0x1c94, w0
    7062:	b1 e4 80    	mov.w     0x1c96, w1
    7064:	16 10 02    	call      0x11016 <_mySqrt>
    7066:	01 00 00 
    7068:	50 c0 88    	mov.w     w0, 0x180a
    706a:	61 c0 88    	mov.w     w1, 0x180c

0000706c <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect_c.zpVal
          );

        /* MATLAB Function: '<S212>/negprotect3' incorporates:
         *  Product: '<S212>/Product9'
         */
        AUAV_V3_TestSe_negprotect3
          (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_j *
    706c:	32 bc 80    	mov.w     0x1786, w2
    706e:	43 bc 80    	mov.w     0x1788, w3
    7070:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7072:	00 00 00 
    7074:	c2 c8 21    	mov.w     #0x1c8c, w2
    7076:	e1 ef 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

00007078 <.L0>:
           AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116,
           &AUAV_V3_TestSensors_B.sf_negprotect3);

        /* Product: '<S212>/Product8' */
        AUAV_V3_TestSensors_B.u1 =
          AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_p.xDoty /
    7078:	62 e4 80    	mov.w     0x1c8c, w2
    707a:	73 e4 80    	mov.w     0x1c8e, w3
    707c:	80 e4 80    	mov.w     0x1c90, w0
    707e:	91 e4 80    	mov.w     0x1c92, w1
    7080:	26 17 02    	call      0x1726 <___divsf3>
    7082:	00 00 00 
    7084:	00 05 be    	mov.d     w0, w10

00007086 <.L0>:
    7086:	70 c0 88    	mov.w     w0, 0x180e
    7088:	81 c0 88    	mov.w     w1, 0x1810

0000708a <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect3.zpVal;

        /* Saturate: '<S212>/[-1 1]' */
        if (AUAV_V3_TestSensors_B.u1 > 1.0F) {
    708a:	02 00 20    	mov.w     #0x0, w2
    708c:	03 f8 23    	mov.w     #0x3f80, w3
    708e:	90 18 02    	call      0x1890 <___gesf2>
    7090:	00 00 00 
    7092:	00 00 e0    	cp0.w     w0
    7094:	05 00 34    	bra       LE, 0x70a0 <.L0> <.L609>

00007096 <.L0>:
          /* Product: '<S212>/Product8' */
          AUAV_V3_TestSensors_B.u1 = 1.0F;
    7096:	00 00 20    	mov.w     #0x0, w0
    7098:	01 f8 23    	mov.w     #0x3f80, w1
    709a:	70 c0 88    	mov.w     w0, 0x180e
    709c:	81 c0 88    	mov.w     w1, 0x1810
    709e:	0b 00 37    	bra       0x70b6 <.L0> <.L203>

000070a0 <.L0>:
        } else {
          if (AUAV_V3_TestSensors_B.u1 < -1.0F) {
    70a0:	02 00 20    	mov.w     #0x0, w2
    70a2:	03 f8 2b    	mov.w     #0xbf80, w3
    70a4:	0a 00 be    	mov.d     w10, w0
    70a6:	8c 18 02    	call      0x188c <___eqsf2>
    70a8:	00 00 00 
    70aa:	00 00 e0    	cp0.w     w0
    70ac:	04 00 3d    	bra       GE, 0x70b6 <.L0> <.L203>

000070ae <.L0>:
            /* Product: '<S212>/Product8' */
            AUAV_V3_TestSensors_B.u1 = -1.0F;
    70ae:	00 00 20    	mov.w     #0x0, w0
    70b0:	01 f8 2b    	mov.w     #0xbf80, w1
    70b2:	70 c0 88    	mov.w     w0, 0x180e
    70b4:	81 c0 88    	mov.w     w1, 0x1810

000070b6 <.L0>:
          }
        }

        /* End of Saturate: '<S212>/[-1 1]' */

        /* S-Function (MCHP_C_function_Call): '<S222>/myAcos() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.myAcosapUtilscupdated5116 = myAcos(
    70b6:	70 c0 80    	mov.w     0x180e, w0
    70b8:	81 c0 80    	mov.w     0x1810, w1
    70ba:	3e 10 02    	call      0x1103e <_myAcos>
    70bc:	01 00 00 
    70be:	90 c0 88    	mov.w     w0, 0x1812
    70c0:	a1 c0 88    	mov.w     w1, 0x1814

000070c2 <.L0>:
          AUAV_V3_TestSensors_B.u1
          );

        /* Sum: '<S200>/Subtract5' */
        AUAV_V3_TestSensors_B.Merge_o[0] -=
    70c2:	aa 78 21    	mov.w     #0x178a, w10
    70c4:	62 e1 80    	mov.w     0x1c2c, w2
    70c6:	73 e1 80    	mov.w     0x1c2e, w3
    70c8:	1a 00 be    	mov.d     [w10], w0
    70ca:	90 14 02    	call      0x1490 <___subsf3>
    70cc:	00 00 00 
    70ce:	00 8d be    	mov.d     w0, [w10]

000070d0 <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[0];
        AUAV_V3_TestSensors_B.Merge_o[1] -=
    70d0:	e4 05 45    	add.w     w10, #0x4, w11
    70d2:	82 e1 80    	mov.w     0x1c30, w2
    70d4:	93 e1 80    	mov.w     0x1c32, w3
    70d6:	1b 00 be    	mov.d     [w11], w0
    70d8:	90 14 02    	call      0x1490 <___subsf3>
    70da:	00 00 00 
    70dc:	80 8d be    	mov.d     w0, [w11]

000070de <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[1];
        AUAV_V3_TestSensors_B.Merge_o[2] -=
    70de:	e4 85 45    	add.w     w11, #0x4, w11
    70e0:	a2 e1 80    	mov.w     0x1c34, w2
    70e2:	b3 e1 80    	mov.w     0x1c36, w3
    70e4:	1b 00 be    	mov.d     [w11], w0
    70e6:	90 14 02    	call      0x1490 <___subsf3>
    70e8:	00 00 00 
    70ea:	80 8d be    	mov.d     w0, [w11]

000070ec <.L0>:
          AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];

        /* MATLAB Function: '<S234>/Embedded MATLAB Function' */
        A_EmbeddedMATLABFunction_k(AUAV_V3_TestSensors_B.sf_ZerooutZ1.P,
    70ec:	02 c8 21    	mov.w     #0x1c80, w2
    70ee:	8a 00 78    	mov.w     w10, w1
    70f0:	80 fb 2f    	mov.w     #0xffb8, w0
    70f2:	02 00 40    	add.w     w0, w2, w0
    70f4:	72 ef 07    	rcall     0x4fda <_A_EmbeddedMATLABFunction_k> <L0> <.LFB1484> <.LFE1483>

000070f6 <.L0>:
          AUAV_V3_TestSensors_B.Merge_o,
          &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_m);

        /* MATLAB Function: '<S237>/Embedded MATLAB Function' */
        A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.Merge_o,
    70f6:	81 c8 21    	mov.w     #0x1c88, w1
    70f8:	0a 00 78    	mov.w     w10, w0
    70fa:	3f ef 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

000070fc <.L0>:
          &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_eg);

        /* MATLAB Function: '<S238>/negprotect' */
        AUAV_V3_TestS_negprotect_l
          (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_eg.xDoty,
    70fc:	42 c8 21    	mov.w     #0x1c84, w2
    70fe:	40 e4 80    	mov.w     0x1c88, w0
    7100:	51 e4 80    	mov.w     0x1c8a, w1
    7102:	29 ef 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00007104 <.L0>:
           &AUAV_V3_TestSensors_B.sf_negprotect_i);

        /* S-Function (MCHP_C_function_Call): '<S238>/mySqrt() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_e = mySqrt(
    7104:	20 e4 80    	mov.w     0x1c84, w0
    7106:	31 e4 80    	mov.w     0x1c86, w1
    7108:	16 10 02    	call      0x11016 <_mySqrt>
    710a:	01 00 00 
    710c:	b0 c0 88    	mov.w     w0, 0x1816
    710e:	c1 c0 88    	mov.w     w1, 0x1818

00007110 <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect_i.zpVal
          );

        /* MATLAB Function: '<S213>/negprotect3' incorporates:
         *  Product: '<S213>/Product9'
         */
        AUAV_V3_TestSe_negprotect3
          (AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_e *
    7110:	32 bc 80    	mov.w     0x1786, w2
    7112:	43 bc 80    	mov.w     0x1788, w3
    7114:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7116:	00 00 00 
    7118:	c2 c7 21    	mov.w     #0x1c7c, w2
    711a:	8f ef 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

0000711c <.L0>:
           AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116,
           &AUAV_V3_TestSensors_B.sf_negprotect3_i);

        /* Product: '<S213>/Product8' */
        AUAV_V3_TestSensors_B.u1_h =
          AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_m.xDoty /
    711c:	e2 e3 80    	mov.w     0x1c7c, w2
    711e:	f3 e3 80    	mov.w     0x1c7e, w3
    7120:	00 e4 80    	mov.w     0x1c80, w0
    7122:	11 e4 80    	mov.w     0x1c82, w1
    7124:	26 17 02    	call      0x1726 <___divsf3>
    7126:	00 00 00 
    7128:	00 05 be    	mov.d     w0, w10

0000712a <.L0>:
    712a:	d0 c0 88    	mov.w     w0, 0x181a
    712c:	e1 c0 88    	mov.w     w1, 0x181c

0000712e <.L0>:
          AUAV_V3_TestSensors_B.sf_negprotect3_i.zpVal;

        /* Saturate: '<S213>/[-1 1]' */
        if (AUAV_V3_TestSensors_B.u1_h > 1.0F) {
    712e:	02 00 20    	mov.w     #0x0, w2
    7130:	03 f8 23    	mov.w     #0x3f80, w3
    7132:	90 18 02    	call      0x1890 <___gesf2>
    7134:	00 00 00 
    7136:	00 00 e0    	cp0.w     w0
    7138:	05 00 34    	bra       LE, 0x7144 <.L0> <.L610>

0000713a <.L0>:
          /* Product: '<S213>/Product8' */
          AUAV_V3_TestSensors_B.u1_h = 1.0F;
    713a:	00 00 20    	mov.w     #0x0, w0
    713c:	01 f8 23    	mov.w     #0x3f80, w1
    713e:	d0 c0 88    	mov.w     w0, 0x181a
    7140:	e1 c0 88    	mov.w     w1, 0x181c
    7142:	0b 00 37    	bra       0x715a <.L0> <.L207>

00007144 <.L0>:
        } else {
          if (AUAV_V3_TestSensors_B.u1_h < -1.0F) {
    7144:	02 00 20    	mov.w     #0x0, w2
    7146:	03 f8 2b    	mov.w     #0xbf80, w3
    7148:	0a 00 be    	mov.d     w10, w0
    714a:	8c 18 02    	call      0x188c <___eqsf2>
    714c:	00 00 00 
    714e:	00 00 e0    	cp0.w     w0
    7150:	04 00 3d    	bra       GE, 0x715a <.L0> <.L207>

00007152 <.L0>:
            /* Product: '<S213>/Product8' */
            AUAV_V3_TestSensors_B.u1_h = -1.0F;
    7152:	00 00 20    	mov.w     #0x0, w0
    7154:	01 f8 2b    	mov.w     #0xbf80, w1
    7156:	d0 c0 88    	mov.w     w0, 0x181a
    7158:	e1 c0 88    	mov.w     w1, 0x181c

0000715a <.L0>:
          }
        }

        /* End of Saturate: '<S213>/[-1 1]' */

        /* S-Function (MCHP_C_function_Call): '<S235>/myACos() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.myACosapUtilscupdated5116 = myAcos(
    715a:	d0 c0 80    	mov.w     0x181a, w0
    715c:	e1 c0 80    	mov.w     0x181c, w1
    715e:	3e 10 02    	call      0x1103e <_myAcos>
    7160:	01 00 00 
    7162:	f0 c0 88    	mov.w     w0, 0x181e
    7164:	01 c1 88    	mov.w     w1, 0x1820

00007166 <.L0>:
          AUAV_V3_TestSensors_B.u1_h
          );

        /* S-Function (MCHP_C_function_Call): '<S216>/myAbs() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_c = myAbs(
    7166:	1c 10 02    	call      0x1101c <_myAbs>
    7168:	01 00 00 
    716a:	2a 82 21    	mov.w     #0x1822, w10
    716c:	00 8d be    	mov.d     w0, [w10]

0000716e <.L0>:
          AUAV_V3_TestSensors_B.myACosapUtilscupdated5116
          );

        /* S-Function (MCHP_C_function_Call): '<S215>/myAbs() apUtils.c [updated 5.1.16]' */
        AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_b = myAbs(
    716e:	90 c0 80    	mov.w     0x1812, w0
    7170:	a1 c0 80    	mov.w     0x1814, w1
    7172:	1c 10 02    	call      0x1101c <_myAbs>
    7174:	01 00 00 
    7176:	30 c1 88    	mov.w     w0, 0x1826
    7178:	41 c1 88    	mov.w     w1, 0x1828

0000717a <.L0>:
          AUAV_V3_TestSensors_B.myAcosapUtilscupdated5116
          );

        /* Switch: '<S200>/Switch1' incorporates:
         *  RelationalOperator: '<S200>/Relational Operator'
         *  Sum: '<S200>/Subtract6'
         */
        if (!(AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_c <=
    717a:	1b c0 b3    	mov.b     #0x1, w11
    717c:	1a 01 be    	mov.d     [w10], w2
    717e:	90 18 02    	call      0x1890 <___gesf2>
    7180:	00 00 00 
    7182:	00 00 e0    	cp0.w     w0
    7184:	01 00 3d    	bra       GE, 0x7188 <.L210>
    7186:	80 45 eb    	clr.b     w11

00007188 <.L210>:
    7188:	0b 04 e0    	cp0.b     w11
    718a:	0f 00 3a    	bra       NZ, 0x71aa <.L0> <.L209>

0000718c <.L0>:
              AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116_b)) {
          AUAV_V3_TestSensors_B.Merge_o[0] = rtb_P32[0];
    718c:	4e 81 90    	mov.w     [w14+136], w2
    718e:	de 81 90    	mov.w     [w14+138], w3
    7190:	52 bc 88    	mov.w     w2, 0x178a
    7192:	63 bc 88    	mov.w     w3, 0x178c
          AUAV_V3_TestSensors_B.Merge_o[1] = rtb_P32[1];
    7194:	6e 82 90    	mov.w     [w14+140], w4
    7196:	fe 82 90    	mov.w     [w14+142], w5
    7198:	74 bc 88    	mov.w     w4, 0x178e
    719a:	85 bc 88    	mov.w     w5, 0x1790

0000719c <.L0>:
          AUAV_V3_TestSensors_B.Merge_o[2] = 0.0F -
    719c:	a2 e1 80    	mov.w     0x1c34, w2
    719e:	b3 e1 80    	mov.w     0x1c36, w3
    71a0:	60 00 b8    	mul.uu    w0, #0x0, w0
    71a2:	90 14 02    	call      0x1490 <___subsf3>
    71a4:	00 00 00 
    71a6:	90 bc 88    	mov.w     w0, 0x1792
    71a8:	a1 bc 88    	mov.w     w1, 0x1794

000071aa <.L0>:
            AUAV_V3_TestSensors_B.sf_ZerooutZ2.P[2];
        }

        /* End of Switch: '<S200>/Switch1' */
        AUAV_V3_TestSensors_B.Merge3 = 2U;
    71aa:	21 c0 b3    	mov.b     #0x2, w1
    71ac:	90 a9 21    	mov.w     #0x1a99, w0
    71ae:	01 48 78    	mov.b     w1, [w0]

000071b0 <.L198>:

        /* End of Outputs for SubSystem: '<S181>/Intersection. Circular Navigation' */
      }

      /* End of If: '<S181>/If' */

      /* Delay: '<S181>/Integer Delay' */
      AUAV_V3_TestSensors_B.Merge2 =
        AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_h;
    71b0:	40 e5 21    	mov.w     #0x1e54, w0
    71b2:	10 01 be    	mov.d     [w0], w2
    71b4:	32 bd 88    	mov.w     w2, 0x17a6
    71b6:	43 bd 88    	mov.w     w3, 0x17a8
      AUAV_V3_TestSensors_B.Merge4 = 0U;
    71b8:	a1 a9 21    	mov.w     #0x1a9a, w1
    71ba:	80 48 eb    	clr.b     [w1]

      /* Update for Delay: '<S198>/Integer Delay1' incorporates:
       *  Constant: '<S181>/RTB1'
       */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_a = rtb_Product3_j0[2];
    71bc:	4e 02 90    	mov.w     [w14+8], w4
    71be:	de 02 90    	mov.w     [w14+10], w5
    71c0:	84 f2 88    	mov.w     w4, 0x1e50
    71c2:	95 f2 88    	mov.w     w5, 0x1e52

      /* Update for Delay: '<S181>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_h = rtb_Product3_bo;
    71c4:	08 88 be    	mov.d     w8, [w0]

000071c6 <.L0>:

      /* End of Outputs for SubSystem: '<S180>/Circle Navigation' */
    }
  }

  /* End of If: '<S180>/Determine Overall Nav by the Nav Mode' */

  /* MATLAB Function: '<S277>/Zero out Z1' */
  AUAV_V3_TestSens_ZerooutZ1(AUAV_V3_TestSensors_B.Merge_o,
    71c6:	c1 c4 21    	mov.w     #0x1c4c, w1
    71c8:	a0 78 21    	mov.w     #0x178a, w0
    71ca:	fd ee 07    	rcall     0x4fc6 <_AUAV_V3_TestSens_ZerooutZ1> <L0> <.LFB1483> <.LFE1482>

000071cc <.L0>:
    &AUAV_V3_TestSensors_B.sf_ZerooutZ1_i);

  /* MATLAB Function: '<S282>/Embedded MATLAB Function' */
  A_EmbeddedMATLABFunction_b(AUAV_V3_TestSensors_B.sf_ZerooutZ1_i.P,
    71cc:	c1 c5 21    	mov.w     #0x1c5c, w1
    71ce:	70 80 50    	sub.w     w1, #0x10, w0
    71d0:	d4 ee 07    	rcall     0x4f7a <_A_EmbeddedMATLABFunction_b> <L0> <.LFB1482> <.LFE1481>

000071d2 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_nv);

  /* MATLAB Function: '<S283>/negprotect' */
  AUAV_V3_TestS_negprotect_l
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_nv.xDoty,
    71d2:	82 c5 21    	mov.w     #0x1c58, w2
    71d4:	e0 e2 80    	mov.w     0x1c5c, w0
    71d6:	f1 e2 80    	mov.w     0x1c5e, w1
    71d8:	be ee 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

000071da <.L0>:
     &AUAV_V3_TestSensors_B.sf_negprotect_o);

  /* S-Function (MCHP_C_function_Call): '<S283>/mySqrt() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_p = mySqrt(
    71da:	c0 e2 80    	mov.w     0x1c58, w0
    71dc:	d1 e2 80    	mov.w     0x1c5a, w1
    71de:	16 10 02    	call      0x11016 <_mySqrt>
    71e0:	01 00 00 
    71e2:	b0 bc 88    	mov.w     w0, 0x1796
    71e4:	c1 bc 88    	mov.w     w1, 0x1798

000071e6 <.L0>:
    AUAV_V3_TestSensors_B.sf_negprotect_o.zpVal
    );

  /* MATLAB Function: '<S269>/negprotect' incorporates:
   *  Product: '<S269>/Product1'
   */
  AUAV_V3_TestSe_negprotect3(AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_p *
    71e6:	32 bc 80    	mov.w     0x1786, w2
    71e8:	43 bc 80    	mov.w     0x1788, w3
    71ea:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    71ec:	00 00 00 
    71ee:	82 c4 21    	mov.w     #0x1c48, w2
    71f0:	24 ef 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

000071f2 <.L0>:
    AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116,
    &AUAV_V3_TestSensors_B.sf_negprotect_h);

  /* DeadZone: '<S269>/Dead Zone' */
  if (AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal > 0.1F) {
    71f2:	48 e2 80    	mov.w     0x1c48, w8
    71f4:	59 e2 80    	mov.w     0x1c4a, w9
    71f6:	d2 cc 2c    	mov.w     #0xcccd, w2
    71f8:	c3 dc 23    	mov.w     #0x3dcc, w3
    71fa:	08 00 be    	mov.d     w8, w0
    71fc:	90 18 02    	call      0x1890 <___gesf2>
    71fe:	00 00 00 
    7200:	00 00 e0    	cp0.w     w0
    7202:	06 00 34    	bra       LE, 0x7210 <.L0> <.L0> <.L611>

00007204 <.L0>:
    rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal - 0.1F;
    7204:	d2 cc 2c    	mov.w     #0xcccd, w2
    7206:	c3 dc 23    	mov.w     #0x3dcc, w3
    7208:	08 00 be    	mov.d     w8, w0
    720a:	90 14 02    	call      0x1490 <___subsf3>
    720c:	00 00 00 
    720e:	0c 00 37    	bra       0x7228 <.L0> <.L0> <.L213>

00007210 <.L0>:
  } else if (AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal >= -0.1F) {
    7210:	d2 cc 2c    	mov.w     #0xcccd, w2
    7212:	c3 dc 2b    	mov.w     #0xbdcc, w3
    7214:	08 00 be    	mov.d     w8, w0
    7216:	90 18 02    	call      0x1890 <___gesf2>
    7218:	00 00 00 
    721a:	00 00 e0    	cp0.w     w0
    721c:	0a 00 3d    	bra       GE, 0x7232 <.L0> <.L214>

0000721e <.L0>:
    rtb_RhhcosphicoslambXe = 0.0F;
  } else {
    rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal - -0.1F;
    721e:	d2 cc 2c    	mov.w     #0xcccd, w2
    7220:	c3 dc 23    	mov.w     #0x3dcc, w3
    7222:	08 00 be    	mov.d     w8, w0
    7224:	92 14 02    	call      0x1492 <___addsf3>
    7226:	00 00 00 

00007228 <.L0>:
  }

  /* End of DeadZone: '<S269>/Dead Zone' */

  /* Switch: '<S269>/Switch' incorporates:
   *  Constant: '<S269>/cos(pi//2)'
   *  Constant: '<S269>/sin(pi//2)'
   *  Constant: '<S276>/Constant'
   *  Product: '<S269>/Divide1'
   *  Product: '<S269>/Divide2'
   *  Product: '<S275>/Product'
   *  Product: '<S275>/Product1'
   *  Product: '<S278>/Product'
   *  Product: '<S278>/Product1'
   *  RelationalOperator: '<S276>/Compare'
   *  Sum: '<S275>/Subtract'
   *  Sum: '<S278>/Subtract'
   *  Switch: '<S269>/Switch2'
   */
  if ((rtb_RhhcosphicoslambXe == 0.0F) > 0) {
    7228:	60 11 b8    	mul.uu    w2, #0x0, w2
    722a:	8c 18 02    	call      0x188c <___eqsf2>
    722c:	00 00 00 
    722e:	00 00 e0    	cp0.w     w0
    7230:	08 00 3a    	bra       NZ, 0x7242 <.L0> <.L612>

00007232 <.L0>:
    AUAV_V3_TestSensors_B.Switch = 1.0F;
    7232:	00 00 20    	mov.w     #0x0, w0
    7234:	01 f8 23    	mov.w     #0x3f80, w1
    7236:	d0 bc 88    	mov.w     w0, 0x179a
    7238:	e1 bc 88    	mov.w     w1, 0x179c
    AUAV_V3_TestSensors_B.Switch2 = 0.0F;
    723a:	60 00 b8    	mul.uu    w0, #0x0, w0
    723c:	f0 bc 88    	mov.w     w0, 0x179e
    723e:	01 bd 88    	mov.w     w1, 0x17a0
    7240:	33 00 37    	bra       0x72a8 <.L0> <.L217>

00007242 <.L0>:
  } else {
    AUAV_V3_TestSensors_B.Switch = (AUAV_V3_TestSensors_B.Merge_o[1] *
    7242:	7c bc 80    	mov.w     0x178e, w12
    7244:	8d bc 80    	mov.w     0x1790, w13
    7246:	c2 e1 80    	mov.w     0x1c38, w2
    7248:	d3 e1 80    	mov.w     0x1c3a, w3
    724a:	0c 00 be    	mov.d     w12, w0
    724c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    724e:	00 00 00 
    7250:	00 05 be    	mov.d     w0, w10

00007252 <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ1.P[0] - AUAV_V3_TestSensors_B.Merge_o[0]
      * AUAV_V3_TestSensors_B.sf_ZerooutZ1.P[1]) /
    7252:	e2 e1 80    	mov.w     0x1c3c, w2
    7254:	f3 e1 80    	mov.w     0x1c3e, w3
    7256:	50 bc 80    	mov.w     0x178a, w0
    7258:	61 bc 80    	mov.w     0x178c, w1
    725a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    725c:	00 00 00 
    725e:	00 01 be    	mov.d     w0, w2

00007260 <.L0>:
    7260:	0a 00 be    	mov.d     w10, w0
    7262:	90 14 02    	call      0x1490 <___subsf3>
    7264:	00 00 00 

00007266 <.L0>:
    7266:	08 01 be    	mov.d     w8, w2
    7268:	26 17 02    	call      0x1726 <___divsf3>
    726a:	00 00 00 

0000726c <.L0>:
    726c:	d0 bc 88    	mov.w     w0, 0x179a
    726e:	e1 bc 88    	mov.w     w1, 0x179c

00007270 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal;
    AUAV_V3_TestSensors_B.Switch2 = (AUAV_V3_TestSensors_B.Merge_o[0] *
    7270:	52 bc 80    	mov.w     0x178a, w2
    7272:	63 bc 80    	mov.w     0x178c, w3
    7274:	c0 e1 80    	mov.w     0x1c38, w0
    7276:	d1 e1 80    	mov.w     0x1c3a, w1
    7278:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    727a:	00 00 00 
    727c:	00 05 be    	mov.d     w0, w10

0000727e <.L0>:
      AUAV_V3_TestSensors_B.sf_ZerooutZ1.P[0] + AUAV_V3_TestSensors_B.Merge_o[1]
      * AUAV_V3_TestSensors_B.sf_ZerooutZ1.P[1]) * (1.0F /
    727e:	e2 e1 80    	mov.w     0x1c3c, w2
    7280:	f3 e1 80    	mov.w     0x1c3e, w3
    7282:	0c 00 be    	mov.d     w12, w0
    7284:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7286:	00 00 00 
    7288:	00 01 be    	mov.d     w0, w2

0000728a <.L0>:
    728a:	0a 00 be    	mov.d     w10, w0
    728c:	92 14 02    	call      0x1492 <___addsf3>
    728e:	00 00 00 
    7290:	00 05 be    	mov.d     w0, w10

00007292 <.L0>:
    7292:	08 01 be    	mov.d     w8, w2
    7294:	00 00 20    	mov.w     #0x0, w0
    7296:	01 f8 23    	mov.w     #0x3f80, w1
    7298:	26 17 02    	call      0x1726 <___divsf3>
    729a:	00 00 00 
    729c:	00 01 be    	mov.d     w0, w2
    729e:	0a 00 be    	mov.d     w10, w0
    72a0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    72a2:	00 00 00 

000072a4 <.L0>:
    72a4:	f0 bc 88    	mov.w     w0, 0x179e
    72a6:	01 bd 88    	mov.w     w1, 0x17a0

000072a8 <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_h.zpVal);
  }

  /* End of Switch: '<S269>/Switch' */

  /* S-Function (MCHP_C_function_Call): '<S273>/myAtan2() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myAtan2apUtilscupdated5116 = myAtan2(
    72a8:	f2 bc 80    	mov.w     0x179e, w2
    72aa:	03 bd 80    	mov.w     0x17a0, w3
    72ac:	d0 bc 80    	mov.w     0x179a, w0
    72ae:	e1 bc 80    	mov.w     0x179c, w1
    72b0:	0a 10 02    	call      0x1100a <_myAtan2>
    72b2:	01 00 00 
    72b4:	29 7a 21    	mov.w     #0x17a2, w9
    72b6:	80 8c be    	mov.d     w0, [w9]

000072b8 <.L0>:
    AUAV_V3_TestSensors_B.Switch
    , AUAV_V3_TestSensors_B.Switch2
    );

  /* Delay: '<S180>/Integer Delay' */
  AUAV_V3_TestSensors_B.Merge3 = AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_c;
    72b8:	62 ff 21    	mov.w     #0x1ff6, w2
    72ba:	12 44 78    	mov.b     [w2], w8
    72bc:	72 2f 20    	mov.w     #0x2f7, w2
    72be:	09 01 41    	add.w     w2, w9, w2
    72c0:	08 49 78    	mov.b     w8, [w2]

  /* Delay: '<S180>/Integer Delay1' */
  AUAV_V3_TestSensors_B.Merge4 =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_o;
    72c2:	72 ff 21    	mov.w     #0x1ff7, w2
    72c4:	12 45 78    	mov.b     [w2], w10
    72c6:	82 2f 20    	mov.w     #0x2f8, w2
    72c8:	09 01 41    	add.w     w2, w9, w2
    72ca:	0a 49 78    	mov.b     w10, [w2]

000072cc <.L0>:

  /* MATLAB Function: '<S180>/myMux Fun1' incorporates:
   *  DataTypeConversion: '<S180>/Data Type Conversion5'
   *  DataTypeConversion: '<S180>/Data Type Conversion6'
   *  Gain: '<S184>/Rad2Deg'
   */
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/myMux Fun1': '<S192>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S192>:1:4' */
  AUAV_V3_TestSensors_B.y_b[0] = 57.2957802F *
    72cc:	0c d3 2f    	mov.w     #0xfd30, w12
    72ce:	02 06 46    	add.w     w12, w2, w12
    72d0:	12 ee 22    	mov.w     #0x2ee1, w2
    72d2:	53 26 24    	mov.w     #0x4265, w3
    72d4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    72d6:	00 00 00 
    72d8:	00 8e be    	mov.d     w0, [w12]

000072da <.L0>:
    AUAV_V3_TestSensors_B.myAtan2apUtilscupdated5116;
  AUAV_V3_TestSensors_B.y_b[1] = AUAV_V3_TestSensors_B.Merge2;
    72da:	30 bd 80    	mov.w     0x17a6, w0
    72dc:	41 bd 80    	mov.w     0x17a8, w1
    72de:	70 be 88    	mov.w     w0, 0x17ce
    72e0:	81 be 88    	mov.w     w1, 0x17d0

000072e2 <.L0>:
  AUAV_V3_TestSensors_B.y_b[2] = AUAV_V3_TestSensors_B.Merge3;
    72e2:	08 80 fb    	ze        w8, w0
    72e4:	80 00 eb    	clr.w     w1
    72e6:	12 19 02    	call      0x1912 <___floatunsisf>
    72e8:	00 00 00 
    72ea:	90 be 88    	mov.w     w0, 0x17d2
    72ec:	a1 be 88    	mov.w     w1, 0x17d4

000072ee <.L0>:
  AUAV_V3_TestSensors_B.y_b[3] = AUAV_V3_TestSensors_B.Merge4;
    72ee:	0a 80 fb    	ze        w10, w0
    72f0:	80 00 eb    	clr.w     w1
    72f2:	12 19 02    	call      0x1912 <___floatunsisf>
    72f4:	00 00 00 
    72f6:	b0 be 88    	mov.w     w0, 0x17d6
    72f8:	c1 be 88    	mov.w     w1, 0x17d8

000072fa <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S180>/getXYZ() navsupport.c [updated 5.1.16]' */
  setNavNav(
    72fa:	0c 00 78    	mov.w     w12, w0
    72fc:	ba f4 02    	call      0xf4ba <_setNavNav>
    72fe:	00 00 00 

00007300 <.L0>:
            &AUAV_V3_TestSensors_B.y_b[0]
            );

  /* MATLAB Function: '<S270>/negprotect' incorporates:
   *  DataStoreRead: '<Root>/PAR_NAV_L2_BASE PAR_NAV_PRETURN_K PAR_NAV_SSCOMP_ON'
   */
  AUAV_V3_TestSe_negprotect3(mlParamInterface.param[19],
    7300:	42 c4 21    	mov.w     #0x1c44, w2
    7302:	30 95 80    	mov.w     0x12a6, w0
    7304:	41 95 80    	mov.w     0x12a8, w1
    7306:	99 ee 07    	rcall     0x503a <_AUAV_V3_TestSe_negprotect3> <L0> <.LFB1486> <.LFE1485>

00007308 <.L0>:
    &AUAV_V3_TestSensors_B.sf_negprotect_b);

  /* S-Function (MCHP_C_function_Call): '<S272>/myAbs() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116 = myAbs(
    7308:	19 00 be    	mov.d     [w9], w0
    730a:	1c 10 02    	call      0x1101c <_myAbs>
    730c:	01 00 00 
    730e:	50 bd 88    	mov.w     w0, 0x17aa
    7310:	61 bd 88    	mov.w     w1, 0x17ac

00007312 <.L0>:
    AUAV_V3_TestSensors_B.myAtan2apUtilscupdated5116
    );

  /* Switch: '<S184>/Switch' incorporates:
   *  Constant: '<S184>/Constant10'
   *  Constant: '<S293>/Constant'
   *  Gain: '<S270>/Gain'
   *  Product: '<S270>/Divide'
   *  RelationalOperator: '<S184>/Relational Operator'
   *  RelationalOperator: '<S293>/Compare'
   *  Switch: '<S274>/Switch1'
   */
  if (AUAV_V3_TestSensors_B.myAbsapUtilscupdated5116 <= 1.57079637F) {
    7312:	b2 fd 20    	mov.w     #0xfdb, w2
    7314:	93 fc 23    	mov.w     #0x3fc9, w3
    7316:	8c 18 02    	call      0x188c <___eqsf2>
    7318:	00 00 00 
    731a:	00 00 e0    	cp0.w     w0
    731c:	0e 00 3c    	bra       GT, 0x733a <.L0> <.L0> <.L613>

0000731e <.L0>:
    rtb_Sum1_mzp = AUAV_V3_TestSensors_B.Switch *
    731e:	32 bc 80    	mov.w     0x1786, w2
    7320:	43 bc 80    	mov.w     0x1788, w3
    7322:	d0 bc 80    	mov.w     0x179a, w0
    7324:	e1 bc 80    	mov.w     0x179c, w1
    7326:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7328:	00 00 00 

0000732a <.L0>:
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116 /
    732a:	22 e2 80    	mov.w     0x1c44, w2
    732c:	33 e2 80    	mov.w     0x1c46, w3
    732e:	26 17 02    	call      0x1726 <___divsf3>
    7330:	00 00 00 

00007332 <.L0>:
    7332:	00 01 be    	mov.d     w0, w2
    7334:	92 14 02    	call      0x1492 <___addsf3>
    7336:	00 00 00 
    7338:	0c 00 37    	bra       0x7352 <.L0> <.L220>

0000733a <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect_b.zpVal * 2.0F;
  } else if ((AUAV_V3_TestSensors_B.Switch < 0.0F) > 0) {
    733a:	60 11 b8    	mul.uu    w2, #0x0, w2
    733c:	d0 bc 80    	mov.w     0x179a, w0
    733e:	e1 bc 80    	mov.w     0x179c, w1
    7340:	8c 18 02    	call      0x188c <___eqsf2>
    7342:	00 00 00 
    7344:	00 00 e0    	cp0.w     w0
    7346:	03 00 3d    	bra       GE, 0x734e <.L614>

00007348 <.L0>:
    /* Switch: '<S274>/Switch1' incorporates:
     *  Constant: '<S274>/Constant9'
     */
    rtb_Sum1_mzp = -4.57681F;
    7348:	a0 53 27    	mov.w     #0x753a, w0
    734a:	21 09 2c    	mov.w     #0xc092, w1
    734c:	02 00 37    	bra       0x7352 <.L0> <.L220>

0000734e <.L614>:
  } else {
    /* Switch: '<S274>/Switch1' incorporates:
     *  Constant: '<S274>/Constant1'
     */
    rtb_Sum1_mzp = 4.57681F;
    734e:	a0 53 27    	mov.w     #0x753a, w0
    7350:	21 09 24    	mov.w     #0x4092, w1

00007352 <.L0>:
  }

  /* End of Switch: '<S184>/Switch' */

  /* Product: '<S271>/Product' incorporates:
   *  Constant: '<S271>/Constant'
   */
  AUAV_V3_TestSensors_B.Product = rtb_Sum1_mzp / 9.815F;
    7352:	d2 a3 20    	mov.w     #0xa3d, w2
    7354:	d3 11 24    	mov.w     #0x411d, w3
    7356:	26 17 02    	call      0x1726 <___divsf3>
    7358:	00 00 00 
    735a:	70 bd 88    	mov.w     w0, 0x17ae
    735c:	81 bd 88    	mov.w     w1, 0x17b0

0000735e <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S289>/myAtan() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myAtanapUtilscupdated5116 = myAtan(
    735e:	20 10 02    	call      0x11020 <_myAtan>
    7360:	01 00 00 
    7362:	10 a7 99    	mov.w     w0, [w14+450]
    7364:	21 a7 99    	mov.w     w1, [w14+452]
    7366:	90 bd 88    	mov.w     w0, 0x17b2
    7368:	a1 bd 88    	mov.w     w1, 0x17b4

0000736a <.L0>:
    AUAV_V3_TestSensors_B.Product
    );

  /* Saturate: '<S271>/Bank  Limit Command' */
  if (AUAV_V3_TestSensors_B.myAtanapUtilscupdated5116 > 0.436332315F) {
    736a:	32 6f 26    	mov.w     #0x66f3, w2
    736c:	f3 ed 23    	mov.w     #0x3edf, w3
    736e:	90 18 02    	call      0x1890 <___gesf2>
    7370:	00 00 00 
    7372:	00 00 e0    	cp0.w     w0
    7374:	0d 00 3c    	bra       GT, 0x7390 <.L438>

00007376 <.L0>:
    rtb_cosphi = 0.436332315F;
  } else if (AUAV_V3_TestSensors_B.myAtanapUtilscupdated5116 < -0.436332315F) {
    7376:	32 6f 26    	mov.w     #0x66f3, w2
    7378:	f3 ed 2b    	mov.w     #0xbedf, w3
    737a:	1e a0 91    	mov.w     [w14+450], w0
    737c:	ae a0 91    	mov.w     [w14+452], w1
    737e:	8c 18 02    	call      0x188c <___eqsf2>
    7380:	00 00 00 
    7382:	00 00 e0    	cp0.w     w0
    7384:	09 00 3d    	bra       GE, 0x7398 <.L222>

00007386 <.L0>:
    rtb_cosphi = -0.436332315F;
    7386:	34 6f 26    	mov.w     #0x66f3, w4
    7388:	f5 ed 2b    	mov.w     #0xbedf, w5
    738a:	14 a7 99    	mov.w     w4, [w14+450]
    738c:	25 a7 99    	mov.w     w5, [w14+452]
    738e:	04 00 37    	bra       0x7398 <.L222>

00007390 <.L438>:
    7390:	30 6f 26    	mov.w     #0x66f3, w0
    7392:	f1 ed 23    	mov.w     #0x3edf, w1
    7394:	10 a7 99    	mov.w     w0, [w14+450]
    7396:	21 a7 99    	mov.w     w1, [w14+452]

00007398 <.L222>:
  } else {
    rtb_cosphi = AUAV_V3_TestSensors_B.myAtanapUtilscupdated5116;
  }

  /* End of Saturate: '<S271>/Bank  Limit Command' */

  /* InitialCondition: '<S189>/IC3' */
  if (AUAV_V3_TestSensors_DWork.IC3_FirstOutputTime) {
    7398:	50 00 22    	mov.w     #0x2005, w0
    739a:	10 04 e0    	cp0.b     [w0]
    739c:	05 00 32    	bra       Z, 0x73a8 <.L224>
    AUAV_V3_TestSensors_DWork.IC3_FirstOutputTime = false;
    739e:	00 48 eb    	clr.b     [w0]
    AUAV_V3_TestSensors_B.IC3 = 0.0F;
    73a0:	60 00 b8    	mul.uu    w0, #0x0, w0
    73a2:	d0 bd 88    	mov.w     w0, 0x17ba
    73a4:	e1 bd 88    	mov.w     w1, 0x17bc
    73a6:	04 00 37    	bra       0x73b0 <.L225>

000073a8 <.L224>:
  } else {
    AUAV_V3_TestSensors_B.IC3 = AUAV_V3_TestSensors_B.NumericalUnity[0];
    73a8:	d2 be 80    	mov.w     0x17da, w2
    73aa:	e3 be 80    	mov.w     0x17dc, w3
    73ac:	d2 bd 88    	mov.w     w2, 0x17ba
    73ae:	e3 bd 88    	mov.w     w3, 0x17bc

000073b0 <.L225>:
  }

  /* End of InitialCondition: '<S189>/IC3' */

  /* Update for Delay: '<S464>/Delay' */
  /* MATLAB Function 'Inner Loop// Navigation/Navigation Encaps [updated 4.28.16]/Navigation/myMux Fun3': '<S194>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S194>:1:5' */
  AUAV_V3_TestSensors_DWork.Delay_DSTATE_e = rtb_IC1;
    73b0:	a0 ff 21    	mov.w     #0x1ffa, w0
    73b2:	ee e1 93    	mov.b     [w14+486], w3
    73b4:	03 48 78    	mov.b     w3, [w0]

  /* Update for Delay: '<S180>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_c = AUAV_V3_TestSensors_B.WP0;
    73b6:	c1 a9 21    	mov.w     #0x1a9c, w1
    73b8:	64 00 50    	sub.w     w0, #0x4, w0
    73ba:	11 48 78    	mov.b     [w1], [w0]

  /* Update for Delay: '<S180>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_o = AUAV_V3_TestSensors_B.WP1;
    73bc:	81 00 e8    	inc.w     w1, w1
    73be:	00 00 e8    	inc.w     w0, w0
    73c0:	11 48 78    	mov.b     [w1], [w0]

  /* End of Outputs for SubSystem: '<S6>/Navigation Encaps [updated 4.28.16]' */

  /* Switch: '<S73>/Switch3' incorporates:
   *  Delay: '<S73>/Integer Delay3'
   *  RelationalOperator: '<S73>/Relational Operator2'
   */
  if ((AUAV_V3_TestSensors_B.sf_myMuxFun1_e.y[2] ==
       AUAV_V3_TestSensors_B.sf_myMuxFun1_e.y[2]) > 0) {
    73c2:	84 df 80    	mov.w     0x1bf0, w4
    73c4:	95 df 80    	mov.w     0x1bf2, w5
    73c6:	74 af 99    	mov.w     w4, [w14+478]
    73c8:	05 b7 99    	mov.w     w5, [w14+480]

000073ca <.L0>:
    73ca:	04 01 be    	mov.d     w4, w2
    73cc:	04 00 be    	mov.d     w4, w0
    73ce:	8c 18 02    	call      0x188c <___eqsf2>
    73d0:	00 00 00 
    73d2:	00 00 e0    	cp0.w     w0
    73d4:	04 00 32    	bra       Z, 0x73de <.L226>

000073d6 <.L0>:
    rtb_Switch3 = AUAV_V3_TestSensors_B.sf_myMuxFun1_e.y[2];
  } else {
    rtb_Switch3 = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE;
    73d6:	c0 ec 80    	mov.w     0x1d98, w0
    73d8:	d1 ec 80    	mov.w     0x1d9a, w1
    73da:	70 af 99    	mov.w     w0, [w14+478]
    73dc:	01 b7 99    	mov.w     w1, [w14+480]

000073de <.L226>:
  }

  /* End of Switch: '<S73>/Switch3' */

  /* Product: '<S21>/Product1' */
  for (i = 0; i < 3; i++) {
    rtb_Product2_c[i] = rtb_MathFunction[i + 6] * AUAV_V3_TestSensors_B.y_k[5] +
    73de:	1c b1 80    	mov.w     0x1622, w12
    73e0:	2d b1 80    	mov.w     0x1624, w13
      (rtb_MathFunction[i + 3] * AUAV_V3_TestSensors_B.y_k[4] +
    73e2:	f2 b0 80    	mov.w     0x161e, w2
    73e4:	03 b1 80    	mov.w     0x1620, w3
    73e6:	12 af 99    	mov.w     w2, [w14+466]
    73e8:	23 af 99    	mov.w     w3, [w14+468]
       rtb_MathFunction[i] * AUAV_V3_TestSensors_B.y_k[3]);
    73ea:	d4 b0 80    	mov.w     0x161a, w4
    73ec:	e5 b0 80    	mov.w     0x161c, w5
    73ee:	54 a7 99    	mov.w     w4, [w14+458]
    73f0:	65 a7 99    	mov.w     w5, [w14+460]
    73f2:	c5 02 20    	mov.w     #0x2c, w5
    73f4:	85 02 47    	add.w     w14, w5, w5
    73f6:	35 b7 99    	mov.w     w5, [w14+486]
    73f8:	7e a0 91    	mov.w     [w14+462], w0
    73fa:	10 b7 99    	mov.w     w0, [w14+482]
    73fc:	be a0 91    	mov.w     [w14+454], w1
    73fe:	51 b7 99    	mov.w     w1, [w14+490]
    7400:	3e a9 91    	mov.w     [w14+470], w2
    7402:	52 af 99    	mov.w     w2, [w14+474]
    7404:	00 04 eb    	clr.w     w8
    7406:	38 9f 99    	mov.w     w8, [w14+438]

00007408 <.L0>:
    7408:	5e aa 91    	mov.w     [w14+474], w4
    740a:	54 01 be    	mov.d     [++w4], w2
    740c:	54 af 99    	mov.w     w4, [w14+474]
    740e:	0c 00 be    	mov.d     w12, w0
    7410:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7412:	00 00 00 
    7414:	00 05 be    	mov.d     w0, w10

00007416 <.L0>:
    7416:	de b2 91    	mov.w     [w14+490], w5
    7418:	55 01 be    	mov.d     [++w5], w2
    741a:	55 b7 99    	mov.w     w5, [w14+490]
    741c:	1e a8 91    	mov.w     [w14+466], w0
    741e:	ae a8 91    	mov.w     [w14+468], w1
    7420:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7422:	00 00 00 
    7424:	00 04 be    	mov.d     w0, w8

00007426 <.L0>:
    7426:	1e b0 91    	mov.w     [w14+482], w0
    7428:	50 01 be    	mov.d     [++w0], w2
    742a:	10 b7 99    	mov.w     w0, [w14+482]
    742c:	5e a0 91    	mov.w     [w14+458], w0
    742e:	ee a0 91    	mov.w     [w14+460], w1
    7430:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7432:	00 00 00 
    7434:	00 01 be    	mov.d     w0, w2

00007436 <.L0>:
    7436:	08 00 be    	mov.d     w8, w0
    7438:	92 14 02    	call      0x1492 <___addsf3>
    743a:	00 00 00 
    743c:	00 01 be    	mov.d     w0, w2

0000743e <.L0>:
    743e:	0a 00 be    	mov.d     w10, w0
    7440:	92 14 02    	call      0x1492 <___addsf3>
    7442:	00 00 00 
    7444:	3e b1 91    	mov.w     [w14+486], w2
    7446:	00 a9 be    	mov.d     w0, [++w2]
    7448:	32 b7 99    	mov.w     w2, [w14+486]

0000744a <.L0>:
    744a:	be 99 91    	mov.w     [w14+438], w3
    744c:	83 01 e8    	inc.w     w3, w3
    744e:	33 9f 99    	mov.w     w3, [w14+438]
    7450:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    7452:	da ff 3a    	bra       NZ, 0x7408 <.L0> <.L227>
  }

  /* End of Product: '<S21>/Product1' */

  /* MATLAB Function: '<S21>/myMux Fun2' incorporates:
   *  MATLAB Function: '<S21>/myMux Fun1'
   */
  /* MATLAB Function 'get Nav Vars [updated 4.28.16]/myMux Fun2': '<S705>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S705>:1:5' */
  AUAV_V3_TestSensors_B.y_j[0] = rtb_y_jl_idx_0;
    7454:	7e 9a 91    	mov.w     [w14+446], w4
    7456:	8e a2 91    	mov.w     [w14+448], w5
    7458:	34 b1 88    	mov.w     w4, 0x1626
    745a:	45 b1 88    	mov.w     w5, 0x1628
  AUAV_V3_TestSensors_B.y_j[1] = rtb_y_jl_idx_1;
    745c:	5e 98 91    	mov.w     [w14+442], w0
    745e:	ee 98 91    	mov.w     [w14+444], w1
    7460:	50 b1 88    	mov.w     w0, 0x162a
    7462:	61 b1 88    	mov.w     w1, 0x162c
  AUAV_V3_TestSensors_B.y_j[2] =
    7464:	f2 d7 80    	mov.w     0x1afe, w2
    7466:	03 d8 80    	mov.w     0x1b00, w3
    7468:	72 b1 88    	mov.w     w2, 0x162e
    746a:	83 b1 88    	mov.w     w3, 0x1630
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1.y;
  AUAV_V3_TestSensors_B.y_j[3] = rtb_Product2_c[0];
    746c:	0e 1a 90    	mov.w     [w14+48], w4
    746e:	9e 1a 90    	mov.w     [w14+50], w5
    7470:	94 b1 88    	mov.w     w4, 0x1632
    7472:	a5 b1 88    	mov.w     w5, 0x1634
  AUAV_V3_TestSensors_B.y_j[4] = rtb_Product2_c[1];
    7474:	2e 18 90    	mov.w     [w14+52], w0
    7476:	be 18 90    	mov.w     [w14+54], w1
    7478:	b0 b1 88    	mov.w     w0, 0x1636
    747a:	c1 b1 88    	mov.w     w1, 0x1638
  AUAV_V3_TestSensors_B.y_j[5] = rtb_Product2_c[2];
    747c:	4e 19 90    	mov.w     [w14+56], w2
    747e:	de 19 90    	mov.w     [w14+58], w3
    7480:	d2 b1 88    	mov.w     w2, 0x163a
    7482:	e3 b1 88    	mov.w     w3, 0x163c

00007484 <.L0>:

  /* Outputs for Atomic SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */
  /* Saturate: '<S166>/[0 1000]' */
  if (rtb_Switch3 > 1000.0F) {
    7484:	02 00 20    	mov.w     #0x0, w2
    7486:	a3 47 24    	mov.w     #0x447a, w3
    7488:	7e a8 91    	mov.w     [w14+478], w0
    748a:	8e b0 91    	mov.w     [w14+480], w1
    748c:	90 18 02    	call      0x1890 <___gesf2>
    748e:	00 00 00 
    7490:	00 00 e0    	cp0.w     w0
    7492:	0a 00 3c    	bra       GT, 0x74a8 <.L439>

00007494 <.L0>:
    rtb_Sum1_mzp = 1000.0F;
  } else if (rtb_Switch3 < 0.0F) {
    7494:	60 11 b8    	mul.uu    w2, #0x0, w2
    7496:	7e a8 91    	mov.w     [w14+478], w0
    7498:	8e b0 91    	mov.w     [w14+480], w1
    749a:	8c 18 02    	call      0x188c <___eqsf2>
    749c:	00 00 00 
    749e:	00 01 78    	mov.w     w0, w2

000074a0 <.L0>:
    rtb_Sum1_mzp = 0.0F;
    74a0:	60 00 b8    	mul.uu    w0, #0x0, w0
    74a2:	02 00 e0    	cp0.w     w2
    74a4:	06 00 35    	bra       LT, 0x74b2 <.L0> <.L228>
    74a6:	03 00 37    	bra       0x74ae <.L645>

000074a8 <.L439>:
    74a8:	00 00 20    	mov.w     #0x0, w0
    74aa:	a1 47 24    	mov.w     #0x447a, w1
    74ac:	02 00 37    	bra       0x74b2 <.L0> <.L228>

000074ae <.L645>:
  } else {
    rtb_Sum1_mzp = rtb_Switch3;
    74ae:	7e a8 91    	mov.w     [w14+478], w0
    74b0:	8e b0 91    	mov.w     [w14+480], w1

000074b2 <.L0>:
  }

  /* Sum: '<S166>/Add' incorporates:
   *  Constant: '<S166>/Constant'
   *  Constant: '<S166>/Constant from Model'
   *  Gain: '<S171>/Unit Conversion'
   *  Product: '<S166>/Divide'
   *  Saturate: '<S166>/[0 1000]'
   */
  AUAV_V3_TestSensors_B.Add = 1.0F - 3.28084F * rtb_Sum1_mzp / 145442.0F;
    74b2:	82 94 2f    	mov.w     #0xf948, w2
    74b4:	13 05 24    	mov.w     #0x4051, w3
    74b6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    74b8:	00 00 00 
    74ba:	02 88 20    	mov.w     #0x880, w2
    74bc:	e3 80 24    	mov.w     #0x480e, w3
    74be:	26 17 02    	call      0x1726 <___divsf3>
    74c0:	00 00 00 
    74c2:	00 01 be    	mov.d     w0, w2
    74c4:	00 00 20    	mov.w     #0x0, w0
    74c6:	01 f8 23    	mov.w     #0x3f80, w1
    74c8:	90 14 02    	call      0x1490 <___subsf3>
    74ca:	00 00 00 
    74cc:	d0 c4 88    	mov.w     w0, 0x189a
    74ce:	e1 c4 88    	mov.w     w1, 0x189c

000074d0 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S172>/myPow() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myPowapUtilscupdated5116 = myPow(
    74d0:	32 02 23    	mov.w     #0x3023, w2
    74d2:	83 08 24    	mov.w     #0x4088, w3
    74d4:	10 10 02    	call      0x11010 <_myPow>
    74d6:	01 00 00 
    74d8:	f0 c4 88    	mov.w     w0, 0x189e
    74da:	01 c5 88    	mov.w     w1, 0x18a0

000074dc <.L0>:
    AUAV_V3_TestSensors_B.Add
    , 4.25587606F
    );

  /* Product: '<S166>/Divide1' incorporates:
   *  Constant: '<S166>/Rho_0 (Kg//m^3)'
   */
  rtb_Sum1_mzp = AUAV_V3_TestSensors_B.myPowapUtilscupdated5116 * 1.225F;
    74dc:	d2 cc 2c    	mov.w     #0xcccd, w2
    74de:	c3 f9 23    	mov.w     #0x3f9c, w3
    74e0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    74e2:	00 00 00 
    74e4:	00 04 be    	mov.d     w0, w8

000074e6 <.L0>:

  /* Saturate: '<S167>/[ 0.01 50000]' */
  if (rtb_Sum1_mzp > 50000.0F) {
    74e6:	02 00 25    	mov.w     #0x5000, w2
    74e8:	33 74 24    	mov.w     #0x4743, w3
    74ea:	90 18 02    	call      0x1890 <___gesf2>
    74ec:	00 00 00 
    74ee:	00 00 e0    	cp0.w     w0
    74f0:	08 00 3c    	bra       GT, 0x7502 <.L0> <.L441>

000074f2 <.L0>:
    rtb_Sum1_mzp = 50000.0F;
  } else {
    if (rtb_Sum1_mzp < 0.01F) {
    74f2:	a2 70 2d    	mov.w     #0xd70a, w2
    74f4:	33 c2 23    	mov.w     #0x3c23, w3
    74f6:	08 00 be    	mov.d     w8, w0
    74f8:	8c 18 02    	call      0x188c <___eqsf2>
    74fa:	00 00 00 
    74fc:	00 00 e0    	cp0.w     w0
    74fe:	04 00 35    	bra       LT, 0x7508 <.L442>
    7500:	05 00 37    	bra       0x750c <.L0> <.L230>

00007502 <.L0>:
    7502:	08 00 25    	mov.w     #0x5000, w8
    7504:	39 74 24    	mov.w     #0x4743, w9
    7506:	02 00 37    	bra       0x750c <.L0> <.L230>

00007508 <.L442>:
      rtb_Sum1_mzp = 0.01F;
    7508:	a8 70 2d    	mov.w     #0xd70a, w8
    750a:	39 c2 23    	mov.w     #0x3c23, w9

0000750c <.L0>:
    }
  }

  /* MATLAB Function: '<S174>/negprotect' incorporates:
   *  Constant: '<S167>/a'
   *  DataStoreRead: '<Root>/Get mlAirData'
   *  Gain: '<Root>/Gain1'
   *  Product: '<S167>/Divide2'
   *  Saturate: '<S167>/[ 0.01 50000]'
   */
  AUAV_V3_TestS_negprotect_l(2.0F * (100.0F * mlAirData.press_diff) /
    750c:	02 00 20    	mov.w     #0x0, w2
    750e:	83 2c 24    	mov.w     #0x42c8, w3
    7510:	00 84 80    	mov.w     0x1080, w0
    7512:	11 84 80    	mov.w     0x1082, w1
    7514:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7516:	00 00 00 
    7518:	00 01 be    	mov.d     w0, w2
    751a:	92 14 02    	call      0x1492 <___addsf3>
    751c:	00 00 00 
    751e:	08 01 be    	mov.d     w8, w2
    7520:	26 17 02    	call      0x1726 <___divsf3>
    7522:	00 00 00 
    7524:	02 d4 21    	mov.w     #0x1d40, w2
    7526:	17 ed 07    	rcall     0x4f56 <_AUAV_V3_TestS_negprotect_l> <L0> <.LFB1481> <.LFE1480>

00007528 <.L0>:
    rtb_Sum1_mzp, &AUAV_V3_TestSensors_B.sf_negprotect_l);

  /* S-Function (MCHP_C_function_Call): '<S174>/mySqrt() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_me = mySqrt(
    7528:	00 ea 80    	mov.w     0x1d40, w0
    752a:	11 ea 80    	mov.w     0x1d42, w1
    752c:	16 10 02    	call      0x11016 <_mySqrt>
    752e:	01 00 00 
    7530:	00 04 be    	mov.d     w0, w8
    7532:	10 c5 88    	mov.w     w0, 0x18a2
    7534:	21 c5 88    	mov.w     w1, 0x18a4

00007536 <.L0>:
    AUAV_V3_TestSensors_B.sf_negprotect_l.zpVal
    );

  /* Switch: '<S168>/Switch3' incorporates:
   *  RelationalOperator: '<S168>/Relational Operator2'
   */
  if ((AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_me ==
    7536:	00 01 be    	mov.d     w0, w2
    7538:	8c 18 02    	call      0x188c <___eqsf2>
    753a:	00 00 00 
    753c:	00 00 e0    	cp0.w     w0
    753e:	02 00 3a    	bra       NZ, 0x7544 <.L0> <.L231>

00007540 <.L0>:
       AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_me) > 0) {
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_g =
    7540:	68 f3 88    	mov.w     w8, 0x1e6c
    7542:	79 f3 88    	mov.w     w9, 0x1e6e

00007544 <.L0>:
      AUAV_V3_TestSensors_B.mySqrtapUtilscupdated5116_me;
  }

  /* End of Switch: '<S168>/Switch3' */

  /* MATLAB Function: '<S165>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S165>/Constant'
   *  Constant: '<S165>/Constant1'
   */
  AUA_EmbeddedMATLABFunction(AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_g,
    7544:	c8 e6 21    	mov.w     #0x1e6c, w8
    7546:	47 33 20    	mov.w     #0x334, w7
    7548:	88 83 43    	add.w     w7, w8, w7
    754a:	46 d4 21    	mov.w     #0x1d44, w6
    754c:	04 00 20    	mov.w     #0x0, w4
    754e:	05 f8 23    	mov.w     #0x3f80, w5
    7550:	a2 70 2d    	mov.w     #0xd70a, w2
    7552:	33 c2 23    	mov.w     #0x3c23, w3
    7554:	18 00 be    	mov.d     [w8], w0
    7556:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    7558:	01 00 00 

0000755a <.L0>:
    0.01, 1.0, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_n,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_n);

  /* Switch: '<S145>/Schedule LPF' incorporates:
   *  Constant: '<S169>/Constant'
   *  RelationalOperator: '<S169>/Compare'
   */
  if ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_g <= 5.0F) > 0) {
    755a:	18 02 be    	mov.d     [w8], w4
    755c:	34 b7 99    	mov.w     w4, [w14+486]
    755e:	45 b7 99    	mov.w     w5, [w14+488]
    7560:	02 00 20    	mov.w     #0x0, w2
    7562:	03 0a 24    	mov.w     #0x40a0, w3
    7564:	04 00 be    	mov.d     w4, w0
    7566:	8c 18 02    	call      0x188c <___eqsf2>
    7568:	00 00 00 
    756a:	00 00 e0    	cp0.w     w0
    756c:	04 00 34    	bra       LE, 0x7576 <.L233>

0000756e <.L0>:
    rtb_Product3_bo = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_g;
  } else {
    rtb_Product3_bo = AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_n.y;
    756e:	20 ea 80    	mov.w     0x1d44, w0
    7570:	31 ea 80    	mov.w     0x1d46, w1
    7572:	30 b7 99    	mov.w     w0, [w14+486]
    7574:	41 b7 99    	mov.w     w1, [w14+488]

00007576 <.L233>:
  }

  /* End of Switch: '<S145>/Schedule LPF' */

  /* Product: '<S150>/delta rise limit' incorporates:
   *  Constant: '<S140>/Constant3'
   *  SampleTimeMath: '<S150>/sample time'
   *
   * About '<S150>/sample time':
   *  y = K where K = ( w * Ts )
   */
  rtb_RhhcosphisinlambYe = 0.02F;

  /* Switch: '<S178>/Init' incorporates:
   *  UnitDelay: '<S178>/FixPt Unit Delay1'
   *  UnitDelay: '<S178>/FixPt Unit Delay2'
   */
  if (AUAV_V3_TestSensors_DWork.FixPtUnitDelay2_DSTATE != 0) {
    7576:	90 ff 21    	mov.w     #0x1ff9, w0
    7578:	10 04 e0    	cp0.b     [w0]
    757a:	03 00 3a    	bra       NZ, 0x7582 <.L443>
    rtb_Deg2R1 = 100.0F;
  } else {
    rtb_Deg2R1 = AUAV_V3_TestSensors_DWork.FixPtUnitDelay1_DSTATE;
    757c:	8a f3 80    	mov.w     0x1e70, w10
    757e:	9b f3 80    	mov.w     0x1e72, w11
    7580:	02 00 37    	bra       0x7586 <.L234>

00007582 <.L443>:
    7582:	0a 00 20    	mov.w     #0x0, w10
    7584:	8b 2c 24    	mov.w     #0x42c8, w11

00007586 <.L234>:
  }

  /* End of Switch: '<S178>/Init' */
  /* End of Outputs for SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */

  /* Switch: '<S6>/Switch' incorporates:
   *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
   */
  if (rtb_IC1_a) {
    7586:	ce 58 93    	mov.b     [w14+412], w1
    7588:	01 04 e0    	cp0.b     w1
    758a:	03 00 32    	bra       Z, 0x7592 <.L235>
    rtb_Sum1_mzp = mlMidLevelCommands.hCommand;
    758c:	50 89 80    	mov.w     0x112a, w0
    758e:	61 89 80    	mov.w     0x112c, w1
    7590:	02 00 37    	bra       0x7596 <.L0> <.L236>

00007592 <.L235>:
  } else {
    rtb_Sum1_mzp = AUAV_V3_TestSensors_B.Merge1;
    7592:	b0 bd 80    	mov.w     0x17b6, w0
    7594:	c1 bd 80    	mov.w     0x17b8, w1

00007596 <.L0>:
  }

  /* End of Switch: '<S6>/Switch' */

  /* Outputs for Atomic SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */
  /* Sum: '<S150>/Difference Inputs1' */
  rtb_Sum1_mzp -= rtb_Deg2R1;
    7596:	0a 01 be    	mov.d     w10, w2
    7598:	90 14 02    	call      0x1490 <___subsf3>
    759a:	00 00 00 
    759c:	00 04 be    	mov.d     w0, w8

0000759e <.L0>:

  /* Switch: '<S177>/Switch2' incorporates:
   *  RelationalOperator: '<S177>/LowerRelop1'
   */
  if (!(rtb_Sum1_mzp > 0.02F)) {
    759e:	1c c0 b3    	mov.b     #0x1, w12
    75a0:	a2 70 2d    	mov.w     #0xd70a, w2
    75a2:	33 ca 23    	mov.w     #0x3ca3, w3
    75a4:	90 18 02    	call      0x1890 <___gesf2>
    75a6:	00 00 00 
    75a8:	00 00 e0    	cp0.w     w0
    75aa:	01 00 3c    	bra       GT, 0x75ae <.L238>
    75ac:	00 46 eb    	clr.b     w12

000075ae <.L238>:
    75ae:	0c 04 e0    	cp0.b     w12
    75b0:	0a 00 3a    	bra       NZ, 0x75c6 <.L444>

000075b2 <.L0>:
    /* Switch: '<S177>/Switch' incorporates:
     *  RelationalOperator: '<S177>/UpperRelop'
     */
    if (rtb_Sum1_mzp < -0.03F) {
    75b2:	f2 28 2c    	mov.w     #0xc28f, w2
    75b4:	53 cf 2b    	mov.w     #0xbcf5, w3
    75b6:	08 00 be    	mov.d     w8, w0
    75b8:	8c 18 02    	call      0x188c <___eqsf2>
    75ba:	00 00 00 
    75bc:	00 00 e0    	cp0.w     w0
    75be:	06 00 3d    	bra       GE, 0x75cc <.L616>

000075c0 <.L0>:
      rtb_RhhcosphisinlambYe = -0.03F;
    75c0:	f0 28 2c    	mov.w     #0xc28f, w0
    75c2:	51 cf 2b    	mov.w     #0xbcf5, w1
    75c4:	04 00 37    	bra       0x75ce <.L0> <.L237>

000075c6 <.L444>:
    75c6:	a0 70 2d    	mov.w     #0xd70a, w0
    75c8:	31 ca 23    	mov.w     #0x3ca3, w1
    75ca:	01 00 37    	bra       0x75ce <.L0> <.L237>

000075cc <.L616>:
    } else {
      rtb_RhhcosphisinlambYe = rtb_Sum1_mzp;
    75cc:	08 00 be    	mov.d     w8, w0

000075ce <.L0>:
    }

    /* End of Switch: '<S177>/Switch' */
  }

  /* End of Switch: '<S177>/Switch2' */

  /* Sum: '<S150>/Difference Inputs2' */
  AUAV_V3_TestSensors_DWork.FixPtUnitDelay1_DSTATE = rtb_RhhcosphisinlambYe +
    75ce:	0a 01 be    	mov.d     w10, w2
    75d0:	92 14 02    	call      0x1492 <___addsf3>
    75d2:	00 00 00 
    75d4:	00 04 be    	mov.d     w0, w8
    75d6:	80 f3 88    	mov.w     w0, 0x1e70
    75d8:	91 f3 88    	mov.w     w1, 0x1e72

000075da <.L0>:
    rtb_Deg2R1;

  /* Sum: '<S140>/Add2' */
  rtb_Deg2R1 = AUAV_V3_TestSensors_DWork.FixPtUnitDelay1_DSTATE - rtb_Switch3;
    75da:	7e a9 91    	mov.w     [w14+478], w2
    75dc:	8e b1 91    	mov.w     [w14+480], w3
    75de:	90 14 02    	call      0x1490 <___subsf3>
    75e0:	00 00 00 
    75e2:	00 05 be    	mov.d     w0, w10

000075e4 <.L0>:

  /* Switch: '<S147>/Switch3' incorporates:
   *  RelationalOperator: '<S147>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    75e4:	00 01 be    	mov.d     w0, w2
    75e6:	8c 18 02    	call      0x188c <___eqsf2>
    75e8:	00 00 00 
    75ea:	00 00 e0    	cp0.w     w0
    75ec:	02 00 3a    	bra       NZ, 0x75f2 <.L0> <.L240>

000075ee <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_e = rtb_Deg2R1;
    75ee:	aa f3 88    	mov.w     w10, 0x1e74
    75f0:	bb f3 88    	mov.w     w11, 0x1e76

000075f2 <.L0>:
  }

  /* End of Switch: '<S147>/Switch3' */

  /* Product: '<S143>/Product1' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_HE_TO_PI_P PAR_PID_HE_TO_PI_I'
   */
  rtb_Sum1_mzp = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_e *
    75f2:	ac f3 80    	mov.w     0x1e74, w12
    75f4:	bd f3 80    	mov.w     0x1e76, w13
    75f6:	f2 93 80    	mov.w     0x127e, w2
    75f8:	03 94 80    	mov.w     0x1280, w3
    75fa:	0c 00 be    	mov.d     w12, w0
    75fc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    75fe:	00 00 00 
    7600:	50 b7 99    	mov.w     w0, [w14+490]
    7602:	61 b7 99    	mov.w     w1, [w14+492]

00007604 <.L0>:
    mlParamInterface.param[9];

  /* Sum: '<S143>/Sum2' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_HE_TO_PI_P PAR_PID_HE_TO_PI_I'
   *  Gain: '<S143>/Gain'
   *  Memory: '<S143>/Memory1'
   *  Product: '<S143>/Product4'
   */
  rtb_Deg2R1 = (0.01F * AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_e *
                mlParamInterface.param[10] +
    7604:	14 94 80    	mov.w     0x1282, w4
    7606:	25 94 80    	mov.w     0x1284, w5
    7608:	14 b7 99    	mov.w     w4, [w14+482]
    760a:	25 b7 99    	mov.w     w5, [w14+484]

0000760c <.L0>:
    760c:	a2 70 2d    	mov.w     #0xd70a, w2
    760e:	33 c2 23    	mov.w     #0x3c23, w3
    7610:	0c 00 be    	mov.d     w12, w0
    7612:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7614:	00 00 00 
    7616:	1e b1 91    	mov.w     [w14+482], w2
    7618:	ae b1 91    	mov.w     [w14+484], w3
    761a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    761c:	00 00 00 

0000761e <.L0>:
    761e:	e2 fe 80    	mov.w     0x1fdc, w2
    7620:	f3 fe 80    	mov.w     0x1fde, w3
    7622:	92 14 02    	call      0x1492 <___addsf3>
    7624:	00 00 00 

00007626 <.L0>:
    7626:	5e b1 91    	mov.w     [w14+490], w2
    7628:	ee b1 91    	mov.w     [w14+492], w3
    762a:	92 14 02    	call      0x1492 <___addsf3>
    762c:	00 00 00 
    762e:	00 05 be    	mov.d     w0, w10

00007630 <.L0>:
                AUAV_V3_TestSensors_DWork.Memory1_PreviousInput) + rtb_Sum1_mzp;

  /* Switch: '<S143>/AntiWindup' incorporates:
   *  Constant: '<S143>/Constant5'
   *  Logic: '<S143>/Logical Operator'
   *  RelationalOperator: '<S143>/Relational Operator'
   *  RelationalOperator: '<S143>/Relational Operator1'
   */
  if ((rtb_Deg2R1 > -0.261799395F) && (rtb_Deg2R1 < 0.261799395F)) {
    7630:	22 a9 20    	mov.w     #0xa92, w2
    7632:	63 e8 2b    	mov.w     #0xbe86, w3
    7634:	90 18 02    	call      0x1890 <___gesf2>
    7636:	00 00 00 
    7638:	00 00 e0    	cp0.w     w0
    763a:	0e 00 34    	bra       LE, 0x7658 <.L0> <.L617>
    763c:	22 a9 20    	mov.w     #0xa92, w2
    763e:	63 e8 23    	mov.w     #0x3e86, w3
    7640:	0a 00 be    	mov.d     w10, w0
    7642:	8c 18 02    	call      0x188c <___eqsf2>
    7644:	00 00 00 
    7646:	00 00 e0    	cp0.w     w0
    7648:	09 00 3d    	bra       GE, 0x765c <.L618>

0000764a <.L0>:
    rtb_Deg2R1 = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_e;
  } else {
    rtb_Deg2R1 = 0.0F;
  }

  /* End of Switch: '<S143>/AntiWindup' */

  /* Switch: '<S160>/Switch3' incorporates:
   *  RelationalOperator: '<S160>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    764a:	0c 01 be    	mov.d     w12, w2
    764c:	0c 00 be    	mov.d     w12, w0
    764e:	8c 18 02    	call      0x188c <___eqsf2>
    7650:	00 00 00 
    7652:	00 00 e0    	cp0.w     w0
    7654:	06 00 3a    	bra       NZ, 0x7662 <.L245>
    7656:	03 00 37    	bra       0x765e <.L242>

00007658 <.L0>:
    7658:	60 66 b8    	mul.uu    w12, #0x0, w12
    765a:	01 00 37    	bra       0x765e <.L242>

0000765c <.L618>:
    765c:	60 66 b8    	mul.uu    w12, #0x0, w12

0000765e <.L242>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_a = rtb_Deg2R1;
    765e:	ec f3 88    	mov.w     w12, 0x1e7c
    7660:	fd f3 88    	mov.w     w13, 0x1e7e

00007662 <.L245>:
  }

  /* End of Switch: '<S160>/Switch3' */

  /* Switch: '<S158>/Switch1' incorporates:
   *  Constant: '<S158>/Constant'
   *  Constant: '<S158>/Constant1'
   *  Constant: '<S158>/Constant2'
   *  Constant: '<S158>/Constant3'
   *  Constant: '<S158>/Constant5'
   *  Delay: '<S158>/Integer Delay'
   *  Delay: '<S158>/Integer Delay1'
   *  Delay: '<S158>/Integer Delay2'
   *  Product: '<S158>/Product'
   *  Product: '<S158>/Product1'
   *  Product: '<S158>/Product2'
   *  Product: '<S158>/Product3'
   *  Sum: '<S158>/Subtract'
   *  Sum: '<S158>/Subtract1'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    7662:	e0 a1 21    	mov.w     #0x1a1e, w0
    7664:	10 46 78    	mov.b     [w0], w12
    rtb_Deg2R1 = 0.0F;
    7666:	60 55 b8    	mul.uu    w10, #0x0, w10
    7668:	0c 04 e0    	cp0.b     w12
    766a:	2a 00 3a    	bra       NZ, 0x76c0 <.L0> <.L247>

0000766c <.L0>:
  } else {
    rtb_Deg2R1 = ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_a *
    766c:	b2 aa 2a    	mov.w     #0xaaab, w2
    766e:	a3 ea 23    	mov.w     #0x3eaa, w3
    7670:	e0 f3 80    	mov.w     0x1e7c, w0
    7672:	f1 f3 80    	mov.w     0x1e7e, w1
    7674:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7676:	00 00 00 
    7678:	00 05 be    	mov.d     w0, w10

0000767a <.L0>:
                   0.333333343F +
                   AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_a * 1.33333337F)
    767a:	b2 aa 2a    	mov.w     #0xaaab, w2
    767c:	a3 fa 23    	mov.w     #0x3faa, w3
    767e:	00 f4 80    	mov.w     0x1e80, w0
    7680:	11 f4 80    	mov.w     0x1e82, w1
    7682:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7684:	00 00 00 
    7686:	00 01 be    	mov.d     w0, w2

00007688 <.L0>:
    7688:	0a 00 be    	mov.d     w10, w0
    768a:	92 14 02    	call      0x1492 <___addsf3>
    768c:	00 00 00 
    768e:	00 05 be    	mov.d     w0, w10

00007690 <.L0>:
                  + AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_h[0] *
    7690:	b2 aa 2a    	mov.w     #0xaaab, w2
    7692:	a3 ea 23    	mov.w     #0x3eaa, w3
    7694:	20 f4 80    	mov.w     0x1e84, w0
    7696:	31 f4 80    	mov.w     0x1e86, w1
    7698:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    769a:	00 00 00 
    769c:	00 01 be    	mov.d     w0, w2
    769e:	0a 00 be    	mov.d     w10, w0
    76a0:	92 14 02    	call      0x1492 <___addsf3>
    76a2:	00 00 00 

000076a4 <.L0>:
                  0.333333343F) * 0.005F +
    76a4:	a2 70 2d    	mov.w     #0xd70a, w2
    76a6:	33 ba 23    	mov.w     #0x3ba3, w3
    76a8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    76aa:	00 00 00 

000076ac <.L0>:
    76ac:	c2 f3 80    	mov.w     0x1e78, w2
    76ae:	d3 f3 80    	mov.w     0x1e7a, w3
    76b0:	92 14 02    	call      0x1492 <___addsf3>
    76b2:	00 00 00 
    76b4:	00 05 be    	mov.d     w0, w10

000076b6 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE;
  }

  /* End of Switch: '<S158>/Switch1' */

  /* Switch: '<S159>/Switch3' incorporates:
   *  RelationalOperator: '<S159>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    76b6:	00 01 be    	mov.d     w0, w2
    76b8:	8c 18 02    	call      0x188c <___eqsf2>
    76ba:	00 00 00 
    76bc:	00 00 e0    	cp0.w     w0
    76be:	0a 00 3a    	bra       NZ, 0x76d4 <.L0> <.L248>

000076c0 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_av = rtb_Deg2R1;
    76c0:	6a f4 88    	mov.w     w10, 0x1e8c
    76c2:	7b f4 88    	mov.w     w11, 0x1e8e
  }

  /* End of Switch: '<S159>/Switch3' */

  /* Switch: '<S143>/On//Off' incorporates:
   *  Constant: '<S143>/Constant1'
   *  DataStoreRead: '<S10>/PAR_PID_HE_TO_PI_P PAR_PID_HE_TO_PI_I'
   *  Product: '<S143>/Product'
   *  Sum: '<S143>/Add2'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    76c4:	0c 04 e0    	cp0.b     w12
    76c6:	06 00 32    	bra       Z, 0x76d4 <.L0> <.L248>
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput = 0.0F;
    76c8:	60 00 b8    	mul.uu    w0, #0x0, w0
    76ca:	e0 fe 88    	mov.w     w0, 0x1fdc
    76cc:	f1 fe 88    	mov.w     w1, 0x1fde
  } else {
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput =
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_av *
      mlParamInterface.param[10] + rtb_Sum1_mzp;
  }

  /* End of Switch: '<S143>/On//Off' */

  /* Switch: '<S157>/Switch2' incorporates:
   *  RelationalOperator: '<S157>/LowerRelop1'
   *  RelationalOperator: '<S157>/UpperRelop'
   *  Switch: '<S157>/Switch'
   */
  if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput > 0.261799395F) {
    76ce:	50 b7 99    	mov.w     w0, [w14+490]
    76d0:	61 b7 99    	mov.w     w1, [w14+492]
    76d2:	25 00 37    	bra       0x771e <.L250>

000076d4 <.L0>:
    76d4:	62 f4 80    	mov.w     0x1e8c, w2
    76d6:	73 f4 80    	mov.w     0x1e8e, w3
    76d8:	1e b0 91    	mov.w     [w14+482], w0
    76da:	ae b0 91    	mov.w     [w14+484], w1
    76dc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    76de:	00 00 00 

000076e0 <.L0>:
    76e0:	5e b1 91    	mov.w     [w14+490], w2
    76e2:	ee b1 91    	mov.w     [w14+492], w3
    76e4:	92 14 02    	call      0x1492 <___addsf3>
    76e6:	00 00 00 
    76e8:	50 b7 99    	mov.w     w0, [w14+490]
    76ea:	61 b7 99    	mov.w     w1, [w14+492]

000076ec <.L0>:
    76ec:	e0 fe 88    	mov.w     w0, 0x1fdc
    76ee:	f1 fe 88    	mov.w     w1, 0x1fde

000076f0 <.L0>:
    76f0:	22 a9 20    	mov.w     #0xa92, w2
    76f2:	63 e8 23    	mov.w     #0x3e86, w3
    76f4:	90 18 02    	call      0x1890 <___gesf2>
    76f6:	00 00 00 
    76f8:	00 00 e0    	cp0.w     w0
    76fa:	0d 00 3c    	bra       GT, 0x7716 <.L449>

000076fc <.L0>:
    /* Saturate: '<S140>/Theta_c Limit' */
    rtb_Deg2R1 = 0.261799395F;
  } else if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput < -0.261799395F) {
    76fc:	22 a9 20    	mov.w     #0xa92, w2
    76fe:	63 e8 2b    	mov.w     #0xbe86, w3
    7700:	5e b0 91    	mov.w     [w14+490], w0
    7702:	ee b0 91    	mov.w     [w14+492], w1
    7704:	8c 18 02    	call      0x188c <___eqsf2>
    7706:	00 00 00 
    7708:	00 00 e0    	cp0.w     w0
    770a:	09 00 3d    	bra       GE, 0x771e <.L250>

0000770c <.L0>:
    /* Switch: '<S157>/Switch' incorporates:
     *  Saturate: '<S140>/Theta_c Limit'
     */
    rtb_Deg2R1 = -0.261799395F;
    770c:	20 a9 20    	mov.w     #0xa92, w0
    770e:	61 e8 2b    	mov.w     #0xbe86, w1
    7710:	50 b7 99    	mov.w     w0, [w14+490]
    7712:	61 b7 99    	mov.w     w1, [w14+492]
    7714:	04 00 37    	bra       0x771e <.L250>

00007716 <.L449>:
    7716:	22 a9 20    	mov.w     #0xa92, w2
    7718:	63 e8 23    	mov.w     #0x3e86, w3
    771a:	52 b7 99    	mov.w     w2, [w14+490]
    771c:	63 b7 99    	mov.w     w3, [w14+492]

0000771e <.L250>:
  } else {
    /* Saturate: '<S140>/Theta_c Limit' incorporates:
     *  Switch: '<S157>/Switch'
     */
    rtb_Deg2R1 = AUAV_V3_TestSensors_DWork.Memory1_PreviousInput;
  }

  /* End of Switch: '<S157>/Switch2' */

  /* DataStoreWrite: '<S71>/mlNavigation' */
  mlNavigation.u_m = rtb_Product3_bo;
    771e:	3e b2 91    	mov.w     [w14+486], w4
    7720:	ce b2 91    	mov.w     [w14+488], w5
    7722:	d4 91 88    	mov.w     w4, 0x123a
    7724:	e5 91 88    	mov.w     w5, 0x123c
  mlNavigation.theta_c = rtb_Deg2R1;
    7726:	5e b0 91    	mov.w     [w14+490], w0
    7728:	ee b0 91    	mov.w     [w14+492], w1
    772a:	10 92 88    	mov.w     w0, 0x1242
    772c:	21 92 88    	mov.w     w1, 0x1244

0000772e <.L0>:

  /* DataTypeConversion: '<S140>/Data Type Conversion' */
  rtb_RhhcosphicoslambXe = (real32_T)floor
    772e:	08 00 be    	mov.d     w8, w0
    7730:	16 19 02    	call      0x1916 <_floorf>
    7732:	00 00 00 
    7734:	00 04 be    	mov.d     w0, w8

00007736 <.L0>:
    (AUAV_V3_TestSensors_DWork.FixPtUnitDelay1_DSTATE);
  if (rtIsNaNF(rtb_RhhcosphicoslambXe) || rtIsInfF(rtb_RhhcosphicoslambXe)) {
    7736:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    7738:	01 00 00 
    773a:	00 04 e0    	cp0.b     w0
    773c:	9d 0b 3a    	bra       NZ, 0x8e78 <.L252>
    773e:	08 00 be    	mov.d     w8, w0
    7740:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    7742:	01 00 00 
    7744:	00 04 e0    	cp0.b     w0
    7746:	98 0b 3a    	bra       NZ, 0x8e78 <.L252>

00007748 <.L0>:
    rtb_RhhcosphicoslambXe = 0.0F;
  } else {
    rtb_RhhcosphicoslambXe = (real32_T)fmod(rtb_RhhcosphicoslambXe, 65536.0F);
    7748:	02 00 20    	mov.w     #0x0, w2
    774a:	03 78 24    	mov.w     #0x4780, w3
    774c:	08 00 be    	mov.d     w8, w0
    774e:	26 19 02    	call      0x1926 <_fmodf>
    7750:	00 00 00 
    7752:	00 04 be    	mov.d     w0, w8

00007754 <.L0>:
  }

  /* DataStoreWrite: '<S71>/mlNavigation' incorporates:
   *  DataTypeConversion: '<S140>/Data Type Conversion'
   */
  mlNavigation.h_c = rtb_RhhcosphicoslambXe < 0.0F ? (uint16_T)-(int16_T)
    (uint16_T)-rtb_RhhcosphicoslambXe : (uint16_T)rtb_RhhcosphicoslambXe;
    7754:	60 11 b8    	mul.uu    w2, #0x0, w2
    7756:	8c 18 02    	call      0x188c <___eqsf2>
    7758:	00 00 00 
    775a:	00 00 e0    	cp0.w     w0
    775c:	06 00 3d    	bra       GE, 0x776a <.L0> <.L253>
    775e:	08 00 be    	mov.d     w8, w0
    7760:	01 f0 a2    	btg.w     w1, #0xf
    7762:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    7764:	00 00 00 

00007766 <.L0>:
    7766:	00 00 ea    	neg.w     w0, w0
    7768:	03 00 37    	bra       0x7770 <.L0> <.L255>

0000776a <.L0>:
    776a:	08 00 be    	mov.d     w8, w0
    776c:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    776e:	00 00 00 

00007770 <.L0>:
    7770:	b0 92 88    	mov.w     w0, 0x1256

00007772 <.L0>:

  /* Switch: '<S149>/Switch3' incorporates:
   *  RelationalOperator: '<S149>/Relational Operator2'
   */
  if ((AUAV_V3_TestSensors_B.y_j[0] == AUAV_V3_TestSensors_B.y_j[0]) > 0) {
    7772:	38 b1 80    	mov.w     0x1626, w8
    7774:	49 b1 80    	mov.w     0x1628, w9
    7776:	08 01 be    	mov.d     w8, w2
    7778:	08 00 be    	mov.d     w8, w0
    777a:	8c 18 02    	call      0x188c <___eqsf2>
    777c:	00 00 00 
    777e:	00 00 e0    	cp0.w     w0
    7780:	02 00 3a    	bra       NZ, 0x7786 <.L0> <.L256>

00007782 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_c =
    7782:	88 f4 88    	mov.w     w8, 0x1e90
    7784:	99 f4 88    	mov.w     w9, 0x1e92

00007786 <.L0>:
      AUAV_V3_TestSensors_B.y_j[0];
  }

  /* End of Switch: '<S149>/Switch3' */

  /* MATLAB Function: '<S141>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S141>/Constant'
   *  Constant: '<S141>/Constant1'
   */
  AUA_EmbeddedMATLABFunction(AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_c,
    7786:	27 1b 22    	mov.w     #0x21b2, w7
    7788:	86 d4 21    	mov.w     #0x1d48, w6
    778a:	a4 70 2d    	mov.w     #0xd70a, w4
    778c:	35 ea 23    	mov.w     #0x3ea3, w5
    778e:	a2 70 2d    	mov.w     #0xd70a, w2
    7790:	33 c2 23    	mov.w     #0x3c23, w3
    7792:	80 f4 80    	mov.w     0x1e90, w0
    7794:	91 f4 80    	mov.w     0x1e92, w1
    7796:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    7798:	01 00 00 

0000779a <.L0>:
    0.01, 0.32, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_i);

  /* Sum: '<S140>/Add' incorporates:
   *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
   */
  rtb_RhhcosphisinlambYe = mlMidLevelCommands.uCommand - rtb_Product3_bo;
    779a:	3e b1 91    	mov.w     [w14+486], w2
    779c:	ce b1 91    	mov.w     [w14+488], w3
    779e:	70 89 80    	mov.w     0x112e, w0
    77a0:	81 89 80    	mov.w     0x1130, w1
    77a2:	90 14 02    	call      0x1490 <___subsf3>
    77a4:	00 00 00 
    77a6:	00 05 be    	mov.d     w0, w10

000077a8 <.L0>:

  /* Sum: '<S142>/Add3' incorporates:
   *  Constant: '<S142>/SaturationLimit'
   */
  rtb_y_jl_idx_0 = 0.95F - AUAV_V3_TestSensors_B.DataTypeConversion;
    77a8:	fc b1 80    	mov.w     0x163e, w12
    77aa:	0d b2 80    	mov.w     0x1640, w13
    77ac:	0c 01 be    	mov.d     w12, w2
    77ae:	30 33 23    	mov.w     #0x3333, w0
    77b0:	31 f7 23    	mov.w     #0x3f73, w1
    77b2:	90 14 02    	call      0x1490 <___subsf3>
    77b4:	00 00 00 
    77b6:	00 04 be    	mov.d     w0, w8

000077b8 <.L0>:

  /* Switch: '<S146>/Switch3' incorporates:
   *  RelationalOperator: '<S146>/Relational Operator2'
   */
  if ((rtb_RhhcosphisinlambYe == rtb_RhhcosphisinlambYe) > 0) {
    77b8:	0a 01 be    	mov.d     w10, w2
    77ba:	0a 00 be    	mov.d     w10, w0
    77bc:	8c 18 02    	call      0x188c <___eqsf2>
    77be:	00 00 00 
    77c0:	00 00 e0    	cp0.w     w0
    77c2:	02 00 3a    	bra       NZ, 0x77c8 <.L0> <.L258>

000077c4 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j = rtb_RhhcosphisinlambYe;
    77c4:	aa f4 88    	mov.w     w10, 0x1e94
    77c6:	bb f4 88    	mov.w     w11, 0x1e96

000077c8 <.L0>:
  }

  /* End of Switch: '<S146>/Switch3' */

  /* Sum: '<S142>/Add1' incorporates:
   *  Constant: '<S142>/delayTime'
   *  DataStoreRead: '<S10>/PAR_PID_AIRSPEED_P PAR_PID_AIRSPEED_I PAR_PID_AIRSPEED_D'
   *  Delay: '<S142>/NDelays'
   *  Product: '<S142>/Product1'
   *  Product: '<S142>/Product2'
   *  Product: '<S142>/Product3'
   *  Sum: '<S142>/Sum'
   */
  rtb_Sum1_mzp = (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j -
    77c8:	aa f4 80    	mov.w     0x1e94, w10
    77ca:	bb f4 80    	mov.w     0x1e96, w11
    77cc:	c2 f4 80    	mov.w     0x1e98, w2
    77ce:	d3 f4 80    	mov.w     0x1e9a, w3
    77d0:	0a 00 be    	mov.d     w10, w0
    77d2:	90 14 02    	call      0x1490 <___subsf3>
    77d4:	00 00 00 

000077d6 <.L0>:
                  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[0]) / 0.05F *
    77d6:	d2 cc 2c    	mov.w     #0xcccd, w2
    77d8:	c3 d4 23    	mov.w     #0x3d4c, w3
    77da:	26 17 02    	call      0x1726 <___divsf3>
    77dc:	00 00 00 
    77de:	12 93 80    	mov.w     0x1262, w2
    77e0:	23 93 80    	mov.w     0x1264, w3
    77e2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    77e4:	00 00 00 
    77e6:	10 b7 99    	mov.w     w0, [w14+482]
    77e8:	21 b7 99    	mov.w     w1, [w14+484]

000077ea <.L0>:
    mlParamInterface.param[2] + AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j
    * mlParamInterface.param[0];
    77ea:	d2 92 80    	mov.w     0x125a, w2
    77ec:	e3 92 80    	mov.w     0x125c, w3
    77ee:	0a 00 be    	mov.d     w10, w0
    77f0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    77f2:	00 00 00 
    77f4:	00 01 be    	mov.d     w0, w2

000077f6 <.L0>:
    77f6:	1e b0 91    	mov.w     [w14+482], w0
    77f8:	ae b0 91    	mov.w     [w14+484], w1
    77fa:	92 14 02    	call      0x1492 <___addsf3>
    77fc:	00 00 00 
    77fe:	10 af 99    	mov.w     w0, [w14+466]
    7800:	21 af 99    	mov.w     w1, [w14+468]

00007802 <.L0>:

  /* Sum: '<S142>/Sum2' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_AIRSPEED_P PAR_PID_AIRSPEED_I PAR_PID_AIRSPEED_D'
   *  Gain: '<S142>/Gain'
   *  Memory: '<S142>/Memory1'
   *  Product: '<S142>/Product4'
   */
  rtb_IC4_idx_0 = (0.01F * AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j *
                   mlParamInterface.param[1] +
    7802:	f0 92 80    	mov.w     0x125e, w0
    7804:	01 93 80    	mov.w     0x1260, w1
    7806:	50 a7 99    	mov.w     w0, [w14+458]
    7808:	61 a7 99    	mov.w     w1, [w14+460]

0000780a <.L0>:
    780a:	a2 70 2d    	mov.w     #0xd70a, w2
    780c:	33 c2 23    	mov.w     #0x3c23, w3
    780e:	0a 00 be    	mov.d     w10, w0
    7810:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7812:	00 00 00 
    7814:	5e a1 91    	mov.w     [w14+458], w2
    7816:	ee a1 91    	mov.w     [w14+460], w3
    7818:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    781a:	00 00 00 

0000781c <.L0>:
    781c:	02 ff 80    	mov.w     0x1fe0, w2
    781e:	13 ff 80    	mov.w     0x1fe2, w3
    7820:	92 14 02    	call      0x1492 <___addsf3>
    7822:	00 00 00 

00007824 <.L0>:
    7824:	1e a9 91    	mov.w     [w14+466], w2
    7826:	ae a9 91    	mov.w     [w14+468], w3
    7828:	92 14 02    	call      0x1492 <___addsf3>
    782a:	00 00 00 
    782c:	10 b7 99    	mov.w     w0, [w14+482]
    782e:	21 b7 99    	mov.w     w1, [w14+484]

00007830 <.L0>:
                   AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p) +
    rtb_Sum1_mzp;

  /* Switch: '<S142>/AntiWindup' incorporates:
   *  Constant: '<S142>/Constant5'
   *  Constant: '<S142>/SaturationLimit'
   *  Constant: '<S142>/SaturationLimit1'
   *  Logic: '<S142>/Logical Operator'
   *  RelationalOperator: '<S142>/Relational Operator'
   *  RelationalOperator: '<S142>/Relational Operator1'
   *  Sum: '<S142>/Add3'
   *  Sum: '<S142>/Add4'
   */
  if ((rtb_IC4_idx_0 > 0.0F - AUAV_V3_TestSensors_B.DataTypeConversion) &&
    7830:	0c 01 be    	mov.d     w12, w2
    7832:	60 00 b8    	mul.uu    w0, #0x0, w0
    7834:	90 14 02    	call      0x1490 <___subsf3>
    7836:	00 00 00 
    7838:	50 af 99    	mov.w     w0, [w14+474]
    783a:	61 af 99    	mov.w     w1, [w14+476]
    783c:	1e b1 91    	mov.w     [w14+482], w2
    783e:	ae b1 91    	mov.w     [w14+484], w3
    7840:	8c 18 02    	call      0x188c <___eqsf2>
    7842:	00 00 00 
    7844:	00 00 e0    	cp0.w     w0
    7846:	0e 00 3d    	bra       GE, 0x7864 <.L0> <.L619>
    7848:	1e b1 91    	mov.w     [w14+482], w2
    784a:	ae b1 91    	mov.w     [w14+484], w3
    784c:	08 00 be    	mov.d     w8, w0
    784e:	90 18 02    	call      0x1890 <___gesf2>
    7850:	00 00 00 
    7852:	00 00 e0    	cp0.w     w0
    7854:	09 00 34    	bra       LE, 0x7868 <.L620>

00007856 <.L0>:
      (rtb_IC4_idx_0 < 0.95F - AUAV_V3_TestSensors_B.DataTypeConversion)) {
    rtb_IC4_idx_0 = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j;
  } else {
    rtb_IC4_idx_0 = 0.0F;
  }

  /* End of Switch: '<S142>/AntiWindup' */

  /* Switch: '<S155>/Switch3' incorporates:
   *  RelationalOperator: '<S155>/Relational Operator2'
   */
  if ((rtb_IC4_idx_0 == rtb_IC4_idx_0) > 0) {
    7856:	0a 01 be    	mov.d     w10, w2
    7858:	0a 00 be    	mov.d     w10, w0
    785a:	8c 18 02    	call      0x188c <___eqsf2>
    785c:	00 00 00 
    785e:	00 00 e0    	cp0.w     w0
    7860:	06 00 3a    	bra       NZ, 0x786e <.L263>
    7862:	03 00 37    	bra       0x786a <.L260>

00007864 <.L0>:
    7864:	60 55 b8    	mul.uu    w10, #0x0, w10
    7866:	01 00 37    	bra       0x786a <.L260>

00007868 <.L620>:
    7868:	60 55 b8    	mul.uu    w10, #0x0, w10

0000786a <.L260>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_cl = rtb_IC4_idx_0;
    786a:	8a f5 88    	mov.w     w10, 0x1eb0
    786c:	9b f5 88    	mov.w     w11, 0x1eb2

0000786e <.L263>:
  }

  /* End of Switch: '<S155>/Switch3' */

  /* Switch: '<S154>/Switch1' incorporates:
   *  Constant: '<S154>/Constant'
   *  Constant: '<S154>/Constant1'
   *  Constant: '<S154>/Constant2'
   *  Constant: '<S154>/Constant3'
   *  Constant: '<S154>/Constant5'
   *  Delay: '<S154>/Integer Delay'
   *  Delay: '<S154>/Integer Delay1'
   *  Delay: '<S154>/Integer Delay2'
   *  Product: '<S154>/Product'
   *  Product: '<S154>/Product1'
   *  Product: '<S154>/Product2'
   *  Product: '<S154>/Product3'
   *  Sum: '<S154>/Subtract'
   *  Sum: '<S154>/Subtract1'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    786e:	e0 a1 21    	mov.w     #0x1a1e, w0
    7870:	10 40 78    	mov.b     [w0], w0
    7872:	20 e7 9b    	mov.b     w0, [w14+482]
    rtb_IC4_idx_0 = 0.0F;
    7874:	60 55 b8    	mul.uu    w10, #0x0, w10
    7876:	00 04 e0    	cp0.b     w0
    7878:	2a 00 3a    	bra       NZ, 0x78ce <.L0> <.L265>

0000787a <.L0>:
  } else {
    rtb_IC4_idx_0 = ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_cl *
    787a:	b2 aa 2a    	mov.w     #0xaaab, w2
    787c:	a3 ea 23    	mov.w     #0x3eaa, w3
    787e:	80 f5 80    	mov.w     0x1eb0, w0
    7880:	91 f5 80    	mov.w     0x1eb2, w1
    7882:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7884:	00 00 00 
    7886:	00 05 be    	mov.d     w0, w10

00007888 <.L0>:
                      0.333333343F +
                      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_l *
    7888:	b2 aa 2a    	mov.w     #0xaaab, w2
    788a:	a3 fa 23    	mov.w     #0x3faa, w3
    788c:	a0 f5 80    	mov.w     0x1eb4, w0
    788e:	b1 f5 80    	mov.w     0x1eb6, w1
    7890:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7892:	00 00 00 
    7894:	00 01 be    	mov.d     w0, w2

00007896 <.L0>:
    7896:	0a 00 be    	mov.d     w10, w0
    7898:	92 14 02    	call      0x1492 <___addsf3>
    789a:	00 00 00 
    789c:	00 05 be    	mov.d     w0, w10

0000789e <.L0>:
                      1.33333337F) +
                     AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_hy[0] *
    789e:	b2 aa 2a    	mov.w     #0xaaab, w2
    78a0:	a3 ea 23    	mov.w     #0x3eaa, w3
    78a2:	c0 f5 80    	mov.w     0x1eb8, w0
    78a4:	d1 f5 80    	mov.w     0x1eba, w1
    78a6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    78a8:	00 00 00 
    78aa:	00 01 be    	mov.d     w0, w2

000078ac <.L0>:
    78ac:	0a 00 be    	mov.d     w10, w0
    78ae:	92 14 02    	call      0x1492 <___addsf3>
    78b0:	00 00 00 

000078b2 <.L0>:
                     0.333333343F) * 0.005F +
    78b2:	a2 70 2d    	mov.w     #0xd70a, w2
    78b4:	33 ba 23    	mov.w     #0x3ba3, w3
    78b6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    78b8:	00 00 00 

000078ba <.L0>:
    78ba:	62 f5 80    	mov.w     0x1eac, w2
    78bc:	73 f5 80    	mov.w     0x1eae, w3
    78be:	92 14 02    	call      0x1492 <___addsf3>
    78c0:	00 00 00 
    78c2:	00 05 be    	mov.d     w0, w10

000078c4 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_f;
  }

  /* End of Switch: '<S154>/Switch1' */

  /* Switch: '<S156>/Switch3' incorporates:
   *  RelationalOperator: '<S156>/Relational Operator2'
   */
  if ((rtb_IC4_idx_0 == rtb_IC4_idx_0) > 0) {
    78c4:	00 01 be    	mov.d     w0, w2
    78c6:	8c 18 02    	call      0x188c <___eqsf2>
    78c8:	00 00 00 
    78ca:	00 00 e0    	cp0.w     w0
    78cc:	09 00 3a    	bra       NZ, 0x78e0 <.L0> <.L266>

000078ce <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_m = rtb_IC4_idx_0;
    78ce:	0a f6 88    	mov.w     w10, 0x1ec0
    78d0:	1b f6 88    	mov.w     w11, 0x1ec2
  }

  /* End of Switch: '<S156>/Switch3' */

  /* Switch: '<S142>/On//Off' incorporates:
   *  Constant: '<S142>/Constant1'
   *  DataStoreRead: '<S10>/PAR_PID_AIRSPEED_P PAR_PID_AIRSPEED_I PAR_PID_AIRSPEED_D'
   *  Product: '<S142>/Product'
   *  Sum: '<S142>/Add2'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    78d2:	ae e2 93    	mov.b     [w14+482], w5
    78d4:	05 04 e0    	cp0.b     w5
    78d6:	04 00 32    	bra       Z, 0x78e0 <.L0> <.L266>
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p = 0.0F;
    78d8:	60 00 b8    	mul.uu    w0, #0x0, w0
    78da:	00 ff 88    	mov.w     w0, 0x1fe0
    78dc:	11 ff 88    	mov.w     w1, 0x1fe2
    78de:	0c 00 37    	bra       0x78f8 <.L0> <.L268>

000078e0 <.L0>:
  } else {
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p =
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_m * mlParamInterface.param
    78e0:	02 f6 80    	mov.w     0x1ec0, w2
    78e2:	13 f6 80    	mov.w     0x1ec2, w3
    78e4:	5e a0 91    	mov.w     [w14+458], w0
    78e6:	ee a0 91    	mov.w     [w14+460], w1
    78e8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    78ea:	00 00 00 

000078ec <.L0>:
      [1] + rtb_Sum1_mzp;
    78ec:	1e a9 91    	mov.w     [w14+466], w2
    78ee:	ae a9 91    	mov.w     [w14+468], w3
    78f0:	92 14 02    	call      0x1492 <___addsf3>
    78f2:	00 00 00 

000078f4 <.L0>:
    78f4:	00 ff 88    	mov.w     w0, 0x1fe0
    78f6:	11 ff 88    	mov.w     w1, 0x1fe2

000078f8 <.L0>:
  }

  /* End of Switch: '<S142>/On//Off' */

  /* Switch: '<S153>/Switch2' incorporates:
   *  Constant: '<S142>/SaturationLimit'
   *  RelationalOperator: '<S153>/LowerRelop1'
   *  Sum: '<S142>/Add3'
   */
  if (!(AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p > 0.95F -
    78f8:	0a ff 80    	mov.w     0x1fe0, w10
    78fa:	1b ff 80    	mov.w     0x1fe2, w11
    78fc:	10 c0 b3    	mov.b     #0x1, w0
    78fe:	20 d7 9b    	mov.b     w0, [w14+466]
    7900:	0a 01 be    	mov.d     w10, w2
    7902:	08 00 be    	mov.d     w8, w0
    7904:	8c 18 02    	call      0x188c <___eqsf2>
    7906:	00 00 00 
    7908:	00 00 e0    	cp0.w     w0
    790a:	02 00 35    	bra       LT, 0x7910 <.L270>
    790c:	80 40 eb    	clr.b     w1
    790e:	21 d7 9b    	mov.b     w1, [w14+466]

00007910 <.L270>:
    7910:	2e d1 93    	mov.b     [w14+466], w2
    7912:	02 04 e0    	cp0.b     w2
    7914:	0b 00 3a    	bra       NZ, 0x792c <.L0> <.L269>

00007916 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion)) {
    /* Switch: '<S153>/Switch' incorporates:
     *  Constant: '<S142>/SaturationLimit1'
     *  RelationalOperator: '<S153>/UpperRelop'
     *  Sum: '<S142>/Add4'
     */
    if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p < 0.0F -
    7916:	0a 01 be    	mov.d     w10, w2
    7918:	5e a8 91    	mov.w     [w14+474], w0
    791a:	ee a8 91    	mov.w     [w14+476], w1
    791c:	90 18 02    	call      0x1890 <___gesf2>
    791e:	00 00 00 
    7920:	00 00 e0    	cp0.w     w0
    7922:	03 00 34    	bra       LE, 0x792a <.L621>

00007924 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion) {
      rtb_y_jl_idx_0 = 0.0F - AUAV_V3_TestSensors_B.DataTypeConversion;
    7924:	5e ac 91    	mov.w     [w14+474], w8
    7926:	ee ac 91    	mov.w     [w14+476], w9
    7928:	01 00 37    	bra       0x792c <.L0> <.L269>

0000792a <.L621>:
    } else {
      rtb_y_jl_idx_0 = AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_p;
    792a:	0a 04 be    	mov.d     w10, w8

0000792c <.L0>:
    }

    /* End of Switch: '<S153>/Switch' */
  }

  /* End of Switch: '<S153>/Switch2' */

  /* Sum: '<S140>/Add1' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_PITC_DT_FF'
   *  Product: '<S140>/Product2'
   */
  rtb_y_jl_idx_0 = (rtb_y_jl_idx_0 + AUAV_V3_TestSensors_B.DataTypeConversion) +
    792c:	0c 01 be    	mov.d     w12, w2
    792e:	08 00 be    	mov.d     w8, w0
    7930:	92 14 02    	call      0x1492 <___addsf3>
    7932:	00 00 00 
    7934:	00 04 be    	mov.d     w0, w8

00007936 <.L0>:
    mlParamInterface.param[15] * AUAV_V3_TestSensors_B.y_j[1];
    7936:	5a b1 80    	mov.w     0x162a, w10
    7938:	6b b1 80    	mov.w     0x162c, w11
    793a:	b2 94 80    	mov.w     0x1296, w2
    793c:	c3 94 80    	mov.w     0x1298, w3
    793e:	0a 00 be    	mov.d     w10, w0
    7940:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7942:	00 00 00 
    7944:	00 01 be    	mov.d     w0, w2

00007946 <.L0>:
    7946:	08 00 be    	mov.d     w8, w0
    7948:	92 14 02    	call      0x1492 <___addsf3>
    794a:	00 00 00 
    794c:	70 97 99    	mov.w     w0, [w14+430]
    794e:	01 9f 99    	mov.w     w1, [w14+432]

00007950 <.L0>:

  /* Sum: '<S140>/Add3' */
  rtb_Deg2R1 -= AUAV_V3_TestSensors_B.y_j[1];
    7950:	0a 01 be    	mov.d     w10, w2
    7952:	5e b0 91    	mov.w     [w14+490], w0
    7954:	ee b0 91    	mov.w     [w14+492], w1
    7956:	90 14 02    	call      0x1490 <___subsf3>
    7958:	00 00 00 
    795a:	00 05 be    	mov.d     w0, w10

0000795c <.L0>:

  /* Sum: '<S144>/Add3' incorporates:
   *  Constant: '<S144>/SaturationLimit'
   */
  rtb_IC4_idx_0 = 0.401425719F - AUAV_V3_TestSensors_B.DataTypeConversion_f;
    795c:	50 b2 80    	mov.w     0x164a, w0
    795e:	61 b2 80    	mov.w     0x164c, w1
    7960:	50 b7 99    	mov.w     w0, [w14+490]
    7962:	61 b7 99    	mov.w     w1, [w14+492]
    7964:	00 01 be    	mov.d     w0, w2
    7966:	c0 7a 28    	mov.w     #0x87ac, w0
    7968:	d1 ec 23    	mov.w     #0x3ecd, w1
    796a:	90 14 02    	call      0x1490 <___subsf3>
    796c:	00 00 00 
    796e:	00 04 be    	mov.d     w0, w8

00007970 <.L0>:

  /* Switch: '<S148>/Switch3' incorporates:
   *  RelationalOperator: '<S148>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    7970:	0a 01 be    	mov.d     w10, w2
    7972:	0a 00 be    	mov.d     w10, w0
    7974:	8c 18 02    	call      0x188c <___eqsf2>
    7976:	00 00 00 
    7978:	00 00 e0    	cp0.w     w0
    797a:	02 00 3a    	bra       NZ, 0x7980 <.L0> <.L272>

0000797c <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b = rtb_Deg2R1;
    797c:	2a f6 88    	mov.w     w10, 0x1ec4
    797e:	3b f6 88    	mov.w     w11, 0x1ec6

00007980 <.L0>:
  }

  /* End of Switch: '<S148>/Switch3' */

  /* Sum: '<S144>/Add1' incorporates:
   *  Constant: '<S144>/delayTime'
   *  DataStoreRead: '<S10>/PAR_PID_PITCH_FO_P PAR_PID_PITCH_FO_I PAR_PID_PITCH_FO_D'
   *  Delay: '<S144>/NDelays'
   *  Product: '<S144>/Product1'
   *  Product: '<S144>/Product2'
   *  Product: '<S144>/Product3'
   *  Sum: '<S144>/Sum'
   */
  rtb_Sum1_mzp = (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b -
    7980:	2a f6 80    	mov.w     0x1ec4, w10
    7982:	3b f6 80    	mov.w     0x1ec6, w11
    7984:	42 f6 80    	mov.w     0x1ec8, w2
    7986:	53 f6 80    	mov.w     0x1eca, w3
    7988:	0a 00 be    	mov.d     w10, w0
    798a:	90 14 02    	call      0x1490 <___subsf3>
    798c:	00 00 00 

0000798e <.L0>:
                  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[0]) / 0.05F *
    798e:	d2 cc 2c    	mov.w     #0xcccd, w2
    7990:	c3 d4 23    	mov.w     #0x3d4c, w3
    7992:	26 17 02    	call      0x1726 <___divsf3>
    7994:	00 00 00 
    7996:	72 93 80    	mov.w     0x126e, w2
    7998:	83 93 80    	mov.w     0x1270, w3
    799a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    799c:	00 00 00 
    799e:	00 06 be    	mov.d     w0, w12

000079a0 <.L0>:
    mlParamInterface.param[5] + AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b
    * mlParamInterface.param[3];
    79a0:	32 93 80    	mov.w     0x1266, w2
    79a2:	43 93 80    	mov.w     0x1268, w3
    79a4:	0a 00 be    	mov.d     w10, w0
    79a6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    79a8:	00 00 00 
    79aa:	00 01 be    	mov.d     w0, w2

000079ac <.L0>:
    79ac:	0c 00 be    	mov.d     w12, w0
    79ae:	92 14 02    	call      0x1492 <___addsf3>
    79b0:	00 00 00 
    79b2:	50 af 99    	mov.w     w0, [w14+474]
    79b4:	61 af 99    	mov.w     w1, [w14+476]

000079b6 <.L0>:

  /* Sum: '<S144>/Sum2' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_PITCH_FO_P PAR_PID_PITCH_FO_I PAR_PID_PITCH_FO_D'
   *  Gain: '<S144>/Gain'
   *  Memory: '<S144>/Memory1'
   *  Product: '<S144>/Product4'
   */
  rtb_Deg2R1 = (0.01F * AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b *
                mlParamInterface.param[4] +
    79b6:	54 93 80    	mov.w     0x126a, w4
    79b8:	65 93 80    	mov.w     0x126c, w5
    79ba:	14 af 99    	mov.w     w4, [w14+466]
    79bc:	25 af 99    	mov.w     w5, [w14+468]

000079be <.L0>:
    79be:	a2 70 2d    	mov.w     #0xd70a, w2
    79c0:	33 c2 23    	mov.w     #0x3c23, w3
    79c2:	0a 00 be    	mov.d     w10, w0
    79c4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    79c6:	00 00 00 
    79c8:	1e a9 91    	mov.w     [w14+466], w2
    79ca:	ae a9 91    	mov.w     [w14+468], w3
    79cc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    79ce:	00 00 00 

000079d0 <.L0>:
    79d0:	22 ff 80    	mov.w     0x1fe4, w2
    79d2:	33 ff 80    	mov.w     0x1fe6, w3
    79d4:	92 14 02    	call      0x1492 <___addsf3>
    79d6:	00 00 00 

000079d8 <.L0>:
    79d8:	5e a9 91    	mov.w     [w14+474], w2
    79da:	ee a9 91    	mov.w     [w14+476], w3
    79dc:	92 14 02    	call      0x1492 <___addsf3>
    79de:	00 00 00 
    79e0:	50 a7 99    	mov.w     w0, [w14+458]
    79e2:	61 a7 99    	mov.w     w1, [w14+460]

000079e4 <.L0>:
                AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o) +
    rtb_Sum1_mzp;

  /* Switch: '<S144>/AntiWindup' incorporates:
   *  Constant: '<S144>/Constant5'
   *  Constant: '<S144>/SaturationLimit'
   *  Constant: '<S144>/SaturationLimit1'
   *  Logic: '<S144>/Logical Operator'
   *  RelationalOperator: '<S144>/Relational Operator'
   *  RelationalOperator: '<S144>/Relational Operator1'
   *  Sum: '<S144>/Add3'
   *  Sum: '<S144>/Add4'
   */
  if ((rtb_Deg2R1 > -0.401425719F - AUAV_V3_TestSensors_B.DataTypeConversion_f) &&
    79e4:	5e b1 91    	mov.w     [w14+490], w2
    79e6:	ee b1 91    	mov.w     [w14+492], w3
    79e8:	c0 7a 28    	mov.w     #0x87ac, w0
    79ea:	d1 ec 2b    	mov.w     #0xbecd, w1
    79ec:	90 14 02    	call      0x1490 <___subsf3>
    79ee:	00 00 00 
    79f0:	00 06 be    	mov.d     w0, w12
    79f2:	5e a1 91    	mov.w     [w14+458], w2
    79f4:	ee a1 91    	mov.w     [w14+460], w3
    79f6:	8c 18 02    	call      0x188c <___eqsf2>
    79f8:	00 00 00 
    79fa:	00 00 e0    	cp0.w     w0
    79fc:	0e 00 3d    	bra       GE, 0x7a1a <.L0> <.L622>
    79fe:	5e a1 91    	mov.w     [w14+458], w2
    7a00:	ee a1 91    	mov.w     [w14+460], w3
    7a02:	08 00 be    	mov.d     w8, w0
    7a04:	90 18 02    	call      0x1890 <___gesf2>
    7a06:	00 00 00 
    7a08:	00 00 e0    	cp0.w     w0
    7a0a:	09 00 34    	bra       LE, 0x7a1e <.L623>

00007a0c <.L0>:
      (rtb_Deg2R1 < 0.401425719F - AUAV_V3_TestSensors_B.DataTypeConversion_f))
  {
    rtb_Deg2R1 = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b;
  } else {
    rtb_Deg2R1 = 0.0F;
  }

  /* End of Switch: '<S144>/AntiWindup' */

  /* Switch: '<S163>/Switch3' incorporates:
   *  RelationalOperator: '<S163>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    7a0c:	0a 01 be    	mov.d     w10, w2
    7a0e:	0a 00 be    	mov.d     w10, w0
    7a10:	8c 18 02    	call      0x188c <___eqsf2>
    7a12:	00 00 00 
    7a14:	00 00 e0    	cp0.w     w0
    7a16:	06 00 3a    	bra       NZ, 0x7a24 <.L277>
    7a18:	03 00 37    	bra       0x7a20 <.L274>

00007a1a <.L0>:
    7a1a:	60 55 b8    	mul.uu    w10, #0x0, w10
    7a1c:	01 00 37    	bra       0x7a20 <.L274>

00007a1e <.L623>:
    7a1e:	60 55 b8    	mul.uu    w10, #0x0, w10

00007a20 <.L274>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_o = rtb_Deg2R1;
    7a20:	0a f7 88    	mov.w     w10, 0x1ee0
    7a22:	1b f7 88    	mov.w     w11, 0x1ee2

00007a24 <.L277>:
  }

  /* End of Switch: '<S163>/Switch3' */

  /* Switch: '<S162>/Switch1' incorporates:
   *  Constant: '<S162>/Constant'
   *  Constant: '<S162>/Constant1'
   *  Constant: '<S162>/Constant2'
   *  Constant: '<S162>/Constant3'
   *  Constant: '<S162>/Constant5'
   *  Delay: '<S162>/Integer Delay'
   *  Delay: '<S162>/Integer Delay1'
   *  Delay: '<S162>/Integer Delay2'
   *  Product: '<S162>/Product'
   *  Product: '<S162>/Product1'
   *  Product: '<S162>/Product2'
   *  Product: '<S162>/Product3'
   *  Sum: '<S162>/Subtract'
   *  Sum: '<S162>/Subtract1'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    rtb_Deg2R1 = 0.0F;
    7a24:	60 55 b8    	mul.uu    w10, #0x0, w10
    7a26:	ae e1 93    	mov.b     [w14+482], w3
    7a28:	03 04 e0    	cp0.b     w3
    7a2a:	2a 00 3a    	bra       NZ, 0x7a80 <.L0> <.L279>

00007a2c <.L0>:
  } else {
    rtb_Deg2R1 = ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_o *
    7a2c:	b2 aa 2a    	mov.w     #0xaaab, w2
    7a2e:	a3 ea 23    	mov.w     #0x3eaa, w3
    7a30:	00 f7 80    	mov.w     0x1ee0, w0
    7a32:	11 f7 80    	mov.w     0x1ee2, w1
    7a34:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7a36:	00 00 00 
    7a38:	00 05 be    	mov.d     w0, w10

00007a3a <.L0>:
                   0.333333343F +
                   AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_e * 1.33333337F)
    7a3a:	b2 aa 2a    	mov.w     #0xaaab, w2
    7a3c:	a3 fa 23    	mov.w     #0x3faa, w3
    7a3e:	20 f7 80    	mov.w     0x1ee4, w0
    7a40:	31 f7 80    	mov.w     0x1ee6, w1
    7a42:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7a44:	00 00 00 
    7a46:	00 01 be    	mov.d     w0, w2

00007a48 <.L0>:
    7a48:	0a 00 be    	mov.d     w10, w0
    7a4a:	92 14 02    	call      0x1492 <___addsf3>
    7a4c:	00 00 00 
    7a4e:	00 05 be    	mov.d     w0, w10

00007a50 <.L0>:
                  + AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_k[0] *
    7a50:	b2 aa 2a    	mov.w     #0xaaab, w2
    7a52:	a3 ea 23    	mov.w     #0x3eaa, w3
    7a54:	40 f7 80    	mov.w     0x1ee8, w0
    7a56:	51 f7 80    	mov.w     0x1eea, w1
    7a58:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7a5a:	00 00 00 
    7a5c:	00 01 be    	mov.d     w0, w2
    7a5e:	0a 00 be    	mov.d     w10, w0
    7a60:	92 14 02    	call      0x1492 <___addsf3>
    7a62:	00 00 00 

00007a64 <.L0>:
                  0.333333343F) * 0.005F +
    7a64:	a2 70 2d    	mov.w     #0xd70a, w2
    7a66:	33 ba 23    	mov.w     #0x3ba3, w3
    7a68:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7a6a:	00 00 00 

00007a6c <.L0>:
    7a6c:	e2 f6 80    	mov.w     0x1edc, w2
    7a6e:	f3 f6 80    	mov.w     0x1ede, w3
    7a70:	92 14 02    	call      0x1492 <___addsf3>
    7a72:	00 00 00 
    7a74:	00 05 be    	mov.d     w0, w10

00007a76 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_b;
  }

  /* End of Switch: '<S162>/Switch1' */

  /* Switch: '<S164>/Switch3' incorporates:
   *  RelationalOperator: '<S164>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    7a76:	00 01 be    	mov.d     w0, w2
    7a78:	8c 18 02    	call      0x188c <___eqsf2>
    7a7a:	00 00 00 
    7a7c:	00 00 e0    	cp0.w     w0
    7a7e:	09 00 3a    	bra       NZ, 0x7a92 <.L0> <.L280>

00007a80 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ep = rtb_Deg2R1;
    7a80:	8a f7 88    	mov.w     w10, 0x1ef0
    7a82:	9b f7 88    	mov.w     w11, 0x1ef2
  }

  /* End of Switch: '<S164>/Switch3' */

  /* Switch: '<S144>/On//Off' incorporates:
   *  Constant: '<S144>/Constant1'
   *  DataStoreRead: '<S10>/PAR_PID_PITCH_FO_P PAR_PID_PITCH_FO_I PAR_PID_PITCH_FO_D'
   *  Product: '<S144>/Product'
   *  Sum: '<S144>/Add2'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    7a84:	2e e2 93    	mov.b     [w14+482], w4
    7a86:	04 04 e0    	cp0.b     w4
    7a88:	04 00 32    	bra       Z, 0x7a92 <.L0> <.L280>
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o = 0.0F;
    7a8a:	60 00 b8    	mul.uu    w0, #0x0, w0
    7a8c:	20 ff 88    	mov.w     w0, 0x1fe4
    7a8e:	31 ff 88    	mov.w     w1, 0x1fe6
    7a90:	0c 00 37    	bra       0x7aaa <.L0> <.L282>

00007a92 <.L0>:
  } else {
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o =
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ep *
    7a92:	82 f7 80    	mov.w     0x1ef0, w2
    7a94:	93 f7 80    	mov.w     0x1ef2, w3
    7a96:	1e a8 91    	mov.w     [w14+466], w0
    7a98:	ae a8 91    	mov.w     [w14+468], w1
    7a9a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7a9c:	00 00 00 

00007a9e <.L0>:
      mlParamInterface.param[4] + rtb_Sum1_mzp;
    7a9e:	5e a9 91    	mov.w     [w14+474], w2
    7aa0:	ee a9 91    	mov.w     [w14+476], w3
    7aa2:	92 14 02    	call      0x1492 <___addsf3>
    7aa4:	00 00 00 

00007aa6 <.L0>:
    7aa6:	20 ff 88    	mov.w     w0, 0x1fe4
    7aa8:	31 ff 88    	mov.w     w1, 0x1fe6

00007aaa <.L0>:
  }

  /* End of Switch: '<S144>/On//Off' */

  /* Switch: '<S161>/Switch2' incorporates:
   *  Constant: '<S144>/SaturationLimit'
   *  RelationalOperator: '<S161>/LowerRelop1'
   *  Sum: '<S144>/Add3'
   */
  if (!(AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o > 0.401425719F -
    7aaa:	2a ff 80    	mov.w     0x1fe4, w10
    7aac:	3b ff 80    	mov.w     0x1fe6, w11
    7aae:	15 c0 b3    	mov.b     #0x1, w5
    7ab0:	25 ef 9b    	mov.b     w5, [w14+490]
    7ab2:	0a 01 be    	mov.d     w10, w2
    7ab4:	08 00 be    	mov.d     w8, w0
    7ab6:	8c 18 02    	call      0x188c <___eqsf2>
    7ab8:	00 00 00 
    7aba:	00 00 e0    	cp0.w     w0
    7abc:	02 00 35    	bra       LT, 0x7ac2 <.L284>
    7abe:	00 40 eb    	clr.b     w0
    7ac0:	20 ef 9b    	mov.b     w0, [w14+490]

00007ac2 <.L284>:
    7ac2:	ae e8 93    	mov.b     [w14+490], w1
    7ac4:	01 04 e0    	cp0.b     w1
    7ac6:	09 00 3a    	bra       NZ, 0x7ada <.L0> <.L283>

00007ac8 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_f)) {
    /* Switch: '<S161>/Switch' incorporates:
     *  Constant: '<S144>/SaturationLimit1'
     *  RelationalOperator: '<S161>/UpperRelop'
     *  Sum: '<S144>/Add4'
     */
    if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o < -0.401425719F -
    7ac8:	0a 01 be    	mov.d     w10, w2
    7aca:	0c 00 be    	mov.d     w12, w0
    7acc:	90 18 02    	call      0x1890 <___gesf2>
    7ace:	00 00 00 
    7ad0:	00 00 e0    	cp0.w     w0
    7ad2:	02 00 34    	bra       LE, 0x7ad8 <.L624>

00007ad4 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_f) {
      rtb_IC4_idx_0 = -0.401425719F - AUAV_V3_TestSensors_B.DataTypeConversion_f;
    7ad4:	0c 04 be    	mov.d     w12, w8
    7ad6:	01 00 37    	bra       0x7ada <.L0> <.L283>

00007ad8 <.L624>:
    } else {
      rtb_IC4_idx_0 = AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_o;
    7ad8:	0a 04 be    	mov.d     w10, w8

00007ada <.L0>:
    }

    /* End of Switch: '<S161>/Switch' */
  }

  /* End of Switch: '<S161>/Switch2' */

  /* Saturate: '<S140>/[-60 60]' */
  if (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i.y > 60.0F) {
    7ada:	4a ea 80    	mov.w     0x1d48, w10
    7adc:	5b ea 80    	mov.w     0x1d4a, w11
    7ade:	02 00 20    	mov.w     #0x0, w2
    7ae0:	03 27 24    	mov.w     #0x4270, w3
    7ae2:	0a 00 be    	mov.d     w10, w0
    7ae4:	90 18 02    	call      0x1890 <___gesf2>
    7ae6:	00 00 00 
    7ae8:	00 00 e0    	cp0.w     w0
    7aea:	05 00 34    	bra       LE, 0x7af6 <.L0> <.L625>

00007aec <.L0>:
    AUAV_V3_TestSensors_B.u060 = 60.0F;
    7aec:	00 00 20    	mov.w     #0x0, w0
    7aee:	01 27 24    	mov.w     #0x4270, w1
    7af0:	30 c5 88    	mov.w     w0, 0x18a6
    7af2:	41 c5 88    	mov.w     w1, 0x18a8
    7af4:	0e 00 37    	bra       0x7b12 <.L0> <.L288>

00007af6 <.L0>:
  } else if (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i.y < -60.0F) {
    7af6:	02 00 20    	mov.w     #0x0, w2
    7af8:	03 27 2c    	mov.w     #0xc270, w3
    7afa:	0a 00 be    	mov.d     w10, w0
    7afc:	8c 18 02    	call      0x188c <___eqsf2>
    7afe:	00 00 00 
    7b00:	00 00 e0    	cp0.w     w0
    7b02:	05 00 3d    	bra       GE, 0x7b0e <.L626>

00007b04 <.L0>:
    AUAV_V3_TestSensors_B.u060 = -60.0F;
    7b04:	00 00 20    	mov.w     #0x0, w0
    7b06:	01 27 2c    	mov.w     #0xc270, w1
    7b08:	30 c5 88    	mov.w     w0, 0x18a6
    7b0a:	41 c5 88    	mov.w     w1, 0x18a8
    7b0c:	02 00 37    	bra       0x7b12 <.L0> <.L288>

00007b0e <.L626>:
  } else {
    AUAV_V3_TestSensors_B.u060 =
    7b0e:	3a c5 88    	mov.w     w10, 0x18a6
    7b10:	4b c5 88    	mov.w     w11, 0x18a8

00007b12 <.L0>:
      AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_i.y;
  }

  /* End of Saturate: '<S140>/[-60 60]' */

  /* S-Function (MCHP_C_function_Call): '<S151>/myCos() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myCosapUtilscupdated5116 = myCos(
    7b12:	30 c5 80    	mov.w     0x18a6, w0
    7b14:	41 c5 80    	mov.w     0x18a8, w1
    7b16:	32 10 02    	call      0x11032 <_myCos>
    7b18:	01 00 00 
    7b1a:	00 05 be    	mov.d     w0, w10
    7b1c:	50 c5 88    	mov.w     w0, 0x18aa
    7b1e:	61 c5 88    	mov.w     w1, 0x18ac

00007b20 <.L0>:
    AUAV_V3_TestSensors_B.u060
    );

  /* Sum: '<S140>/Add4' incorporates:
   *  Constant: '<S140>/Constant2'
   *  Constant: '<S140>/Constant4'
   *  DataStoreRead: '<S10>/PAR_PID_HEI_ERR_FF'
   *  Product: '<S140>/Product'
   *  Product: '<S140>/Product1'
   *  Sum: '<S140>/Add5'
   */
  rtb_IC4_idx_0 = (1.0F / AUAV_V3_TestSensors_B.myCosapUtilscupdated5116 - 1.0F)
    * mlParamInterface.param[11] + (rtb_IC4_idx_0 +
    7b20:	52 b2 80    	mov.w     0x164a, w2
    7b22:	63 b2 80    	mov.w     0x164c, w3
    7b24:	08 00 be    	mov.d     w8, w0
    7b26:	92 14 02    	call      0x1492 <___addsf3>
    7b28:	00 00 00 
    7b2a:	00 04 be    	mov.d     w0, w8

00007b2c <.L0>:
    7b2c:	0a 01 be    	mov.d     w10, w2
    7b2e:	00 00 20    	mov.w     #0x0, w0
    7b30:	01 f8 23    	mov.w     #0x3f80, w1
    7b32:	26 17 02    	call      0x1726 <___divsf3>
    7b34:	00 00 00 
    7b36:	02 00 20    	mov.w     #0x0, w2
    7b38:	03 f8 23    	mov.w     #0x3f80, w3
    7b3a:	90 14 02    	call      0x1490 <___subsf3>
    7b3c:	00 00 00 

00007b3e <.L0>:
    7b3e:	32 94 80    	mov.w     0x1286, w2
    7b40:	43 94 80    	mov.w     0x1288, w3
    7b42:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7b44:	00 00 00 

00007b46 <.L0>:
    7b46:	08 01 be    	mov.d     w8, w2
    7b48:	92 14 02    	call      0x1492 <___addsf3>
    7b4a:	00 00 00 
    7b4c:	30 9f 99    	mov.w     w0, [w14+438]
    7b4e:	41 9f 99    	mov.w     w1, [w14+440]

00007b50 <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion_f);

  /* Update for UnitDelay: '<S178>/FixPt Unit Delay2' incorporates:
   *  Constant: '<S178>/FixPt Constant'
   */
  AUAV_V3_TestSensors_DWork.FixPtUnitDelay2_DSTATE = 0U;
    7b50:	90 ff 21    	mov.w     #0x1ff9, w0
    7b52:	00 48 eb    	clr.b     [w0]

  /* Update for Delay: '<S158>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE =
    7b54:	64 f4 80    	mov.w     0x1e8c, w4
    7b56:	75 f4 80    	mov.w     0x1e8e, w5
    7b58:	c4 f3 88    	mov.w     w4, 0x1e78
    7b5a:	d5 f3 88    	mov.w     w5, 0x1e7a
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_av;

  /* Update for Delay: '<S158>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_a =
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_a;
    7b5c:	e2 f3 80    	mov.w     0x1e7c, w2
    7b5e:	f3 f3 80    	mov.w     0x1e7e, w3
    7b60:	02 f4 88    	mov.w     w2, 0x1e80
    7b62:	13 f4 88    	mov.w     w3, 0x1e82

  /* Update for Delay: '<S158>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_h[0] =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_h[1];
    7b64:	10 17 b1    	sub.w     #0x171, w0
    7b66:	10 02 be    	mov.d     [w0], w4
    7b68:	24 f4 88    	mov.w     w4, 0x1e84
    7b6a:	35 f4 88    	mov.w     w5, 0x1e86
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_h[1] =
    7b6c:	02 88 be    	mov.d     w2, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_a;

  /* Update for Delay: '<S142>/NDelays' */
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[0] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE[1];
    7b6e:	74 00 40    	add.w     w0, #0x14, w0
    7b70:	10 01 be    	mov.d     [w0], w2
    7b72:	c2 f4 88    	mov.w     w2, 0x1e98
    7b74:	d3 f4 88    	mov.w     w3, 0x1e9a
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[1] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE[2];
    7b76:	e4 00 40    	add.w     w0, #0x4, w1
    7b78:	31 18 78    	mov.w     [w1++], [w0++]
    7b7a:	21 10 78    	mov.w     [w1--], [w0--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[2] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE[3];
    7b7c:	68 01 40    	add.w     w0, #0x8, w2
    7b7e:	b2 18 78    	mov.w     [w2++], [w1++]
    7b80:	a2 10 78    	mov.w     [w2--], [w1--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[3] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE[4];
    7b82:	6c 00 40    	add.w     w0, #0xc, w0
    7b84:	30 19 78    	mov.w     [w0++], [w2++]
    7b86:	20 11 78    	mov.w     [w0--], [w2--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE[4] =
    7b88:	a4 f4 80    	mov.w     0x1e94, w4
    7b8a:	b5 f4 80    	mov.w     0x1e96, w5
    7b8c:	04 88 be    	mov.d     w4, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_j;

  /* Update for Delay: '<S154>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_f =
    7b8e:	00 f6 80    	mov.w     0x1ec0, w0
    7b90:	11 f6 80    	mov.w     0x1ec2, w1
    7b92:	60 f5 88    	mov.w     w0, 0x1eac
    7b94:	71 f5 88    	mov.w     w1, 0x1eae
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_m;

  /* Update for Delay: '<S154>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_l =
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_cl;
    7b96:	82 f5 80    	mov.w     0x1eb0, w2
    7b98:	93 f5 80    	mov.w     0x1eb2, w3
    7b9a:	a2 f5 88    	mov.w     w2, 0x1eb4
    7b9c:	b3 f5 88    	mov.w     w3, 0x1eb6

  /* Update for Delay: '<S154>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_hy[0] =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_hy[1];
    7b9e:	c0 eb 21    	mov.w     #0x1ebc, w0
    7ba0:	10 02 be    	mov.d     [w0], w4
    7ba2:	c4 f5 88    	mov.w     w4, 0x1eb8
    7ba4:	d5 f5 88    	mov.w     w5, 0x1eba
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_hy[1] =
    7ba6:	02 88 be    	mov.d     w2, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_cl;

  /* Update for Delay: '<S144>/NDelays' */
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[0] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[1];
    7ba8:	70 00 40    	add.w     w0, #0x10, w0
    7baa:	10 01 be    	mov.d     [w0], w2
    7bac:	42 f6 88    	mov.w     w2, 0x1ec8
    7bae:	53 f6 88    	mov.w     w3, 0x1eca
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[1] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[2];
    7bb0:	e4 00 40    	add.w     w0, #0x4, w1
    7bb2:	31 18 78    	mov.w     [w1++], [w0++]
    7bb4:	21 10 78    	mov.w     [w1--], [w0--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[2] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[3];
    7bb6:	68 01 40    	add.w     w0, #0x8, w2
    7bb8:	b2 18 78    	mov.w     [w2++], [w1++]
    7bba:	a2 10 78    	mov.w     [w2--], [w1--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[3] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[4];
    7bbc:	6c 00 40    	add.w     w0, #0xc, w0
    7bbe:	30 19 78    	mov.w     [w0++], [w2++]
    7bc0:	20 11 78    	mov.w     [w0--], [w2--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_c[4] =
    7bc2:	24 f6 80    	mov.w     0x1ec4, w4
    7bc4:	35 f6 80    	mov.w     0x1ec6, w5
    7bc6:	04 88 be    	mov.d     w4, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_b;

  /* Update for Delay: '<S162>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_b =
    7bc8:	80 f7 80    	mov.w     0x1ef0, w0
    7bca:	91 f7 80    	mov.w     0x1ef2, w1
    7bcc:	e0 f6 88    	mov.w     w0, 0x1edc
    7bce:	f1 f6 88    	mov.w     w1, 0x1ede
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ep;

  /* Update for Delay: '<S162>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_e =
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_o;
    7bd0:	02 f7 80    	mov.w     0x1ee0, w2
    7bd2:	13 f7 80    	mov.w     0x1ee2, w3
    7bd4:	22 f7 88    	mov.w     w2, 0x1ee4
    7bd6:	33 f7 88    	mov.w     w3, 0x1ee6

  /* Update for Delay: '<S162>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_k[0] =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_k[1];
    7bd8:	c0 ee 21    	mov.w     #0x1eec, w0
    7bda:	10 02 be    	mov.d     [w0], w4
    7bdc:	44 f7 88    	mov.w     w4, 0x1ee8
    7bde:	55 f7 88    	mov.w     w5, 0x1eea
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_k[1] =
    7be0:	02 88 be    	mov.d     w2, [w0]

00007be2 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_o;

  /* End of Outputs for SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */

  /* S-Function (MCHP_C_function_Call): '<S75>/myCos() aLib.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myCosaLibcupdated5116 = myCos(
    7be2:	6a 62 21    	mov.w     #0x1626, w10
    7be4:	1a 00 be    	mov.d     [w10], w0
    7be6:	32 10 02    	call      0x11032 <_myCos>
    7be8:	01 00 00 
    7bea:	10 af 88    	mov.w     w0, 0x15e2
    7bec:	21 af 88    	mov.w     w1, 0x15e4

00007bee <.L0>:
    AUAV_V3_TestSensors_B.y_j[0]
    );

  /* Product: '<S68>/Product' */
  rtb_Sum1_mzp = AUAV_V3_TestSensors_B.y_j[5] *
    7bee:	d2 b1 80    	mov.w     0x163a, w2
    7bf0:	e3 b1 80    	mov.w     0x163c, w3
    7bf2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7bf4:	00 00 00 
    7bf6:	00 04 be    	mov.d     w0, w8

00007bf8 <.L0>:
    AUAV_V3_TestSensors_B.myCosaLibcupdated5116;

  /* S-Function (MCHP_C_function_Call): '<S76>/C Function Call1' */
  AUAV_V3_TestSensors_B.CFunctionCall1 = mySin(
    7bf8:	1a 00 be    	mov.d     [w10], w0
    7bfa:	2c 10 02    	call      0x1102c <_mySin>
    7bfc:	01 00 00 
    7bfe:	30 af 88    	mov.w     w0, 0x15e6
    7c00:	41 af 88    	mov.w     w1, 0x15e8

00007c02 <.L0>:
    AUAV_V3_TestSensors_B.y_j[0]
    );

  /* Sum: '<S68>/Subtract' incorporates:
   *  Product: '<S68>/Product1'
   */
  rtb_Deg2R_h_idx_0 = AUAV_V3_TestSensors_B.y_j[4] *
    7c02:	b2 b1 80    	mov.w     0x1636, w2
    7c04:	c3 b1 80    	mov.w     0x1638, w3
    7c06:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7c08:	00 00 00 
    7c0a:	08 01 be    	mov.d     w8, w2
    7c0c:	92 14 02    	call      0x1492 <___addsf3>
    7c0e:	00 00 00 
    7c10:	00 01 be    	mov.d     w0, w2
    7c12:	50 a7 99    	mov.w     w0, [w14+458]
    7c14:	61 a7 99    	mov.w     w1, [w14+460]

00007c16 <.L0>:
    AUAV_V3_TestSensors_B.CFunctionCall1 + rtb_Sum1_mzp;

  /* Switch: '<S74>/Switch3' incorporates:
   *  Delay: '<S74>/Integer Delay3'
   *  RelationalOperator: '<S74>/Relational Operator2'
   */
  if (!((rtb_Deg2R_h_idx_0 == rtb_Deg2R_h_idx_0) > 0)) {
    7c16:	18 c0 b3    	mov.b     #0x1, w8
    7c18:	8c 18 02    	call      0x188c <___eqsf2>
    7c1a:	00 00 00 
    7c1c:	00 00 e0    	cp0.w     w0
    7c1e:	01 00 32    	bra       Z, 0x7c22 <.L292>
    7c20:	00 44 eb    	clr.b     w8

00007c22 <.L292>:
    7c22:	08 04 e0    	cp0.b     w8
    7c24:	04 00 3a    	bra       NZ, 0x7c2e <.L291>

00007c26 <.L0>:
    rtb_Deg2R_h_idx_0 = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k;
    7c26:	e4 ec 80    	mov.w     0x1d9c, w4
    7c28:	f5 ec 80    	mov.w     0x1d9e, w5
    7c2a:	54 a7 99    	mov.w     w4, [w14+458]
    7c2c:	65 a7 99    	mov.w     w5, [w14+460]

00007c2e <.L291>:
  }

  /* End of Switch: '<S74>/Switch3' */

  /* DataStoreRead: '<Root>/PAR_L1_OMEGA PAR_L1_M PAR_L1_GAMMA PAR_L1_ON_OFF' incorporates:
   *  Inport: '<S92>/In1'
   *  Logic: '<S80>/Logical Operator'
   */
  rtb_IC4_idx_1 = mlParamInterface.param[22];
    7c2e:	90 95 80    	mov.w     0x12b2, w0
    7c30:	a1 95 80    	mov.w     0x12b4, w1
    7c32:	70 8f 99    	mov.w     w0, [w14+414]
    7c34:	01 97 99    	mov.w     w1, [w14+416]
  rtb_Product_lf = mlParamInterface.param[23];
    7c36:	b2 95 80    	mov.w     0x12b6, w2
    7c38:	c3 95 80    	mov.w     0x12b8, w3
    7c3a:	12 9f 99    	mov.w     w2, [w14+434]
    7c3c:	23 9f 99    	mov.w     w3, [w14+436]

00007c3e <.L0>:

  /* Outputs for Enabled SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' incorporates:
   *  EnablePort: '<S69>/Enable'
   */
  if (mlParamInterface.param[25L] > 0.0F) {
    7c3e:	60 11 b8    	mul.uu    w2, #0x0, w2
    7c40:	f0 95 80    	mov.w     0x12be, w0
    7c42:	01 96 80    	mov.w     0x12c0, w1
    7c44:	90 18 02    	call      0x1890 <___gesf2>
    7c46:	00 00 00 
    7c48:	00 00 e0    	cp0.w     w0
    7c4a:	b0 01 34    	bra       LE, 0x7fac <.L627>

00007c4c <.L0>:
    if (!AUAV_V3_TestSensors_DWork.L1OutputFeedbackControllerWithP) {
    7c4c:	a0 00 22    	mov.w     #0x200a, w0
    7c4e:	10 04 e0    	cp0.b     [w0]
    7c50:	2b 00 3a    	bra       NZ, 0x7ca8 <.L295>
      /* InitializeConditions for UnitDelay: '<S89>/UD' */
      AUAV_V3_TestSensors_DWork.UD_DSTATE_ff = 0.0F;
    7c52:	60 00 b8    	mul.uu    w0, #0x0, w0
    7c54:	60 fb 88    	mov.w     w0, 0x1f6c
    7c56:	71 fb 88    	mov.w     w1, 0x1f6e

      /* InitializeConditions for Delay: '<S79>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_an = 0.0F;
    7c58:	80 fb 88    	mov.w     w0, 0x1f70
    7c5a:	91 fb 88    	mov.w     w1, 0x1f72

      /* InitializeConditions for Delay: '<S79>/Integer Delay1' */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_i = 0.0F;
    7c5c:	a0 fb 88    	mov.w     w0, 0x1f74
    7c5e:	b1 fb 88    	mov.w     w1, 0x1f76

      /* InitializeConditions for Delay: '<S81>/Integer Delay3' */
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_fs = 0.0F;
    7c60:	c0 fb 88    	mov.w     w0, 0x1f78
    7c62:	d1 fb 88    	mov.w     w1, 0x1f7a

      /* InitializeConditions for UnitDelay: '<S99>/UD' */
      AUAV_V3_TestSensors_DWork.UD_DSTATE_j = 0.0F;
    7c64:	e0 fb 88    	mov.w     w0, 0x1f7c
    7c66:	f1 fb 88    	mov.w     w1, 0x1f7e

      /* InitializeConditions for Delay: '<S83>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_k = 0.0F;
    7c68:	00 fc 88    	mov.w     w0, 0x1f80
    7c6a:	11 fc 88    	mov.w     w1, 0x1f82

      /* InitializeConditions for Delay: '<S83>/Integer Delay1' */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_b = 0.0F;
    7c6c:	20 fc 88    	mov.w     w0, 0x1f84
    7c6e:	31 fc 88    	mov.w     w1, 0x1f86

      /* InitializeConditions for Delay: '<S69>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_i = 0.0F;
    7c70:	40 fc 88    	mov.w     w0, 0x1f88
    7c72:	51 fc 88    	mov.w     w1, 0x1f8a

      /* InitializeConditions for Delay: '<S69>/Integer Delay1' */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e = 0.0F;
    7c74:	60 fc 88    	mov.w     w0, 0x1f8c
    7c76:	71 fc 88    	mov.w     w1, 0x1f8e

      /* InitializeConditions for Merge: '<S80>/Merge' */
      if (rtmIsFirstInitCond(AUAV_V3_TestSensors_M)) {
    7c78:	40 23 22    	mov.w     #0x2234, w0
    7c7a:	10 04 e0    	cp0.b     [w0]
    7c7c:	03 00 32    	bra       Z, 0x7c84 <.L296>
        AUAV_V3_TestSensors_B.Merge_oo = 0.0F;
    7c7e:	60 00 b8    	mul.uu    w0, #0x0, w0
    7c80:	d0 c6 88    	mov.w     w0, 0x18da
    7c82:	e1 c6 88    	mov.w     w1, 0x18dc

00007c84 <.L296>:
      }

      /* End of InitializeConditions for Merge: '<S80>/Merge' */

      /* InitializeConditions for Delay: '<S82>/Integer Delay3' */
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_h = 0.0F;
    7c84:	60 00 b8    	mul.uu    w0, #0x0, w0
    7c86:	80 fc 88    	mov.w     w0, 0x1f90
    7c88:	91 fc 88    	mov.w     w1, 0x1f92

      /* InitializeConditions for Delay: '<S84>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_p = 0.0F;
    7c8a:	a0 fc 88    	mov.w     w0, 0x1f94
    7c8c:	b1 fc 88    	mov.w     w1, 0x1f96

      /* InitializeConditions for Delay: '<S84>/Integer Delay1' */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[0] = 0.0F;
    7c8e:	c0 fc 88    	mov.w     w0, 0x1f98
    7c90:	d1 fc 88    	mov.w     w1, 0x1f9a
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[1] = 0.0F;
    7c92:	e0 fc 88    	mov.w     w0, 0x1f9c
    7c94:	f1 fc 88    	mov.w     w1, 0x1f9e

      /* InitializeConditions for Delay: '<S84>/Integer Delay2' */
      AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_g = 0.0F;
    7c96:	00 fd 88    	mov.w     w0, 0x1fa0
    7c98:	11 fd 88    	mov.w     w1, 0x1fa2

      /* InitializeConditions for Delay: '<S100>/Integer Delay3' */
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_nz = 0.0F;
    7c9a:	20 fd 88    	mov.w     w0, 0x1fa4
    7c9c:	31 fd 88    	mov.w     w1, 0x1fa6

      /* InitializeConditions for Delay: '<S101>/Integer Delay3' */
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_hh = 0.0F;
    7c9e:	40 fd 88    	mov.w     w0, 0x1fa8
    7ca0:	51 fd 88    	mov.w     w1, 0x1faa
      AUAV_V3_TestSensors_DWork.L1OutputFeedbackControllerWithP = true;
    7ca2:	11 c0 b3    	mov.b     #0x1, w1
    7ca4:	a0 00 22    	mov.w     #0x200a, w0
    7ca6:	01 48 78    	mov.b     w1, [w0]

00007ca8 <.L295>:
    }

    /* InitialCondition: '<S79>/IC' */
    if (AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_g) {
    7ca8:	80 00 22    	mov.w     #0x2008, w0
    7caa:	10 04 e0    	cp0.b     [w0]
    7cac:	02 00 32    	bra       Z, 0x7cb2 <.L0> <.L297>
      AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_g = false;
    7cae:	00 48 eb    	clr.b     [w0]
    7cb0:	15 00 37    	bra       0x7cdc <.L0> <.L0> <.L422>

00007cb2 <.L0>:
      rtb_Sum1_mzp = 1.0F;
    } else {
      /* Abs: '<S86>/Abs1' incorporates:
       *  Sum: '<S89>/Diff'
       *  UnitDelay: '<S89>/UD'
       */
      rtb_Sum1_mzp = (real32_T)fabs(mlParamInterface.param[22] -
    7cb2:	62 fb 80    	mov.w     0x1f6c, w2
    7cb4:	73 fb 80    	mov.w     0x1f6e, w3
    7cb6:	7e 88 91    	mov.w     [w14+414], w0
    7cb8:	8e 90 91    	mov.w     [w14+416], w1
    7cba:	90 14 02    	call      0x1490 <___subsf3>
    7cbc:	00 00 00 
    7cbe:	00 04 be    	mov.d     w0, w8
    7cc0:	09 f0 a1    	bclr.w    w9, #0xf

00007cc2 <.L0>:
        AUAV_V3_TestSensors_DWork.UD_DSTATE_ff);

      /* Saturate: '<S86>/Saturation1' */
      if (rtb_Sum1_mzp > 1.0F) {
    7cc2:	02 00 20    	mov.w     #0x0, w2
    7cc4:	03 f8 23    	mov.w     #0x3f80, w3
    7cc6:	08 00 be    	mov.d     w8, w0
    7cc8:	90 18 02    	call      0x1890 <___gesf2>
    7cca:	00 00 00 
    7ccc:	00 00 e0    	cp0.w     w0
    7cce:	06 00 3c    	bra       GT, 0x7cdc <.L0> <.L0> <.L422>

00007cd0 <.L0>:
        rtb_Sum1_mzp = 1.0F;
      }

      /* End of Saturate: '<S86>/Saturation1' */
    }

    /* End of InitialCondition: '<S79>/IC' */

    /* Outputs for Enabled SubSystem: '<S79>/Compute Coef' incorporates:
     *  EnablePort: '<S85>/Enable'
     */
    if (rtb_Sum1_mzp > 0.0F) {
    7cd0:	60 11 b8    	mul.uu    w2, #0x0, w2
    7cd2:	08 00 be    	mov.d     w8, w0
    7cd4:	90 18 02    	call      0x1890 <___gesf2>
    7cd6:	00 00 00 
    7cd8:	00 00 e0    	cp0.w     w0
    7cda:	15 00 34    	bra       LE, 0x7d06 <.L0> <.L0> <.L299>

00007cdc <.L0>:
      /* Gain: '<S85>/-T' */
      AUAV_V3_TestSensors_B.T_m = -0.01F * mlParamInterface.param[22];
    7cdc:	a2 70 2d    	mov.w     #0xd70a, w2
    7cde:	33 c2 2b    	mov.w     #0xbc23, w3
    7ce0:	7e 88 91    	mov.w     [w14+414], w0
    7ce2:	8e 90 91    	mov.w     [w14+416], w1
    7ce4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7ce6:	00 00 00 
    7ce8:	90 c7 88    	mov.w     w0, 0x18f2
    7cea:	a1 c7 88    	mov.w     w1, 0x18f4

00007cec <.L0>:

      /* S-Function (MCHP_C_function_Call): '<S87>/myExp() apUtils.c [updated 5.1.16]' */
      AUAV_V3_TestSensors_B.myExpapUtilscupdated5116_f = myExp(
    7cec:	44 10 02    	call      0x11044 <_myExp>
    7cee:	01 00 00 
    7cf0:	00 01 be    	mov.d     w0, w2
    7cf2:	b0 c7 88    	mov.w     w0, 0x18f6
    7cf4:	c1 c7 88    	mov.w     w1, 0x18f8
        AUAV_V3_TestSensors_B.T_m
        );

      /* SignalConversion: '<S88>/Numerical Unity' */
      AUAV_V3_TestSensors_B.NumericalUnity_a =
    7cf6:	d0 c7 88    	mov.w     w0, 0x18fa
    7cf8:	e1 c7 88    	mov.w     w1, 0x18fc

00007cfa <.L0>:
        AUAV_V3_TestSensors_B.myExpapUtilscupdated5116_f;

      /* Sum: '<S85>/1-c' incorporates:
       *  Constant: '<S85>/Constant'
       */
      AUAV_V3_TestSensors_B.c_d = (real32_T)(1.0 -
    7cfa:	00 00 20    	mov.w     #0x0, w0
    7cfc:	01 f8 23    	mov.w     #0x3f80, w1
    7cfe:	90 14 02    	call      0x1490 <___subsf3>
    7d00:	00 00 00 
    7d02:	f0 c7 88    	mov.w     w0, 0x18fe
    7d04:	01 c8 88    	mov.w     w1, 0x1900

00007d06 <.L0>:
        AUAV_V3_TestSensors_B.NumericalUnity_a);
    }

    /* End of Outputs for SubSystem: '<S79>/Compute Coef' */

    /* Sum: '<S79>/Subtract' incorporates:
     *  Delay: '<S79>/Integer Delay'
     *  Delay: '<S79>/Integer Delay1'
     *  Product: '<S79>/Divide'
     *  Product: '<S79>/Divide1'
     */
    rtb_Subtract_od = AUAV_V3_TestSensors_B.c_d *
    7d06:	82 fb 80    	mov.w     0x1f70, w2
    7d08:	93 fb 80    	mov.w     0x1f72, w3
    7d0a:	f0 c7 80    	mov.w     0x18fe, w0
    7d0c:	01 c8 80    	mov.w     0x1900, w1
    7d0e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7d10:	00 00 00 
    7d12:	00 04 be    	mov.d     w0, w8

00007d14 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_an +
      AUAV_V3_TestSensors_B.NumericalUnity_a *
    7d14:	a2 fb 80    	mov.w     0x1f74, w2
    7d16:	b3 fb 80    	mov.w     0x1f76, w3
    7d18:	d0 c7 80    	mov.w     0x18fa, w0
    7d1a:	e1 c7 80    	mov.w     0x18fc, w1
    7d1c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7d1e:	00 00 00 
    7d20:	00 01 be    	mov.d     w0, w2

00007d22 <.L0>:
    7d22:	08 00 be    	mov.d     w8, w0
    7d24:	92 14 02    	call      0x1492 <___addsf3>
    7d26:	00 00 00 
    7d28:	20 87 99    	mov.w     w0, [w14+388]
    7d2a:	31 87 99    	mov.w     w1, [w14+390]

00007d2c <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_i;

    /* Switch: '<S81>/Switch3' incorporates:
     *  Delay: '<S81>/Integer Delay3'
     *  RelationalOperator: '<S81>/Relational Operator2'
     */
    if ((rtb_Deg2R_h_idx_0 == rtb_Deg2R_h_idx_0) > 0) {
    7d2c:	5e a1 91    	mov.w     [w14+458], w2
    7d2e:	ee a1 91    	mov.w     [w14+460], w3
    7d30:	02 00 be    	mov.d     w2, w0
    7d32:	8c 18 02    	call      0x188c <___eqsf2>
    7d34:	00 00 00 
    7d36:	00 00 e0    	cp0.w     w0
    7d38:	05 00 32    	bra       Z, 0x7d44 <.L458>

00007d3a <.L0>:
      rtb_Switch3_gd = rtb_Deg2R_h_idx_0;
    } else {
      rtb_Switch3_gd = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_fs;
    7d3a:	c0 fb 80    	mov.w     0x1f78, w0
    7d3c:	d1 fb 80    	mov.w     0x1f7a, w1
    7d3e:	00 87 99    	mov.w     w0, [w14+384]
    7d40:	11 87 99    	mov.w     w1, [w14+386]
    7d42:	04 00 37    	bra       0x7d4c <.L301>

00007d44 <.L458>:
    7d44:	5e a1 91    	mov.w     [w14+458], w2
    7d46:	ee a1 91    	mov.w     [w14+460], w3
    7d48:	02 87 99    	mov.w     w2, [w14+384]
    7d4a:	13 87 99    	mov.w     w3, [w14+386]

00007d4c <.L301>:
    }

    /* End of Switch: '<S81>/Switch3' */

    /* InitialCondition: '<S83>/IC' */
    if (AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_f) {
    7d4c:	90 00 22    	mov.w     #0x2009, w0
    7d4e:	10 04 e0    	cp0.b     [w0]
    7d50:	02 00 32    	bra       Z, 0x7d56 <.L0> <.L302>
      AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_f = false;
    7d52:	00 48 eb    	clr.b     [w0]
    7d54:	15 00 37    	bra       0x7d80 <.L0> <.L0> <.L423>

00007d56 <.L0>:
      rtb_Sum1_mzp = 1.0F;
    } else {
      /* Abs: '<S96>/Abs1' incorporates:
       *  Sum: '<S99>/Diff'
       *  UnitDelay: '<S99>/UD'
       */
      rtb_Sum1_mzp = (real32_T)fabs(mlParamInterface.param[23] -
    7d56:	e2 fb 80    	mov.w     0x1f7c, w2
    7d58:	f3 fb 80    	mov.w     0x1f7e, w3
    7d5a:	b0 95 80    	mov.w     0x12b6, w0
    7d5c:	c1 95 80    	mov.w     0x12b8, w1
    7d5e:	90 14 02    	call      0x1490 <___subsf3>
    7d60:	00 00 00 
    7d62:	00 04 be    	mov.d     w0, w8
    7d64:	09 f0 a1    	bclr.w    w9, #0xf

00007d66 <.L0>:
        AUAV_V3_TestSensors_DWork.UD_DSTATE_j);

      /* Saturate: '<S96>/Saturation1' */
      if (rtb_Sum1_mzp > 1.0F) {
    7d66:	02 00 20    	mov.w     #0x0, w2
    7d68:	03 f8 23    	mov.w     #0x3f80, w3
    7d6a:	08 00 be    	mov.d     w8, w0
    7d6c:	90 18 02    	call      0x1890 <___gesf2>
    7d6e:	00 00 00 
    7d70:	00 00 e0    	cp0.w     w0
    7d72:	06 00 3c    	bra       GT, 0x7d80 <.L0> <.L0> <.L423>

00007d74 <.L0>:
        rtb_Sum1_mzp = 1.0F;
      }

      /* End of Saturate: '<S96>/Saturation1' */
    }

    /* End of InitialCondition: '<S83>/IC' */

    /* Outputs for Enabled SubSystem: '<S83>/Compute Coef' incorporates:
     *  EnablePort: '<S95>/Enable'
     */
    if (rtb_Sum1_mzp > 0.0F) {
    7d74:	60 11 b8    	mul.uu    w2, #0x0, w2
    7d76:	08 00 be    	mov.d     w8, w0
    7d78:	90 18 02    	call      0x1890 <___gesf2>
    7d7a:	00 00 00 
    7d7c:	00 00 e0    	cp0.w     w0
    7d7e:	15 00 34    	bra       LE, 0x7daa <.L0> <.L0> <.L304>

00007d80 <.L0>:
      /* Gain: '<S95>/-T' */
      AUAV_V3_TestSensors_B.T = -0.01F * mlParamInterface.param[23];
    7d80:	a2 70 2d    	mov.w     #0xd70a, w2
    7d82:	33 c2 2b    	mov.w     #0xbc23, w3
    7d84:	b0 95 80    	mov.w     0x12b6, w0
    7d86:	c1 95 80    	mov.w     0x12b8, w1
    7d88:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7d8a:	00 00 00 
    7d8c:	10 c7 88    	mov.w     w0, 0x18e2
    7d8e:	21 c7 88    	mov.w     w1, 0x18e4

00007d90 <.L0>:

      /* S-Function (MCHP_C_function_Call): '<S97>/myExp() apUtils.c [updated 5.1.16]' */
      AUAV_V3_TestSensors_B.myExpapUtilscupdated5116 = myExp(
    7d90:	44 10 02    	call      0x11044 <_myExp>
    7d92:	01 00 00 
    7d94:	00 01 be    	mov.d     w0, w2
    7d96:	30 c7 88    	mov.w     w0, 0x18e6
    7d98:	41 c7 88    	mov.w     w1, 0x18e8
        AUAV_V3_TestSensors_B.T
        );

      /* SignalConversion: '<S98>/Numerical Unity' */
      AUAV_V3_TestSensors_B.NumericalUnity_n =
    7d9a:	50 c7 88    	mov.w     w0, 0x18ea
    7d9c:	61 c7 88    	mov.w     w1, 0x18ec

00007d9e <.L0>:
        AUAV_V3_TestSensors_B.myExpapUtilscupdated5116;

      /* Sum: '<S95>/1-c' incorporates:
       *  Constant: '<S95>/Constant'
       */
      AUAV_V3_TestSensors_B.c_h = (real32_T)(1.0 -
    7d9e:	00 00 20    	mov.w     #0x0, w0
    7da0:	01 f8 23    	mov.w     #0x3f80, w1
    7da2:	90 14 02    	call      0x1490 <___subsf3>
    7da4:	00 00 00 
    7da6:	70 c7 88    	mov.w     w0, 0x18ee
    7da8:	81 c7 88    	mov.w     w1, 0x18f0

00007daa <.L0>:
        AUAV_V3_TestSensors_B.NumericalUnity_n);
    }

    /* End of Outputs for SubSystem: '<S83>/Compute Coef' */

    /* Sum: '<S83>/Subtract' incorporates:
     *  Delay: '<S83>/Integer Delay'
     *  Delay: '<S83>/Integer Delay1'
     *  Product: '<S83>/Divide'
     *  Product: '<S83>/Divide1'
     */
    rtb_Subtract_a = AUAV_V3_TestSensors_B.c_h *
    7daa:	02 fc 80    	mov.w     0x1f80, w2
    7dac:	13 fc 80    	mov.w     0x1f82, w3
    7dae:	70 c7 80    	mov.w     0x18ee, w0
    7db0:	81 c7 80    	mov.w     0x18f0, w1
    7db2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7db4:	00 00 00 
    7db6:	00 04 be    	mov.d     w0, w8

00007db8 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_k +
      AUAV_V3_TestSensors_B.NumericalUnity_n *
    7db8:	22 fc 80    	mov.w     0x1f84, w2
    7dba:	33 fc 80    	mov.w     0x1f86, w3
    7dbc:	50 c7 80    	mov.w     0x18ea, w0
    7dbe:	61 c7 80    	mov.w     0x18ec, w1
    7dc0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7dc2:	00 00 00 
    7dc4:	00 01 be    	mov.d     w0, w2

00007dc6 <.L0>:
    7dc6:	08 00 be    	mov.d     w8, w0
    7dc8:	92 14 02    	call      0x1492 <___addsf3>
    7dca:	00 00 00 
    7dcc:	40 87 99    	mov.w     w0, [w14+392]
    7dce:	51 87 99    	mov.w     w1, [w14+394]

00007dd0 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_b;

    /* Gain: '<S69>/Gain' incorporates:
     *  Sum: '<S69>/Sum3'
     */
    rtb_Sum1_mzp = -(rtb_Subtract_a - rtb_Switch3_gd);
    7dd0:	0e 81 91    	mov.w     [w14+384], w2
    7dd2:	9e 81 91    	mov.w     [w14+386], w3
    7dd4:	90 14 02    	call      0x1490 <___subsf3>
    7dd6:	00 00 00 
    7dd8:	00 06 be    	mov.d     w0, w12
    7dda:	0d f0 a2    	btg.w     w13, #0xf

00007ddc <.L0>:

    /* Product: '<S94>/Divide4' incorporates:
     *  Constant: '<S94>/Constant'
     *  Delay: '<S69>/Integer Delay1'
     */
    rtb_RhhcosphisinlambYe = 0.25F *
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e * 2.0F;
    7ddc:	6a fc 80    	mov.w     0x1f8c, w10
    7dde:	7b fc 80    	mov.w     0x1f8e, w11

00007de0 <.L0>:
    7de0:	02 00 20    	mov.w     #0x0, w2
    7de2:	03 e8 23    	mov.w     #0x3e80, w3
    7de4:	0a 00 be    	mov.d     w10, w0
    7de6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7de8:	00 00 00 
    7dea:	00 01 be    	mov.d     w0, w2
    7dec:	92 14 02    	call      0x1492 <___addsf3>
    7dee:	00 00 00 
    7df0:	00 04 be    	mov.d     w0, w8

00007df2 <.L0>:

    /* Product: '<S94>/Divide3' incorporates:
     *  Delay: '<S69>/Integer Delay1'
     *  Product: '<S94>/Divide'
     *  Sum: '<S94>/Subtract'
     */
    rtb_Deg2R1 = (AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e *
                  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e - 4.0F) /
      4.0F;

    /* Logic: '<S80>/Logical Operator2' incorporates:
     *  Constant: '<S90>/Constant'
     *  Constant: '<S91>/Constant'
     *  Product: '<S80>/Divide2'
     *  RelationalOperator: '<S90>/Compare'
     *  RelationalOperator: '<S91>/Compare'
     */
    rtb_Compare_j = (uint8_T)((rtb_RhhcosphisinlambYe * rtb_Sum1_mzp > 0.0F) &&
    7df2:	0c 01 be    	mov.d     w12, w2
    7df4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7df6:	00 00 00 
    7df8:	60 11 b8    	mul.uu    w2, #0x0, w2
    7dfa:	90 18 02    	call      0x1890 <___gesf2>
    7dfc:	00 00 00 
    7dfe:	00 00 e0    	cp0.w     w0
    7e00:	3d 08 34    	bra       LE, 0x8e7c <.L306>

00007e02 <.L0>:
    7e02:	0a 01 be    	mov.d     w10, w2
    7e04:	0a 00 be    	mov.d     w10, w0
    7e06:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7e08:	00 00 00 

00007e0a <.L0>:
    7e0a:	02 00 20    	mov.w     #0x0, w2
    7e0c:	03 08 24    	mov.w     #0x4080, w3
    7e0e:	90 14 02    	call      0x1490 <___subsf3>
    7e10:	00 00 00 

00007e12 <.L0>:
    7e12:	02 00 20    	mov.w     #0x0, w2
    7e14:	03 e8 23    	mov.w     #0x3e80, w3
    7e16:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7e18:	00 00 00 
    7e1a:	00 05 be    	mov.d     w0, w10

00007e1c <.L0>:
    7e1c:	60 11 b8    	mul.uu    w2, #0x0, w2
    7e1e:	90 18 02    	call      0x1890 <___gesf2>
    7e20:	00 00 00 
    7e22:	00 00 e0    	cp0.w     w0
    7e24:	2b 08 35    	bra       LT, 0x8e7c <.L306>

00007e26 <.L0>:
      (rtb_Deg2R1 >= 0.0F));

    /* Outputs for Enabled SubSystem: '<S80>/Enabled Subsystem' incorporates:
     *  EnablePort: '<S92>/Enable'
     */
    if (!(rtb_Compare_j != 0) > 0) {
      AUAV_V3_TestSensors_B.Merge_oo = rtb_Sum1_mzp;
    }

    /* End of Outputs for SubSystem: '<S80>/Enabled Subsystem' */

    /* Outputs for Enabled SubSystem: '<S80>/Enabled Subsystem1' incorporates:
     *  EnablePort: '<S93>/Enable'
     */
    if (rtb_Compare_j > 0) {
      /* Signum: '<S93>/Sign' */
      if (rtb_RhhcosphisinlambYe < 0.0F) {
    7e26:	60 11 b8    	mul.uu    w2, #0x0, w2
    7e28:	08 00 be    	mov.d     w8, w0
    7e2a:	8c 18 02    	call      0x188c <___eqsf2>
    7e2c:	00 00 00 
    7e2e:	00 00 e0    	cp0.w     w0
    7e30:	0d 00 35    	bra       LT, 0x7e4c <.L0> <.L459>

00007e32 <.L0>:
        rtb_RhhcosphisinlambYe = -1.0F;
      } else if (rtb_RhhcosphisinlambYe > 0.0F) {
    7e32:	60 11 b8    	mul.uu    w2, #0x0, w2
    7e34:	08 00 be    	mov.d     w8, w0
    7e36:	90 18 02    	call      0x1890 <___gesf2>
    7e38:	00 00 00 
    7e3a:	00 00 e0    	cp0.w     w0
    7e3c:	0a 00 3c    	bra       GT, 0x7e52 <.L460>

00007e3e <.L0>:
        rtb_RhhcosphisinlambYe = 1.0F;
      } else {
        if (rtb_RhhcosphisinlambYe == 0.0F) {
    7e3e:	60 11 b8    	mul.uu    w2, #0x0, w2
    7e40:	08 00 be    	mov.d     w8, w0
    7e42:	8c 18 02    	call      0x188c <___eqsf2>
    7e44:	00 00 00 
    7e46:	00 00 e0    	cp0.w     w0
    7e48:	07 00 32    	bra       Z, 0x7e58 <.L461>
    7e4a:	07 00 37    	bra       0x7e5a <.L0> <.L309>

00007e4c <.L0>:
    7e4c:	08 00 20    	mov.w     #0x0, w8
    7e4e:	09 f8 2b    	mov.w     #0xbf80, w9
    7e50:	04 00 37    	bra       0x7e5a <.L0> <.L309>

00007e52 <.L460>:
    7e52:	08 00 20    	mov.w     #0x0, w8
    7e54:	09 f8 23    	mov.w     #0x3f80, w9
    7e56:	01 00 37    	bra       0x7e5a <.L0> <.L309>

00007e58 <.L461>:
          rtb_RhhcosphisinlambYe = 0.0F;
    7e58:	60 44 b8    	mul.uu    w8, #0x0, w8

00007e5a <.L0>:
        }
      }

      /* Product: '<S93>/Divide2' incorporates:
       *  Constant: '<S93>/Constant'
       *  Product: '<S93>/Divide1'
       *  Signum: '<S93>/Sign'
       *  Sum: '<S93>/Subtract'
       */
      AUAV_V3_TestSensors_B.Merge_oo = (1.0F - rtb_Deg2R1 *
    7e5a:	08 01 be    	mov.d     w8, w2
    7e5c:	0a 00 be    	mov.d     w10, w0
    7e5e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7e60:	00 00 00 
    7e62:	00 01 be    	mov.d     w0, w2
    7e64:	00 00 20    	mov.w     #0x0, w0
    7e66:	01 f8 23    	mov.w     #0x3f80, w1
    7e68:	90 14 02    	call      0x1490 <___subsf3>
    7e6a:	00 00 00 

00007e6c <.L0>:
        rtb_RhhcosphisinlambYe) * rtb_Sum1_mzp;
    7e6c:	0c 01 be    	mov.d     w12, w2
    7e6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7e70:	00 00 00 

00007e72 <.L0>:
    7e72:	d0 c6 88    	mov.w     w0, 0x18da
    7e74:	e1 c6 88    	mov.w     w1, 0x18dc

00007e76 <.L0>:
    }

    /* End of Outputs for SubSystem: '<S80>/Enabled Subsystem1' */

    /* Product: '<S69>/Projection' incorporates:
     *  Inport: '<S92>/In1'
     *  Logic: '<S80>/Logical Operator'
     */
    rtb_Projection = mlParamInterface.param[24] * AUAV_V3_TestSensors_B.Merge_oo;
    7e76:	d2 c6 80    	mov.w     0x18da, w2
    7e78:	e3 c6 80    	mov.w     0x18dc, w3
    7e7a:	d0 95 80    	mov.w     0x12ba, w0
    7e7c:	e1 95 80    	mov.w     0x12bc, w1
    7e7e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7e80:	00 00 00 
    7e82:	30 97 99    	mov.w     w0, [w14+422]
    7e84:	41 97 99    	mov.w     w1, [w14+424]

00007e86 <.L0>:

    /* Sum: '<S69>/Sum4' incorporates:
     *  Delay: '<S69>/Integer Delay'
     */
    AUAV_V3_TestSensors_B.PsiDotLimit =
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_i - rtb_Subtract_od;
    7e86:	2e 81 91    	mov.w     [w14+388], w2
    7e88:	be 81 91    	mov.w     [w14+390], w3
    7e8a:	40 fc 80    	mov.w     0x1f88, w0
    7e8c:	51 fc 80    	mov.w     0x1f8a, w1
    7e8e:	90 14 02    	call      0x1490 <___subsf3>
    7e90:	00 00 00 
    7e92:	00 04 be    	mov.d     w0, w8

00007e94 <.L0>:
    7e94:	f0 c6 88    	mov.w     w0, 0x18de
    7e96:	01 c7 88    	mov.w     w1, 0x18e0

00007e98 <.L0>:

    /* Saturate: '<S69>/Psi Dot  Limit' */
    if (AUAV_V3_TestSensors_B.PsiDotLimit > 1.0F) {
    7e98:	02 00 20    	mov.w     #0x0, w2
    7e9a:	03 f8 23    	mov.w     #0x3f80, w3
    7e9c:	90 18 02    	call      0x1890 <___gesf2>
    7e9e:	00 00 00 
    7ea0:	00 00 e0    	cp0.w     w0
    7ea2:	05 00 34    	bra       LE, 0x7eae <.L0> <.L628>

00007ea4 <.L0>:
      /* Sum: '<S69>/Sum4' */
      AUAV_V3_TestSensors_B.PsiDotLimit = 1.0F;
    7ea4:	00 00 20    	mov.w     #0x0, w0
    7ea6:	01 f8 23    	mov.w     #0x3f80, w1
    7ea8:	f0 c6 88    	mov.w     w0, 0x18de
    7eaa:	01 c7 88    	mov.w     w1, 0x18e0
    7eac:	0b 00 37    	bra       0x7ec4 <.L0> <.L312>

00007eae <.L0>:
    } else {
      if (AUAV_V3_TestSensors_B.PsiDotLimit < -1.0F) {
    7eae:	02 00 20    	mov.w     #0x0, w2
    7eb0:	03 f8 2b    	mov.w     #0xbf80, w3
    7eb2:	08 00 be    	mov.d     w8, w0
    7eb4:	8c 18 02    	call      0x188c <___eqsf2>
    7eb6:	00 00 00 
    7eb8:	00 00 e0    	cp0.w     w0
    7eba:	04 00 3d    	bra       GE, 0x7ec4 <.L0> <.L312>

00007ebc <.L0>:
        /* Sum: '<S69>/Sum4' */
        AUAV_V3_TestSensors_B.PsiDotLimit = -1.0F;
    7ebc:	00 00 20    	mov.w     #0x0, w0
    7ebe:	01 f8 2b    	mov.w     #0xbf80, w1
    7ec0:	f0 c6 88    	mov.w     w0, 0x18de
    7ec2:	01 c7 88    	mov.w     w1, 0x18e0

00007ec4 <.L0>:
      }
    }

    /* End of Saturate: '<S69>/Psi Dot  Limit' */

    /* Sum: '<S69>/Sum2' incorporates:
     *  Delay: '<S69>/Integer Delay1'
     */
    rtb_Switch1_a = AUAV_V3_TestSensors_B.PsiDotLimit +
    7ec4:	62 fc 80    	mov.w     0x1f8c, w2
    7ec6:	73 fc 80    	mov.w     0x1f8e, w3
    7ec8:	f0 c6 80    	mov.w     0x18de, w0
    7eca:	01 c7 80    	mov.w     0x18e0, w1
    7ecc:	92 14 02    	call      0x1492 <___addsf3>
    7ece:	00 00 00 
    7ed0:	00 04 be    	mov.d     w0, w8

00007ed2 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e;

    /* Switch: '<S82>/Switch3' incorporates:
     *  Delay: '<S82>/Integer Delay3'
     *  RelationalOperator: '<S82>/Relational Operator2'
     */
    if ((rtb_Switch1_a == rtb_Switch1_a) > 0) {
    7ed2:	00 01 be    	mov.d     w0, w2
    7ed4:	8c 18 02    	call      0x188c <___eqsf2>
    7ed6:	00 00 00 
    7ed8:	00 00 e0    	cp0.w     w0
    7eda:	05 00 32    	bra       Z, 0x7ee6 <.L462>

00007edc <.L0>:
      rtb_Switch3_kh = rtb_Switch1_a;
    } else {
      rtb_Switch3_kh = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_h;
    7edc:	84 fc 80    	mov.w     0x1f90, w4
    7ede:	95 fc 80    	mov.w     0x1f92, w5
    7ee0:	64 87 99    	mov.w     w4, [w14+396]
    7ee2:	75 87 99    	mov.w     w5, [w14+398]
    7ee4:	02 00 37    	bra       0x7eea <.L0> <.L314>

00007ee6 <.L462>:
    7ee6:	68 87 99    	mov.w     w8, [w14+396]
    7ee8:	79 87 99    	mov.w     w9, [w14+398]

00007eea <.L0>:
    }

    /* End of Switch: '<S82>/Switch3' */

    /* Switch: '<S100>/Switch3' incorporates:
     *  Delay: '<S100>/Integer Delay3'
     *  RelationalOperator: '<S100>/Relational Operator2'
     */
    if (!((rtb_Projection == rtb_Projection) > 0)) {
    7eea:	18 c0 b3    	mov.b     #0x1, w8
    7eec:	3e 91 91    	mov.w     [w14+422], w2
    7eee:	ce 91 91    	mov.w     [w14+424], w3
    7ef0:	02 00 be    	mov.d     w2, w0
    7ef2:	8c 18 02    	call      0x188c <___eqsf2>
    7ef4:	00 00 00 
    7ef6:	00 00 e0    	cp0.w     w0
    7ef8:	01 00 32    	bra       Z, 0x7efc <.L316>
    7efa:	00 44 eb    	clr.b     w8

00007efc <.L316>:
    7efc:	08 04 e0    	cp0.b     w8
    7efe:	04 00 3a    	bra       NZ, 0x7f08 <.L0> <.L315>

00007f00 <.L0>:
      rtb_Projection = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_nz;
    7f00:	22 fd 80    	mov.w     0x1fa4, w2
    7f02:	33 fd 80    	mov.w     0x1fa6, w3
    7f04:	32 97 99    	mov.w     w2, [w14+422]
    7f06:	43 97 99    	mov.w     w3, [w14+424]

00007f08 <.L0>:
    }

    /* End of Switch: '<S100>/Switch3' */

    /* Switch: '<S84>/Switch1' incorporates:
     *  Constant: '<S84>/Constant5'
     *  Logic: '<S69>/Logical Operator'
     */
    if (!(mlParamInterface.param[25] != 0.0F) > 0) {
    7f08:	18 c0 b3    	mov.b     #0x1, w8
    7f0a:	60 11 b8    	mul.uu    w2, #0x0, w2
    7f0c:	f0 95 80    	mov.w     0x12be, w0
    7f0e:	01 96 80    	mov.w     0x12c0, w1
    7f10:	c8 19 02    	call      0x19c8 <___nesf2>
    7f12:	00 00 00 
    7f14:	00 00 e0    	cp0.w     w0
    7f16:	01 00 3a    	bra       NZ, 0x7f1a <.L0> <.L318>
    7f18:	00 44 eb    	clr.b     w8

00007f1a <.L0>:
      rtb_Switch1_a = 0.0F;
    7f1a:	60 22 b8    	mul.uu    w4, #0x0, w4
    7f1c:	14 97 99    	mov.w     w4, [w14+418]
    7f1e:	25 97 99    	mov.w     w5, [w14+420]
    7f20:	08 04 e0    	cp0.b     w8
    7f22:	48 00 32    	bra       Z, 0x7fb4 <.L319>

00007f24 <.L0>:
    } else {
      /* Sum: '<S84>/Subtract1' incorporates:
       *  Constant: '<S84>/Constant'
       *  Constant: '<S84>/Constant1'
       *  Constant: '<S84>/Constant2'
       *  Constant: '<S84>/Constant3'
       *  Delay: '<S84>/Integer Delay'
       *  Delay: '<S84>/Integer Delay1'
       *  Delay: '<S84>/Integer Delay2'
       *  Product: '<S84>/Product'
       *  Product: '<S84>/Product1'
       *  Product: '<S84>/Product2'
       *  Product: '<S84>/Product3'
       *  Sum: '<S84>/Subtract'
       */
      rtb_Switch1_a = ((rtb_Projection * 0.333333343F +
    7f24:	b2 aa 2a    	mov.w     #0xaaab, w2
    7f26:	a3 ea 23    	mov.w     #0x3eaa, w3
    7f28:	3e 90 91    	mov.w     [w14+422], w0
    7f2a:	ce 90 91    	mov.w     [w14+424], w1
    7f2c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7f2e:	00 00 00 
    7f30:	00 04 be    	mov.d     w0, w8

00007f32 <.L0>:
                        AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_p *
    7f32:	b2 aa 2a    	mov.w     #0xaaab, w2
    7f34:	a3 fa 23    	mov.w     #0x3faa, w3
    7f36:	a0 fc 80    	mov.w     0x1f94, w0
    7f38:	b1 fc 80    	mov.w     0x1f96, w1
    7f3a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7f3c:	00 00 00 
    7f3e:	00 01 be    	mov.d     w0, w2

00007f40 <.L0>:
    7f40:	08 00 be    	mov.d     w8, w0
    7f42:	92 14 02    	call      0x1492 <___addsf3>
    7f44:	00 00 00 
    7f46:	00 04 be    	mov.d     w0, w8

00007f48 <.L0>:
                        1.33333337F) +
                       AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[0] *
    7f48:	b2 aa 2a    	mov.w     #0xaaab, w2
    7f4a:	a3 ea 23    	mov.w     #0x3eaa, w3
    7f4c:	c0 fc 80    	mov.w     0x1f98, w0
    7f4e:	d1 fc 80    	mov.w     0x1f9a, w1
    7f50:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7f52:	00 00 00 
    7f54:	00 01 be    	mov.d     w0, w2

00007f56 <.L0>:
    7f56:	08 00 be    	mov.d     w8, w0
    7f58:	92 14 02    	call      0x1492 <___addsf3>
    7f5a:	00 00 00 

00007f5c <.L0>:
                       0.333333343F) * 0.005F +
    7f5c:	a2 70 2d    	mov.w     #0xd70a, w2
    7f5e:	33 ba 23    	mov.w     #0x3ba3, w3
    7f60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7f62:	00 00 00 

00007f64 <.L0>:
    7f64:	02 fd 80    	mov.w     0x1fa0, w2
    7f66:	13 fd 80    	mov.w     0x1fa2, w3
    7f68:	92 14 02    	call      0x1492 <___addsf3>
    7f6a:	00 00 00 
    7f6c:	10 97 99    	mov.w     w0, [w14+418]
    7f6e:	21 97 99    	mov.w     w1, [w14+420]

00007f70 <.L0>:
        AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_g;

      /* Saturate: '<S84>/[min max]' */
      if (rtb_Switch1_a > 2.0F) {
    7f70:	02 00 20    	mov.w     #0x0, w2
    7f72:	03 00 24    	mov.w     #0x4000, w3
    7f74:	90 18 02    	call      0x1890 <___gesf2>
    7f76:	00 00 00 
    7f78:	00 00 e0    	cp0.w     w0
    7f7a:	83 07 3c    	bra       GT, 0x8e82 <.L464>

00007f7c <.L0>:
        rtb_Switch1_a = 2.0F;
      } else {
        if (rtb_Switch1_a < -2.0F) {
    7f7c:	02 00 20    	mov.w     #0x0, w2
    7f7e:	03 00 2c    	mov.w     #0xc000, w3
    7f80:	1e 90 91    	mov.w     [w14+418], w0
    7f82:	ae 90 91    	mov.w     [w14+420], w1
    7f84:	8c 18 02    	call      0x188c <___eqsf2>
    7f86:	00 00 00 
    7f88:	00 00 e0    	cp0.w     w0
    7f8a:	80 07 35    	bra       LT, 0x8e8c <.L0> <.L465>

00007f8c <.L0>:
          rtb_Switch1_a = -2.0F;
        }
      }

      /* End of Saturate: '<S84>/[min max]' */
    }

    /* End of Switch: '<S84>/Switch1' */

    /* Switch: '<S101>/Switch3' incorporates:
     *  Delay: '<S101>/Integer Delay3'
     *  RelationalOperator: '<S101>/Relational Operator2'
     */
    if (!((rtb_Switch1_a == rtb_Switch1_a) > 0)) {
    7f8c:	18 c0 b3    	mov.b     #0x1, w8
    7f8e:	1e 91 91    	mov.w     [w14+418], w2
    7f90:	ae 91 91    	mov.w     [w14+420], w3
    7f92:	02 00 be    	mov.d     w2, w0
    7f94:	8c 18 02    	call      0x188c <___eqsf2>
    7f96:	00 00 00 
    7f98:	00 00 e0    	cp0.w     w0
    7f9a:	01 00 32    	bra       Z, 0x7f9e <.L320>
    7f9c:	00 44 eb    	clr.b     w8

00007f9e <.L320>:
    7f9e:	08 04 e0    	cp0.b     w8
    7fa0:	09 00 3a    	bra       NZ, 0x7fb4 <.L319>

00007fa2 <.L0>:
      rtb_Switch1_a = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_hh;
    7fa2:	44 fd 80    	mov.w     0x1fa8, w4
    7fa4:	55 fd 80    	mov.w     0x1faa, w5
    7fa6:	14 97 99    	mov.w     w4, [w14+418]
    7fa8:	25 97 99    	mov.w     w5, [w14+420]
    7faa:	04 00 37    	bra       0x7fb4 <.L319>

00007fac <.L627>:
    }

    /* End of Switch: '<S101>/Switch3' */
  } else {
    if (AUAV_V3_TestSensors_DWork.L1OutputFeedbackControllerWithP) {
    7fac:	a0 00 22    	mov.w     #0x200a, w0
    7fae:	10 04 e0    	cp0.b     [w0]
    7fb0:	01 00 32    	bra       Z, 0x7fb4 <.L319>
      AUAV_V3_TestSensors_DWork.L1OutputFeedbackControllerWithP = false;
    7fb2:	00 48 eb    	clr.b     [w0]

00007fb4 <.L319>:
    }
  }

  /* End of Outputs for SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */

  /* Product: '<S21>/Product2' incorporates:
   *  Sum: '<S21>/Sum'
   */
  for (i = 0; i < 3; i++) {
    rtb_P32[i] = rtb_MathFunction[i + 6] *
      AUAV_V3_TestSensors_B.DataTypeConversion3[2] + (rtb_MathFunction[i + 3] *
    7fb4:	fc b3 80    	mov.w     0x167e, w12
    7fb6:	0d b4 80    	mov.w     0x1680, w13
      AUAV_V3_TestSensors_B.DataTypeConversion3[1] + rtb_MathFunction[i] *
    7fb8:	d0 b3 80    	mov.w     0x167a, w0
    7fba:	e1 b3 80    	mov.w     0x167c, w1
    7fbc:	70 9f 99    	mov.w     w0, [w14+446]
    7fbe:	01 a7 99    	mov.w     w1, [w14+448]
      AUAV_V3_TestSensors_B.DataTypeConversion3[0]);
    7fc0:	b2 b3 80    	mov.w     0x1676, w2
    7fc2:	c3 b3 80    	mov.w     0x1678, w3
    7fc4:	52 9f 99    	mov.w     w2, [w14+442]
    7fc6:	63 9f 99    	mov.w     w3, [w14+444]
    7fc8:	43 08 20    	mov.w     #0x84, w3
    7fca:	83 01 47    	add.w     w14, w3, w3
    7fcc:	53 b7 99    	mov.w     w3, [w14+490]
    7fce:	7e a2 91    	mov.w     [w14+462], w4
    7fd0:	14 b7 99    	mov.w     w4, [w14+482]
    7fd2:	be a2 91    	mov.w     [w14+454], w5
    7fd4:	55 af 99    	mov.w     w5, [w14+474]
    7fd6:	3e a8 91    	mov.w     [w14+470], w0
    7fd8:	10 af 99    	mov.w     w0, [w14+466]
    7fda:	00 04 eb    	clr.w     w8
    7fdc:	58 97 99    	mov.w     w8, [w14+426]

00007fde <.L0>:
    7fde:	9e a8 91    	mov.w     [w14+466], w1
    7fe0:	51 01 be    	mov.d     [++w1], w2
    7fe2:	11 af 99    	mov.w     w1, [w14+466]
    7fe4:	0c 00 be    	mov.d     w12, w0
    7fe6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7fe8:	00 00 00 
    7fea:	00 05 be    	mov.d     w0, w10

00007fec <.L0>:
    7fec:	5e aa 91    	mov.w     [w14+474], w4
    7fee:	54 01 be    	mov.d     [++w4], w2
    7ff0:	54 af 99    	mov.w     w4, [w14+474]
    7ff2:	7e 98 91    	mov.w     [w14+446], w0
    7ff4:	8e a0 91    	mov.w     [w14+448], w1
    7ff6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    7ff8:	00 00 00 
    7ffa:	00 04 be    	mov.d     w0, w8

00007ffc <.L0>:
    7ffc:	9e b2 91    	mov.w     [w14+482], w5
    7ffe:	55 01 be    	mov.d     [++w5], w2
    8000:	15 b7 99    	mov.w     w5, [w14+482]
    8002:	5e 98 91    	mov.w     [w14+442], w0
    8004:	ee 98 91    	mov.w     [w14+444], w1
    8006:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8008:	00 00 00 
    800a:	00 01 be    	mov.d     w0, w2
    800c:	08 00 be    	mov.d     w8, w0
    800e:	92 14 02    	call      0x1492 <___addsf3>
    8010:	00 00 00 
    8012:	00 01 be    	mov.d     w0, w2

00008014 <.L0>:
    8014:	0a 00 be    	mov.d     w10, w0
    8016:	92 14 02    	call      0x1492 <___addsf3>
    8018:	00 00 00 

0000801a <.L0>:
    801a:	5e b1 91    	mov.w     [w14+490], w2
    801c:	00 a9 be    	mov.d     w0, [++w2]
    801e:	52 b7 99    	mov.w     w2, [w14+490]
    8020:	de 91 91    	mov.w     [w14+426], w3
    8022:	83 01 e8    	inc.w     w3, w3
    8024:	53 97 99    	mov.w     w3, [w14+426]
    8026:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    8028:	da ff 3a    	bra       NZ, 0x7fde <.L0> <.L321>
  }

  /* End of Product: '<S21>/Product2' */

  /* Product: '<S21>/Product3' incorporates:
   *  Sum: '<S21>/Sum'
   */
  for (i = 0; i < 3; i++) {
    rtb_Merge_m[i] = rtb_MathFunction[i + 6] *
      AUAV_V3_TestSensors_B.DataTypeConversion1[2] + (rtb_MathFunction[i + 3] *
    802a:	dc b9 80    	mov.w     0x173a, w12
    802c:	ed b9 80    	mov.w     0x173c, w13
      AUAV_V3_TestSensors_B.DataTypeConversion1[1] + rtb_MathFunction[i] *
    802e:	b4 b9 80    	mov.w     0x1736, w4
    8030:	c5 b9 80    	mov.w     0x1738, w5
    8032:	14 b7 99    	mov.w     w4, [w14+482]
    8034:	25 b7 99    	mov.w     w5, [w14+484]
      AUAV_V3_TestSensors_B.DataTypeConversion1[0]);
    8036:	90 b9 80    	mov.w     0x1732, w0
    8038:	a1 b9 80    	mov.w     0x1734, w1
    803a:	50 af 99    	mov.w     w0, [w14+474]
    803c:	61 af 99    	mov.w     w1, [w14+476]
    803e:	81 07 20    	mov.w     #0x78, w1
    8040:	81 00 47    	add.w     w14, w1, w1
    8042:	51 b7 99    	mov.w     w1, [w14+490]
    8044:	00 04 eb    	clr.w     w8
    8046:	18 af 99    	mov.w     w8, [w14+466]

00008048 <.L0>:
    8048:	3e aa 91    	mov.w     [w14+470], w4
    804a:	54 01 be    	mov.d     [++w4], w2
    804c:	34 af 99    	mov.w     w4, [w14+470]
    804e:	0c 00 be    	mov.d     w12, w0
    8050:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8052:	00 00 00 
    8054:	00 05 be    	mov.d     w0, w10

00008056 <.L0>:
    8056:	be a2 91    	mov.w     [w14+454], w5
    8058:	55 01 be    	mov.d     [++w5], w2
    805a:	35 a7 99    	mov.w     w5, [w14+454]
    805c:	1e b0 91    	mov.w     [w14+482], w0
    805e:	ae b0 91    	mov.w     [w14+484], w1
    8060:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8062:	00 00 00 
    8064:	00 04 be    	mov.d     w0, w8

00008066 <.L0>:
    8066:	7e a0 91    	mov.w     [w14+462], w0
    8068:	50 01 be    	mov.d     [++w0], w2
    806a:	70 a7 99    	mov.w     w0, [w14+462]
    806c:	5e a8 91    	mov.w     [w14+474], w0
    806e:	ee a8 91    	mov.w     [w14+476], w1
    8070:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8072:	00 00 00 
    8074:	00 01 be    	mov.d     w0, w2
    8076:	08 00 be    	mov.d     w8, w0
    8078:	92 14 02    	call      0x1492 <___addsf3>
    807a:	00 00 00 
    807c:	00 01 be    	mov.d     w0, w2

0000807e <.L0>:
    807e:	0a 00 be    	mov.d     w10, w0
    8080:	92 14 02    	call      0x1492 <___addsf3>
    8082:	00 00 00 

00008084 <.L0>:
    8084:	5e b1 91    	mov.w     [w14+490], w2
    8086:	00 a9 be    	mov.d     w0, [++w2]
    8088:	52 b7 99    	mov.w     w2, [w14+490]
    808a:	9e a9 91    	mov.w     [w14+466], w3
    808c:	83 01 e8    	inc.w     w3, w3
    808e:	13 af 99    	mov.w     w3, [w14+466]
    8090:	e3 8f 51    	sub.w     w3, #0x3, [w15]
    8092:	da ff 3a    	bra       NZ, 0x8048 <.L0> <.L322>

00008094 <.L0>:
  }

  /* End of Product: '<S21>/Product3' */

  /* Sum: '<S21>/Sum' */
  rtb_Product3_j0[1] = rtb_P32[1] + rtb_Merge_m[1];
    8094:	0e 81 90    	mov.w     [w14+128], w2
    8096:	9e 81 90    	mov.w     [w14+130], w3
    8098:	6e 80 90    	mov.w     [w14+140], w0
    809a:	fe 80 90    	mov.w     [w14+142], w1
    809c:	92 14 02    	call      0x1492 <___addsf3>
    809e:	00 00 00 
    80a0:	20 07 98    	mov.w     w0, [w14+4]
    80a2:	31 07 98    	mov.w     w1, [w14+6]

000080a4 <.L0>:

  /* Outputs for Atomic SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */
  /* Switch: '<S136>/Switch3' incorporates:
   *  RelationalOperator: '<S136>/Relational Operator2'
   */
  if ((rtb_cosphi == rtb_cosphi) > 0) {
    80a4:	1e a1 91    	mov.w     [w14+450], w2
    80a6:	ae a1 91    	mov.w     [w14+452], w3
    80a8:	02 00 be    	mov.d     w2, w0
    80aa:	8c 18 02    	call      0x188c <___eqsf2>
    80ac:	00 00 00 
    80ae:	00 00 e0    	cp0.w     w0
    80b0:	04 00 3a    	bra       NZ, 0x80ba <.L0> <.L323>

000080b2 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_mw = rtb_cosphi;
    80b2:	1e a2 91    	mov.w     [w14+450], w4
    80b4:	ae a2 91    	mov.w     [w14+452], w5
    80b6:	a4 f7 88    	mov.w     w4, 0x1ef4
    80b8:	b5 f7 88    	mov.w     w5, 0x1ef6

000080ba <.L0>:
  }

  /* End of Switch: '<S136>/Switch3' */

  /* Saturate: '<S135>/bank Limit' */
  if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_mw > 0.436332315F) {
    80ba:	a8 f7 80    	mov.w     0x1ef4, w8
    80bc:	b9 f7 80    	mov.w     0x1ef6, w9
    80be:	32 6f 26    	mov.w     #0x66f3, w2
    80c0:	f3 ed 23    	mov.w     #0x3edf, w3
    80c2:	08 00 be    	mov.d     w8, w0
    80c4:	90 18 02    	call      0x1890 <___gesf2>
    80c6:	00 00 00 
    80c8:	00 00 e0    	cp0.w     w0
    80ca:	05 00 34    	bra       LE, 0x80d6 <.L0> <.L629>

000080cc <.L0>:
    AUAV_V3_TestSensors_B.bankLimit = 0.436332315F;
    80cc:	30 6f 26    	mov.w     #0x66f3, w0
    80ce:	f1 ed 23    	mov.w     #0x3edf, w1
    80d0:	70 c5 88    	mov.w     w0, 0x18ae
    80d2:	81 c5 88    	mov.w     w1, 0x18b0
    80d4:	0e 00 37    	bra       0x80f2 <.L0> <.L327>

000080d6 <.L0>:
  } else if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_mw < -0.436332315F)
    80d6:	32 6f 26    	mov.w     #0x66f3, w2
    80d8:	f3 ed 2b    	mov.w     #0xbedf, w3
    80da:	08 00 be    	mov.d     w8, w0
    80dc:	8c 18 02    	call      0x188c <___eqsf2>
    80de:	00 00 00 
    80e0:	00 00 e0    	cp0.w     w0
    80e2:	05 00 3d    	bra       GE, 0x80ee <.L630>

000080e4 <.L0>:
  {
    AUAV_V3_TestSensors_B.bankLimit = -0.436332315F;
    80e4:	30 6f 26    	mov.w     #0x66f3, w0
    80e6:	f1 ed 2b    	mov.w     #0xbedf, w1
    80e8:	70 c5 88    	mov.w     w0, 0x18ae
    80ea:	81 c5 88    	mov.w     w1, 0x18b0
    80ec:	02 00 37    	bra       0x80f2 <.L0> <.L327>

000080ee <.L630>:
  } else {
    AUAV_V3_TestSensors_B.bankLimit =
    80ee:	78 c5 88    	mov.w     w8, 0x18ae
    80f0:	89 c5 88    	mov.w     w9, 0x18b0

000080f2 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_mw;
  }

  /* End of Saturate: '<S135>/bank Limit' */

  /* S-Function (MCHP_C_function_Call): '<S138>/myTan() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myTanapUtilscupdated5116 = myTan(
    80f2:	70 c5 80    	mov.w     0x18ae, w0
    80f4:	81 c5 80    	mov.w     0x18b0, w1
    80f6:	38 10 02    	call      0x11038 <_myTan>
    80f8:	01 00 00 
    80fa:	00 04 be    	mov.d     w0, w8
    80fc:	90 c5 88    	mov.w     w0, 0x18b2
    80fe:	a1 c5 88    	mov.w     w1, 0x18b4

00008100 <.L0>:
    AUAV_V3_TestSensors_B.bankLimit
    );

  /* Switch: '<S137>/Switch3' incorporates:
   *  RelationalOperator: '<S137>/Relational Operator2'
   */
  if ((rtb_Product3_bo == rtb_Product3_bo) > 0) {
    8100:	3e b1 91    	mov.w     [w14+486], w2
    8102:	ce b1 91    	mov.w     [w14+488], w3
    8104:	02 00 be    	mov.d     w2, w0
    8106:	8c 18 02    	call      0x188c <___eqsf2>
    8108:	00 00 00 
    810a:	00 00 e0    	cp0.w     w0
    810c:	04 00 3a    	bra       NZ, 0x8116 <.L330>

0000810e <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_bs = rtb_Product3_bo;
    810e:	3e b0 91    	mov.w     [w14+486], w0
    8110:	ce b0 91    	mov.w     [w14+488], w1
    8112:	c0 f7 88    	mov.w     w0, 0x1ef8
    8114:	d1 f7 88    	mov.w     w1, 0x1efa

00008116 <.L330>:
  }

  /* End of Switch: '<S137>/Switch3' */

  /* Switch: '<S103>/Switch1' incorporates:
   *  Constant: '<S135>/Constant1'
   *  DataStoreRead: '<Root>/Get mlMidLevelCommands'
   *  Product: '<S135>/Divide'
   *  Product: '<S135>/Divide1'
   *  Saturate: '<S135>/[0 40]'
   */
  if (rtb_IC1_a) {
    8116:	ce 58 93    	mov.b     [w14+412], w1
    8118:	01 04 e0    	cp0.b     w1
    811a:	05 00 32    	bra       Z, 0x8126 <.L0> <.L332>
    rtb_Ze_b = mlMidLevelCommands.rCommand;
    811c:	92 89 80    	mov.w     0x1132, w2
    811e:	a3 89 80    	mov.w     0x1134, w3
    8120:	52 af 99    	mov.w     w2, [w14+474]
    8122:	63 af 99    	mov.w     w3, [w14+476]
    8124:	22 00 37    	bra       0x816a <.L0> <.L0> <.L333>

00008126 <.L0>:
  } else {
    if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_bs > 40.0F) {
    8126:	ca f7 80    	mov.w     0x1ef8, w10
    8128:	db f7 80    	mov.w     0x1efa, w11
    812a:	02 00 20    	mov.w     #0x0, w2
    812c:	03 22 24    	mov.w     #0x4220, w3
    812e:	0a 00 be    	mov.d     w10, w0
    8130:	90 18 02    	call      0x1890 <___gesf2>
    8132:	00 00 00 
    8134:	00 00 e0    	cp0.w     w0
    8136:	08 00 3c    	bra       GT, 0x8148 <.L466>

00008138 <.L0>:
      /* Saturate: '<S135>/[0 40]' */
      rtb_Sum1_mzp = 40.0F;
    } else if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_bs < 0.0F) {
    8138:	60 11 b8    	mul.uu    w2, #0x0, w2
    813a:	0a 00 be    	mov.d     w10, w0
    813c:	8c 18 02    	call      0x188c <___eqsf2>
    813e:	00 00 00 
    8140:	00 00 e0    	cp0.w     w0
    8142:	04 00 3d    	bra       GE, 0x814c <.L0> <.L334>

00008144 <.L0>:
      /* Saturate: '<S135>/[0 40]' */
      rtb_Sum1_mzp = 0.0F;
    8144:	60 55 b8    	mul.uu    w10, #0x0, w10
    8146:	02 00 37    	bra       0x814c <.L0> <.L334>

00008148 <.L466>:
    8148:	0a 00 20    	mov.w     #0x0, w10
    814a:	0b 22 24    	mov.w     #0x4220, w11

0000814c <.L0>:
    } else {
      /* Saturate: '<S135>/[0 40]' */
      rtb_Sum1_mzp = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_bs;
    }

    rtb_Ze_b = 1.0F / rtb_Sum1_mzp * 9.80665F *
    814c:	0a 01 be    	mov.d     w10, w2
    814e:	00 00 20    	mov.w     #0x0, w0
    8150:	01 f8 23    	mov.w     #0x3f80, w1
    8152:	26 17 02    	call      0x1726 <___divsf3>
    8154:	00 00 00 
    8156:	a2 80 2e    	mov.w     #0xe80a, w2
    8158:	c3 11 24    	mov.w     #0x411c, w3
    815a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    815c:	00 00 00 
    815e:	00 01 be    	mov.d     w0, w2
    8160:	08 00 be    	mov.d     w8, w0
    8162:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8164:	00 00 00 
    8166:	50 af 99    	mov.w     w0, [w14+474]
    8168:	61 af 99    	mov.w     w1, [w14+476]

0000816a <.L0>:
      AUAV_V3_TestSensors_B.myTanapUtilscupdated5116;
  }

  /* End of Switch: '<S103>/Switch1' */

  /* Switch: '<S103>/Switch' incorporates:
   *  DataStoreRead: '<Root>/PAR_L1_OMEGA PAR_L1_M PAR_L1_GAMMA PAR_L1_ON_OFF'
   */
  if (mlParamInterface.param[25] > 0.3F) {
    816a:	a2 99 29    	mov.w     #0x999a, w2
    816c:	93 e9 23    	mov.w     #0x3e99, w3
    816e:	f0 95 80    	mov.w     0x12be, w0
    8170:	01 96 80    	mov.w     0x12c0, w1
    8172:	90 18 02    	call      0x1890 <___gesf2>
    8174:	00 00 00 
    8176:	00 00 e0    	cp0.w     w0
    8178:	03 00 34    	bra       LE, 0x8180 <.L631>

0000817a <.L0>:
    rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_B.PsiDotLimit;
    817a:	fc c6 80    	mov.w     0x18de, w12
    817c:	0d c7 80    	mov.w     0x18e0, w13
    817e:	02 00 37    	bra       0x8184 <.L0> <.L336>

00008180 <.L631>:
  } else {
    rtb_RhhcosphisinlambYe = rtb_Ze_b;
    8180:	5e ae 91    	mov.w     [w14+474], w12
    8182:	ee ae 91    	mov.w     [w14+476], w13

00008184 <.L0>:
  }

  /* End of Switch: '<S103>/Switch' */

  /* Saturate: '<S102>/Psi Dot  Limit' */
  if (rtb_RhhcosphisinlambYe > 1.0F) {
    8184:	02 00 20    	mov.w     #0x0, w2
    8186:	03 f8 23    	mov.w     #0x3f80, w3
    8188:	0c 00 be    	mov.d     w12, w0
    818a:	90 18 02    	call      0x1890 <___gesf2>
    818c:	00 00 00 
    818e:	00 00 e0    	cp0.w     w0
    8190:	08 00 3c    	bra       GT, 0x81a2 <.L0> <.L468>

00008192 <.L0>:
    rtb_RhhcosphisinlambYe = 1.0F;
  } else {
    if (rtb_RhhcosphisinlambYe < -1.0F) {
    8192:	02 00 20    	mov.w     #0x0, w2
    8194:	03 f8 2b    	mov.w     #0xbf80, w3
    8196:	0c 00 be    	mov.d     w12, w0
    8198:	8c 18 02    	call      0x188c <___eqsf2>
    819a:	00 00 00 
    819c:	00 00 e0    	cp0.w     w0
    819e:	04 00 35    	bra       LT, 0x81a8 <.L469>
    81a0:	05 00 37    	bra       0x81ac <.L0> <.L338>

000081a2 <.L0>:
    81a2:	0c 00 20    	mov.w     #0x0, w12
    81a4:	0d f8 23    	mov.w     #0x3f80, w13
    81a6:	02 00 37    	bra       0x81ac <.L0> <.L338>

000081a8 <.L469>:
      rtb_RhhcosphisinlambYe = -1.0F;
    81a8:	0c 00 20    	mov.w     #0x0, w12
    81aa:	0d f8 2b    	mov.w     #0xbf80, w13

000081ac <.L0>:
    }
  }

  /* End of Saturate: '<S102>/Psi Dot  Limit' */

  /* Outputs for Enabled SubSystem: '<S102>/Sideslip Compensation' incorporates:
   *  EnablePort: '<S109>/Enable'
   */
  /* DataStoreRead: '<Root>/PAR_NAV_L2_BASE PAR_NAV_PRETURN_K PAR_NAV_SSCOMP_ON' */
  if (mlParamInterface.param[21L] > 0.0F) {
    81ac:	60 11 b8    	mul.uu    w2, #0x0, w2
    81ae:	70 95 80    	mov.w     0x12ae, w0
    81b0:	81 95 80    	mov.w     0x12b0, w1
    81b2:	90 18 02    	call      0x1890 <___gesf2>
    81b4:	00 00 00 
    81b6:	00 00 e0    	cp0.w     w0
    81b8:	a1 00 34    	bra       LE, 0x82fc <.L632>

000081ba <.L0>:
    if (!AUAV_V3_TestSensors_DWork.SideslipCompensation_MODE) {
    81ba:	c0 00 22    	mov.w     #0x200c, w0
    81bc:	10 04 e0    	cp0.b     [w0]
    81be:	0c 00 3a    	bra       NZ, 0x81d8 <.L0> <.L341>
      /* InitializeConditions for UnitDelay: '<S126>/UD' */
      AUAV_V3_TestSensors_DWork.UD_DSTATE_f = 0.0F;
    81c0:	60 00 b8    	mul.uu    w0, #0x0, w0
    81c2:	e0 fa 88    	mov.w     w0, 0x1f5c
    81c4:	f1 fa 88    	mov.w     w1, 0x1f5e

      /* InitializeConditions for Delay: '<S118>/Integer Delay' */
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_ed = 0.0F;
    81c6:	00 fb 88    	mov.w     w0, 0x1f60
    81c8:	11 fb 88    	mov.w     w1, 0x1f62

      /* InitializeConditions for Delay: '<S118>/Integer Delay1' */
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_n = 0.0F;
    81ca:	20 fb 88    	mov.w     w0, 0x1f64
    81cc:	31 fb 88    	mov.w     w1, 0x1f66

      /* InitializeConditions for Delay: '<S119>/Integer Delay3' */
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ph = 0.0F;
    81ce:	40 fb 88    	mov.w     w0, 0x1f68
    81d0:	51 fb 88    	mov.w     w1, 0x1f6a
      AUAV_V3_TestSensors_DWork.SideslipCompensation_MODE = true;
    81d2:	11 c0 b3    	mov.b     #0x1, w1
    81d4:	c0 00 22    	mov.w     #0x200c, w0
    81d6:	01 48 78    	mov.b     w1, [w0]

000081d8 <.L0>:
    }

    /* MATLAB Function: '<S117>/negprotect' */
    AUAV_V3_TestSen_negprotect(rtb_Product3_bo,
    81d8:	c2 d4 21    	mov.w     #0x1d4c, w2
    81da:	3e b0 91    	mov.w     [w14+486], w0
    81dc:	ce b0 91    	mov.w     [w14+488], w1
    81de:	14 12 02    	call      0x11214 <_AUAV_V3_TestSen_negprotect>
    81e0:	01 00 00 

000081e2 <.L0>:
      &AUAV_V3_TestSensors_B.sf_negprotect);

    /* Saturate: '<S117>/bank Limit' */
    if (AUAV_V3_TestSensors_B.y_j[0] > 0.436332315F) {
    81e2:	38 b1 80    	mov.w     0x1626, w8
    81e4:	49 b1 80    	mov.w     0x1628, w9
    81e6:	32 6f 26    	mov.w     #0x66f3, w2
    81e8:	f3 ed 23    	mov.w     #0x3edf, w3
    81ea:	08 00 be    	mov.d     w8, w0
    81ec:	90 18 02    	call      0x1890 <___gesf2>
    81ee:	00 00 00 
    81f0:	00 00 e0    	cp0.w     w0
    81f2:	05 00 34    	bra       LE, 0x81fe <.L0> <.L633>

000081f4 <.L0>:
      AUAV_V3_TestSensors_B.bankLimit_e = 0.436332315F;
    81f4:	30 6f 26    	mov.w     #0x66f3, w0
    81f6:	f1 ed 23    	mov.w     #0x3edf, w1
    81f8:	f0 c5 88    	mov.w     w0, 0x18be
    81fa:	01 c6 88    	mov.w     w1, 0x18c0
    81fc:	0e 00 37    	bra       0x821a <.L0> <.L344>

000081fe <.L0>:
    } else if (AUAV_V3_TestSensors_B.y_j[0] < -0.436332315F) {
    81fe:	32 6f 26    	mov.w     #0x66f3, w2
    8200:	f3 ed 2b    	mov.w     #0xbedf, w3
    8202:	08 00 be    	mov.d     w8, w0
    8204:	8c 18 02    	call      0x188c <___eqsf2>
    8206:	00 00 00 
    8208:	00 00 e0    	cp0.w     w0
    820a:	05 00 3d    	bra       GE, 0x8216 <.L634>

0000820c <.L0>:
      AUAV_V3_TestSensors_B.bankLimit_e = -0.436332315F;
    820c:	30 6f 26    	mov.w     #0x66f3, w0
    820e:	f1 ed 2b    	mov.w     #0xbedf, w1
    8210:	f0 c5 88    	mov.w     w0, 0x18be
    8212:	01 c6 88    	mov.w     w1, 0x18c0
    8214:	02 00 37    	bra       0x821a <.L0> <.L344>

00008216 <.L634>:
    } else {
      AUAV_V3_TestSensors_B.bankLimit_e = AUAV_V3_TestSensors_B.y_j[0];
    8216:	f8 c5 88    	mov.w     w8, 0x18be
    8218:	09 c6 88    	mov.w     w9, 0x18c0

0000821a <.L0>:
    }

    /* End of Saturate: '<S117>/bank Limit' */

    /* S-Function (MCHP_C_function_Call): '<S121>/myTan() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_o = myTan(
    821a:	f0 c5 80    	mov.w     0x18be, w0
    821c:	01 c6 80    	mov.w     0x18c0, w1
    821e:	38 10 02    	call      0x11038 <_myTan>
    8220:	01 00 00 
    8222:	00 05 be    	mov.d     w0, w10
    8224:	10 c6 88    	mov.w     w0, 0x18c2
    8226:	21 c6 88    	mov.w     w1, 0x18c4

00008228 <.L0>:
      AUAV_V3_TestSensors_B.bankLimit_e
      );

    /* InitialCondition: '<S118>/IC' */
    if (AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_b) {
    8228:	70 00 22    	mov.w     #0x2007, w0
    822a:	10 04 e0    	cp0.b     [w0]
    822c:	02 00 32    	bra       Z, 0x8232 <.L0> <.L347>
      AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_b = false;
    822e:	00 48 eb    	clr.b     [w0]
    8230:	15 00 37    	bra       0x825c <.L0> <.L425>

00008232 <.L0>:
      rtb_Sum1_mzp = 1.0F;
    } else {
      /* Abs: '<S125>/Abs1' incorporates:
       *  Constant: '<S109>/Constant'
       *  Sum: '<S126>/Diff'
       *  UnitDelay: '<S126>/UD'
       */
      rtb_Sum1_mzp = (real32_T)fabs(0.3F - AUAV_V3_TestSensors_DWork.UD_DSTATE_f);
    8232:	e2 fa 80    	mov.w     0x1f5c, w2
    8234:	f3 fa 80    	mov.w     0x1f5e, w3
    8236:	a0 99 29    	mov.w     #0x999a, w0
    8238:	91 e9 23    	mov.w     #0x3e99, w1
    823a:	90 14 02    	call      0x1490 <___subsf3>
    823c:	00 00 00 
    823e:	00 04 be    	mov.d     w0, w8
    8240:	09 f0 a1    	bclr.w    w9, #0xf

00008242 <.L0>:

      /* Saturate: '<S125>/Saturation1' */
      if (rtb_Sum1_mzp > 1.0F) {
    8242:	02 00 20    	mov.w     #0x0, w2
    8244:	03 f8 23    	mov.w     #0x3f80, w3
    8246:	08 00 be    	mov.d     w8, w0
    8248:	90 18 02    	call      0x1890 <___gesf2>
    824a:	00 00 00 
    824c:	00 00 e0    	cp0.w     w0
    824e:	06 00 3c    	bra       GT, 0x825c <.L0> <.L425>

00008250 <.L0>:
        rtb_Sum1_mzp = 1.0F;
      }

      /* End of Saturate: '<S125>/Saturation1' */
    }

    /* End of InitialCondition: '<S118>/IC' */

    /* Outputs for Enabled SubSystem: '<S118>/Compute Coef' incorporates:
     *  EnablePort: '<S124>/Enable'
     */
    if (rtb_Sum1_mzp > 0.0F) {
    8250:	60 11 b8    	mul.uu    w2, #0x0, w2
    8252:	08 00 be    	mov.d     w8, w0
    8254:	90 18 02    	call      0x1890 <___gesf2>
    8256:	00 00 00 
    8258:	00 00 e0    	cp0.w     w0
    825a:	08 00 34    	bra       LE, 0x826c <.L0> <.L349>

0000825c <.L0>:
      /* Math: '<S124>/Math Function' incorporates:
       *  Constant: '<S109>/Constant'
       *  Gain: '<S124>/-T'
       *
       * About '<S124>/Math Function':
       *  Operator: exp
       */
      AUAV_V3_TestSensors_B.c = 0.997004509F;
    825c:	00 bb 23    	mov.w     #0x3bb0, w0
    825e:	f1 f7 23    	mov.w     #0x3f7f, w1
    8260:	90 c6 88    	mov.w     w0, 0x18d2
    8262:	a1 c6 88    	mov.w     w1, 0x18d4

      /* Sum: '<S124>/1-c' incorporates:
       *  Constant: '<S124>/Constant'
       */
      AUAV_V3_TestSensors_B.c_b = (real32_T)(1.0 - AUAV_V3_TestSensors_B.c);
    8264:	00 00 25    	mov.w     #0x5000, w0
    8266:	41 b4 23    	mov.w     #0x3b44, w1
    8268:	b0 c6 88    	mov.w     w0, 0x18d6
    826a:	c1 c6 88    	mov.w     w1, 0x18d8

0000826c <.L0>:
    }

    /* End of Outputs for SubSystem: '<S118>/Compute Coef' */

    /* Sum: '<S118>/Subtract' incorporates:
     *  Delay: '<S118>/Integer Delay'
     *  Delay: '<S118>/Integer Delay1'
     *  Product: '<S118>/Divide'
     *  Product: '<S118>/Divide1'
     */
    AUAV_V3_TestSensors_B.Subtract = AUAV_V3_TestSensors_B.c_b *
    826c:	02 fb 80    	mov.w     0x1f60, w2
    826e:	13 fb 80    	mov.w     0x1f62, w3
    8270:	b0 c6 80    	mov.w     0x18d6, w0
    8272:	c1 c6 80    	mov.w     0x18d8, w1
    8274:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8276:	00 00 00 
    8278:	00 04 be    	mov.d     w0, w8

0000827a <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_ed + AUAV_V3_TestSensors_B.c
      * AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_n;
    827a:	22 fb 80    	mov.w     0x1f64, w2
    827c:	33 fb 80    	mov.w     0x1f66, w3
    827e:	90 c6 80    	mov.w     0x18d2, w0
    8280:	a1 c6 80    	mov.w     0x18d4, w1
    8282:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8284:	00 00 00 
    8286:	00 01 be    	mov.d     w0, w2

00008288 <.L0>:
    8288:	08 00 be    	mov.d     w8, w0
    828a:	92 14 02    	call      0x1492 <___addsf3>
    828c:	00 00 00 

0000828e <.L0>:
    828e:	30 c6 88    	mov.w     w0, 0x18c6
    8290:	41 c6 88    	mov.w     w1, 0x18c8

00008292 <.L0>:

    /* Product: '<S120>/Divide' incorporates:
     *  Constant: '<S117>/Constant1'
     *  Constant: '<S120>/Constant1'
     *  Product: '<S117>/Divide'
     *  Product: '<S117>/Divide1'
     *  Sum: '<S109>/Subtract'
     */
    AUAV_V3_TestSensors_B.Divide_h = (1.0F /
    8292:	62 ea 80    	mov.w     0x1d4c, w2
    8294:	73 ea 80    	mov.w     0x1d4e, w3
    8296:	00 00 20    	mov.w     #0x0, w0
    8298:	01 f8 23    	mov.w     #0x3f80, w1
    829a:	26 17 02    	call      0x1726 <___divsf3>
    829c:	00 00 00 

0000829e <.L0>:
      AUAV_V3_TestSensors_B.sf_negprotect.zpVal * 9.80665F *
    829e:	a2 80 2e    	mov.w     #0xe80a, w2
    82a0:	c3 11 24    	mov.w     #0x411c, w3
    82a2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    82a4:	00 00 00 
    82a6:	00 01 be    	mov.d     w0, w2
    82a8:	0a 00 be    	mov.d     w10, w0
    82aa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    82ac:	00 00 00 

000082ae <.L0>:
      AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_o -
    82ae:	d2 b1 80    	mov.w     0x163a, w2
    82b0:	e3 b1 80    	mov.w     0x163c, w3
    82b2:	90 14 02    	call      0x1490 <___subsf3>
    82b4:	00 00 00 

000082b6 <.L0>:
      AUAV_V3_TestSensors_B.y_j[5]) * rtb_Product3_bo / 9.80665F;
    82b6:	3e b1 91    	mov.w     [w14+486], w2
    82b8:	ce b1 91    	mov.w     [w14+488], w3
    82ba:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    82bc:	00 00 00 
    82be:	a2 80 2e    	mov.w     #0xe80a, w2
    82c0:	c3 11 24    	mov.w     #0x411c, w3
    82c2:	26 17 02    	call      0x1726 <___divsf3>
    82c4:	00 00 00 

000082c6 <.L0>:
    82c6:	50 c6 88    	mov.w     w0, 0x18ca
    82c8:	61 c6 88    	mov.w     w1, 0x18cc

000082ca <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S127>/myTan() apUtils.c [updated 5.1.16]' */
    AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_i = myTan(
    82ca:	38 10 02    	call      0x11038 <_myTan>
    82cc:	01 00 00 
    82ce:	00 04 be    	mov.d     w0, w8
    82d0:	70 c6 88    	mov.w     w0, 0x18ce
    82d2:	81 c6 88    	mov.w     w1, 0x18d0

000082d4 <.L0>:
      AUAV_V3_TestSensors_B.Divide_h
      );

    /* Switch: '<S119>/Switch3' incorporates:
     *  RelationalOperator: '<S119>/Relational Operator2'
     */
    if ((AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_i ==
    82d4:	00 01 be    	mov.d     w0, w2
    82d6:	8c 18 02    	call      0x188c <___eqsf2>
    82d8:	00 00 00 
    82da:	00 00 e0    	cp0.w     w0
    82dc:	02 00 3a    	bra       NZ, 0x82e2 <.L351>

000082de <.L0>:
         AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_i) > 0) {
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ph =
    82de:	48 fb 88    	mov.w     w8, 0x1f68
    82e0:	59 fb 88    	mov.w     w9, 0x1f6a

000082e2 <.L351>:
        AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_i;
    }

    /* End of Switch: '<S119>/Switch3' */

    /* Update for UnitDelay: '<S126>/UD' incorporates:
     *  Constant: '<S109>/Constant'
     */
    AUAV_V3_TestSensors_DWork.UD_DSTATE_f = 0.3F;
    82e2:	a0 99 29    	mov.w     #0x999a, w0
    82e4:	91 e9 23    	mov.w     #0x3e99, w1
    82e6:	e0 fa 88    	mov.w     w0, 0x1f5c
    82e8:	f1 fa 88    	mov.w     w1, 0x1f5e

    /* Update for Delay: '<S118>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_ed =
    82ea:	40 fb 80    	mov.w     0x1f68, w0
    82ec:	51 fb 80    	mov.w     0x1f6a, w1
    82ee:	00 fb 88    	mov.w     w0, 0x1f60
    82f0:	11 fb 88    	mov.w     w1, 0x1f62
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ph;

    /* Update for Delay: '<S118>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_n =
    82f2:	32 c6 80    	mov.w     0x18c6, w2
    82f4:	43 c6 80    	mov.w     0x18c8, w3
    82f6:	22 fb 88    	mov.w     w2, 0x1f64
    82f8:	33 fb 88    	mov.w     w3, 0x1f66
    82fa:	08 00 37    	bra       0x830c <.L0> <.L353>

000082fc <.L632>:
      AUAV_V3_TestSensors_B.Subtract;
  } else {
    if (AUAV_V3_TestSensors_DWork.SideslipCompensation_MODE) {
    82fc:	c0 00 22    	mov.w     #0x200c, w0
    82fe:	10 04 e0    	cp0.b     [w0]
    8300:	05 00 32    	bra       Z, 0x830c <.L0> <.L353>
      /* Disable for Outport: '<S109>/bankComp' */
      AUAV_V3_TestSensors_B.Subtract = 0.0F;
    8302:	60 00 b8    	mul.uu    w0, #0x0, w0
    8304:	30 c6 88    	mov.w     w0, 0x18c6
    8306:	41 c6 88    	mov.w     w1, 0x18c8
      AUAV_V3_TestSensors_DWork.SideslipCompensation_MODE = false;
    8308:	c0 00 22    	mov.w     #0x200c, w0
    830a:	00 48 eb    	clr.b     [w0]

0000830c <.L0>:
    }
  }

  /* End of Outputs for SubSystem: '<S102>/Sideslip Compensation' */

  /* Product: '<S111>/Divide' incorporates:
   *  Constant: '<S111>/Constant1'
   */
  AUAV_V3_TestSensors_B.Divide = rtb_RhhcosphisinlambYe * rtb_Product3_bo /
    830c:	3e b1 91    	mov.w     [w14+486], w2
    830e:	ce b1 91    	mov.w     [w14+488], w3
    8310:	0c 00 be    	mov.d     w12, w0
    8312:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8314:	00 00 00 
    8316:	a2 80 2e    	mov.w     #0xe80a, w2
    8318:	c3 11 24    	mov.w     #0x411c, w3
    831a:	26 17 02    	call      0x1726 <___divsf3>
    831c:	00 00 00 
    831e:	b0 c5 88    	mov.w     w0, 0x18b6
    8320:	c1 c5 88    	mov.w     w1, 0x18b8

00008322 <.L0>:
    9.80665F;

  /* S-Function (MCHP_C_function_Call): '<S133>/myTan() apUtils.c [updated 5.1.16]' */
  AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_b = myTan(
    8322:	38 10 02    	call      0x11038 <_myTan>
    8324:	01 00 00 
    8326:	d0 c5 88    	mov.w     w0, 0x18ba
    8328:	e1 c5 88    	mov.w     w1, 0x18bc

0000832a <.L0>:
    AUAV_V3_TestSensors_B.Divide
    );

  /* Sum: '<S102>/Add2' */
  rtb_Deg2R1 = AUAV_V3_TestSensors_B.Subtract +
    832a:	32 c6 80    	mov.w     0x18c6, w2
    832c:	43 c6 80    	mov.w     0x18c8, w3
    832e:	92 14 02    	call      0x1492 <___addsf3>
    8330:	00 00 00 
    8332:	00 05 be    	mov.d     w0, w10

00008334 <.L0>:
    AUAV_V3_TestSensors_B.myTanapUtilscupdated5116_b;

  /* Saturate: '<S102>/Bank  Limit Command' */
  if (rtb_Deg2R1 > 0.436332315F) {
    8334:	32 6f 26    	mov.w     #0x66f3, w2
    8336:	f3 ed 23    	mov.w     #0x3edf, w3
    8338:	90 18 02    	call      0x1890 <___gesf2>
    833a:	00 00 00 
    833c:	00 00 e0    	cp0.w     w0
    833e:	08 00 3c    	bra       GT, 0x8350 <.L0> <.L470>

00008340 <.L0>:
    rtb_Deg2R1 = 0.436332315F;
  } else {
    if (rtb_Deg2R1 < -0.436332315F) {
    8340:	32 6f 26    	mov.w     #0x66f3, w2
    8342:	f3 ed 2b    	mov.w     #0xbedf, w3
    8344:	0a 00 be    	mov.d     w10, w0
    8346:	8c 18 02    	call      0x188c <___eqsf2>
    8348:	00 00 00 
    834a:	00 00 e0    	cp0.w     w0
    834c:	04 00 35    	bra       LT, 0x8356 <.L471>
    834e:	05 00 37    	bra       0x835a <.L0> <.L354>

00008350 <.L0>:
    8350:	3a 6f 26    	mov.w     #0x66f3, w10
    8352:	fb ed 23    	mov.w     #0x3edf, w11
    8354:	02 00 37    	bra       0x835a <.L0> <.L354>

00008356 <.L471>:
      rtb_Deg2R1 = -0.436332315F;
    8356:	3a 6f 26    	mov.w     #0x66f3, w10
    8358:	fb ed 2b    	mov.w     #0xbedf, w11

0000835a <.L0>:
    }
  }

  /* End of Saturate: '<S102>/Bank  Limit Command' */

  /* Switch: '<S107>/Switch3' incorporates:
   *  RelationalOperator: '<S107>/Relational Operator2'
   */
  if ((rtb_Product3_j0[1] == rtb_Product3_j0[1]) > 0) {
    835a:	2e 04 90    	mov.w     [w14+4], w8
    835c:	be 04 90    	mov.w     [w14+6], w9
    835e:	08 01 be    	mov.d     w8, w2
    8360:	08 00 be    	mov.d     w8, w0
    8362:	8c 18 02    	call      0x188c <___eqsf2>
    8364:	00 00 00 
    8366:	00 00 e0    	cp0.w     w0
    8368:	02 00 3a    	bra       NZ, 0x836e <.L0> <.L355>

0000836a <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_oy = rtb_Product3_j0[1];
    836a:	e8 f7 88    	mov.w     w8, 0x1efc
    836c:	f9 f7 88    	mov.w     w9, 0x1efe

0000836e <.L0>:
  }

  /* End of Switch: '<S107>/Switch3' */

  /* Saturate: '<S102>/[-20 20]' */
  if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_oy > 20.0F) {
    836e:	e8 f7 80    	mov.w     0x1efc, w8
    8370:	f9 f7 80    	mov.w     0x1efe, w9
    8372:	02 00 20    	mov.w     #0x0, w2
    8374:	03 1a 24    	mov.w     #0x41a0, w3
    8376:	08 00 be    	mov.d     w8, w0
    8378:	90 18 02    	call      0x1890 <___gesf2>
    837a:	00 00 00 
    837c:	00 00 e0    	cp0.w     w0
    837e:	0a 00 3c    	bra       GT, 0x8394 <.L472>

00008380 <.L0>:
    rtb_Sum1_mzp = 20.0F;
  } else if (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_oy < -20.0F) {
    8380:	02 00 20    	mov.w     #0x0, w2
    8382:	03 1a 2c    	mov.w     #0xc1a0, w3
    8384:	08 00 be    	mov.d     w8, w0
    8386:	8c 18 02    	call      0x188c <___eqsf2>
    8388:	00 00 00 
    838a:	00 00 e0    	cp0.w     w0
    838c:	05 00 3d    	bra       GE, 0x8398 <.L0> <.L357>

0000838e <.L0>:
    rtb_Sum1_mzp = -20.0F;
    838e:	08 00 20    	mov.w     #0x0, w8
    8390:	09 1a 2c    	mov.w     #0xc1a0, w9
    8392:	02 00 37    	bra       0x8398 <.L0> <.L357>

00008394 <.L472>:
    8394:	08 00 20    	mov.w     #0x0, w8
    8396:	09 1a 24    	mov.w     #0x41a0, w9

00008398 <.L0>:
  } else {
    rtb_Sum1_mzp = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_oy;
  }

  /* MATLAB Function: '<S104>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S104>/Constant'
   *  Constant: '<S104>/Constant1'
   *  Saturate: '<S102>/[-20 20]'
   */
  AUA_EmbeddedMATLABFunction(rtb_Sum1_mzp, 0.01, 10.0,
    8398:	47 1c 22    	mov.w     #0x21c4, w7
    839a:	06 d5 21    	mov.w     #0x1d50, w6
    839c:	04 00 20    	mov.w     #0x0, w4
    839e:	05 12 24    	mov.w     #0x4120, w5
    83a0:	a2 70 2d    	mov.w     #0xd70a, w2
    83a2:	33 c2 23    	mov.w     #0x3c23, w3
    83a4:	08 00 be    	mov.d     w8, w0
    83a6:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    83a8:	01 00 00 

000083aa <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_b0);

  /* DataStoreWrite: '<S70>/mlNavigation' incorporates:
   *  Gain: '<S102>/Neg Feedback '
   */
  mlNavigation.psiDot_c = rtb_RhhcosphisinlambYe;
    83aa:	3c 92 88    	mov.w     w12, 0x1246
    83ac:	4d 92 88    	mov.w     w13, 0x1248
  mlNavigation.phi_c = rtb_Deg2R1;
    83ae:	fa 91 88    	mov.w     w10, 0x123e
    83b0:	0b 92 88    	mov.w     w11, 0x1240
  mlNavigation.ay_body = -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y;
    83b2:	80 ea 80    	mov.w     0x1d50, w0
    83b4:	91 ea 80    	mov.w     0x1d52, w1
    83b6:	00 02 be    	mov.d     w0, w4
    83b8:	05 f0 a2    	btg.w     w5, #0xf
    83ba:	34 b7 99    	mov.w     w4, [w14+486]
    83bc:	45 b7 99    	mov.w     w5, [w14+488]
    83be:	54 92 88    	mov.w     w4, 0x124a
    83c0:	65 92 88    	mov.w     w5, 0x124c

  /* Sum: '<S110>/Add3' incorporates:
   *  Constant: '<S110>/SaturationLimit'
   */
  rtb_RhhcosphicoslambXe = 0.17453292F -
    AUAV_V3_TestSensors_B.DataTypeConversion_g;
    83c2:	3c b2 80    	mov.w     0x1646, w12
    83c4:	4d b2 80    	mov.w     0x1648, w13

000083c6 <.L0>:
    83c6:	0c 01 be    	mov.d     w12, w2
    83c8:	20 8c 2b    	mov.w     #0xb8c2, w0
    83ca:	21 e3 23    	mov.w     #0x3e32, w1
    83cc:	90 14 02    	call      0x1490 <___subsf3>
    83ce:	00 00 00 
    83d0:	00 04 be    	mov.d     w0, w8

000083d2 <.L0>:

  /* Sum: '<S110>/Add1' incorporates:
   *  Constant: '<S110>/delayTime'
   *  DataStoreRead: '<S10>/PAR_PID_YAW_DAMP_P PAR_PID_YAW_DAMP_I PAR_PID_YAW_DAMP_D'
   *  Delay: '<S110>/NDelays'
   *  Gain: '<S102>/Neg Feedback '
   *  Product: '<S110>/Product1'
   *  Product: '<S110>/Product2'
   *  Product: '<S110>/Product3'
   *  Sum: '<S110>/Sum'
   */
  rtb_Sum1_mzp = (-AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y -
    83d2:	02 f8 80    	mov.w     0x1f00, w2
    83d4:	13 f8 80    	mov.w     0x1f02, w3
    83d6:	3e b0 91    	mov.w     [w14+486], w0
    83d8:	ce b0 91    	mov.w     [w14+488], w1
    83da:	90 14 02    	call      0x1490 <___subsf3>
    83dc:	00 00 00 

000083de <.L0>:
                  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[0]) / 0.05F *
    83de:	d2 cc 2c    	mov.w     #0xcccd, w2
    83e0:	c3 d4 23    	mov.w     #0x3d4c, w3
    83e2:	26 17 02    	call      0x1726 <___divsf3>
    83e4:	00 00 00 
    83e6:	92 94 80    	mov.w     0x1292, w2
    83e8:	a3 94 80    	mov.w     0x1294, w3
    83ea:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    83ec:	00 00 00 
    83ee:	50 b7 99    	mov.w     w0, [w14+490]
    83f0:	61 b7 99    	mov.w     w1, [w14+492]

000083f2 <.L0>:
    mlParamInterface.param[14] +
    -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y *
    83f2:	52 94 80    	mov.w     0x128a, w2
    83f4:	63 94 80    	mov.w     0x128c, w3
    83f6:	3e b0 91    	mov.w     [w14+486], w0
    83f8:	ce b0 91    	mov.w     [w14+488], w1
    83fa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    83fc:	00 00 00 
    83fe:	00 01 be    	mov.d     w0, w2

00008400 <.L0>:
    8400:	5e b0 91    	mov.w     [w14+490], w0
    8402:	ee b0 91    	mov.w     [w14+492], w1
    8404:	92 14 02    	call      0x1492 <___addsf3>
    8406:	00 00 00 
    8408:	30 a7 99    	mov.w     w0, [w14+454]
    840a:	41 a7 99    	mov.w     w1, [w14+456]

0000840c <.L0>:
    mlParamInterface.param[12];

  /* Sum: '<S110>/Sum2' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_YAW_DAMP_P PAR_PID_YAW_DAMP_I PAR_PID_YAW_DAMP_D'
   *  Gain: '<S102>/Neg Feedback '
   *  Gain: '<S110>/Gain'
   *  Memory: '<S110>/Memory1'
   *  Product: '<S110>/Product4'
   */
  rtb_RhhcosphisinlambYe = (0.01F *
    -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y *
    mlParamInterface.param[13] +
    840c:	70 94 80    	mov.w     0x128e, w0
    840e:	81 94 80    	mov.w     0x1290, w1
    8410:	10 b7 99    	mov.w     w0, [w14+482]
    8412:	21 b7 99    	mov.w     w1, [w14+484]

00008414 <.L0>:
    8414:	a2 70 2d    	mov.w     #0xd70a, w2
    8416:	33 c2 23    	mov.w     #0x3c23, w3
    8418:	3e b0 91    	mov.w     [w14+486], w0
    841a:	ce b0 91    	mov.w     [w14+488], w1
    841c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    841e:	00 00 00 

00008420 <.L0>:
    8420:	1e b1 91    	mov.w     [w14+482], w2
    8422:	ae b1 91    	mov.w     [w14+484], w3
    8424:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8426:	00 00 00 

00008428 <.L0>:
    8428:	42 ff 80    	mov.w     0x1fe8, w2
    842a:	53 ff 80    	mov.w     0x1fea, w3
    842c:	92 14 02    	call      0x1492 <___addsf3>
    842e:	00 00 00 

00008430 <.L0>:
    8430:	3e a1 91    	mov.w     [w14+454], w2
    8432:	ce a1 91    	mov.w     [w14+456], w3
    8434:	92 14 02    	call      0x1492 <___addsf3>
    8436:	00 00 00 
    8438:	50 b7 99    	mov.w     w0, [w14+490]
    843a:	61 b7 99    	mov.w     w1, [w14+492]

0000843c <.L0>:
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g) + rtb_Sum1_mzp;

  /* Switch: '<S110>/AntiWindup' incorporates:
   *  Constant: '<S110>/Constant5'
   *  Constant: '<S110>/SaturationLimit'
   *  Constant: '<S110>/SaturationLimit1'
   *  Gain: '<S102>/Neg Feedback '
   *  Logic: '<S110>/Logical Operator'
   *  RelationalOperator: '<S110>/Relational Operator'
   *  RelationalOperator: '<S110>/Relational Operator1'
   *  Sum: '<S110>/Add3'
   *  Sum: '<S110>/Add4'
   */
  if ((rtb_RhhcosphisinlambYe > -0.17453292F -
    843c:	0c 01 be    	mov.d     w12, w2
    843e:	20 8c 2b    	mov.w     #0xb8c2, w0
    8440:	21 e3 2b    	mov.w     #0xbe32, w1
    8442:	90 14 02    	call      0x1490 <___subsf3>
    8444:	00 00 00 
    8446:	70 a7 99    	mov.w     w0, [w14+462]
    8448:	01 af 99    	mov.w     w1, [w14+464]
    844a:	5e b1 91    	mov.w     [w14+490], w2
    844c:	ee b1 91    	mov.w     [w14+492], w3
    844e:	8c 18 02    	call      0x188c <___eqsf2>
    8450:	00 00 00 
    8452:	00 00 e0    	cp0.w     w0
    8454:	11 00 3d    	bra       GE, 0x8478 <.L635>

00008456 <.L0>:
       AUAV_V3_TestSensors_B.DataTypeConversion_g) && (rtb_RhhcosphisinlambYe <
    8456:	5e b1 91    	mov.w     [w14+490], w2
    8458:	ee b1 91    	mov.w     [w14+492], w3
    845a:	08 00 be    	mov.d     w8, w0
    845c:	90 18 02    	call      0x1890 <___gesf2>
    845e:	00 00 00 
    8460:	00 00 e0    	cp0.w     w0
    8462:	0c 00 34    	bra       LE, 0x847c <.L636>

00008464 <.L0>:
       0.17453292F - AUAV_V3_TestSensors_B.DataTypeConversion_g)) {
    rtb_RhhcosphisinlambYe =
      -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y;
  } else {
    rtb_RhhcosphisinlambYe = 0.0F;
  }

  /* End of Switch: '<S110>/AntiWindup' */

  /* Switch: '<S131>/Switch3' incorporates:
   *  RelationalOperator: '<S131>/Relational Operator2'
   */
  if ((rtb_RhhcosphisinlambYe == rtb_RhhcosphisinlambYe) > 0) {
    8464:	3e b1 91    	mov.w     [w14+486], w2
    8466:	ce b1 91    	mov.w     [w14+488], w3
    8468:	02 00 be    	mov.d     w2, w0
    846a:	8c 18 02    	call      0x188c <___eqsf2>
    846c:	00 00 00 
    846e:	00 00 e0    	cp0.w     w0
    8470:	08 00 3a    	bra       NZ, 0x8482 <.L362>

00008472 <.L0>:
    8472:	3e b0 91    	mov.w     [w14+486], w0
    8474:	ce b0 91    	mov.w     [w14+488], w1
    8476:	03 00 37    	bra       0x847e <.L359>

00008478 <.L635>:
    8478:	60 00 b8    	mul.uu    w0, #0x0, w0
    847a:	01 00 37    	bra       0x847e <.L359>

0000847c <.L636>:
    847c:	60 00 b8    	mul.uu    w0, #0x0, w0

0000847e <.L359>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_n = rtb_RhhcosphisinlambYe;
    847e:	c0 f8 88    	mov.w     w0, 0x1f18
    8480:	d1 f8 88    	mov.w     w1, 0x1f1a

00008482 <.L362>:
  }

  /* End of Switch: '<S131>/Switch3' */

  /* Switch: '<S130>/Switch1' incorporates:
   *  Constant: '<S130>/Constant'
   *  Constant: '<S130>/Constant1'
   *  Constant: '<S130>/Constant2'
   *  Constant: '<S130>/Constant3'
   *  Constant: '<S130>/Constant5'
   *  Delay: '<S130>/Integer Delay'
   *  Delay: '<S130>/Integer Delay1'
   *  Delay: '<S130>/Integer Delay2'
   *  Product: '<S130>/Product'
   *  Product: '<S130>/Product1'
   *  Product: '<S130>/Product2'
   *  Product: '<S130>/Product3'
   *  Sum: '<S130>/Subtract'
   *  Sum: '<S130>/Subtract1'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    8482:	e0 a1 21    	mov.w     #0x1a1e, w0
    8484:	10 40 78    	mov.b     [w0], w0
    8486:	20 ef 9b    	mov.b     w0, [w14+490]
    rtb_cosphi = 0.0F;
    8488:	60 00 b8    	mul.uu    w0, #0x0, w0
    848a:	30 af 99    	mov.w     w0, [w14+470]
    848c:	41 af 99    	mov.w     w1, [w14+472]
    848e:	ae e8 93    	mov.b     [w14+490], w1
    8490:	01 04 e0    	cp0.b     w1
    8492:	2f 00 3a    	bra       NZ, 0x84f2 <.L364>

00008494 <.L0>:
  } else {
    rtb_cosphi = ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_n *
    8494:	b2 aa 2a    	mov.w     #0xaaab, w2
    8496:	a3 ea 23    	mov.w     #0x3eaa, w3
    8498:	c0 f8 80    	mov.w     0x1f18, w0
    849a:	d1 f8 80    	mov.w     0x1f1a, w1
    849c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    849e:	00 00 00 
    84a0:	30 af 99    	mov.w     w0, [w14+470]
    84a2:	41 af 99    	mov.w     w1, [w14+472]

000084a4 <.L0>:
                   0.333333343F +
                   AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_o * 1.33333337F)
    84a4:	b2 aa 2a    	mov.w     #0xaaab, w2
    84a6:	a3 fa 23    	mov.w     #0x3faa, w3
    84a8:	e0 f8 80    	mov.w     0x1f1c, w0
    84aa:	f1 f8 80    	mov.w     0x1f1e, w1
    84ac:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    84ae:	00 00 00 
    84b0:	00 01 be    	mov.d     w0, w2

000084b2 <.L0>:
    84b2:	3e a8 91    	mov.w     [w14+470], w0
    84b4:	ce a8 91    	mov.w     [w14+472], w1
    84b6:	92 14 02    	call      0x1492 <___addsf3>
    84b8:	00 00 00 
    84ba:	30 af 99    	mov.w     w0, [w14+470]
    84bc:	41 af 99    	mov.w     w1, [w14+472]

000084be <.L0>:
                  + AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l[0] *
    84be:	b2 aa 2a    	mov.w     #0xaaab, w2
    84c0:	a3 ea 23    	mov.w     #0x3eaa, w3
    84c2:	00 f9 80    	mov.w     0x1f20, w0
    84c4:	11 f9 80    	mov.w     0x1f22, w1
    84c6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    84c8:	00 00 00 
    84ca:	00 01 be    	mov.d     w0, w2
    84cc:	3e a8 91    	mov.w     [w14+470], w0
    84ce:	ce a8 91    	mov.w     [w14+472], w1
    84d0:	92 14 02    	call      0x1492 <___addsf3>
    84d2:	00 00 00 

000084d4 <.L0>:
                  0.333333343F) * 0.005F +
    84d4:	a2 70 2d    	mov.w     #0xd70a, w2
    84d6:	33 ba 23    	mov.w     #0x3ba3, w3
    84d8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    84da:	00 00 00 

000084dc <.L0>:
    84dc:	a2 f8 80    	mov.w     0x1f14, w2
    84de:	b3 f8 80    	mov.w     0x1f16, w3
    84e0:	92 14 02    	call      0x1492 <___addsf3>
    84e2:	00 00 00 
    84e4:	00 01 be    	mov.d     w0, w2
    84e6:	30 af 99    	mov.w     w0, [w14+470]
    84e8:	41 af 99    	mov.w     w1, [w14+472]

000084ea <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_bj;
  }

  /* End of Switch: '<S130>/Switch1' */

  /* Switch: '<S132>/Switch3' incorporates:
   *  RelationalOperator: '<S132>/Relational Operator2'
   */
  if ((rtb_cosphi == rtb_cosphi) > 0) {
    84ea:	8c 18 02    	call      0x188c <___eqsf2>
    84ec:	00 00 00 
    84ee:	00 00 e0    	cp0.w     w0
    84f0:	0b 00 3a    	bra       NZ, 0x8508 <.L0> <.L365>

000084f2 <.L364>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_f = rtb_cosphi;
    84f2:	3e aa 91    	mov.w     [w14+470], w4
    84f4:	ce aa 91    	mov.w     [w14+472], w5
    84f6:	44 f9 88    	mov.w     w4, 0x1f28
    84f8:	55 f9 88    	mov.w     w5, 0x1f2a
  }

  /* End of Switch: '<S132>/Switch3' */

  /* Switch: '<S110>/On//Off' incorporates:
   *  Constant: '<S110>/Constant1'
   *  DataStoreRead: '<S10>/PAR_PID_YAW_DAMP_P PAR_PID_YAW_DAMP_I PAR_PID_YAW_DAMP_D'
   *  Product: '<S110>/Product'
   *  Sum: '<S110>/Add2'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    84fa:	ae ea 93    	mov.b     [w14+490], w5
    84fc:	05 04 e0    	cp0.b     w5
    84fe:	04 00 32    	bra       Z, 0x8508 <.L0> <.L365>
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g = 0.0F;
    8500:	60 00 b8    	mul.uu    w0, #0x0, w0
    8502:	40 ff 88    	mov.w     w0, 0x1fe8
    8504:	51 ff 88    	mov.w     w1, 0x1fea
    8506:	0c 00 37    	bra       0x8520 <.L0> <.L367>

00008508 <.L0>:
  } else {
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g =
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_f * mlParamInterface.param
    8508:	42 f9 80    	mov.w     0x1f28, w2
    850a:	53 f9 80    	mov.w     0x1f2a, w3
    850c:	1e b0 91    	mov.w     [w14+482], w0
    850e:	ae b0 91    	mov.w     [w14+484], w1
    8510:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8512:	00 00 00 

00008514 <.L0>:
      [13] + rtb_Sum1_mzp;
    8514:	3e a1 91    	mov.w     [w14+454], w2
    8516:	ce a1 91    	mov.w     [w14+456], w3
    8518:	92 14 02    	call      0x1492 <___addsf3>
    851a:	00 00 00 

0000851c <.L0>:
    851c:	40 ff 88    	mov.w     w0, 0x1fe8
    851e:	51 ff 88    	mov.w     w1, 0x1fea

00008520 <.L0>:
  }

  /* End of Switch: '<S110>/On//Off' */

  /* Switch: '<S129>/Switch2' incorporates:
   *  Constant: '<S110>/SaturationLimit'
   *  RelationalOperator: '<S129>/LowerRelop1'
   *  Sum: '<S110>/Add3'
   */
  if (!(AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g > 0.17453292F -
    8520:	40 ff 80    	mov.w     0x1fe8, w0
    8522:	51 ff 80    	mov.w     0x1fea, w1
    8524:	30 af 99    	mov.w     w0, [w14+470]
    8526:	41 af 99    	mov.w     w1, [w14+472]
    8528:	11 c0 b3    	mov.b     #0x1, w1
    852a:	21 e7 9b    	mov.b     w1, [w14+482]
    852c:	3e a9 91    	mov.w     [w14+470], w2
    852e:	ce a9 91    	mov.w     [w14+472], w3
    8530:	08 00 be    	mov.d     w8, w0
    8532:	8c 18 02    	call      0x188c <___eqsf2>
    8534:	00 00 00 
    8536:	00 00 e0    	cp0.w     w0
    8538:	02 00 35    	bra       LT, 0x853e <.L369>
    853a:	00 41 eb    	clr.b     w2
    853c:	22 e7 9b    	mov.b     w2, [w14+482]

0000853e <.L369>:
    853e:	ae e1 93    	mov.b     [w14+482], w3
    8540:	03 04 e0    	cp0.b     w3
    8542:	0d 00 3a    	bra       NZ, 0x855e <.L0> <.L368>

00008544 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_g)) {
    /* Switch: '<S129>/Switch' incorporates:
     *  Constant: '<S110>/SaturationLimit1'
     *  RelationalOperator: '<S129>/UpperRelop'
     *  Sum: '<S110>/Add4'
     */
    if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g < -0.17453292F -
    8544:	3e a9 91    	mov.w     [w14+470], w2
    8546:	ce a9 91    	mov.w     [w14+472], w3
    8548:	7e a0 91    	mov.w     [w14+462], w0
    854a:	8e a8 91    	mov.w     [w14+464], w1
    854c:	90 18 02    	call      0x1890 <___gesf2>
    854e:	00 00 00 
    8550:	00 00 e0    	cp0.w     w0
    8552:	03 00 34    	bra       LE, 0x855a <.L637>

00008554 <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_g) {
      rtb_RhhcosphicoslambXe = -0.17453292F -
    8554:	7e a4 91    	mov.w     [w14+462], w8
    8556:	8e ac 91    	mov.w     [w14+464], w9
    8558:	02 00 37    	bra       0x855e <.L0> <.L368>

0000855a <.L637>:
        AUAV_V3_TestSensors_B.DataTypeConversion_g;
    } else {
      rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_g;
    855a:	3e ac 91    	mov.w     [w14+470], w8
    855c:	ce ac 91    	mov.w     [w14+472], w9

0000855e <.L0>:
    }

    /* End of Switch: '<S129>/Switch' */
  }

  /* End of Switch: '<S129>/Switch2' */

  /* Sum: '<S102>/Add' */
  rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe +
    855e:	0c 01 be    	mov.d     w12, w2
    8560:	08 00 be    	mov.d     w8, w0
    8562:	92 14 02    	call      0x1492 <___addsf3>
    8564:	00 00 00 
    8566:	10 af 99    	mov.w     w0, [w14+466]
    8568:	21 af 99    	mov.w     w1, [w14+468]

0000856a <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion_g;

  /* Sum: '<S102>/Add1' */
  rtb_Deg2R1 -= AUAV_V3_TestSensors_B.y_j[0];
    856a:	32 b1 80    	mov.w     0x1626, w2
    856c:	43 b1 80    	mov.w     0x1628, w3
    856e:	0a 00 be    	mov.d     w10, w0
    8570:	90 14 02    	call      0x1490 <___subsf3>
    8572:	00 00 00 
    8574:	00 06 be    	mov.d     w0, w12

00008576 <.L0>:

  /* Sum: '<S108>/Add3' incorporates:
   *  Constant: '<S108>/SaturationLimit'
   */
  rtb_cosphi = 0.383972436F - AUAV_V3_TestSensors_B.DataTypeConversion_h;
    8576:	1a b2 80    	mov.w     0x1642, w10
    8578:	2b b2 80    	mov.w     0x1644, w11
    857a:	0a 01 be    	mov.d     w10, w2
    857c:	90 80 29    	mov.w     #0x9809, w0
    857e:	41 ec 23    	mov.w     #0x3ec4, w1
    8580:	90 14 02    	call      0x1490 <___subsf3>
    8582:	00 00 00 
    8584:	00 04 be    	mov.d     w0, w8

00008586 <.L0>:

  /* Switch: '<S106>/Switch3' incorporates:
   *  RelationalOperator: '<S106>/Relational Operator2'
   */
  if ((rtb_Deg2R1 == rtb_Deg2R1) > 0) {
    8586:	0c 01 be    	mov.d     w12, w2
    8588:	0c 00 be    	mov.d     w12, w0
    858a:	8c 18 02    	call      0x188c <___eqsf2>
    858c:	00 00 00 
    858e:	00 00 e0    	cp0.w     w0
    8590:	02 00 3a    	bra       NZ, 0x8596 <.L0> <.L371>

00008592 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0 = rtb_Deg2R1;
    8592:	6c f9 88    	mov.w     w12, 0x1f2c
    8594:	7d f9 88    	mov.w     w13, 0x1f2e

00008596 <.L0>:
  }

  /* End of Switch: '<S106>/Switch3' */

  /* Sum: '<S108>/Add1' incorporates:
   *  Constant: '<S108>/delayTime'
   *  DataStoreRead: '<S10>/PAR_PID_ROLL_P PAR_PID_ROLL_I PAR_PID_ROLL_D'
   *  Delay: '<S108>/NDelays'
   *  Product: '<S108>/Product1'
   *  Product: '<S108>/Product2'
   *  Product: '<S108>/Product3'
   *  Sum: '<S108>/Sum'
   */
  rtb_Sum1_mzp = (AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0 -
    8596:	6c f9 80    	mov.w     0x1f2c, w12
    8598:	7d f9 80    	mov.w     0x1f2e, w13
    859a:	82 f9 80    	mov.w     0x1f30, w2
    859c:	93 f9 80    	mov.w     0x1f32, w3
    859e:	0c 00 be    	mov.d     w12, w0
    85a0:	90 14 02    	call      0x1490 <___subsf3>
    85a2:	00 00 00 

000085a4 <.L0>:
                  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[0]) / 0.05F *
    85a4:	d2 cc 2c    	mov.w     #0xcccd, w2
    85a6:	c3 d4 23    	mov.w     #0x3d4c, w3
    85a8:	26 17 02    	call      0x1726 <___divsf3>
    85aa:	00 00 00 
    85ac:	d2 93 80    	mov.w     0x127a, w2
    85ae:	e3 93 80    	mov.w     0x127c, w3
    85b0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    85b2:	00 00 00 
    85b4:	30 af 99    	mov.w     w0, [w14+470]
    85b6:	41 af 99    	mov.w     w1, [w14+472]

000085b8 <.L0>:
    mlParamInterface.param[8] +
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0 * mlParamInterface.param[6];
    85b8:	92 93 80    	mov.w     0x1272, w2
    85ba:	a3 93 80    	mov.w     0x1274, w3
    85bc:	0c 00 be    	mov.d     w12, w0
    85be:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    85c0:	00 00 00 
    85c2:	00 01 be    	mov.d     w0, w2

000085c4 <.L0>:
    85c4:	3e a8 91    	mov.w     [w14+470], w0
    85c6:	ce a8 91    	mov.w     [w14+472], w1
    85c8:	92 14 02    	call      0x1492 <___addsf3>
    85ca:	00 00 00 
    85cc:	30 a7 99    	mov.w     w0, [w14+454]
    85ce:	41 a7 99    	mov.w     w1, [w14+456]

000085d0 <.L0>:

  /* Sum: '<S108>/Sum2' incorporates:
   *  DataStoreRead: '<S10>/PAR_PID_ROLL_P PAR_PID_ROLL_I PAR_PID_ROLL_D'
   *  Gain: '<S108>/Gain'
   *  Memory: '<S108>/Memory1'
   *  Product: '<S108>/Product4'
   */
  rtb_RhhcosphicoslambXe = (0.01F *
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0 * mlParamInterface.param[7]
    85d0:	b0 93 80    	mov.w     0x1276, w0
    85d2:	c1 93 80    	mov.w     0x1278, w1
    85d4:	10 b7 99    	mov.w     w0, [w14+482]
    85d6:	21 b7 99    	mov.w     w1, [w14+484]

000085d8 <.L0>:
    85d8:	a2 70 2d    	mov.w     #0xd70a, w2
    85da:	33 c2 23    	mov.w     #0x3c23, w3
    85dc:	0c 00 be    	mov.d     w12, w0
    85de:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    85e0:	00 00 00 

000085e2 <.L0>:
    85e2:	1e b1 91    	mov.w     [w14+482], w2
    85e4:	ae b1 91    	mov.w     [w14+484], w3
    85e6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    85e8:	00 00 00 

000085ea <.L0>:
    + AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j) + rtb_Sum1_mzp;
    85ea:	62 ff 80    	mov.w     0x1fec, w2
    85ec:	73 ff 80    	mov.w     0x1fee, w3
    85ee:	92 14 02    	call      0x1492 <___addsf3>
    85f0:	00 00 00 

000085f2 <.L0>:
    85f2:	3e a1 91    	mov.w     [w14+454], w2
    85f4:	ce a1 91    	mov.w     [w14+456], w3
    85f6:	92 14 02    	call      0x1492 <___addsf3>
    85f8:	00 00 00 
    85fa:	30 af 99    	mov.w     w0, [w14+470]
    85fc:	41 af 99    	mov.w     w1, [w14+472]

000085fe <.L0>:

  /* Switch: '<S108>/AntiWindup' incorporates:
   *  Constant: '<S108>/Constant5'
   *  Constant: '<S108>/SaturationLimit'
   *  Constant: '<S108>/SaturationLimit1'
   *  Logic: '<S108>/Logical Operator'
   *  RelationalOperator: '<S108>/Relational Operator'
   *  RelationalOperator: '<S108>/Relational Operator1'
   *  Sum: '<S108>/Add3'
   *  Sum: '<S108>/Add4'
   */
  if ((rtb_RhhcosphicoslambXe > -0.383972436F -
    85fe:	0a 01 be    	mov.d     w10, w2
    8600:	90 80 29    	mov.w     #0x9809, w0
    8602:	41 ec 2b    	mov.w     #0xbec4, w1
    8604:	90 14 02    	call      0x1490 <___subsf3>
    8606:	00 00 00 
    8608:	70 a7 99    	mov.w     w0, [w14+462]
    860a:	01 af 99    	mov.w     w1, [w14+464]
    860c:	3e a9 91    	mov.w     [w14+470], w2
    860e:	ce a9 91    	mov.w     [w14+472], w3
    8610:	8c 18 02    	call      0x188c <___eqsf2>
    8612:	00 00 00 
    8614:	00 00 e0    	cp0.w     w0
    8616:	0f 00 3d    	bra       GE, 0x8636 <.L638>

00008618 <.L0>:
       AUAV_V3_TestSensors_B.DataTypeConversion_h) && (rtb_RhhcosphicoslambXe <
    8618:	3e a9 91    	mov.w     [w14+470], w2
    861a:	ce a9 91    	mov.w     [w14+472], w3
    861c:	08 00 be    	mov.d     w8, w0
    861e:	90 18 02    	call      0x1890 <___gesf2>
    8620:	00 00 00 
    8622:	00 00 e0    	cp0.w     w0
    8624:	0a 00 34    	bra       LE, 0x863a <.L639>

00008626 <.L0>:
       0.383972436F - AUAV_V3_TestSensors_B.DataTypeConversion_h)) {
    rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0;
  } else {
    rtb_RhhcosphicoslambXe = 0.0F;
  }

  /* End of Switch: '<S108>/AntiWindup' */

  /* Switch: '<S115>/Switch3' incorporates:
   *  RelationalOperator: '<S115>/Relational Operator2'
   */
  if ((rtb_RhhcosphicoslambXe == rtb_RhhcosphicoslambXe) > 0) {
    8626:	0c 01 be    	mov.d     w12, w2
    8628:	0c 00 be    	mov.d     w12, w0
    862a:	8c 18 02    	call      0x188c <___eqsf2>
    862c:	00 00 00 
    862e:	00 00 e0    	cp0.w     w0
    8630:	07 00 3a    	bra       NZ, 0x8640 <.L376>

00008632 <.L0>:
    8632:	0c 00 be    	mov.d     w12, w0
    8634:	03 00 37    	bra       0x863c <.L373>

00008636 <.L638>:
    8636:	60 00 b8    	mul.uu    w0, #0x0, w0
    8638:	01 00 37    	bra       0x863c <.L373>

0000863a <.L639>:
    863a:	60 00 b8    	mul.uu    w0, #0x0, w0

0000863c <.L373>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_l = rtb_RhhcosphicoslambXe;
    863c:	40 fa 88    	mov.w     w0, 0x1f48
    863e:	51 fa 88    	mov.w     w1, 0x1f4a

00008640 <.L376>:
  }

  /* End of Switch: '<S115>/Switch3' */

  /* Switch: '<S114>/Switch1' incorporates:
   *  Constant: '<S114>/Constant'
   *  Constant: '<S114>/Constant1'
   *  Constant: '<S114>/Constant2'
   *  Constant: '<S114>/Constant3'
   *  Constant: '<S114>/Constant5'
   *  Delay: '<S114>/Integer Delay'
   *  Delay: '<S114>/Integer Delay1'
   *  Delay: '<S114>/Integer Delay2'
   *  Product: '<S114>/Product'
   *  Product: '<S114>/Product1'
   *  Product: '<S114>/Product2'
   *  Product: '<S114>/Product3'
   *  Sum: '<S114>/Subtract'
   *  Sum: '<S114>/Subtract1'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    rtb_RhhcosphicoslambXe = 0.0F;
    8640:	60 00 b8    	mul.uu    w0, #0x0, w0
    8642:	30 af 99    	mov.w     w0, [w14+470]
    8644:	41 af 99    	mov.w     w1, [w14+472]
    8646:	ae e8 93    	mov.b     [w14+490], w1
    8648:	01 04 e0    	cp0.b     w1
    864a:	2f 00 3a    	bra       NZ, 0x86aa <.L378>

0000864c <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = ((AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_l *
    864c:	b2 aa 2a    	mov.w     #0xaaab, w2
    864e:	a3 ea 23    	mov.w     #0x3eaa, w3
    8650:	40 fa 80    	mov.w     0x1f48, w0
    8652:	51 fa 80    	mov.w     0x1f4a, w1
    8654:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8656:	00 00 00 
    8658:	30 af 99    	mov.w     w0, [w14+470]
    865a:	41 af 99    	mov.w     w1, [w14+472]

0000865c <.L0>:
      0.333333343F + AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_b *
    865c:	b2 aa 2a    	mov.w     #0xaaab, w2
    865e:	a3 fa 23    	mov.w     #0x3faa, w3
    8660:	60 fa 80    	mov.w     0x1f4c, w0
    8662:	71 fa 80    	mov.w     0x1f4e, w1
    8664:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8666:	00 00 00 
    8668:	00 01 be    	mov.d     w0, w2
    866a:	3e a8 91    	mov.w     [w14+470], w0
    866c:	ce a8 91    	mov.w     [w14+472], w1
    866e:	92 14 02    	call      0x1492 <___addsf3>
    8670:	00 00 00 
    8672:	30 af 99    	mov.w     w0, [w14+470]
    8674:	41 af 99    	mov.w     w1, [w14+472]

00008676 <.L0>:
      1.33333337F) + AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l3[0] *
    8676:	b2 aa 2a    	mov.w     #0xaaab, w2
    8678:	a3 ea 23    	mov.w     #0x3eaa, w3
    867a:	80 fa 80    	mov.w     0x1f50, w0
    867c:	91 fa 80    	mov.w     0x1f52, w1
    867e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8680:	00 00 00 
    8682:	00 01 be    	mov.d     w0, w2
    8684:	3e a8 91    	mov.w     [w14+470], w0
    8686:	ce a8 91    	mov.w     [w14+472], w1
    8688:	92 14 02    	call      0x1492 <___addsf3>
    868a:	00 00 00 

0000868c <.L0>:
      0.333333343F) * 0.005F + AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_j;
    868c:	a2 70 2d    	mov.w     #0xd70a, w2
    868e:	33 ba 23    	mov.w     #0x3ba3, w3
    8690:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8692:	00 00 00 

00008694 <.L0>:
    8694:	22 fa 80    	mov.w     0x1f44, w2
    8696:	33 fa 80    	mov.w     0x1f46, w3
    8698:	92 14 02    	call      0x1492 <___addsf3>
    869a:	00 00 00 
    869c:	00 01 be    	mov.d     w0, w2
    869e:	30 af 99    	mov.w     w0, [w14+470]
    86a0:	41 af 99    	mov.w     w1, [w14+472]

000086a2 <.L0>:
  }

  /* End of Switch: '<S114>/Switch1' */

  /* Switch: '<S116>/Switch3' incorporates:
   *  RelationalOperator: '<S116>/Relational Operator2'
   */
  if ((rtb_RhhcosphicoslambXe == rtb_RhhcosphicoslambXe) > 0) {
    86a2:	8c 18 02    	call      0x188c <___eqsf2>
    86a4:	00 00 00 
    86a6:	00 00 e0    	cp0.w     w0
    86a8:	0b 00 3a    	bra       NZ, 0x86c0 <.L0> <.L379>

000086aa <.L378>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_d = rtb_RhhcosphicoslambXe;
    86aa:	3e aa 91    	mov.w     [w14+470], w4
    86ac:	ce aa 91    	mov.w     [w14+472], w5
    86ae:	c4 fa 88    	mov.w     w4, 0x1f58
    86b0:	d5 fa 88    	mov.w     w5, 0x1f5a
  }

  /* End of Switch: '<S116>/Switch3' */

  /* Switch: '<S108>/On//Off' incorporates:
   *  Constant: '<S108>/Constant1'
   *  DataStoreRead: '<S10>/PAR_PID_ROLL_P PAR_PID_ROLL_I PAR_PID_ROLL_D'
   *  Product: '<S108>/Product'
   *  Sum: '<S108>/Add2'
   */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 > 0) {
    86b2:	ae ea 93    	mov.b     [w14+490], w5
    86b4:	05 04 e0    	cp0.b     w5
    86b6:	04 00 32    	bra       Z, 0x86c0 <.L0> <.L379>
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j = 0.0F;
    86b8:	60 00 b8    	mul.uu    w0, #0x0, w0
    86ba:	60 ff 88    	mov.w     w0, 0x1fec
    86bc:	71 ff 88    	mov.w     w1, 0x1fee
    86be:	0c 00 37    	bra       0x86d8 <.L0> <.L381>

000086c0 <.L0>:
  } else {
    AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j =
      AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_d * mlParamInterface.param
    86c0:	c2 fa 80    	mov.w     0x1f58, w2
    86c2:	d3 fa 80    	mov.w     0x1f5a, w3
    86c4:	1e b0 91    	mov.w     [w14+482], w0
    86c6:	ae b0 91    	mov.w     [w14+484], w1
    86c8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    86ca:	00 00 00 

000086cc <.L0>:
      [7] + rtb_Sum1_mzp;
    86cc:	3e a1 91    	mov.w     [w14+454], w2
    86ce:	ce a1 91    	mov.w     [w14+456], w3
    86d0:	92 14 02    	call      0x1492 <___addsf3>
    86d2:	00 00 00 

000086d4 <.L0>:
    86d4:	60 ff 88    	mov.w     w0, 0x1fec
    86d6:	71 ff 88    	mov.w     w1, 0x1fee

000086d8 <.L0>:
  }

  /* End of Switch: '<S108>/On//Off' */

  /* Switch: '<S113>/Switch2' incorporates:
   *  Constant: '<S108>/SaturationLimit'
   *  RelationalOperator: '<S113>/LowerRelop1'
   *  Sum: '<S108>/Add3'
   */
  if (!(AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j > 0.383972436F -
    86d8:	60 ff 80    	mov.w     0x1fec, w0
    86da:	71 ff 80    	mov.w     0x1fee, w1
    86dc:	30 af 99    	mov.w     w0, [w14+470]
    86de:	41 af 99    	mov.w     w1, [w14+472]
    86e0:	11 c0 b3    	mov.b     #0x1, w1
    86e2:	21 e7 9b    	mov.b     w1, [w14+482]
    86e4:	3e a9 91    	mov.w     [w14+470], w2
    86e6:	ce a9 91    	mov.w     [w14+472], w3
    86e8:	08 00 be    	mov.d     w8, w0
    86ea:	8c 18 02    	call      0x188c <___eqsf2>
    86ec:	00 00 00 
    86ee:	00 00 e0    	cp0.w     w0
    86f0:	02 00 35    	bra       LT, 0x86f6 <.L383>
    86f2:	00 41 eb    	clr.b     w2
    86f4:	22 e7 9b    	mov.b     w2, [w14+482]

000086f6 <.L383>:
    86f6:	ae e1 93    	mov.b     [w14+482], w3
    86f8:	03 04 e0    	cp0.b     w3
    86fa:	0d 00 3a    	bra       NZ, 0x8716 <.L0> <.L382>

000086fc <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_h)) {
    /* Switch: '<S113>/Switch' incorporates:
     *  Constant: '<S108>/SaturationLimit1'
     *  RelationalOperator: '<S113>/UpperRelop'
     *  Sum: '<S108>/Add4'
     */
    if (AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j < -0.383972436F -
    86fc:	3e a9 91    	mov.w     [w14+470], w2
    86fe:	ce a9 91    	mov.w     [w14+472], w3
    8700:	7e a0 91    	mov.w     [w14+462], w0
    8702:	8e a8 91    	mov.w     [w14+464], w1
    8704:	90 18 02    	call      0x1890 <___gesf2>
    8706:	00 00 00 
    8708:	00 00 e0    	cp0.w     w0
    870a:	03 00 34    	bra       LE, 0x8712 <.L640>

0000870c <.L0>:
        AUAV_V3_TestSensors_B.DataTypeConversion_h) {
      rtb_cosphi = -0.383972436F - AUAV_V3_TestSensors_B.DataTypeConversion_h;
    870c:	7e a4 91    	mov.w     [w14+462], w8
    870e:	8e ac 91    	mov.w     [w14+464], w9
    8710:	02 00 37    	bra       0x8716 <.L0> <.L382>

00008712 <.L640>:
    } else {
      rtb_cosphi = AUAV_V3_TestSensors_DWork.Memory1_PreviousInput_j;
    8712:	3e ac 91    	mov.w     [w14+470], w8
    8714:	ce ac 91    	mov.w     [w14+472], w9

00008716 <.L0>:
    }

    /* End of Switch: '<S113>/Switch' */
  }

  /* End of Switch: '<S113>/Switch2' */

  /* Sum: '<S102>/Add3' */
  rtb_cosphi += AUAV_V3_TestSensors_B.DataTypeConversion_h;
    8716:	0a 01 be    	mov.d     w10, w2
    8718:	08 00 be    	mov.d     w8, w0
    871a:	92 14 02    	call      0x1492 <___addsf3>
    871c:	00 00 00 
    871e:	00 04 be    	mov.d     w0, w8

00008720 <.L0>:

  /* Saturate: '<S102>/Aileron Limit' */
  if (rtb_cosphi > 0.383972436F) {
    8720:	92 80 29    	mov.w     #0x9809, w2
    8722:	43 ec 23    	mov.w     #0x3ec4, w3
    8724:	90 18 02    	call      0x1890 <___gesf2>
    8726:	00 00 00 
    8728:	00 00 e0    	cp0.w     w0
    872a:	0a 00 3c    	bra       GT, 0x8740 <.L481>

0000872c <.L0>:
    rtb_Sum1_mzp = 0.383972436F;
  } else if (rtb_cosphi < -0.383972436F) {
    872c:	92 80 29    	mov.w     #0x9809, w2
    872e:	43 ec 2b    	mov.w     #0xbec4, w3
    8730:	08 00 be    	mov.d     w8, w0
    8732:	8c 18 02    	call      0x188c <___eqsf2>
    8734:	00 00 00 
    8736:	00 00 e0    	cp0.w     w0
    8738:	06 00 3d    	bra       GE, 0x8746 <.L641>

0000873a <.L0>:
    rtb_Sum1_mzp = -0.383972436F;
    873a:	9a 80 29    	mov.w     #0x9809, w10
    873c:	4b ec 2b    	mov.w     #0xbec4, w11
    873e:	04 00 37    	bra       0x8748 <.L0> <.L385>

00008740 <.L481>:
    8740:	9a 80 29    	mov.w     #0x9809, w10
    8742:	4b ec 23    	mov.w     #0x3ec4, w11
    8744:	01 00 37    	bra       0x8748 <.L0> <.L385>

00008746 <.L641>:
  } else {
    rtb_Sum1_mzp = rtb_cosphi;
    8746:	08 05 be    	mov.d     w8, w10

00008748 <.L0>:
  }

  /* End of Saturate: '<S102>/Aileron Limit' */

  /* Switch: '<S102>/Switch2' incorporates:
   *  Constant: '<S102>/Constant'
   *  DataStoreRead: '<Root>/PAR_NAV_ISR_FAC PAR_PID_RMIX_ON PAR_PID_RMIX_P'
   *  Product: '<S102>/Product'
   */
  if (mlParamInterface.param[27L] > 0.3F) {
    8748:	a2 99 29    	mov.w     #0x999a, w2
    874a:	93 e9 23    	mov.w     #0x3e99, w3
    874c:	30 96 80    	mov.w     0x12c6, w0
    874e:	41 96 80    	mov.w     0x12c8, w1
    8750:	90 18 02    	call      0x1890 <___gesf2>
    8752:	00 00 00 
    8754:	00 00 e0    	cp0.w     w0
    8756:	06 00 34    	bra       LE, 0x8764 <.L0> <.L642>

00008758 <.L0>:
    rtb_RhhcosphicoslambXe = mlParamInterface.param[28] * rtb_Sum1_mzp;
    8758:	52 96 80    	mov.w     0x12ca, w2
    875a:	63 96 80    	mov.w     0x12cc, w3
    875c:	0a 00 be    	mov.d     w10, w0
    875e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8760:	00 00 00 
    8762:	01 00 37    	bra       0x8766 <.L0> <.L387>

00008764 <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = 0.0F;
    8764:	60 00 b8    	mul.uu    w0, #0x0, w0

00008766 <.L0>:
  }

  /* End of Switch: '<S102>/Switch2' */

  /* Sum: '<S102>/Add4' */
  rtb_cosphi = rtb_RhhcosphicoslambXe + rtb_RhhcosphisinlambYe;
    8766:	1e a9 91    	mov.w     [w14+466], w2
    8768:	ae a9 91    	mov.w     [w14+468], w3
    876a:	92 14 02    	call      0x1492 <___addsf3>
    876c:	00 00 00 
    876e:	00 04 be    	mov.d     w0, w8

00008770 <.L0>:

  /* Update for Delay: '<S110>/NDelays' incorporates:
   *  Gain: '<S102>/Neg Feedback '
   */
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[0] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[1];
    8770:	40 f0 21    	mov.w     #0x1f04, w0
    8772:	10 02 be    	mov.d     [w0], w4
    8774:	04 f8 88    	mov.w     w4, 0x1f00
    8776:	15 f8 88    	mov.w     w5, 0x1f02
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[1] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[2];
    8778:	e4 00 40    	add.w     w0, #0x4, w1
    877a:	31 18 78    	mov.w     [w1++], [w0++]
    877c:	21 10 78    	mov.w     [w1--], [w0--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[2] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[3];
    877e:	68 01 40    	add.w     w0, #0x8, w2
    8780:	b2 18 78    	mov.w     [w2++], [w1++]
    8782:	a2 10 78    	mov.w     [w2--], [w1--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[3] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[4];
    8784:	6c 00 40    	add.w     w0, #0xc, w0
    8786:	30 19 78    	mov.w     [w0++], [w2++]
    8788:	20 11 78    	mov.w     [w0--], [w2--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_l[4] =
    878a:	3e b1 91    	mov.w     [w14+486], w2
    878c:	ce b1 91    	mov.w     [w14+488], w3
    878e:	02 88 be    	mov.d     w2, [w0]
    -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b0.y;

  /* Update for Delay: '<S130>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_bj =
    8790:	44 f9 80    	mov.w     0x1f28, w4
    8792:	55 f9 80    	mov.w     0x1f2a, w5
    8794:	a4 f8 88    	mov.w     w4, 0x1f14
    8796:	b5 f8 88    	mov.w     w5, 0x1f16
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_f;

  /* Update for Delay: '<S130>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_o =
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_n;
    8798:	c2 f8 80    	mov.w     0x1f18, w2
    879a:	d3 f8 80    	mov.w     0x1f1a, w3
    879c:	e2 f8 88    	mov.w     w2, 0x1f1c
    879e:	f3 f8 88    	mov.w     w3, 0x1f1e

  /* Update for Delay: '<S130>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l[0] =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l[1];
    87a0:	74 00 40    	add.w     w0, #0x14, w0
    87a2:	10 02 be    	mov.d     [w0], w4
    87a4:	04 f9 88    	mov.w     w4, 0x1f20
    87a6:	15 f9 88    	mov.w     w5, 0x1f22
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l[1] =
    87a8:	02 88 be    	mov.d     w2, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_n;

  /* Update for Delay: '<S108>/NDelays' */
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[0] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[1];
    87aa:	70 00 40    	add.w     w0, #0x10, w0
    87ac:	10 01 be    	mov.d     [w0], w2
    87ae:	82 f9 88    	mov.w     w2, 0x1f30
    87b0:	93 f9 88    	mov.w     w3, 0x1f32
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[1] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[2];
    87b2:	01 03 b0    	add.w     #0x30, w1
    87b4:	31 18 78    	mov.w     [w1++], [w0++]
    87b6:	21 10 78    	mov.w     [w1--], [w0--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[2] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[3];
    87b8:	68 01 40    	add.w     w0, #0x8, w2
    87ba:	b2 18 78    	mov.w     [w2++], [w1++]
    87bc:	a2 10 78    	mov.w     [w2--], [w1--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[3] =
    AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[4];
    87be:	6c 00 40    	add.w     w0, #0xc, w0
    87c0:	30 19 78    	mov.w     [w0++], [w2++]
    87c2:	20 11 78    	mov.w     [w0--], [w2--]
  AUAV_V3_TestSensors_DWork.NDelays_DSTATE_p[4] =
    87c4:	0c 88 be    	mov.d     w12, [w0]
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k0;

  /* Update for Delay: '<S114>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_j =
    87c6:	c4 fa 80    	mov.w     0x1f58, w4
    87c8:	d5 fa 80    	mov.w     0x1f5a, w5
    87ca:	24 fa 88    	mov.w     w4, 0x1f44
    87cc:	35 fa 88    	mov.w     w5, 0x1f46
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_d;

  /* Update for Delay: '<S114>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_b =
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_l;
    87ce:	42 fa 80    	mov.w     0x1f48, w2
    87d0:	53 fa 80    	mov.w     0x1f4a, w3
    87d2:	62 fa 88    	mov.w     w2, 0x1f4c
    87d4:	73 fa 88    	mov.w     w3, 0x1f4e

  /* Update for Delay: '<S114>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l3[0] =
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l3[1];
    87d6:	74 00 40    	add.w     w0, #0x14, w0
    87d8:	10 02 be    	mov.d     [w0], w4
    87da:	84 fa 88    	mov.w     w4, 0x1f50
    87dc:	95 fa 88    	mov.w     w5, 0x1f52
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_l3[1] =
    87de:	02 88 be    	mov.d     w2, [w0]

000087e0 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_l;

  /* End of Outputs for SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */

  /* Outputs for Atomic SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */
  /* Saturate: '<S140>/Throttle  Limit' */
  /* MATLAB Function 'myMux Fun1': '<S22>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S22>:1:5' */
  if (rtb_y_jl_idx_0 > 0.95F) {
    87e0:	32 33 23    	mov.w     #0x3333, w2
    87e2:	33 f7 23    	mov.w     #0x3f73, w3
    87e4:	7e 90 91    	mov.w     [w14+430], w0
    87e6:	8e 98 91    	mov.w     [w14+432], w1
    87e8:	90 18 02    	call      0x1890 <___gesf2>
    87ea:	00 00 00 
    87ec:	00 00 e0    	cp0.w     w0
    87ee:	08 00 3c    	bra       GT, 0x8800 <.L0> <.L484>

000087f0 <.L0>:
    /* MATLAB Function: '<Root>/myMux Fun1' */
    rtb_y_jl_idx_0 = 0.95F;
  } else {
    if (rtb_y_jl_idx_0 < 0.0F) {
    87f0:	60 11 b8    	mul.uu    w2, #0x0, w2
    87f2:	7e 90 91    	mov.w     [w14+430], w0
    87f4:	8e 98 91    	mov.w     [w14+432], w1
    87f6:	8c 18 02    	call      0x188c <___eqsf2>
    87f8:	00 00 00 
    87fa:	00 00 e0    	cp0.w     w0
    87fc:	06 00 35    	bra       LT, 0x880a <.L485>
    87fe:	08 00 37    	bra       0x8810 <.L0> <.L389>

00008800 <.L0>:
    8800:	30 33 23    	mov.w     #0x3333, w0
    8802:	31 f7 23    	mov.w     #0x3f73, w1
    8804:	70 97 99    	mov.w     w0, [w14+430]
    8806:	01 9f 99    	mov.w     w1, [w14+432]
    8808:	03 00 37    	bra       0x8810 <.L0> <.L389>

0000880a <.L485>:
      /* MATLAB Function: '<Root>/myMux Fun1' */
      rtb_y_jl_idx_0 = 0.0F;
    880a:	60 11 b8    	mul.uu    w2, #0x0, w2
    880c:	72 97 99    	mov.w     w2, [w14+430]
    880e:	03 9f 99    	mov.w     w3, [w14+432]

00008810 <.L0>:
    }
  }

  /* End of Saturate: '<S140>/Throttle  Limit' */
  /* End of Outputs for SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */

  /* Outputs for Atomic SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */
  /* Saturate: '<S102>/Rudder Limit' */
  if (rtb_cosphi > 0.17453292F) {
    8810:	22 8c 2b    	mov.w     #0xb8c2, w2
    8812:	23 e3 23    	mov.w     #0x3e32, w3
    8814:	08 00 be    	mov.d     w8, w0
    8816:	90 18 02    	call      0x1890 <___gesf2>
    8818:	00 00 00 
    881a:	00 00 e0    	cp0.w     w0
    881c:	08 00 3c    	bra       GT, 0x882e <.L0> <.L486>

0000881e <.L0>:
    /* MATLAB Function: '<Root>/myMux Fun1' */
    rtb_cosphi = 0.17453292F;
  } else {
    if (rtb_cosphi < -0.17453292F) {
    881e:	22 8c 2b    	mov.w     #0xb8c2, w2
    8820:	23 e3 2b    	mov.w     #0xbe32, w3
    8822:	08 00 be    	mov.d     w8, w0
    8824:	8c 18 02    	call      0x188c <___eqsf2>
    8826:	00 00 00 
    8828:	00 00 e0    	cp0.w     w0
    882a:	04 00 35    	bra       LT, 0x8834 <.L487>
    882c:	05 00 37    	bra       0x8838 <.L0> <.L390>

0000882e <.L0>:
    882e:	28 8c 2b    	mov.w     #0xb8c2, w8
    8830:	29 e3 23    	mov.w     #0x3e32, w9
    8832:	02 00 37    	bra       0x8838 <.L0> <.L390>

00008834 <.L487>:
      /* MATLAB Function: '<Root>/myMux Fun1' */
      rtb_cosphi = -0.17453292F;
    8834:	28 8c 2b    	mov.w     #0xb8c2, w8
    8836:	29 e3 2b    	mov.w     #0xbe32, w9

00008838 <.L0>:
    }
  }

  /* End of Saturate: '<S102>/Rudder Limit' */
  /* End of Outputs for SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */

  /* Outputs for Atomic SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */
  /* Saturate: '<S140>/Elevator  Limit' */
  if (rtb_IC4_idx_0 > 0.401425719F) {
    8838:	c2 7a 28    	mov.w     #0x87ac, w2
    883a:	d3 ec 23    	mov.w     #0x3ecd, w3
    883c:	3e 98 91    	mov.w     [w14+438], w0
    883e:	ce 98 91    	mov.w     [w14+440], w1
    8840:	90 18 02    	call      0x1890 <___gesf2>
    8842:	00 00 00 
    8844:	00 00 e0    	cp0.w     w0
    8846:	09 00 3c    	bra       GT, 0x885a <.L0> <.L488>

00008848 <.L0>:
    /* MATLAB Function: '<Root>/myMux Fun1' */
    rtb_IC4_idx_0 = 0.401425719F;
  } else {
    if (rtb_IC4_idx_0 < -0.401425719F) {
    8848:	c2 7a 28    	mov.w     #0x87ac, w2
    884a:	d3 ec 2b    	mov.w     #0xbecd, w3
    884c:	3e 98 91    	mov.w     [w14+438], w0
    884e:	ce 98 91    	mov.w     [w14+440], w1
    8850:	8c 18 02    	call      0x188c <___eqsf2>
    8852:	00 00 00 
    8854:	00 00 e0    	cp0.w     w0
    8856:	06 00 35    	bra       LT, 0x8864 <.L489>
    8858:	09 00 37    	bra       0x886c <.L391>

0000885a <.L0>:
    885a:	c4 7a 28    	mov.w     #0x87ac, w4
    885c:	d5 ec 23    	mov.w     #0x3ecd, w5
    885e:	34 9f 99    	mov.w     w4, [w14+438]
    8860:	45 9f 99    	mov.w     w5, [w14+440]
    8862:	04 00 37    	bra       0x886c <.L391>

00008864 <.L489>:
      /* MATLAB Function: '<Root>/myMux Fun1' */
      rtb_IC4_idx_0 = -0.401425719F;
    8864:	c0 7a 28    	mov.w     #0x87ac, w0
    8866:	d1 ec 2b    	mov.w     #0xbecd, w1
    8868:	30 9f 99    	mov.w     w0, [w14+438]
    886a:	41 9f 99    	mov.w     w1, [w14+440]

0000886c <.L391>:
    }
  }

  /* End of Saturate: '<S140>/Elevator  Limit' */
  /* End of Outputs for SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */

  /* If: '<S682>/If' */
  if (AUAV_V3_TestSensors_B.ManualorAutonavSupportcupdated4 == 1) {
    886c:	ae e8 93    	mov.b     [w14+490], w1
    886e:	e1 cf 50    	sub.b     w1, #0x1, [w15]
    8870:	0d 00 3a    	bra       NZ, 0x888c <.L392>
    /* Outputs for IfAction SubSystem: '<S682>/If  Control Type Is Manual' incorporates:
     *  ActionPort: '<S685>/Action Port'
     */
    /* Gain: '<S685>/Gain4' incorporates:
     *  MATLAB Function: '<S656>/myMux Fun5'
     */
    AUAV_V3_TestSensors_B.Merge_oc[0] = AUAV_V3_TestSensors_B.InputCapture_o3 >>
    8872:	00 ce 80    	mov.w     0x19c0, w0
    8874:	00 00 d1    	lsr.w     w0, w0
    8876:	40 ce 88    	mov.w     w0, 0x19c8
      1;
    AUAV_V3_TestSensors_B.Merge_oc[1] = AUAV_V3_TestSensors_B.InputCapture_o1 >>
    8878:	e0 cd 80    	mov.w     0x19bc, w0
    887a:	00 00 d1    	lsr.w     w0, w0
    887c:	50 ce 88    	mov.w     w0, 0x19ca
      1;
    AUAV_V3_TestSensors_B.Merge_oc[2] = AUAV_V3_TestSensors_B.InputCapture_o4 >>
    887e:	10 ce 80    	mov.w     0x19c2, w0
    8880:	00 00 d1    	lsr.w     w0, w0
    8882:	60 ce 88    	mov.w     w0, 0x19cc
      1;
    AUAV_V3_TestSensors_B.Merge_oc[3] = AUAV_V3_TestSensors_B.InputCapture_o2 >>
    8884:	f0 cd 80    	mov.w     0x19be, w0
    8886:	00 00 d1    	lsr.w     w0, w0
    8888:	70 ce 88    	mov.w     w0, 0x19ce
    888a:	59 01 37    	bra       0x8b3e <.L0> <.L393>

0000888c <.L392>:
    888c:	8e 50 93    	mov.b     [w14+400], w1
      1;

    /* End of Outputs for SubSystem: '<S682>/If  Control Type Is Manual' */
  } else if ((rtb_DataTypeConversion1_hq == 3) || (rtb_DataTypeConversion1_hq ==
    888e:	63 c0 50    	sub.b     w1, #0x3, w0
    8890:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    8892:	04 00 36    	bra       LEU, 0x889c <.L0> <.L394>
              4) || (rtb_DataTypeConversion1_hq == 9) ||
    8894:	e9 cf 50    	sub.b     w1, #0x9, [w15]
    8896:	02 00 32    	bra       Z, 0x889c <.L0> <.L394>
    8898:	ea cf 50    	sub.b     w1, #0xa, [w15]
    889a:	a1 00 3a    	bra       NZ, 0x89de <.L0> <.L395>

0000889c <.L0>:
             (rtb_DataTypeConversion1_hq == 10)) {
    /* Outputs for IfAction SubSystem: '<S682>/If  Control Type Is Wp, ISR, LP or  Mid Lvl Cmds' incorporates:
     *  ActionPort: '<S688>/Action Port'
     */
    /* DataTypeConversion: '<S695>/Data Type Conversion' incorporates:
     *  Constant: '<S695>/Constant1'
     *  Constant: '<S695>/Constant2'
     *  Product: '<S695>/Divide'
     *  Sum: '<S695>/Add'
     */
    tmp_4 = floor(rtb_y_jl_idx_0 * 2000.0 + 2000.0);
    889c:	02 00 20    	mov.w     #0x0, w2
    889e:	a3 4f 24    	mov.w     #0x44fa, w3
    88a0:	7e 90 91    	mov.w     [w14+430], w0
    88a2:	8e 98 91    	mov.w     [w14+432], w1
    88a4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    88a6:	00 00 00 
    88a8:	02 00 20    	mov.w     #0x0, w2
    88aa:	a3 4f 24    	mov.w     #0x44fa, w3
    88ac:	92 14 02    	call      0x1492 <___addsf3>
    88ae:	00 00 00 
    88b0:	16 19 02    	call      0x1916 <_floorf>
    88b2:	00 00 00 
    88b4:	50 b7 99    	mov.w     w0, [w14+490]
    88b6:	61 b7 99    	mov.w     w1, [w14+492]

000088b8 <.L0>:

    /* DataTypeConversion: '<S696>/Data Type Conversion' incorporates:
     *  Constant: '<S696>/Constant1'
     *  Constant: '<S696>/Constant2'
     *  MATLAB Function: '<Root>/myMux Fun1'
     *  Product: '<S696>/Divide'
     *  Sum: '<S696>/Add'
     */
    tmp_5 = floor(rtb_Sum1_mzp * -5729.5779513082325 + 3000.0000000000005);
    88b8:	02 ca 20    	mov.w     #0xca0, w2
    88ba:	33 5b 2c    	mov.w     #0xc5b3, w3
    88bc:	0a 00 be    	mov.d     w10, w0
    88be:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    88c0:	00 00 00 
    88c2:	02 00 28    	mov.w     #0x8000, w2
    88c4:	b3 53 24    	mov.w     #0x453b, w3
    88c6:	92 14 02    	call      0x1492 <___addsf3>
    88c8:	00 00 00 
    88ca:	16 19 02    	call      0x1916 <_floorf>
    88cc:	00 00 00 
    88ce:	00 06 be    	mov.d     w0, w12

000088d0 <.L0>:

    /* DataTypeConversion: '<S697>/Data Type Conversion' incorporates:
     *  Constant: '<S697>/Constant1'
     *  Constant: '<S697>/Constant2'
     *  Product: '<S697>/Divide'
     *  Sum: '<S697>/Add'
     */
    tmp_6 = floor(rtb_cosphi * -5729.5779513082325 + 3000.0000000000005);
    88d0:	02 ca 20    	mov.w     #0xca0, w2
    88d2:	33 5b 2c    	mov.w     #0xc5b3, w3
    88d4:	08 00 be    	mov.d     w8, w0
    88d6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    88d8:	00 00 00 
    88da:	02 00 28    	mov.w     #0x8000, w2
    88dc:	b3 53 24    	mov.w     #0x453b, w3
    88de:	92 14 02    	call      0x1492 <___addsf3>
    88e0:	00 00 00 
    88e2:	16 19 02    	call      0x1916 <_floorf>
    88e4:	00 00 00 
    88e6:	00 04 be    	mov.d     w0, w8

000088e8 <.L0>:

    /* DataTypeConversion: '<S694>/Data Type Conversion' incorporates:
     *  Constant: '<S694>/Constant1'
     *  Constant: '<S694>/Constant2'
     *  Product: '<S694>/Divide'
     *  Sum: '<S694>/Add'
     */
    tmp_7 = floor(rtb_IC4_idx_0 * 5729.5779513082325 + 3000.0000000000005);
    88e8:	02 ca 20    	mov.w     #0xca0, w2
    88ea:	33 5b 24    	mov.w     #0x45b3, w3
    88ec:	3e 98 91    	mov.w     [w14+438], w0
    88ee:	ce 98 91    	mov.w     [w14+440], w1
    88f0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    88f2:	00 00 00 
    88f4:	02 00 28    	mov.w     #0x8000, w2
    88f6:	b3 53 24    	mov.w     #0x453b, w3
    88f8:	92 14 02    	call      0x1492 <___addsf3>
    88fa:	00 00 00 
    88fc:	16 19 02    	call      0x1916 <_floorf>
    88fe:	00 00 00 
    8900:	00 05 be    	mov.d     w0, w10

00008902 <.L0>:

    /* DataTypeConversion: '<S695>/Data Type Conversion' */
    if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    8902:	5e b0 91    	mov.w     [w14+490], w0
    8904:	ee b0 91    	mov.w     [w14+492], w1
    8906:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8908:	01 00 00 

0000890a <.L0>:
      tmp_4 = 0.0;
    890a:	60 22 b8    	mul.uu    w4, #0x0, w4
    890c:	34 b7 99    	mov.w     w4, [w14+486]
    890e:	45 b7 99    	mov.w     w5, [w14+488]

00008910 <.L0>:
    8910:	00 04 e0    	cp0.b     w0
    8912:	11 00 3a    	bra       NZ, 0x8936 <.L0> <.L0> <.L396>
    8914:	5e b0 91    	mov.w     [w14+490], w0
    8916:	ee b0 91    	mov.w     [w14+492], w1
    8918:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    891a:	01 00 00 

0000891c <.L0>:
    891c:	60 11 b8    	mul.uu    w2, #0x0, w2
    891e:	32 b7 99    	mov.w     w2, [w14+486]
    8920:	43 b7 99    	mov.w     w3, [w14+488]
    8922:	00 04 e0    	cp0.b     w0
    8924:	08 00 3a    	bra       NZ, 0x8936 <.L0> <.L0> <.L396>

00008926 <.L0>:
    } else {
      tmp_4 = fmod(tmp_4, 65536.0);
    8926:	02 00 20    	mov.w     #0x0, w2
    8928:	03 78 24    	mov.w     #0x4780, w3
    892a:	5e b0 91    	mov.w     [w14+490], w0
    892c:	ee b0 91    	mov.w     [w14+492], w1
    892e:	26 19 02    	call      0x1926 <_fmodf>
    8930:	00 00 00 
    8932:	30 b7 99    	mov.w     w0, [w14+486]
    8934:	41 b7 99    	mov.w     w1, [w14+488]

00008936 <.L0>:
    }

    /* DataTypeConversion: '<S696>/Data Type Conversion' */
    if (rtIsNaN(tmp_5) || rtIsInf(tmp_5)) {
    8936:	0c 00 be    	mov.d     w12, w0
    8938:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    893a:	01 00 00 

0000893c <.L0>:
      tmp_5 = 0.0;
    893c:	60 11 b8    	mul.uu    w2, #0x0, w2
    893e:	52 b7 99    	mov.w     w2, [w14+490]
    8940:	63 b7 99    	mov.w     w3, [w14+492]

00008942 <.L0>:
    8942:	00 04 e0    	cp0.b     w0
    8944:	0f 00 3a    	bra       NZ, 0x8964 <.L0> <.L0> <.L397>
    8946:	0c 00 be    	mov.d     w12, w0
    8948:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    894a:	01 00 00 

0000894c <.L0>:
    894c:	60 22 b8    	mul.uu    w4, #0x0, w4
    894e:	54 b7 99    	mov.w     w4, [w14+490]
    8950:	65 b7 99    	mov.w     w5, [w14+492]
    8952:	00 04 e0    	cp0.b     w0
    8954:	07 00 3a    	bra       NZ, 0x8964 <.L0> <.L0> <.L397>

00008956 <.L0>:
    } else {
      tmp_5 = fmod(tmp_5, 65536.0);
    8956:	02 00 20    	mov.w     #0x0, w2
    8958:	03 78 24    	mov.w     #0x4780, w3
    895a:	0c 00 be    	mov.d     w12, w0
    895c:	26 19 02    	call      0x1926 <_fmodf>
    895e:	00 00 00 
    8960:	50 b7 99    	mov.w     w0, [w14+490]
    8962:	61 b7 99    	mov.w     w1, [w14+492]

00008964 <.L0>:
    }

    /* DataTypeConversion: '<S697>/Data Type Conversion' */
    if (rtIsNaN(tmp_6) || rtIsInf(tmp_6)) {
    8964:	08 00 be    	mov.d     w8, w0
    8966:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8968:	01 00 00 

0000896a <.L0>:
      tmp_6 = 0.0;
    896a:	60 66 b8    	mul.uu    w12, #0x0, w12

0000896c <.L0>:
    896c:	00 04 e0    	cp0.b     w0
    896e:	0b 00 3a    	bra       NZ, 0x8986 <.L0> <.L0> <.L398>
    8970:	08 00 be    	mov.d     w8, w0
    8972:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8974:	01 00 00 
    8976:	00 04 e0    	cp0.b     w0
    8978:	06 00 3a    	bra       NZ, 0x8986 <.L0> <.L0> <.L398>

0000897a <.L0>:
    } else {
      tmp_6 = fmod(tmp_6, 65536.0);
    897a:	02 00 20    	mov.w     #0x0, w2
    897c:	03 78 24    	mov.w     #0x4780, w3
    897e:	08 00 be    	mov.d     w8, w0
    8980:	26 19 02    	call      0x1926 <_fmodf>
    8982:	00 00 00 
    8984:	00 06 be    	mov.d     w0, w12

00008986 <.L0>:
    }

    /* DataTypeConversion: '<S694>/Data Type Conversion' */
    if (rtIsNaN(tmp_7) || rtIsInf(tmp_7)) {
    8986:	0a 00 be    	mov.d     w10, w0
    8988:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    898a:	01 00 00 
    898c:	00 41 78    	mov.b     w0, w2

0000898e <.L0>:
      tmp_7 = 0.0;
    898e:	60 00 b8    	mul.uu    w0, #0x0, w0

00008990 <.L0>:
    8990:	02 04 e0    	cp0.b     w2
    8992:	0c 00 3a    	bra       NZ, 0x89ac <.L0> <.L0> <.L399>
    8994:	0a 00 be    	mov.d     w10, w0
    8996:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8998:	01 00 00 
    899a:	00 41 78    	mov.b     w0, w2

0000899c <.L0>:
    899c:	60 00 b8    	mul.uu    w0, #0x0, w0
    899e:	02 04 e0    	cp0.b     w2
    89a0:	05 00 3a    	bra       NZ, 0x89ac <.L0> <.L0> <.L399>

000089a2 <.L0>:
    } else {
      tmp_7 = fmod(tmp_7, 65536.0);
    89a2:	02 00 20    	mov.w     #0x0, w2
    89a4:	03 78 24    	mov.w     #0x4780, w3
    89a6:	0a 00 be    	mov.d     w10, w0
    89a8:	26 19 02    	call      0x1926 <_fmodf>
    89aa:	00 00 00 

000089ac <.L0>:
    }

    /* MATLAB Function: '<S688>/myMux Fun1' incorporates:
     *  DataTypeConversion: '<S694>/Data Type Conversion'
     *  DataTypeConversion: '<S695>/Data Type Conversion'
     *  DataTypeConversion: '<S696>/Data Type Conversion'
     *  DataTypeConversion: '<S697>/Data Type Conversion'
     */
    AUAV_V3_TestSe_myMuxFun1_d((uint16_T)tmp_4, (uint16_T)tmp_5, (uint16_T)tmp_6,
    89ac:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    89ae:	00 00 00 
    89b0:	30 af 99    	mov.w     w0, [w14+470]
    89b2:	41 af 99    	mov.w     w1, [w14+472]
    89b4:	0c 00 be    	mov.d     w12, w0
    89b6:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    89b8:	00 00 00 
    89ba:	00 04 be    	mov.d     w0, w8
    89bc:	5e b0 91    	mov.w     [w14+490], w0
    89be:	ee b0 91    	mov.w     [w14+492], w1
    89c0:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    89c2:	00 00 00 
    89c4:	00 05 be    	mov.d     w0, w10
    89c6:	3e b0 91    	mov.w     [w14+486], w0
    89c8:	ce b0 91    	mov.w     [w14+488], w1
    89ca:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    89cc:	00 00 00 
    89ce:	00 03 be    	mov.d     w0, w6
    89d0:	84 9c 21    	mov.w     #0x19c8, w4
    89d2:	be a9 91    	mov.w     [w14+470], w3
    89d4:	08 01 78    	mov.w     w8, w2
    89d6:	8a 00 78    	mov.w     w10, w1
    89d8:	06 00 78    	mov.w     w6, w0
    89da:	5e e3 07    	rcall     0x5098 <_AUAV_V3_TestSe_myMuxFun1_d> <L0> <.LFB1489> <.LFE1488>
    89dc:	b0 00 37    	bra       0x8b3e <.L0> <.L393>

000089de <.L0>:
      (uint16_T)tmp_7, AUAV_V3_TestSensors_B.Merge_oc);

    /* End of Outputs for SubSystem: '<S682>/If  Control Type Is Wp, ISR, LP or  Mid Lvl Cmds' */
  } else if (rtb_DataTypeConversion1_hq == 2) {
    89de:	e2 cf 50    	sub.b     w1, #0x2, [w15]
    89e0:	0d 00 3a    	bra       NZ, 0x89fc <.L400>
    /* Outputs for IfAction SubSystem: '<S682>/If  Control Type Is Passthrough' incorporates:
     *  ActionPort: '<S686>/Action Port'
     */
    /* Gain: '<S686>/Gain4' incorporates:
     *  MATLAB Function: '<S656>/myMux Fun5'
     */
    AUAV_V3_TestSensors_B.Merge_oc[0] = AUAV_V3_TestSensors_B.InputCapture_o3 >>
    89e2:	00 ce 80    	mov.w     0x19c0, w0
    89e4:	00 00 d1    	lsr.w     w0, w0
    89e6:	40 ce 88    	mov.w     w0, 0x19c8
      1;
    AUAV_V3_TestSensors_B.Merge_oc[1] = AUAV_V3_TestSensors_B.InputCapture_o1 >>
    89e8:	e0 cd 80    	mov.w     0x19bc, w0
    89ea:	00 00 d1    	lsr.w     w0, w0
    89ec:	50 ce 88    	mov.w     w0, 0x19ca
      1;
    AUAV_V3_TestSensors_B.Merge_oc[2] = AUAV_V3_TestSensors_B.InputCapture_o4 >>
    89ee:	10 ce 80    	mov.w     0x19c2, w0
    89f0:	00 00 d1    	lsr.w     w0, w0
    89f2:	60 ce 88    	mov.w     w0, 0x19cc
      1;
    AUAV_V3_TestSensors_B.Merge_oc[3] = AUAV_V3_TestSensors_B.InputCapture_o2 >>
    89f4:	f0 cd 80    	mov.w     0x19be, w0
    89f6:	00 00 d1    	lsr.w     w0, w0
    89f8:	70 ce 88    	mov.w     w0, 0x19ce
    89fa:	a1 00 37    	bra       0x8b3e <.L0> <.L393>

000089fc <.L400>:
      1;

    /* End of Outputs for SubSystem: '<S682>/If  Control Type Is Passthrough' */
  } else {
    if (rtb_DataTypeConversion1_hq == 8) {
    89fc:	e8 cf 50    	sub.b     w1, #0x8, [w15]
    89fe:	9f 00 3a    	bra       NZ, 0x8b3e <.L0> <.L393>
      /* Switch: '<S687>/Switch' incorporates:
       *  Gain: '<S687>/Gain'
       *  MATLAB Function: '<S656>/myMux Fun5'
       */
      if (AUAV_V3_TestSensors_B.InitializeControlMCU[3] >= 1) {
    8a00:	60 a2 21    	mov.w     #0x1a26, w0
    8a02:	10 04 e0    	cp0.b     [w0]
    8a04:	04 00 32    	bra       Z, 0x8a0e <.L0> <.L401>
        rtb_u2deg = AUAV_V3_TestSensors_B.InputCapture_o3 >> 1;
    8a06:	05 ce 80    	mov.w     0x19c0, w5
    8a08:	85 02 d1    	lsr.w     w5, w5
    8a0a:	55 b7 99    	mov.w     w5, [w14+490]
    8a0c:	23 00 37    	bra       0x8a54 <.L0> <.L402>

00008a0e <.L0>:
      } else {
        /* DataTypeConversion: '<S690>/Data Type Conversion' incorporates:
         *  Constant: '<S690>/Constant1'
         *  Constant: '<S690>/Constant2'
         *  Product: '<S690>/Divide'
         *  Sum: '<S690>/Add'
         */
        tmp_4 = floor(rtb_y_jl_idx_0 * 2000.0 + 2000.0);
    8a0e:	02 00 20    	mov.w     #0x0, w2
    8a10:	a3 4f 24    	mov.w     #0x44fa, w3
    8a12:	7e 90 91    	mov.w     [w14+430], w0
    8a14:	8e 98 91    	mov.w     [w14+432], w1
    8a16:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8a18:	00 00 00 
    8a1a:	02 00 20    	mov.w     #0x0, w2
    8a1c:	a3 4f 24    	mov.w     #0x44fa, w3
    8a1e:	92 14 02    	call      0x1492 <___addsf3>
    8a20:	00 00 00 
    8a22:	16 19 02    	call      0x1916 <_floorf>
    8a24:	00 00 00 
    8a26:	00 06 be    	mov.d     w0, w12

00008a28 <.L0>:
        if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    8a28:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8a2a:	01 00 00 
          rtb_u2deg = 0U;
    8a2c:	80 00 eb    	clr.w     w1
    8a2e:	51 b7 99    	mov.w     w1, [w14+490]

00008a30 <.L0>:
    8a30:	00 04 e0    	cp0.b     w0
    8a32:	10 00 3a    	bra       NZ, 0x8a54 <.L0> <.L402>
    8a34:	0c 00 be    	mov.d     w12, w0
    8a36:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8a38:	01 00 00 

00008a3a <.L0>:
    8a3a:	00 01 eb    	clr.w     w2
    8a3c:	52 b7 99    	mov.w     w2, [w14+490]
    8a3e:	00 04 e0    	cp0.b     w0
    8a40:	09 00 3a    	bra       NZ, 0x8a54 <.L0> <.L402>

00008a42 <.L0>:
        } else {
          rtb_u2deg = (uint16_T)fmod(tmp_4, 65536.0);
    8a42:	02 00 20    	mov.w     #0x0, w2
    8a44:	03 78 24    	mov.w     #0x4780, w3
    8a46:	0c 00 be    	mov.d     w12, w0
    8a48:	26 19 02    	call      0x1926 <_fmodf>
    8a4a:	00 00 00 
    8a4c:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8a4e:	00 00 00 
    8a50:	80 01 78    	mov.w     w0, w3
    8a52:	53 b7 99    	mov.w     w3, [w14+490]

00008a54 <.L0>:
        }

        /* End of DataTypeConversion: '<S690>/Data Type Conversion' */
      }

      /* End of Switch: '<S687>/Switch' */

      /* Switch: '<S687>/Switch1' incorporates:
       *  Gain: '<S687>/Gain1'
       *  MATLAB Function: '<S656>/myMux Fun5'
       */
      if (AUAV_V3_TestSensors_B.InitializeControlMCU[2] >= 1) {
    8a54:	50 a2 21    	mov.w     #0x1a25, w0
    8a56:	10 04 e0    	cp0.b     [w0]
    8a58:	03 00 32    	bra       Z, 0x8a60 <.L0> <.L403>
        rtb_Switch1_m = AUAV_V3_TestSensors_B.InputCapture_o1 >> 1;
    8a5a:	ec cd 80    	mov.w     0x19bc, w12
    8a5c:	0c 06 d1    	lsr.w     w12, w12
    8a5e:	1e 00 37    	bra       0x8a9c <.L0> <.L404>

00008a60 <.L0>:
      } else {
        /* DataTypeConversion: '<S691>/Data Type Conversion' incorporates:
         *  Constant: '<S691>/Constant1'
         *  Constant: '<S691>/Constant2'
         *  MATLAB Function: '<Root>/myMux Fun1'
         *  Product: '<S691>/Divide'
         *  Sum: '<S691>/Add'
         */
        tmp_4 = floor(rtb_Sum1_mzp * -5729.5779513082325 + 3000.0000000000005);
    8a60:	02 ca 20    	mov.w     #0xca0, w2
    8a62:	33 5b 2c    	mov.w     #0xc5b3, w3
    8a64:	0a 00 be    	mov.d     w10, w0
    8a66:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8a68:	00 00 00 
    8a6a:	02 00 28    	mov.w     #0x8000, w2
    8a6c:	b3 53 24    	mov.w     #0x453b, w3
    8a6e:	92 14 02    	call      0x1492 <___addsf3>
    8a70:	00 00 00 
    8a72:	16 19 02    	call      0x1916 <_floorf>
    8a74:	00 00 00 
    8a76:	00 05 be    	mov.d     w0, w10

00008a78 <.L0>:
        if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    8a78:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8a7a:	01 00 00 
          rtb_Switch1_m = 0U;
    8a7c:	00 06 eb    	clr.w     w12

00008a7e <.L0>:
    8a7e:	00 04 e0    	cp0.b     w0
    8a80:	0d 00 3a    	bra       NZ, 0x8a9c <.L0> <.L404>
    8a82:	0a 00 be    	mov.d     w10, w0
    8a84:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8a86:	01 00 00 
    8a88:	00 04 e0    	cp0.b     w0
    8a8a:	08 00 3a    	bra       NZ, 0x8a9c <.L0> <.L404>

00008a8c <.L0>:
        } else {
          rtb_Switch1_m = (uint16_T)fmod(tmp_4, 65536.0);
    8a8c:	02 00 20    	mov.w     #0x0, w2
    8a8e:	03 78 24    	mov.w     #0x4780, w3
    8a90:	0a 00 be    	mov.d     w10, w0
    8a92:	26 19 02    	call      0x1926 <_fmodf>
    8a94:	00 00 00 
    8a96:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8a98:	00 00 00 
    8a9a:	00 06 78    	mov.w     w0, w12

00008a9c <.L0>:
        }

        /* End of DataTypeConversion: '<S691>/Data Type Conversion' */
      }

      /* End of Switch: '<S687>/Switch1' */

      /* Switch: '<S687>/Switch2' incorporates:
       *  Gain: '<S687>/Gain2'
       *  MATLAB Function: '<S656>/myMux Fun5'
       */
      if (AUAV_V3_TestSensors_B.InitializeControlMCU[1] >= 1) {
    8a9c:	40 a2 21    	mov.w     #0x1a24, w0
    8a9e:	10 04 e0    	cp0.b     [w0]
    8aa0:	03 00 32    	bra       Z, 0x8aa8 <.L0> <.L405>
        rtb_Switch2 = AUAV_V3_TestSensors_B.InputCapture_o4 >> 1;
    8aa2:	1a ce 80    	mov.w     0x19c2, w10
    8aa4:	0a 05 d1    	lsr.w     w10, w10
    8aa6:	1e 00 37    	bra       0x8ae4 <.L0> <.L406>

00008aa8 <.L0>:
      } else {
        /* DataTypeConversion: '<S692>/Data Type Conversion' incorporates:
         *  Constant: '<S692>/Constant1'
         *  Constant: '<S692>/Constant2'
         *  Product: '<S692>/Divide'
         *  Sum: '<S692>/Add'
         */
        tmp_4 = floor(rtb_cosphi * -5729.5779513082325 + 3000.0000000000005);
    8aa8:	02 ca 20    	mov.w     #0xca0, w2
    8aaa:	33 5b 2c    	mov.w     #0xc5b3, w3
    8aac:	08 00 be    	mov.d     w8, w0
    8aae:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8ab0:	00 00 00 
    8ab2:	02 00 28    	mov.w     #0x8000, w2
    8ab4:	b3 53 24    	mov.w     #0x453b, w3
    8ab6:	92 14 02    	call      0x1492 <___addsf3>
    8ab8:	00 00 00 
    8aba:	16 19 02    	call      0x1916 <_floorf>
    8abc:	00 00 00 
    8abe:	00 04 be    	mov.d     w0, w8

00008ac0 <.L0>:
        if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    8ac0:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8ac2:	01 00 00 
          rtb_Switch2 = 0U;
    8ac4:	00 05 eb    	clr.w     w10

00008ac6 <.L0>:
    8ac6:	00 04 e0    	cp0.b     w0
    8ac8:	0d 00 3a    	bra       NZ, 0x8ae4 <.L0> <.L406>
    8aca:	08 00 be    	mov.d     w8, w0
    8acc:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8ace:	01 00 00 
    8ad0:	00 04 e0    	cp0.b     w0
    8ad2:	08 00 3a    	bra       NZ, 0x8ae4 <.L0> <.L406>

00008ad4 <.L0>:
        } else {
          rtb_Switch2 = (uint16_T)fmod(tmp_4, 65536.0);
    8ad4:	02 00 20    	mov.w     #0x0, w2
    8ad6:	03 78 24    	mov.w     #0x4780, w3
    8ad8:	08 00 be    	mov.d     w8, w0
    8ada:	26 19 02    	call      0x1926 <_fmodf>
    8adc:	00 00 00 
    8ade:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8ae0:	00 00 00 
    8ae2:	00 05 78    	mov.w     w0, w10

00008ae4 <.L0>:
        }

        /* End of DataTypeConversion: '<S692>/Data Type Conversion' */
      }

      /* End of Switch: '<S687>/Switch2' */

      /* Switch: '<S687>/Switch3' incorporates:
       *  Gain: '<S687>/Gain3'
       *  MATLAB Function: '<S656>/myMux Fun5'
       */
      if (AUAV_V3_TestSensors_B.InitializeControlMCU[0] >= 1) {
    8ae4:	30 a2 21    	mov.w     #0x1a23, w0
    8ae6:	10 04 e0    	cp0.b     [w0]
    8ae8:	03 00 32    	bra       Z, 0x8af0 <.L0> <.L407>
        rtb_Switch3_fq = AUAV_V3_TestSensors_B.InputCapture_o2 >> 1;
    8aea:	f0 cd 80    	mov.w     0x19be, w0
    8aec:	00 00 d1    	lsr.w     w0, w0
    8aee:	21 00 37    	bra       0x8b32 <.L0> <.L0> <.L408>

00008af0 <.L0>:
      } else {
        /* DataTypeConversion: '<S689>/Data Type Conversion' incorporates:
         *  Constant: '<S689>/Constant1'
         *  Constant: '<S689>/Constant2'
         *  Product: '<S689>/Divide'
         *  Sum: '<S689>/Add'
         */
        tmp_4 = floor(rtb_IC4_idx_0 * 5729.5779513082325 + 3000.0000000000005);
    8af0:	02 ca 20    	mov.w     #0xca0, w2
    8af2:	33 5b 24    	mov.w     #0x45b3, w3
    8af4:	3e 98 91    	mov.w     [w14+438], w0
    8af6:	ce 98 91    	mov.w     [w14+440], w1
    8af8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    8afa:	00 00 00 
    8afc:	02 00 28    	mov.w     #0x8000, w2
    8afe:	b3 53 24    	mov.w     #0x453b, w3
    8b00:	92 14 02    	call      0x1492 <___addsf3>
    8b02:	00 00 00 
    8b04:	16 19 02    	call      0x1916 <_floorf>
    8b06:	00 00 00 
    8b08:	00 04 be    	mov.d     w0, w8

00008b0a <.L0>:
        if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    8b0a:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    8b0c:	01 00 00 
    8b0e:	80 40 78    	mov.b     w0, w1
          rtb_Switch3_fq = 0U;
    8b10:	00 00 eb    	clr.w     w0

00008b12 <.L0>:
    8b12:	01 04 e0    	cp0.b     w1
    8b14:	0e 00 3a    	bra       NZ, 0x8b32 <.L0> <.L0> <.L408>
    8b16:	08 00 be    	mov.d     w8, w0
    8b18:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    8b1a:	01 00 00 
    8b1c:	80 40 78    	mov.b     w0, w1

00008b1e <.L0>:
    8b1e:	00 00 eb    	clr.w     w0
    8b20:	01 04 e0    	cp0.b     w1
    8b22:	07 00 3a    	bra       NZ, 0x8b32 <.L0> <.L0> <.L408>

00008b24 <.L0>:
        } else {
          rtb_Switch3_fq = (uint16_T)fmod(tmp_4, 65536.0);
    8b24:	02 00 20    	mov.w     #0x0, w2
    8b26:	03 78 24    	mov.w     #0x4780, w3
    8b28:	08 00 be    	mov.d     w8, w0
    8b2a:	26 19 02    	call      0x1926 <_fmodf>
    8b2c:	00 00 00 
    8b2e:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8b30:	00 00 00 

00008b32 <.L0>:
        }

        /* End of DataTypeConversion: '<S689>/Data Type Conversion' */
      }

      /* End of Switch: '<S687>/Switch3' */

      /* MATLAB Function: '<S687>/myMux Fun1' */
      AUAV_V3_TestSe_myMuxFun1_d(rtb_u2deg, rtb_Switch1_m, rtb_Switch2,
    8b32:	84 9c 21    	mov.w     #0x19c8, w4
    8b34:	80 01 78    	mov.w     w0, w3
    8b36:	0a 01 78    	mov.w     w10, w2
    8b38:	8c 00 78    	mov.w     w12, w1
    8b3a:	5e b0 91    	mov.w     [w14+490], w0
    8b3c:	ad e2 07    	rcall     0x5098 <_AUAV_V3_TestSe_myMuxFun1_d> <L0> <.LFB1489> <.LFE1488>

00008b3e <.L0>:
        rtb_Switch3_fq, AUAV_V3_TestSensors_B.Merge_oc);

      /* End of Outputs for SubSystem: '<S682>/If  Control Type Is Selective Passthrough' */
    }
  }

  /* End of If: '<S682>/If' */

  /* DataStoreWrite: '<S20>/mlPwmCommands' incorporates:
   *  DataStoreRead: '<S20>/Get time3'
   *  DataTypeConversion: '<S681>/Data Type Conversion'
   *  Gain: '<S681>/Convert to  Microseconds'
   */
  mlPwmCommands.servo1_raw = (uint16_T)(52429UL *
    8b3e:	d2 cc 2c    	mov.w     #0xcccd, w2
    8b40:	40 ce 80    	mov.w     0x19c8, w0
    8b42:	02 00 b8    	mul.uu    w0, w2, w0
    AUAV_V3_TestSensors_B.Merge_oc[0] >> 18);
    8b44:	42 08 de    	lsr.w     w1, #0x2, w0
    8b46:	70 88 88    	mov.w     w0, 0x110e
  mlPwmCommands.servo2_raw = (uint16_T)(52429UL *
    8b48:	50 ce 80    	mov.w     0x19ca, w0
    8b4a:	02 00 b8    	mul.uu    w0, w2, w0
    AUAV_V3_TestSensors_B.Merge_oc[1] >> 18);
    8b4c:	42 08 de    	lsr.w     w1, #0x2, w0
    8b4e:	80 88 88    	mov.w     w0, 0x1110
  mlPwmCommands.servo3_raw = (uint16_T)(52429UL *
    8b50:	60 ce 80    	mov.w     0x19cc, w0
    8b52:	02 00 b8    	mul.uu    w0, w2, w0
    AUAV_V3_TestSensors_B.Merge_oc[2] >> 18);
    8b54:	42 08 de    	lsr.w     w1, #0x2, w0
    8b56:	90 88 88    	mov.w     w0, 0x1112
  mlPwmCommands.servo4_raw = (uint16_T)(52429UL *
    8b58:	70 ce 80    	mov.w     0x19ce, w0
    8b5a:	02 00 b8    	mul.uu    w0, w2, w0
    AUAV_V3_TestSensors_B.Merge_oc[3] >> 18);
    8b5c:	42 08 de    	lsr.w     w1, #0x2, w0
    8b5e:	a0 88 88    	mov.w     w0, 0x1114
  mlPwmCommands.time_usec = AUAV_V3_TestSensors_DWork.time_since_boot_usec;
    8b60:	84 ff 80    	mov.w     0x1ff0, w4
    8b62:	95 ff 80    	mov.w     0x1ff2, w5
    8b64:	54 88 88    	mov.w     w4, 0x110a
    8b66:	65 88 88    	mov.w     w5, 0x110c

  /* DataStoreWrite: '<S20>/mlAttitudePQR' */
  mlAttitudeSol.rollspeed = rtb_Product2_c[0];
    8b68:	0e 18 90    	mov.w     [w14+48], w0
    8b6a:	9e 18 90    	mov.w     [w14+50], w1
    8b6c:	70 0f 89    	mov.w     w0, 0x21ee
    8b6e:	81 0f 89    	mov.w     w1, 0x21f0
  mlAttitudeSol.pitchspeed = rtb_Product2_c[1];
    8b70:	2e 19 90    	mov.w     [w14+52], w2
    8b72:	be 19 90    	mov.w     [w14+54], w3
    8b74:	92 0f 89    	mov.w     w2, 0x21f2
    8b76:	a3 0f 89    	mov.w     w3, 0x21f4
  mlAttitudeSol.yawspeed = rtb_Product2_c[2];
    8b78:	4e 1a 90    	mov.w     [w14+56], w4
    8b7a:	de 1a 90    	mov.w     [w14+58], w5
    8b7c:	b4 0f 89    	mov.w     w4, 0x21f6
    8b7e:	c5 0f 89    	mov.w     w5, 0x21f8

00008b80 <.L0>:

  /* MATLAB Function: '<S665>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S665>/Constant'
   *  Constant: '<S665>/Constant1'
   *  DataTypeConversion: '<S656>/Data Type Conversion2'
   */
  AUA_EmbeddedMATLABFunction((real32_T)AUAV_V3_TestSensors_B.InputCapture_o6,
    8b80:	c0 d0 80    	mov.w     0x1a18, w0
    8b82:	80 00 eb    	clr.w     w1
    8b84:	12 19 02    	call      0x1912 <___floatunsisf>
    8b86:	00 00 00 
    8b88:	e7 02 22    	mov.w     #0x202e, w7
    8b8a:	46 b1 21    	mov.w     #0x1b14, w6
    8b8c:	d4 cc 2c    	mov.w     #0xcccd, w4
    8b8e:	c5 dc 23    	mov.w     #0x3dcc, w5
    8b90:	a2 70 2d    	mov.w     #0xd70a, w2
    8b92:	33 c2 23    	mov.w     #0x3c23, w3
    8b94:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    8b96:	01 00 00 

00008b98 <.L0>:
    0.01, 0.1, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction);

  /* DataTypeConversion: '<S656>/Data Type Conversion1' */
  rtb_RhhcosphicoslambXe = (real32_T)floor
    8b98:	a0 d8 80    	mov.w     0x1b14, w0
    8b9a:	b1 d8 80    	mov.w     0x1b16, w1
    8b9c:	16 19 02    	call      0x1916 <_floorf>
    8b9e:	00 00 00 
    8ba0:	00 04 be    	mov.d     w0, w8

00008ba2 <.L0>:
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction.y);
  if (rtIsNaNF(rtb_RhhcosphicoslambXe) || rtIsInfF(rtb_RhhcosphicoslambXe)) {
    8ba2:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    8ba4:	01 00 00 
    rtb_RhhcosphicoslambXe = 0.0F;
    8ba6:	60 66 b8    	mul.uu    w12, #0x0, w12

00008ba8 <.L0>:
    8ba8:	00 04 e0    	cp0.b     w0
    8baa:	0b 00 3a    	bra       NZ, 0x8bc2 <.L0> <.L0> <.L409>
    8bac:	08 00 be    	mov.d     w8, w0
    8bae:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    8bb0:	01 00 00 
    8bb2:	00 04 e0    	cp0.b     w0
    8bb4:	06 00 3a    	bra       NZ, 0x8bc2 <.L0> <.L0> <.L409>

00008bb6 <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = (real32_T)fmod(rtb_RhhcosphicoslambXe, 65536.0F);
    8bb6:	02 00 20    	mov.w     #0x0, w2
    8bb8:	03 78 24    	mov.w     #0x4780, w3
    8bba:	08 00 be    	mov.d     w8, w0
    8bbc:	26 19 02    	call      0x1926 <_fmodf>
    8bbe:	00 00 00 
    8bc0:	00 06 be    	mov.d     w0, w12

00008bc2 <.L0>:
  }

  /* MATLAB Function: '<S666>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S666>/Constant'
   *  Constant: '<S666>/Constant1'
   *  DataTypeConversion: '<S656>/Data Type Conversion3'
   */
  AUA_EmbeddedMATLABFunction((real32_T)AUAV_V3_TestSensors_B.InputCapture_o7,
    8bc2:	d0 d0 80    	mov.w     0x1a1a, w0
    8bc4:	80 00 eb    	clr.w     w1
    8bc6:	12 19 02    	call      0x1912 <___floatunsisf>
    8bc8:	00 00 00 
    8bca:	c7 01 22    	mov.w     #0x201c, w7
    8bcc:	06 b1 21    	mov.w     #0x1b10, w6
    8bce:	d4 cc 2c    	mov.w     #0xcccd, w4
    8bd0:	c5 dc 23    	mov.w     #0x3dcc, w5
    8bd2:	a2 70 2d    	mov.w     #0xd70a, w2
    8bd4:	33 c2 23    	mov.w     #0x3c23, w3
    8bd6:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    8bd8:	01 00 00 

00008bda <.L0>:
    0.01, 0.1, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_b);

  /* DataTypeConversion: '<S656>/Data Type Conversion4' */
  /* MATLAB Function 'Trim Vals [updated 4.28.16]/Control Surface Input/myMux Fun1': '<S667>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S667>:1:5' */
  rtb_Sum1_mzp = (real32_T)floor
    8bda:	80 d8 80    	mov.w     0x1b10, w0
    8bdc:	91 d8 80    	mov.w     0x1b12, w1
    8bde:	16 19 02    	call      0x1916 <_floorf>
    8be0:	00 00 00 
    8be2:	00 04 be    	mov.d     w0, w8

00008be4 <.L0>:
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_b.y);
  if (rtIsNaNF(rtb_Sum1_mzp) || rtIsInfF(rtb_Sum1_mzp)) {
    8be4:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    8be6:	01 00 00 
    rtb_Sum1_mzp = 0.0F;
    8be8:	60 55 b8    	mul.uu    w10, #0x0, w10

00008bea <.L0>:
    8bea:	00 04 e0    	cp0.b     w0
    8bec:	0b 00 3a    	bra       NZ, 0x8c04 <.L0> <.L0> <.L410>
    8bee:	08 00 be    	mov.d     w8, w0
    8bf0:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    8bf2:	01 00 00 
    8bf4:	00 04 e0    	cp0.b     w0
    8bf6:	06 00 3a    	bra       NZ, 0x8c04 <.L0> <.L0> <.L410>

00008bf8 <.L0>:
  } else {
    rtb_Sum1_mzp = (real32_T)fmod(rtb_Sum1_mzp, 65536.0F);
    8bf8:	02 00 20    	mov.w     #0x0, w2
    8bfa:	03 78 24    	mov.w     #0x4780, w3
    8bfc:	08 00 be    	mov.d     w8, w0
    8bfe:	26 19 02    	call      0x1926 <_fmodf>
    8c00:	00 00 00 
    8c02:	00 05 be    	mov.d     w0, w10

00008c04 <.L0>:
  }

  /* DataStoreWrite: '<S20>/mlAttitude' incorporates:
   *  DataTypeConversion: '<S656>/Data Type Conversion1'
   *  DataTypeConversion: '<S656>/Data Type Conversion4'
   */
  mlVISensor.voltage = rtb_RhhcosphicoslambXe < 0.0F ? (uint16_T)-(int16_T)
    (uint16_T)-rtb_RhhcosphicoslambXe : (uint16_T)rtb_RhhcosphicoslambXe;
    8c04:	60 11 b8    	mul.uu    w2, #0x0, w2
    8c06:	0c 00 be    	mov.d     w12, w0
    8c08:	8c 18 02    	call      0x188c <___eqsf2>
    8c0a:	00 00 00 
    8c0c:	00 00 e0    	cp0.w     w0
    8c0e:	06 00 3d    	bra       GE, 0x8c1c <.L0> <.L643>
    8c10:	0c 00 be    	mov.d     w12, w0
    8c12:	01 f0 a2    	btg.w     w1, #0xf
    8c14:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8c16:	00 00 00 

00008c18 <.L0>:
    8c18:	00 00 ea    	neg.w     w0, w0
    8c1a:	03 00 37    	bra       0x8c22 <.L0> <.L413>

00008c1c <.L0>:
    8c1c:	0c 00 be    	mov.d     w12, w0
    8c1e:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8c20:	00 00 00 

00008c22 <.L0>:
    8c22:	00 a7 88    	mov.w     w0, 0x14e0

00008c24 <.L0>:
  mlVISensor.reading2 = rtb_Sum1_mzp < 0.0F ? (uint16_T)-(int16_T)(uint16_T)
    -rtb_Sum1_mzp : (uint16_T)rtb_Sum1_mzp;
    8c24:	60 11 b8    	mul.uu    w2, #0x0, w2
    8c26:	0a 00 be    	mov.d     w10, w0
    8c28:	8c 18 02    	call      0x188c <___eqsf2>
    8c2a:	00 00 00 
    8c2c:	00 00 e0    	cp0.w     w0
    8c2e:	06 00 3d    	bra       GE, 0x8c3c <.L0> <.L644>
    8c30:	0a 00 be    	mov.d     w10, w0
    8c32:	01 f0 a2    	btg.w     w1, #0xf

00008c34 <.L0>:
    8c34:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8c36:	00 00 00 
    8c38:	00 00 ea    	neg.w     w0, w0
    8c3a:	03 00 37    	bra       0x8c42 <.L0> <.L416>

00008c3c <.L0>:
    8c3c:	0a 00 be    	mov.d     w10, w0
    8c3e:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    8c40:	00 00 00 

00008c42 <.L0>:
    8c42:	10 a7 88    	mov.w     w0, 0x14e2

00008c44 <.L0>:

  /* Outputs for Enabled SubSystem: '<S20>/Send_Cmd_6DOF_HIL' incorporates:
   *  EnablePort: '<S683>/Enable'
   */
  /* DataStoreRead: '<S20>/Data Store Read' incorporates:
   *  Constant: '<S683>/COMP_ID'
   *  Constant: '<S683>/SYS_ID'
   */
  if (AUAV_V3_TestSensors_DWork.SIX_DOF_HIL_FLAG > 0.0) {
    8c44:	60 11 b8    	mul.uu    w2, #0x0, w2
    8c46:	60 ec 80    	mov.w     0x1d8c, w0
    8c48:	71 ec 80    	mov.w     0x1d8e, w1
    8c4a:	90 18 02    	call      0x1890 <___gesf2>
    8c4c:	00 00 00 
    8c4e:	00 00 e0    	cp0.w     w0
    8c50:	17 00 34    	bra       LE, 0x8c80 <.L0> <.L417>

00008c52 <.L0>:
    /* DataStoreRead: '<S683>/Get Raw Commands' */
    AUAV_V3_TestSensors_B.GetRawCommands = mlPwmCommands;
    8c52:	00 59 21    	mov.w     #0x1590, w0
    8c54:	a5 10 21    	mov.w     #0x110a, w5
    8c56:	0a 00 09    	.pword 0x09000a
    8c58:	35 18 78    	mov.w     [w5++], [w0++]
    8c5a:	60 01 b1    	sub.w     #0x16, w0

    /* DataStoreRead: '<S683>/Get time5' */
    AUAV_V3_TestSensors_B.Gettime5 =
      AUAV_V3_TestSensors_DWork.time_since_boot_usec;
    8c5c:	82 ff 80    	mov.w     0x1ff0, w2
    8c5e:	93 ff 80    	mov.w     0x1ff2, w3
    8c60:	72 c8 88    	mov.w     w2, 0x190e
    8c62:	83 c8 88    	mov.w     w3, 0x1910

00008c64 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S683>/PackRawServo' */
    AUAV_V3_TestSensors_B.PackRawServo_l = HIL_PackRawServo(
    8c64:	f6 87 47    	add.w     w15, #0x16, w15
    8c66:	76 84 57    	sub.w     w15, #0x16, w8
    8c68:	0a 00 09    	.pword 0x09000a
    8c6a:	30 1c 78    	mov.w     [w0++], [w8++]
    8c6c:	68 01 b1    	sub.w     #0x16, w8
    8c6e:	60 01 b1    	sub.w     #0x16, w0
    8c70:	11 c0 b3    	mov.b     #0x1, w1
    8c72:	50 c6 b3    	mov.b     #0x65, w0
    8c74:	e8 d2 02    	call      0xd2e8 <_HIL_PackRawServo>
    8c76:	00 00 00 
    8c78:	a0 ce 88    	mov.w     w0, 0x19d4

00008c7a <.L0>:
      ((uint8_T)101U)
      , ((uint8_T)1U)
      , AUAV_V3_TestSensors_B.GetRawCommands
      , AUAV_V3_TestSensors_B.Gettime5
      );

    /* S-Function (MCHP_C_function_Call): '<S683>/TX_N_Data9' */
    TxN_Data_OverU4(
    8c7a:	18 d6 02    	call      0xd618 <_TxN_Data_OverU4>
    8c7c:	00 00 00 
    8c7e:	88 07 78    	mov.w     w8, w15

00008c80 <.L0>:
                    AUAV_V3_TestSensors_B.PackRawServo_l
                    );
  }

  /* End of DataStoreRead: '<S20>/Data Store Read' */
  /* End of Outputs for SubSystem: '<S20>/Send_Cmd_6DOF_HIL' */

  /* Outputs for Enabled SubSystem: '<S20>/Send_Cmd_X_Plane_HIL' incorporates:
   *  EnablePort: '<S684>/Enable'
   */
  /* DataStoreRead: '<S20>/Data Store Read1' */
  if (AUAV_V3_TestSensors_DWork.X_PLANE_HIL_FLAG > 0.0) {
    8c80:	60 11 b8    	mul.uu    w2, #0x0, w2
    8c82:	80 ec 80    	mov.w     0x1d90, w0
    8c84:	91 ec 80    	mov.w     0x1d92, w1
    8c86:	90 18 02    	call      0x1890 <___gesf2>
    8c88:	00 00 00 
    8c8a:	00 00 e0    	cp0.w     w0
    8c8c:	05 00 34    	bra       LE, 0x8c98 <.L419>

00008c8e <.L0>:
    /* S-Function (MCHP_C_function_Call): '<S684>/PackRawServo' */
    AUAV_V3_TestSensors_B.PackRawServo = send_HILSIM_outputs(
    8c8e:	14 f2 02    	call      0xf214 <_send_HILSIM_outputs>
    8c90:	00 00 00 
    8c92:	90 ce 88    	mov.w     w0, 0x19d2

00008c94 <.L0>:
      );

    /* S-Function (MCHP_C_function_Call): '<S684>/TX_N_Data9' */
    TxN_Data_OverU4(
    8c94:	18 d6 02    	call      0xd618 <_TxN_Data_OverU4>
    8c96:	00 00 00 

00008c98 <.L419>:
                    AUAV_V3_TestSensors_B.PackRawServo
                    );
  }

  /* End of DataStoreRead: '<S20>/Data Store Read1' */
  /* End of Outputs for SubSystem: '<S20>/Send_Cmd_X_Plane_HIL' */

  /* DataStoreWrite: '<S656>/Update Control Surface DATA' */
  mlPilotConsoleData.chan1_raw = AUAV_V3_TestSensors_B.InputCapture_o1;
    8c98:	e0 cd 80    	mov.w     0x19bc, w0
    8c9a:	50 84 88    	mov.w     w0, 0x108a
  mlPilotConsoleData.chan2_raw = AUAV_V3_TestSensors_B.InputCapture_o2;
    8c9c:	f1 cd 80    	mov.w     0x19be, w1
    8c9e:	61 84 88    	mov.w     w1, 0x108c
  mlPilotConsoleData.chan3_raw = AUAV_V3_TestSensors_B.InputCapture_o3;
    8ca0:	02 ce 80    	mov.w     0x19c0, w2
    8ca2:	72 84 88    	mov.w     w2, 0x108e
  mlPilotConsoleData.chan4_raw = AUAV_V3_TestSensors_B.InputCapture_o4;
    8ca4:	13 ce 80    	mov.w     0x19c2, w3
    8ca6:	83 84 88    	mov.w     w3, 0x1090
  mlPilotConsoleData.chan5_raw = AUAV_V3_TestSensors_B.InputCapture_o5;
    8ca8:	24 ce 80    	mov.w     0x19c4, w4
    8caa:	94 84 88    	mov.w     w4, 0x1092
  mlPilotConsoleData.chan6_raw = AUAV_V3_TestSensors_B.InputCapture_o6;
    8cac:	c5 d0 80    	mov.w     0x1a18, w5
    8cae:	a5 84 88    	mov.w     w5, 0x1094
  mlPilotConsoleData.chan7_raw = AUAV_V3_TestSensors_B.InputCapture_o7;
    8cb0:	d0 d0 80    	mov.w     0x1a1a, w0
    8cb2:	b0 84 88    	mov.w     w0, 0x1096
  mlPilotConsoleData.chan8_raw = AUAV_V3_TestSensors_B.InputCapture_o8;
    8cb4:	e1 d0 80    	mov.w     0x1a1c, w1
    8cb6:	c1 84 88    	mov.w     w1, 0x1098

  /* DataStoreWrite: '<Root>/Data Store Write' incorporates:
   *  Constant: '<Root>/Constant3'
   */
  AUAV_V3_TestSensors_DWork.SIX_DOF_HIL_FLAG = 0.0;
    8cb8:	60 00 b8    	mul.uu    w0, #0x0, w0
    8cba:	60 ec 88    	mov.w     w0, 0x1d8c
    8cbc:	71 ec 88    	mov.w     w1, 0x1d8e

  /* DataStoreWrite: '<Root>/Data Store Write1' incorporates:
   *  Constant: '<Root>/Constant4'
   */
  AUAV_V3_TestSensors_DWork.X_PLANE_HIL_FLAG = 1.0;
    8cbe:	00 00 20    	mov.w     #0x0, w0
    8cc0:	01 f8 23    	mov.w     #0x3f80, w1
    8cc2:	80 ec 88    	mov.w     w0, 0x1d90
    8cc4:	91 ec 88    	mov.w     w1, 0x1d92

  /* Gain: '<Root>/Gain' incorporates:
   *  UnitDelay: '<S3>/Output'
   */
  tmp_a = 3276800000UL;
    8cc6:	00 00 20    	mov.w     #0x0, w0
    8cc8:	01 35 2c    	mov.w     #0xc350, w1
    8cca:	20 37 99    	mov.w     w0, [w14+356]
    8ccc:	31 37 99    	mov.w     w1, [w14+358]

00008cce <.L0>:
  uMultiWordMul(&tmp_a, 1, &AUAV_V3_TestSensors_DWork.Output_DSTATE, 1,
    8cce:	25 00 20    	mov.w     #0x2, w5
    8cd0:	c4 15 20    	mov.w     #0x15c, w4
    8cd2:	0e 02 42    	add.w     w4, w14, w4
    8cd4:	13 00 20    	mov.w     #0x1, w3
    8cd6:	02 fb 21    	mov.w     #0x1fb0, w2
    8cd8:	83 00 78    	mov.w     w3, w1
    8cda:	40 16 20    	mov.w     #0x164, w0
    8cdc:	0e 00 40    	add.w     w0, w14, w0
    8cde:	4e e0 07    	rcall     0x4d7c <_uMultiWordMul> <L0> <.LFB1480> <.LFE1479>

00008ce0 <.L0>:
                &tmp_9.chunks[0U], 2);

  /* DataTypeConversion: '<Root>/Data Type Conversion6' */
  uMultiWordShr(&tmp_9.chunks[0U], 2, 15U, &tmp_8.chunks[0U], 2);
    8ce0:	24 00 20    	mov.w     #0x2, w4
    8ce2:	43 15 20    	mov.w     #0x154, w3
    8ce4:	8e 81 41    	add.w     w3, w14, w3
    8ce6:	f2 00 20    	mov.w     #0xf, w2
    8ce8:	84 00 78    	mov.w     w4, w1
    8cea:	c0 15 20    	mov.w     #0x15c, w0
    8cec:	0e 00 40    	add.w     w0, w14, w0
    8cee:	ce df 07    	rcall     0x4c8c <_uMultiWordShr> <L0> <.LFB1479> <.LFE1478>

00008cf0 <.L0>:

  /* DataStoreWrite: '<Root>/Update time' incorporates:
   *  DataTypeConversion: '<Root>/Data Type Conversion6'
   */
  AUAV_V3_TestSensors_DWork.time_since_boot_usec = MultiWord2uLong
    (&tmp_8.chunks[0U]);
    8cf0:	40 15 20    	mov.w     #0x154, w0
    8cf2:	0e 00 40    	add.w     w0, w14, w0
    8cf4:	c9 df 07    	rcall     0x4c88 <_MultiWord2uLong> <L0> <.LFB1478> <.LFE1477>

00008cf6 <.L0>:
    8cf6:	0c ff 21    	mov.w     #0x1ff0, w12
    8cf8:	00 8e be    	mov.d     w0, [w12]

  /* S-Function "MCHP_MCU_LOAD" Block: <Root>/MCU Load */
  AUAV_V3_TestSensors_B.U3CH4 = MCHP_MCULoadResult[0];
    8cfa:	a0 82 80    	mov.w     0x1054, w0
    8cfc:	80 ce 88    	mov.w     w0, 0x19d0

00008cfe <.L0>:

  /* DataStoreWrite: '<Root>/Update SysStatus Load' */
  mlSysStatus.load = AUAV_V3_TestSensors_B.U3CH4;
    8cfe:	30 10 89    	mov.w     w0, 0x2206

00008d00 <.L0>:

  /* Outputs for Atomic SubSystem: '<Root>/Barometer_Driver' */
  AUAV_V3_T_Barometer_Driver();
    8d00:	f4 e6 02    	call      0xe6f4 <_AUAV_V3_T_Barometer_Driver>
    8d02:	00 00 00 

00008d04 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Barometer_Driver' */

  /* Outputs for Atomic SubSystem: '<Root>/IMU_Mag_Driver' */
  AUAV_V3_Tes_IMU_Mag_Driver();
    8d04:	8c 09 02    	call      0x1098c <_AUAV_V3_Tes_IMU_Mag_Driver>
    8d06:	01 00 00 

00008d08 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/IMU_Mag_Driver' */

  /* MATLAB Function: '<Root>/myMux Fun4' */
  AUAV_V3_TestSens_myMuxFun3(AUAV_V3_TestSensors_B.BiasRateLimiter,
    8d08:	e2 ac 21    	mov.w     #0x1ace, w2
    8d0a:	41 c6 2f    	mov.w     #0xfc64, w1
    8d0c:	82 80 40    	add.w     w1, w2, w1
    8d0e:	7c 80 40    	add.w     w1, #0x1c, w0
    8d10:	c8 e1 07    	rcall     0x50a2 <_AUAV_V3_TestSens_myMuxFun3> <L0> <.LFB1490> <.LFE1489>

00008d12 <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1,
    &AUAV_V3_TestSensors_B.sf_myMuxFun4);

  /* MATLAB Function: '<Root>/myMux Fun3' */
  AUAV_V3_TestSens_myMuxFun3(AUAV_V3_TestSensors_B.sf_myMuxFun1_e.y,
    8d12:	62 ae 21    	mov.w     #0x1ae6, w2
    8d14:	61 0f 20    	mov.w     #0xf6, w1
    8d16:	82 80 40    	add.w     w1, w2, w1
    8d18:	6c 80 40    	add.w     w1, #0xc, w0
    8d1a:	c3 e1 07    	rcall     0x50a2 <_AUAV_V3_TestSens_myMuxFun3> <L0> <.LFB1490> <.LFE1489>

00008d1c <.L0>:
    AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y, &AUAV_V3_TestSensors_B.sf_myMuxFun3);

  /* MATLAB Function: '<Root>/myMux Fun5' */
  /* MATLAB Function 'myMux Fun5': '<S26>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S26>:1:5' */
  AUAV_V3_TestSensors_B.y[0] = AUAV_V3_TestSensors_B.DataTypeConversion3[0];
    8d1c:	aa 5e 21    	mov.w     #0x15ea, w10
    8d1e:	b2 b3 80    	mov.w     0x1676, w2
    8d20:	c3 b3 80    	mov.w     0x1678, w3
    8d22:	02 8d be    	mov.d     w2, [w10]
  AUAV_V3_TestSensors_B.y[1] = AUAV_V3_TestSensors_B.DataTypeConversion3[1];
    8d24:	d4 b3 80    	mov.w     0x167a, w4
    8d26:	e5 b3 80    	mov.w     0x167c, w5
    8d28:	74 af 88    	mov.w     w4, 0x15ee
    8d2a:	85 af 88    	mov.w     w5, 0x15f0
  AUAV_V3_TestSensors_B.y[2] = AUAV_V3_TestSensors_B.DataTypeConversion3[2];
    8d2c:	f0 b3 80    	mov.w     0x167e, w0
    8d2e:	01 b4 80    	mov.w     0x1680, w1
    8d30:	90 af 88    	mov.w     w0, 0x15f2
    8d32:	a1 af 88    	mov.w     w1, 0x15f4
  AUAV_V3_TestSensors_B.y[3] = AUAV_V3_TestSensors_B.DataTypeConversion6[0];
    8d34:	12 b4 80    	mov.w     0x1682, w2
    8d36:	23 b4 80    	mov.w     0x1684, w3
    8d38:	b2 af 88    	mov.w     w2, 0x15f6
    8d3a:	c3 af 88    	mov.w     w3, 0x15f8
  AUAV_V3_TestSensors_B.y[4] = AUAV_V3_TestSensors_B.DataTypeConversion6[1];
    8d3c:	34 b4 80    	mov.w     0x1686, w4
    8d3e:	45 b4 80    	mov.w     0x1688, w5
    8d40:	d4 af 88    	mov.w     w4, 0x15fa
    8d42:	e5 af 88    	mov.w     w5, 0x15fc

00008d44 <.L0>:
  AUAV_V3_TestSensors_B.y[5] = AUAV_V3_TestSensors_B.DataTypeConversion6[2];
    8d44:	50 b4 80    	mov.w     0x168a, w0
    8d46:	61 b4 80    	mov.w     0x168c, w1
    8d48:	f0 af 88    	mov.w     w0, 0x15fe
    8d4a:	01 b0 88    	mov.w     w1, 0x1600

00008d4c <.L0>:
  AUAV_V3_TestSensors_B.y[6] = AUAV_V3_TestSensors_B.DataTypeConversion7[0];
    8d4c:	52 b3 80    	mov.w     0x166a, w2
    8d4e:	63 b3 80    	mov.w     0x166c, w3
    8d50:	12 b0 88    	mov.w     w2, 0x1602
    8d52:	23 b0 88    	mov.w     w3, 0x1604
  AUAV_V3_TestSensors_B.y[7] = AUAV_V3_TestSensors_B.DataTypeConversion7[1];
    8d54:	74 b3 80    	mov.w     0x166e, w4
    8d56:	85 b3 80    	mov.w     0x1670, w5
    8d58:	34 b0 88    	mov.w     w4, 0x1606
    8d5a:	45 b0 88    	mov.w     w5, 0x1608
  AUAV_V3_TestSensors_B.y[8] = AUAV_V3_TestSensors_B.DataTypeConversion7[2];
    8d5c:	90 b3 80    	mov.w     0x1672, w0
    8d5e:	a1 b3 80    	mov.w     0x1674, w1
    8d60:	50 b0 88    	mov.w     w0, 0x160a
    8d62:	61 b0 88    	mov.w     w1, 0x160c

  /* DataStoreRead: '<Root>/Get time4' */
  AUAV_V3_TestSensors_B.Gettime4 =
    8d64:	08 32 20    	mov.w     #0x320, w8
    8d66:	0a 04 44    	add.w     w8, w10, w8
    8d68:	3c 1c 78    	mov.w     [w12++], [w8++]
    8d6a:	2c 14 78    	mov.w     [w12--], [w8--]

00008d6c <.L0>:
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;

  /* S-Function (MCHP_C_function_Call): '<S18>/Update Euler and PQR [updateSensorMcuState.c]1' */
  updateEuler(
    8d6c:	40 d0 2f    	mov.w     #0xfd04, w0
    8d6e:	08 00 40    	add.w     w0, w8, w0
    8d70:	7e 0e 02    	call      0x10e7e <_updateEuler>
    8d72:	01 00 00 

00008d74 <.L0>:
              &AUAV_V3_TestSensors_B.y_k[0]
              );

  /* S-Function (MCHP_C_function_Call): '<S18>/Update the Time Stamp [updateSensorMcuState.c]1' */
  updateTimeStamp(
    8d74:	18 00 be    	mov.d     [w8], w0
    8d76:	fe fd 02    	call      0xfdfe <_updateTimeStamp>
    8d78:	00 00 00 

00008d7a <.L0>:
                  AUAV_V3_TestSensors_B.Gettime4
                  );

  /* S-Function (MCHP_C_function_Call): '<S18>/Update the Time Stamp [updateSensorMcuState.c]2' */
  updateSensorData(
    8d7a:	0a 00 78    	mov.w     w10, w0
    8d7c:	ac fe 02    	call      0xfeac <_updateSensorData>
    8d7e:	00 00 00 

00008d80 <.L0>:
                   &AUAV_V3_TestSensors_B.y[0]
                   );

  /* S-Function (MCHP_C_function_Call): '<S18>/Update the Time Stamp [updateSensorMcuState.c]7' */
  updatePosition(
    8d80:	c0 1d 20    	mov.w     #0x1dc, w0
    8d82:	08 00 40    	add.w     w0, w8, w0
    8d84:	10 fe 02    	call      0xfe10 <_updatePosition>
    8d86:	00 00 00 

00008d88 <.L0>:
                 &AUAV_V3_TestSensors_B.sf_myMuxFun3.y[0]
                 );

  /* S-Function (MCHP_C_function_Call): '<S18>/Update the Time Stamp [updateSensorMcuState.c]6' */
  updateBias(
    8d88:	40 1c 20    	mov.w     #0x1c4, w0
    8d8a:	08 00 40    	add.w     w0, w8, w0
    8d8c:	7c fe 02    	call      0xfe7c <_updateBias>
    8d8e:	00 00 00 

00008d90 <.L0>:
             &AUAV_V3_TestSensors_B.sf_myMuxFun4.y[0]
             );

  /* S-Function (MCHP_Digital_Input): '<Root>/Config UART4 Rx Pin' */

  /* MCHP_Digital_Input Block: <Root>/Config UART4 Rx Pin/Output */
  rtb_ConfigUART4RxPin = PORTEbits.RE6;/* Read pin E6 */
    8d90:	10 72 80    	mov.w     0xe42, w0

00008d92 <.L0>:

  /* Switch: '<S59>/FixPt Switch' incorporates:
   *  Constant: '<S58>/FixPt Constant'
   *  Sum: '<S58>/FixPt Sum1'
   *  UnitDelay: '<S3>/Output'
   */
  AUAV_V3_TestSensors_DWork.Output_DSTATE++;
    8d92:	00 fc 2f    	mov.w     #0xffc0, w0
    8d94:	0c 00 40    	add.w     w0, w12, w0
    8d96:	12 00 20    	mov.w     #0x1, w2
    8d98:	03 00 20    	mov.w     #0x0, w3
    8d9a:	10 08 41    	add.w     w2, [w0], [w0]
    8d9c:	50 90 49    	addc.w    w3, [++w0], [w0--]

00008d9e <.L0>:

  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID0();
    8d9e:	00 03 02    	call      0x10300 <_AUAV_V3_Mavlink_TX_AdapterTID0>
    8da0:	01 00 00 

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */

  /* Update for Delay: '<S73>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE = rtb_Switch3;
    8da2:	7e aa 91    	mov.w     [w14+478], w4
    8da4:	8e b2 91    	mov.w     [w14+480], w5
    8da6:	c4 ec 88    	mov.w     w4, 0x1d98
    8da8:	d5 ec 88    	mov.w     w5, 0x1d9a

  /* Update for Delay: '<S74>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_k = rtb_Deg2R_h_idx_0;
    8daa:	5e a0 91    	mov.w     [w14+458], w0
    8dac:	ee a0 91    	mov.w     [w14+460], w1
    8dae:	e0 ec 88    	mov.w     w0, 0x1d9c
    8db0:	f1 ec 88    	mov.w     w1, 0x1d9e

  /* Update for Enabled SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' incorporates:
   *  Update for EnablePort: '<S69>/Enable'
   */
  if (AUAV_V3_TestSensors_DWork.L1OutputFeedbackControllerWithP) {
    8db2:	7a 00 46    	add.w     w12, #0x1a, w0
    8db4:	10 04 e0    	cp0.b     [w0]
    8db6:	3c 00 32    	bra       Z, 0x8e30 <.L421>
    /* Update for UnitDelay: '<S89>/UD' */
    AUAV_V3_TestSensors_DWork.UD_DSTATE_ff = rtb_IC4_idx_1;
    8db8:	7e 89 91    	mov.w     [w14+414], w2
    8dba:	8e 91 91    	mov.w     [w14+416], w3
    8dbc:	62 fb 88    	mov.w     w2, 0x1f6c
    8dbe:	73 fb 88    	mov.w     w3, 0x1f6e

    /* Update for Delay: '<S79>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_an = rtb_Switch1_a;
    8dc0:	1e 92 91    	mov.w     [w14+418], w4
    8dc2:	ae 92 91    	mov.w     [w14+420], w5
    8dc4:	84 fb 88    	mov.w     w4, 0x1f70
    8dc6:	95 fb 88    	mov.w     w5, 0x1f72

    /* Update for Delay: '<S79>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_i = rtb_Subtract_od;
    8dc8:	2e 80 91    	mov.w     [w14+388], w0
    8dca:	be 80 91    	mov.w     [w14+390], w1
    8dcc:	a0 fb 88    	mov.w     w0, 0x1f74
    8dce:	b1 fb 88    	mov.w     w1, 0x1f76

    /* Update for Delay: '<S81>/Integer Delay3' */
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_fs = rtb_Switch3_gd;
    8dd0:	0e 81 91    	mov.w     [w14+384], w2
    8dd2:	9e 81 91    	mov.w     [w14+386], w3
    8dd4:	c2 fb 88    	mov.w     w2, 0x1f78
    8dd6:	d3 fb 88    	mov.w     w3, 0x1f7a

    /* Update for UnitDelay: '<S99>/UD' */
    AUAV_V3_TestSensors_DWork.UD_DSTATE_j = rtb_Product_lf;
    8dd8:	1e 9a 91    	mov.w     [w14+434], w4
    8dda:	ae 9a 91    	mov.w     [w14+436], w5
    8ddc:	e4 fb 88    	mov.w     w4, 0x1f7c
    8dde:	f5 fb 88    	mov.w     w5, 0x1f7e

    /* Update for Delay: '<S83>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_k = rtb_Switch3_kh;
    8de0:	6e 80 91    	mov.w     [w14+396], w0
    8de2:	fe 80 91    	mov.w     [w14+398], w1
    8de4:	00 fc 88    	mov.w     w0, 0x1f80
    8de6:	11 fc 88    	mov.w     w1, 0x1f82

    /* Update for Delay: '<S83>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_b = rtb_Subtract_a;
    8de8:	4e 81 91    	mov.w     [w14+392], w2
    8dea:	de 81 91    	mov.w     [w14+394], w3
    8dec:	22 fc 88    	mov.w     w2, 0x1f84
    8dee:	33 fc 88    	mov.w     w3, 0x1f86

    /* Update for Delay: '<S69>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_i = rtb_Ze_b;
    8df0:	5e aa 91    	mov.w     [w14+474], w4
    8df2:	ee aa 91    	mov.w     [w14+476], w5
    8df4:	44 fc 88    	mov.w     w4, 0x1f88
    8df6:	55 fc 88    	mov.w     w5, 0x1f8a

    /* Update for Delay: '<S69>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e = rtb_Switch1_a;
    8df8:	1e 90 91    	mov.w     [w14+418], w0
    8dfa:	ae 90 91    	mov.w     [w14+420], w1
    8dfc:	60 fc 88    	mov.w     w0, 0x1f8c
    8dfe:	71 fc 88    	mov.w     w1, 0x1f8e

    /* Update for Delay: '<S82>/Integer Delay3' */
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_h = rtb_Switch3_kh;
    8e00:	6e 81 91    	mov.w     [w14+396], w2
    8e02:	fe 81 91    	mov.w     [w14+398], w3
    8e04:	82 fc 88    	mov.w     w2, 0x1f90
    8e06:	93 fc 88    	mov.w     w3, 0x1f92

    /* Update for Delay: '<S84>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_p = rtb_Projection;
    8e08:	3e 92 91    	mov.w     [w14+422], w4
    8e0a:	ce 92 91    	mov.w     [w14+424], w5
    8e0c:	a4 fc 88    	mov.w     w4, 0x1f94
    8e0e:	b5 fc 88    	mov.w     w5, 0x1f96

    /* Update for Delay: '<S84>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[0] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[1];
    8e10:	c0 fa 2f    	mov.w     #0xffac, w0
    8e12:	0c 00 40    	add.w     w0, w12, w0
    8e14:	10 01 be    	mov.d     [w0], w2
    8e16:	c2 fc 88    	mov.w     w2, 0x1f98
    8e18:	d3 fc 88    	mov.w     w3, 0x1f9a
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[1] = rtb_Projection;
    8e1a:	04 88 be    	mov.d     w4, [w0]

    /* Update for Delay: '<S84>/Integer Delay2' */
    AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_g = rtb_Switch1_a;
    8e1c:	1e 92 91    	mov.w     [w14+418], w4
    8e1e:	ae 92 91    	mov.w     [w14+420], w5
    8e20:	04 fd 88    	mov.w     w4, 0x1fa0
    8e22:	15 fd 88    	mov.w     w5, 0x1fa2

    /* Update for Delay: '<S100>/Integer Delay3' */
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_nz = rtb_Projection;
    8e24:	3e 90 91    	mov.w     [w14+422], w0
    8e26:	ce 90 91    	mov.w     [w14+424], w1
    8e28:	20 fd 88    	mov.w     w0, 0x1fa4
    8e2a:	31 fd 88    	mov.w     w1, 0x1fa6

    /* Update for Delay: '<S101>/Integer Delay3' */
    AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_hh = rtb_Switch1_a;
    8e2c:	44 fd 88    	mov.w     w4, 0x1fa8
    8e2e:	55 fd 88    	mov.w     w5, 0x1faa

00008e30 <.L421>:
  }

  /* End of Update for SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */

  /* S-Function "dsPIC_PWM_OC" Block: <S20>/Output Compare - HW Drive Servo motor */
  OC1CON1 = 0x1008;                    /* Disable OC1 */
    8e30:	80 00 21    	mov.w     #0x1008, w0
    8e32:	00 48 88    	mov.w     w0, 0x900
  OC1CON2bits.TRIGSTAT = 0;
    8e34:	02 c9 a9    	bclr.b    0x902, #0x6
  OC1RS = AUAV_V3_TestSensors_B.Merge_oc[1];/* Pulse in Set-Reset mode (mimic up & down mode) */
    8e36:	51 ce 80    	mov.w     0x19ca, w1
    8e38:	21 48 88    	mov.w     w1, 0x904
  OC2CON1 = 0x1008;                    /* Disable OC2 */
    8e3a:	50 48 88    	mov.w     w0, 0x90a
  OC2CON2bits.TRIGSTAT = 0;
    8e3c:	0c c9 a9    	bclr.b    0x90c, #0x6
  OC2RS = AUAV_V3_TestSensors_B.Merge_oc[3];/* Pulse in Set-Reset mode (mimic up & down mode) */
    8e3e:	72 ce 80    	mov.w     0x19ce, w2
    8e40:	72 48 88    	mov.w     w2, 0x90e
  OC3CON1 = 0x1008;                    /* Disable OC3 */
    8e42:	a0 48 88    	mov.w     w0, 0x914
  OC3CON2bits.TRIGSTAT = 0;
    8e44:	16 c9 a9    	bclr.b    0x916, #0x6
  OC3RS = AUAV_V3_TestSensors_B.Merge_oc[0];/* Pulse in Set-Reset mode (mimic up & down mode) */
    8e46:	43 ce 80    	mov.w     0x19c8, w3
    8e48:	c3 48 88    	mov.w     w3, 0x918
  OC4CON1 = 0x1008;                    /* Disable OC4 */
    8e4a:	f0 48 88    	mov.w     w0, 0x91e
  OC4CON2bits.TRIGSTAT = 0;
    8e4c:	20 c9 a9    	bclr.b    0x920, #0x6
  OC4RS = AUAV_V3_TestSensors_B.Merge_oc[2];/* Pulse in Set-Reset mode (mimic up & down mode) */
    8e4e:	64 ce 80    	mov.w     0x19cc, w4
    8e50:	14 49 88    	mov.w     w4, 0x922
  OC1CON2bits.TRIGSTAT = 1;
    8e52:	02 c9 a8    	bset.b    0x902, #0x6
  OC1CON1 = 0x100C;                    /* Trig OC1 pulse */
    8e54:	64 00 40    	add.w     w0, #0x4, w0
    8e56:	00 48 88    	mov.w     w0, 0x900
  OC2CON2bits.TRIGSTAT = 1;
    8e58:	0c c9 a8    	bset.b    0x90c, #0x6
  OC2CON1 = 0x100C;                    /* Trig OC2 pulse */
    8e5a:	50 48 88    	mov.w     w0, 0x90a
  OC3CON2bits.TRIGSTAT = 1;
    8e5c:	16 c9 a8    	bset.b    0x916, #0x6
  OC3CON1 = 0x100C;                    /* Trig OC3 pulse */
    8e5e:	a0 48 88    	mov.w     w0, 0x914
  OC4CON2bits.TRIGSTAT = 1;
    8e60:	20 c9 a8    	bset.b    0x920, #0x6
  OC4CON1 = 0x100C;                    /* Trig OC4 pulse */
    8e62:	f0 48 88    	mov.w     w0, 0x91e

  /* Update absolute time */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The resolution of this integer timer is 0.01, which is the step size
   * of the task. Size of "clockTick0" ensures timer will not overflow during the
   * application lifespan selected.
   */
  AUAV_V3_TestSensors_M->Timing.clockTick0++;
    8e64:	00 23 22    	mov.w     #0x2230, w0
    8e66:	12 00 20    	mov.w     #0x1, w2
    8e68:	03 00 20    	mov.w     #0x0, w3
    8e6a:	10 08 41    	add.w     w2, [w0], [w0]
    8e6c:	50 90 49    	addc.w    w3, [++w0], [w0--]
}
    8e6e:	4f 06 be    	mov.d     [--w15], w12
    8e70:	4f 05 be    	mov.d     [--w15], w10
    8e72:	4f 04 be    	mov.d     [--w15], w8
    8e74:	00 80 fa    	ulnk      
    8e76:	00 00 06    	return    

00008e78 <.L252>:
    8e78:	60 44 b8    	mul.uu    w8, #0x0, w8
    8e7a:	77 f4 37    	bra       0x776a <.L0> <.L253>

00008e7c <.L306>:
    8e7c:	dc c6 88    	mov.w     w12, 0x18da
    8e7e:	ed c6 88    	mov.w     w13, 0x18dc
    8e80:	fa f7 37    	bra       0x7e76 <.L0> <.L424>

00008e82 <.L464>:
    8e82:	04 00 20    	mov.w     #0x0, w4
    8e84:	05 00 24    	mov.w     #0x4000, w5
    8e86:	14 97 99    	mov.w     w4, [w14+418]
    8e88:	25 97 99    	mov.w     w5, [w14+420]
    8e8a:	94 f8 37    	bra       0x7fb4 <.L319>

00008e8c <.L0>:
    8e8c:	00 00 20    	mov.w     #0x0, w0
    8e8e:	01 00 2c    	mov.w     #0xc000, w1
    8e90:	10 97 99    	mov.w     w0, [w14+418]
    8e92:	21 97 99    	mov.w     w1, [w14+420]
    8e94:	8f f8 37    	bra       0x7fb4 <.L319>

00008e96 <_AUAV_V3_TestSensors_step1>:

/* Model step function for TID1 */
void AUAV_V3_TestSensors_step1(void)   /* Sample time: [0.05s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/LEDs_Driver' */
  AUAV_V3_TestSe_LEDs_DriverTID1();
    8e96:	78 10 02    	call      0x11078 <_AUAV_V3_TestSe_LEDs_DriverTID1>
    8e98:	01 00 00 

00008e9a <.L0>:

  /* End of Outputs for SubSystem: '<Root>/LEDs_Driver' */
}
    8e9a:	00 00 06    	return    

00008e9c <_AUAV_V3_TestSensors_step2>:

/* Model step function for TID2 */
void AUAV_V3_TestSensors_step2(void)   /* Sample time: [0.1s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/LEDs_Driver' */
  AUAV_V3_TestSe_LEDs_DriverTID2();
    8e9c:	92 10 02    	call      0x11092 <_AUAV_V3_TestSe_LEDs_DriverTID2>
    8e9e:	01 00 00 

00008ea0 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/LEDs_Driver' */

  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID2();
    8ea0:	fe 03 02    	call      0x103fe <_AUAV_V3_Mavlink_TX_AdapterTID2>
    8ea2:	01 00 00 

00008ea4 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8ea4:	00 00 06    	return    

00008ea6 <_AUAV_V3_TestSensors_step3>:

/* Model step function for TID3 */
void AUAV_V3_TestSensors_step3(void)   /* Sample time: [0.2s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID3();
    8ea6:	6c 04 02    	call      0x1046c <_AUAV_V3_Mavlink_TX_AdapterTID3>
    8ea8:	01 00 00 

00008eaa <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */

  /* S-Function (MCHP_C_function_Call): '<Root>/ protDecodeMavlink' */
  protDecodeMavlink(
    8eaa:	e4 cb 02    	call      0xcbe4 <_protDecodeMavlink>
    8eac:	00 00 00 

00008eae <.L0>:
                    );
}
    8eae:	00 00 06    	return    

00008eb0 <_AUAV_V3_TestSensors_step4>:

/* Model step function for TID4 */
void AUAV_V3_TestSensors_step4(void)   /* Sample time: [0.2s, 0.02s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID4();
    8eb0:	ec 04 02    	call      0x104ec <_AUAV_V3_Mavlink_TX_AdapterTID4>
    8eb2:	01 00 00 

00008eb4 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8eb4:	00 00 06    	return    

00008eb6 <_AUAV_V3_TestSensors_step5>:

/* Model step function for TID5 */
void AUAV_V3_TestSensors_step5(void)   /* Sample time: [0.2s, 0.04s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID5();
    8eb6:	24 05 02    	call      0x10524 <_AUAV_V3_Mavlink_TX_AdapterTID5>
    8eb8:	01 00 00 

00008eba <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8eba:	00 00 06    	return    

00008ebc <_AUAV_V3_TestSensors_step6>:

/* Model step function for TID6 */
void AUAV_V3_TestSensors_step6(void)   /* Sample time: [0.2s, 0.06s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID6();
    8ebc:	56 05 02    	call      0x10556 <_AUAV_V3_Mavlink_TX_AdapterTID6>
    8ebe:	01 00 00 

00008ec0 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8ec0:	00 00 06    	return    

00008ec2 <_AUAV_V3_TestSensors_step7>:

/* Model step function for TID7 */
void AUAV_V3_TestSensors_step7(void)   /* Sample time: [0.2s, 0.08s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID7();
    8ec2:	66 05 02    	call      0x10566 <_AUAV_V3_Mavlink_TX_AdapterTID7>
    8ec4:	01 00 00 

00008ec6 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8ec6:	00 00 06    	return    

00008ec8 <_AUAV_V3_TestSensors_step8>:

/* Model step function for TID8 */
void AUAV_V3_TestSensors_step8(void)   /* Sample time: [0.25s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/LEDs_Driver' */
  AUAV_V3_TestSe_LEDs_DriverTID8();
    8ec8:	ac 10 02    	call      0x110ac <_AUAV_V3_TestSe_LEDs_DriverTID8>
    8eca:	01 00 00 

00008ecc <.L0>:

  /* End of Outputs for SubSystem: '<Root>/LEDs_Driver' */
}
    8ecc:	00 00 06    	return    

00008ece <_AUAV_V3_TestSensors_step9>:

/* Model step function for TID9 */
void AUAV_V3_TestSensors_step9(void)   /* Sample time: [0.5s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/LEDs_Driver' */
  AUAV_V3_TestSe_LEDs_DriverTID9();
    8ece:	c6 10 02    	call      0x110c6 <_AUAV_V3_TestSe_LEDs_DriverTID9>
    8ed0:	01 00 00 

00008ed2 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/LEDs_Driver' */

  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID9();
    8ed2:	76 05 02    	call      0x10576 <_AUAV_V3_Mavlink_TX_AdapterTID9>
    8ed4:	01 00 00 

00008ed6 <.L0>:

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */

  /* S-Function (MCHP_C_function_Call): '<Root>/ gpsUbloxParse' */
  gpsUbloxParse(
    8ed6:	ca e0 02    	call      0xe0ca <_gpsUbloxParse>
    8ed8:	00 00 00 
                );

  /* S-Function (MCHP_BUS_I2C_MASTER): '<Root>/BUS I2C Initialize HMC5883 re-initialize at 0.5Hz1' */
  /* number of I2C blocks : 5 ; Current: 5 ; MCHP_I2C_StartImplemented =  5*/
  if (MCHP_I2C25_Request == 0)         /* Last I2C sequence from this block is finished (not in the queue ?) */
    8eda:	50 1d 82    	mov.w     0x43aa, w0
    8edc:	00 00 e0    	cp0.w     w0
    8ede:	16 00 3a    	bra       NZ, 0x8f0c <.L655>
  {
    MCHP_I2C25_Request ++;
    8ee0:	50 1d 82    	mov.w     0x43aa, w0
    8ee2:	00 00 e8    	inc.w     w0, w0
    8ee4:	50 1d 8a    	mov.w     w0, 0x43aa
    MCHP_I2C2_Queue.buffer[MCHP_I2C2_Queue.head] = 107;
    8ee6:	a0 3b 24    	mov.w     #0x43ba, w0
    8ee8:	90 00 78    	mov.w     [w0], w1
    8eea:	81 80 40    	add.w     w1, w1, w1
    8eec:	6e 01 50    	sub.w     w0, #0xe, w2
    8eee:	81 00 41    	add.w     w2, w1, w1
    8ef0:	b2 06 20    	mov.w     #0x6b, w2
    8ef2:	82 08 78    	mov.w     w2, [w1]
    if (MCHP_I2C2_Queue.head >= 5)     /* There are 5 blocks I2C2, max idx for queue is 5 */
    8ef4:	41 00 20    	mov.w     #0x4, w1
    8ef6:	90 8f 10    	subr.w    w1, [w0], [w15]
    8ef8:	02 00 36    	bra       LEU, 0x8efe <.L656>
      MCHP_I2C2_Queue.head = 0;
    8efa:	00 08 eb    	clr.w     [w0]
    8efc:	02 00 37    	bra       0x8f02 <.L657>

00008efe <.L656>:
    else
      MCHP_I2C2_Queue.head ++;
    8efe:	a0 3b 24    	mov.w     #0x43ba, w0
    8f00:	10 08 e8    	inc.w     [w0], [w0]

00008f02 <.L657>:
    if (MCHP_I2C2_State == 0)
    8f02:	00 1d 82    	mov.w     0x43a0, w0
    8f04:	00 00 e0    	cp0.w     w0
    8f06:	11 00 3a    	bra       NZ, 0x8f2a <.L0> <.L654>
      _MI2C2IF = 1;                    /* Force Interrupt */
    8f08:	06 48 a8    	bset.b    0x806, #0x2
    8f0a:	0f 00 37    	bra       0x8f2a <.L0> <.L654>

00008f0c <.L655>:
  } else if (MCHP_I2C25_Request > 3) {
    8f0c:	50 1d 82    	mov.w     0x43aa, w0
    8f0e:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    8f10:	09 00 36    	bra       LEU, 0x8f24 <.L659>
    I2C2CONbits.I2CEN = 0;             /* Switch Off I2C*/
    8f12:	17 e2 a9    	bclr.b    0x217, #0x7
    TRISAbits.TRISA3 = 0;              /* Set I2C Port as Port Output */
    8f14:	00 6e a9    	bclr.b    0xe00, #0x3
    TRISAbits.TRISA2 = 0;
    8f16:	00 4e a9    	bclr.b    0xe00, #0x2
    MCHP_I2C25_Request = 0;            /* This block might still be in the queue provided another I2C block stuck the bus, Next block execution will however add another Request */
    8f18:	00 00 eb    	clr.w     w0
    8f1a:	50 1d 8a    	mov.w     w0, 0x43aa
    MCHP_I2C2_State = 1;               /* try to Reset I2C BUS */
    8f1c:	10 00 20    	mov.w     #0x1, w0
    8f1e:	00 1d 8a    	mov.w     w0, 0x43a0
    _MI2C2IF = 1;                      /* Force Interrupt */
    8f20:	06 48 a8    	bset.b    0x806, #0x2
    8f22:	03 00 37    	bra       0x8f2a <.L0> <.L654>

00008f24 <.L659>:
  } else
    MCHP_I2C25_Request++;
    8f24:	50 1d 82    	mov.w     0x43aa, w0
    8f26:	00 00 e8    	inc.w     w0, w0
    8f28:	50 1d 8a    	mov.w     w0, 0x43aa

00008f2a <.L0>:
}
    8f2a:	00 00 06    	return    

00008f2c <_AUAV_V3_TestSensors_step10>:

/* Model step function for TID10 */
void AUAV_V3_TestSensors_step10(void)  /* Sample time: [1.0s, 0.0s] */
{
  /* Outputs for Atomic SubSystem: '<Root>/Mavlink_TX_Adapter' */
  AUAV_V3_Mavlink_TX_AdapterTID10();
    8f2c:	86 05 02    	call      0x10586 <_AUAV_V3_Mavlink_TX_AdapterTID10>
    8f2e:	01 00 00 

  /* End of Outputs for SubSystem: '<Root>/Mavlink_TX_Adapter' */
}
    8f30:	00 00 06    	return    

00008f32 <_AUAV_V3_TestSensors_initialize>:

/* Model initialize function */
void AUAV_V3_TestSensors_initialize(void)
{
    8f32:	0c 00 fa    	lnk       #0xc
    8f34:	88 9f be    	mov.d     w8, [w15++]
    8f36:	8a 9f be    	mov.d     w10, [w15++]
    8f38:	8c 1f 78    	mov.w     w12, [w15++]

00008f3a <.L0>:
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));
    8f3a:	40 00 20    	mov.w     #0x4, w0
    8f3c:	82 0d 02    	call      0x10d82 <_rt_InitInfAndNaN>
    8f3e:	01 00 00 

00008f40 <.L0>:

  /* initialize real-time model */
  (void) memset((void *)AUAV_V3_TestSensors_M, 0,
    8f40:	00 23 22    	mov.w     #0x2230, w0
    8f42:	0e 00 09    	.pword 0x09000e
    8f44:	00 18 eb    	clr.w     [w0++]
                sizeof(RT_MODEL_AUAV_V3_TestSensors_T));
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[0] = 1;
    8f46:	18 c0 b3    	mov.b     #0x1, w8
    8f48:	00 24 22    	mov.w     #0x2240, w0
    8f4a:	08 48 78    	mov.b     w8, [w0]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[1] = 5;
    8f4c:	51 c0 b3    	mov.b     #0x5, w1
    8f4e:	00 00 e8    	inc.w     w0, w0
    8f50:	01 48 78    	mov.b     w1, [w0]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[2] = 10;
    8f52:	a1 c0 b3    	mov.b     #0xa, w1
    8f54:	00 00 e8    	inc.w     w0, w0
    8f56:	01 48 78    	mov.b     w1, [w0]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[3] = 20;
    8f58:	40 c1 b3    	mov.b     #0x14, w0
    8f5a:	31 24 22    	mov.w     #0x2243, w1
    8f5c:	80 48 78    	mov.b     w0, [w1]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[4] = 20;
    8f5e:	81 00 e8    	inc.w     w1, w1
    8f60:	80 48 78    	mov.b     w0, [w1]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[5] = 20;
    8f62:	81 00 e8    	inc.w     w1, w1
    8f64:	80 48 78    	mov.b     w0, [w1]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[6] = 20;
    8f66:	81 00 e8    	inc.w     w1, w1
    8f68:	80 48 78    	mov.b     w0, [w1]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[7] = 20;
    8f6a:	81 00 e8    	inc.w     w1, w1
    8f6c:	80 48 78    	mov.b     w0, [w1]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[8] = 25;
    8f6e:	91 c1 b3    	mov.b     #0x19, w1
    8f70:	80 24 22    	mov.w     #0x2248, w0
    8f72:	01 48 78    	mov.b     w1, [w0]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[9] = 50;
    8f74:	f9 c0 40    	add.b     w1, #0x19, w1
    8f76:	00 00 e8    	inc.w     w0, w0
    8f78:	01 48 78    	mov.b     w1, [w0]
  (AUAV_V3_TestSensors_M)->Timing.TaskCounters.cLimit[10] = 100;
    8f7a:	41 c6 b3    	mov.b     #0x64, w1
    8f7c:	00 00 e8    	inc.w     w0, w0
    8f7e:	01 48 78    	mov.b     w1, [w0]
  rtmSetFirstInitCond(AUAV_V3_TestSensors_M, 1);
    8f80:	76 06 50    	sub.w     w0, #0x16, w12
    8f82:	08 4e 78    	mov.b     w8, [w12]

  /* initialize sample time offsets */
  AUAV_V3_TestSensors_M->Timing.TaskCounters.TID[4] = 18;/* Sample time: [0.2s, 0.02s] */
    8f84:	21 c1 b3    	mov.b     #0x12, w1
    8f86:	71 00 50    	sub.w     w0, #0x11, w0
    8f88:	01 48 78    	mov.b     w1, [w0]

  /* initialize sample time offsets */
  AUAV_V3_TestSensors_M->Timing.TaskCounters.TID[5] = 16;/* Sample time: [0.2s, 0.04s] */
    8f8a:	01 c1 b3    	mov.b     #0x10, w1
    8f8c:	00 00 e8    	inc.w     w0, w0
    8f8e:	01 48 78    	mov.b     w1, [w0]

  /* initialize sample time offsets */
  AUAV_V3_TestSensors_M->Timing.TaskCounters.TID[6] = 14;/* Sample time: [0.2s, 0.06s] */
    8f90:	e1 c0 b3    	mov.b     #0xe, w1
    8f92:	00 00 e8    	inc.w     w0, w0
    8f94:	01 48 78    	mov.b     w1, [w0]

  /* initialize sample time offsets */
  AUAV_V3_TestSensors_M->Timing.TaskCounters.TID[7] = 12;/* Sample time: [0.2s, 0.08s] */
    8f96:	c1 c0 b3    	mov.b     #0xc, w1
    8f98:	00 00 e8    	inc.w     w0, w0
    8f9a:	01 48 78    	mov.b     w1, [w0]

  /* block I/O */
  (void) memset(((void *) &AUAV_V3_TestSensors_B), 0,
    8f9c:	61 4e 21    	mov.w     #0x14e6, w1
    8f9e:	3a 04 09    	.pword 0x09043a
    8fa0:	80 18 eb    	clr.w     [w1++]
                sizeof(BlockIO_AUAV_V3_TestSensors_T));

  /* states (dwork) */
  (void) memset((void *)&AUAV_V3_TestSensors_DWork, 0,
    8fa2:	c3 d5 21    	mov.w     #0x1d5c, w3
    8fa4:	40 02 09    	.pword 0x090240
    8fa6:	80 19 eb    	clr.w     [w3++]
                sizeof(D_Work_AUAV_V3_TestSensors_T));

  /* exported global states */
  mlParamInterface = AUAV_V3_TestSensors_rtZpi_struct;
    8fa8:	a0 25 21    	mov.w     #0x125a, w0
    8faa:	35 01 09    	.pword 0x090135
    8fac:	00 18 eb    	clr.w     [w0++]
  mlWpValues = AUAV_V3_TestSensors_rtZmavlink_mission_item_values_t;
    8fae:	81 13 21    	mov.w     #0x1138, w1
    8fb0:	80 00 09    	.pword 0x090080
    8fb2:	80 18 eb    	clr.w     [w1++]
  mlAttitudeData = AUAV_V3_TestSensors_rtZmavlink_attitude_t;
    8fb4:	62 0c 21    	mov.w     #0x10c6, w2
    8fb6:	0d 00 09    	.pword 0x09000d
    8fb8:	00 19 eb    	clr.w     [w2++]
  mlAttitudeSol = AUAV_V3_TestSensors_rtZmavlink_attitude_t;
    8fba:	e3 1d 22    	mov.w     #0x21de, w3
    8fbc:	0d 00 09    	.pword 0x09000d
    8fbe:	80 19 eb    	clr.w     [w3++]
  mlGpsData = AUAV_V3_TestSensors_rtZmavlink_gps_raw_int_t;
    8fc0:	a4 05 21    	mov.w     #0x105a, w4
    8fc2:	0e 00 09    	.pword 0x09000e
    8fc4:	00 1a eb    	clr.w     [w4++]
  mlLocalPositionData = AUAV_V3_TestSensors_rtZmavlink_local_position_ned_t;
    8fc6:	20 0e 21    	mov.w     #0x10e2, w0
    8fc8:	0d 00 09    	.pword 0x09000d
    8fca:	00 18 eb    	clr.w     [w0++]
  mlNavigation = AUAV_V3_TestSensors_rtZmavlink_slugs_navigation_t;
    8fcc:	a1 23 21    	mov.w     #0x123a, w1
    8fce:	0f 00 09    	.pword 0x09000f
    8fd0:	80 18 eb    	clr.w     [w1++]
  mlSysStatus = AUAV_V3_TestSensors_rtZmavlink_sys_status_t;
    8fd2:	a2 1f 22    	mov.w     #0x21fa, w2
    8fd4:	0f 00 09    	.pword 0x09000f
    8fd6:	00 19 eb    	clr.w     [w2++]
  mlPilotConsoleData = AUAV_V3_TestSensors_rtZmavlink_rc_channels_raw_t;
    8fd8:	63 08 21    	mov.w     #0x1086, w3
    8fda:	0a 00 09    	.pword 0x09000a
    8fdc:	80 19 eb    	clr.w     [w3++]
  mlRawImuData = AUAV_V3_TestSensors_rtZmavlink_raw_imu_t;
    8fde:	c4 09 21    	mov.w     #0x109c, w4
    8fe0:	0c 00 09    	.pword 0x09000c
    8fe2:	00 1a eb    	clr.w     [w4++]
  mlPwmCommands = AUAV_V3_TestSensors_rtZmavlink_servo_output_raw_t;
    8fe4:	a0 10 21    	mov.w     #0x110a, w0
    8fe6:	0a 00 09    	.pword 0x09000a
    8fe8:	00 18 eb    	clr.w     [w0++]
  mlVfr_hud = AUAV_V3_TestSensors_rtZmavlink_vfr_hud_t;
    8fea:	a1 21 22    	mov.w     #0x221a, w1
    8fec:	09 00 09    	.pword 0x090009
    8fee:	80 18 eb    	clr.w     [w1++]
  mlAirData = AUAV_V3_TestSensors_rtZmavlink_scaled_pressure_t;
    8ff0:	82 07 21    	mov.w     #0x1078, w2
    8ff2:	06 00 09    	.pword 0x090006
    8ff4:	00 19 eb    	clr.w     [w2++]
  mlGSLocationFloat = AUAV_V3_TestSensors_rtZmavlink_coordinate_float_t;
    8ff6:	60 55 b8    	mul.uu    w10, #0x0, w10
    8ff8:	fa 87 88    	mov.w     w10, 0x10fe
    8ffa:	0b 88 88    	mov.w     w11, 0x1100
    8ffc:	1a 88 88    	mov.w     w10, 0x1102
    8ffe:	2b 88 88    	mov.w     w11, 0x1104
    9000:	3a 88 88    	mov.w     w10, 0x1106
    9002:	4b 88 88    	mov.w     w11, 0x1108
  mlHeartbeatLocal = AUAV_V3_TestSensors_rtZmavlink_heartbeat_t;
    9004:	03 12 21    	mov.w     #0x1120, w3
    9006:	04 00 09    	.pword 0x090004
    9008:	80 19 eb    	clr.w     [w3++]
  mlISR = AUAV_V3_TestSensors_rtZmavlink_isr_location_t;
    900a:	04 4d 21    	mov.w     #0x14d0, w4
    900c:	07 00 09    	.pword 0x090007
    900e:	00 1a eb    	clr.w     [w4++]
  mlMidLevelCommands = AUAV_V3_TestSensors_rtZmavlink_mid_lvl_cmds_t;
    9010:	a0 12 21    	mov.w     #0x112a, w0
    9012:	06 00 09    	.pword 0x090006
    9014:	00 18 eb    	clr.w     [w0++]
  mlMobileLocation = AUAV_V3_TestSensors_rtZmavlink_slugs_mobile_location_t;
    9016:	3a a6 88    	mov.w     w10, 0x14c6
    9018:	4b a6 88    	mov.w     w11, 0x14c8
    901a:	5a a6 88    	mov.w     w10, 0x14ca
    901c:	6b a6 88    	mov.w     w11, 0x14cc
    901e:	80 44 eb    	clr.b     w9
    9020:	e0 4c 21    	mov.w     #0x14ce, w0
    9022:	09 48 78    	mov.b     w9, [w0]
  mlRawPressureData = AUAV_V3_TestSensors_rtZmavlink_raw_pressure_t;
    9024:	61 0b 21    	mov.w     #0x10b6, w1
    9026:	07 00 09    	.pword 0x090007
    9028:	80 18 eb    	clr.w     [w1++]
  mlVISensor = AUAV_V3_TestSensors_rtZmavlink_volt_sensor_t;
    902a:	00 00 eb    	clr.w     w0
    902c:	00 a7 88    	mov.w     w0, 0x14e0
    902e:	10 a7 88    	mov.w     w0, 0x14e2
    9030:	41 4e 21    	mov.w     #0x14e4, w1
    9032:	80 48 78    	mov.b     w0, [w1]

00009034 <.L0>:
  MPU_T = 0U;
    9034:	70 11 89    	mov.w     w0, 0x222e

00009036 <.L0>:

  /* S-Function "Microchip MASTER" initialization Block: <Root>/Microchip Master AUAV V3 Board Busy Flag on D2 (RA6) */

  /* Start for Atomic SubSystem: '<Root>/Sensor_Data_Adapter' */
  Sensor_Data_Adapter_Start();
    9036:	84 d7 02    	call      0xd784 <_Sensor_Data_Adapter_Start>
    9038:	00 00 00 

0000903a <.L0>:

  /* End of Start for SubSystem: '<Root>/Sensor_Data_Adapter' */

  /* Start for Atomic SubSystem: '<Root>/Position_and_Attitude_Filter' */
  Position_and_Attitud_Start();
    903a:	b4 ab 02    	call      0xabb4 <_Position_and_Attitud_Start>
    903c:	00 00 00 

  /* End of Start for SubSystem: '<Root>/Position_and_Attitude_Filter' */

  /* Start for S-Function (MCHP_IC): '<S656>/Input Capture' */
  IC1CON1 = 0x1003;
    903e:	30 00 21    	mov.w     #0x1003, w0
    9040:	00 0a 88    	mov.w     w0, 0x140
  IC1CON2 = 0x00;
    9042:	42 21 ef    	clr.w     0x142
  IC2CON1 = 0x1003;
    9044:	40 0a 88    	mov.w     w0, 0x148
  IC2CON2 = 0x00;
    9046:	4a 21 ef    	clr.w     0x14a
  IC3CON1 = 0x1003;
    9048:	80 0a 88    	mov.w     w0, 0x150
  IC3CON2 = 0x00;
    904a:	52 21 ef    	clr.w     0x152
  IC4CON1 = 0x1003;
    904c:	c0 0a 88    	mov.w     w0, 0x158
  IC4CON2 = 0x00;
    904e:	5a 21 ef    	clr.w     0x15a
  IC5CON1 = 0x1003;
    9050:	00 0b 88    	mov.w     w0, 0x160
  IC5CON2 = 0x00;
    9052:	62 21 ef    	clr.w     0x162
  IC6CON1 = 0x1003;
    9054:	40 0b 88    	mov.w     w0, 0x168
  IC6CON2 = 0x00;
    9056:	6a 21 ef    	clr.w     0x16a
  IC7CON1 = 0x1003;
    9058:	80 0b 88    	mov.w     w0, 0x170
  IC7CON2 = 0x00;
    905a:	72 21 ef    	clr.w     0x172
  IC8CON1 = 0x1003;
    905c:	c0 0b 88    	mov.w     w0, 0x178
  IC8CON2 = 0x00;
    905e:	7a 21 ef    	clr.w     0x17a

  /* Set-up Input Capture Interruption */
  _IC1IF = 0;
    9060:	00 28 a9    	bclr.b    0x800, #0x1
  _IC1IP = 6;
    9062:	00 42 80    	mov.w     0x840, w0
    9064:	00 40 a1    	bclr.w    w0, #0x4
    9066:	00 06 b3    	ior.w     #0x60, w0
    9068:	00 42 88    	mov.w     w0, 0x840
  _IC1IE = 1;
    906a:	20 28 a8    	bset.b    0x820, #0x1
  _IC2IF = 0;
    906c:	00 a8 a9    	bclr.b    0x800, #0x5
  _IC2IP = 6;
    906e:	10 42 80    	mov.w     0x842, w0
    9070:	00 40 a1    	bclr.w    w0, #0x4
    9072:	00 06 b3    	ior.w     #0x60, w0
    9074:	10 42 88    	mov.w     w0, 0x842
  _IC2IE = 1;
    9076:	20 a8 a8    	bset.b    0x820, #0x5
  _IC3IF = 0;
    9078:	04 a8 a9    	bclr.b    0x804, #0x5
  _IC3IP = 6;
    907a:	90 42 80    	mov.w     0x852, w0
    907c:	00 40 a1    	bclr.w    w0, #0x4
    907e:	00 06 b3    	ior.w     #0x60, w0
    9080:	90 42 88    	mov.w     w0, 0x852
  _IC3IE = 1;
    9082:	24 a8 a8    	bset.b    0x824, #0x5
  _IC4IF = 0;
    9084:	04 c8 a9    	bclr.b    0x804, #0x6
  _IC4IP = 6;
    9086:	90 42 80    	mov.w     0x852, w0
    9088:	00 80 a1    	bclr.w    w0, #0x8
    908a:	00 90 a0    	bset.w    w0, #0x9
    908c:	00 a0 a0    	bset.w    w0, #0xa
    908e:	90 42 88    	mov.w     w0, 0x852
  _IC4IE = 1;
    9090:	24 c8 a8    	bset.b    0x824, #0x6
  _IC5IF = 0;
    9092:	04 e8 a9    	bclr.b    0x804, #0x7
  _IC5IP = 6;
    9094:	90 42 80    	mov.w     0x852, w0
    9096:	00 c0 a1    	bclr.w    w0, #0xc
    9098:	00 d0 a0    	bset.w    w0, #0xd
    909a:	00 e0 a0    	bset.w    w0, #0xe
    909c:	90 42 88    	mov.w     w0, 0x852
  _IC5IE = 1;
    909e:	24 e8 a8    	bset.b    0x824, #0x7
  _IC6IF = 0;
    90a0:	05 08 a9    	bclr.b    0x805, #0x0
  _IC6IP = 6;
    90a2:	a0 42 80    	mov.w     0x854, w0
    90a4:	00 00 a1    	bclr.w    w0, #0x0
    90a6:	60 00 b3    	ior.w     #0x6, w0
    90a8:	a0 42 88    	mov.w     w0, 0x854
  _IC6IE = 1;
    90aa:	25 08 a8    	bset.b    0x825, #0x0
  _IC7IF = 0;
    90ac:	02 c8 a9    	bclr.b    0x802, #0x6
  _IC7IP = 6;
    90ae:	50 42 80    	mov.w     0x84a, w0
    90b0:	00 80 a1    	bclr.w    w0, #0x8
    90b2:	00 90 a0    	bset.w    w0, #0x9
    90b4:	00 a0 a0    	bset.w    w0, #0xa
    90b6:	50 42 88    	mov.w     w0, 0x84a
  _IC7IE = 1;
    90b8:	22 c8 a8    	bset.b    0x822, #0x6
  _IC8IF = 0;
    90ba:	02 e8 a9    	bclr.b    0x802, #0x7
  _IC8IP = 6;
    90bc:	50 42 80    	mov.w     0x84a, w0
    90be:	00 c0 a1    	bclr.w    w0, #0xc
    90c0:	00 d0 a0    	bset.w    w0, #0xd
    90c2:	00 e0 a0    	bset.w    w0, #0xe
    90c4:	50 42 88    	mov.w     w0, 0x84a
  _IC8IE = 1;
    90c6:	22 e8 a8    	bset.b    0x822, #0x7

  /* Start for InitialCondition: '<S658>/IC1' */
  AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime = true;
    90c8:	f0 ff 21    	mov.w     #0x1fff, w0
    90ca:	08 48 78    	mov.b     w8, [w0]

  /* Start for Atomic SubSystem: '<S6>/Navigation Encaps [updated 4.28.16]' */
  /* Start for InitialCondition: '<S189>/IC1' */
  AUAV_V3_TestSensors_DWork.IC1_FirstOutputTime_m = true;
    90cc:	00 80 e8    	inc2.w    w0, w0
    90ce:	08 48 78    	mov.b     w8, [w0]

  /* Start for InitialCondition: '<S189>/IC2' */
  AUAV_V3_TestSensors_DWork.IC2_FirstOutputTime = true;
    90d0:	00 00 e8    	inc.w     w0, w0
    90d2:	08 48 78    	mov.b     w8, [w0]

  /* Start for InitialCondition: '<S189>/IC4' */
  AUAV_V3_TestSensors_DWork.IC4_FirstOutputTime = true;
    90d4:	00 00 e8    	inc.w     w0, w0
    90d6:	08 48 78    	mov.b     w8, [w0]

  /* Start for InitialCondition: '<S186>/IC' */
  AUAV_V3_TestSensors_DWork.IC_FirstOutputTime = true;
    90d8:	00 00 e8    	inc.w     w0, w0
    90da:	08 48 78    	mov.b     w8, [w0]

  /* InitializeConditions for IfAction SubSystem: '<S180>/RTB//Follow Mobile Navigation' */
  /* InitializeConditions for DiscreteIntegrator: '<S443>/Discrete-Time Integrator' */
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator_IC_LOADI = 1U;
    90dc:	66 00 50    	sub.w     w0, #0x6, w0
    90de:	08 48 78    	mov.b     w8, [w0]

  /* End of InitializeConditions for SubSystem: '<S180>/RTB//Follow Mobile Navigation' */

  /* Start for IfAction SubSystem: '<S180>/Normal WP  Navigation' */

  /* Start for InitialCondition: '<S187>/IC' */
  AUAV_V3_TestSensors_B.IC = 0U;
    90e0:	b0 a9 21    	mov.w     #0x1a9b, w0
    90e2:	09 48 78    	mov.b     w9, [w0]
  AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_m = true;
    90e4:	60 00 22    	mov.w     #0x2006, w0
    90e6:	08 48 78    	mov.b     w8, [w0]

  /* InitializeConditions for Enabled SubSystem: '<S187>/Get Frenet' */
  /* InitializeConditions for Delay: '<S303>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_gn = 1.0F;
    90e8:	00 00 20    	mov.w     #0x0, w0
    90ea:	01 f8 23    	mov.w     #0x3f80, w1
    90ec:	e0 f2 88    	mov.w     w0, 0x1e5c
    90ee:	f1 f2 88    	mov.w     w1, 0x1e5e

  /* End of InitializeConditions for SubSystem: '<S187>/Get Frenet' */
  /* InitializeConditions for IfAction SubSystem: '<S180>/Normal WP  Navigation' */
  /* InitializeConditions for Delay: '<S187>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_im = 1U;
    90f0:	80 ff 21    	mov.w     #0x1ff8, w0
    90f2:	08 48 78    	mov.b     w8, [w0]

  /* InitializeConditions for MATLAB Function: '<S187>/Embedded MATLAB Function' */
  AUAV_V3_TestSensors_DWork.persistentDidReachIP = 0U;
    90f4:	65 00 40    	add.w     w0, #0x5, w0
    90f6:	09 48 78    	mov.b     w9, [w0]

  /* InitializeConditions for MATLAB Function: '<S187>/computeCurrentWP' */
  AUAV_V3_TestSensors_DWork.fromWp = 1U;
    90f8:	00 80 e9    	dec2.w    w0, w0
    90fa:	08 48 78    	mov.b     w8, [w0]
  AUAV_V3_TestSensors_DWork.toWp = 2U;
    90fc:	20 c0 b3    	mov.b     #0x2, w0
    90fe:	c1 ff 21    	mov.w     #0x1ffc, w1
    9100:	80 48 78    	mov.b     w0, [w1]

  /* End of InitializeConditions for SubSystem: '<S180>/Normal WP  Navigation' */

  /* Start for IfAction SubSystem: '<S180>/Normal WP  Navigation' */
  /* VirtualOutportStart for Outport: '<S187>/FromWP' */
  AUAV_V3_TestSensors_B.WP0 = 1U;
    9102:	c1 a9 21    	mov.w     #0x1a9c, w1
    9104:	88 48 78    	mov.b     w8, [w1]

  /* VirtualOutportStart for Outport: '<S187>/ToWP' */
  AUAV_V3_TestSensors_B.WP1 = 2U;
    9106:	81 00 e8    	inc.w     w1, w1
    9108:	80 48 78    	mov.b     w0, [w1]

  /* End of Start for SubSystem: '<S180>/Normal WP  Navigation' */
  /* VirtualOutportStart for Outport: '<S185>/FromWP' */
  AUAV_V3_TestSensors_B.Merge3 = 1U;
    910a:	64 80 50    	sub.w     w1, #0x4, w0
    910c:	08 48 78    	mov.b     w8, [w0]

  /* VirtualOutportStart for Outport: '<S185>/ToWP' */
  AUAV_V3_TestSensors_B.Merge4 = 2U;

  /* End of Start for SubSystem: '<S180>/Line Segment' */

  /* VirtualOutportStart for Outport: '<S181>/FromWP' */
  AUAV_V3_TestSensors_B.Merge3 = 1U;

  /* VirtualOutportStart for Outport: '<S181>/ToWP' */
  AUAV_V3_TestSensors_B.Merge4 = 1U;
    910e:	00 00 e8    	inc.w     w0, w0
    9110:	08 48 78    	mov.b     w8, [w0]

  /* End of Start for SubSystem: '<S180>/Circle Navigation' */
  /* Start for InitialCondition: '<S189>/IC3' */
  AUAV_V3_TestSensors_B.IC3 = 0.0F;
    9112:	da bd 88    	mov.w     w10, 0x17ba
    9114:	eb bd 88    	mov.w     w11, 0x17bc
  AUAV_V3_TestSensors_DWork.IC3_FirstOutputTime = true;
    9116:	50 00 22    	mov.w     #0x2005, w0
    9118:	08 48 78    	mov.b     w8, [w0]

  /* End of Start for SubSystem: '<S6>/Navigation Encaps [updated 4.28.16]' */

  /* Start for Enabled SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */
  /* Start for InitialCondition: '<S79>/IC' */
  AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_g = true;
    911a:	63 00 40    	add.w     w0, #0x3, w0
    911c:	08 48 78    	mov.b     w8, [w0]

  /* Start for InitialCondition: '<S83>/IC' */
  AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_f = true;
    911e:	00 00 e8    	inc.w     w0, w0
    9120:	08 48 78    	mov.b     w8, [w0]

  /* End of Start for SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */

  /* InitializeConditions for Enabled SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */
  /* InitializeConditions for UnitDelay: '<S89>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE_ff = 0.0F;
    9122:	6a fb 88    	mov.w     w10, 0x1f6c
    9124:	7b fb 88    	mov.w     w11, 0x1f6e

  /* InitializeConditions for Delay: '<S79>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_an = 0.0F;
    9126:	8a fb 88    	mov.w     w10, 0x1f70
    9128:	9b fb 88    	mov.w     w11, 0x1f72

  /* InitializeConditions for Delay: '<S79>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_i = 0.0F;
    912a:	aa fb 88    	mov.w     w10, 0x1f74
    912c:	bb fb 88    	mov.w     w11, 0x1f76

  /* InitializeConditions for Delay: '<S81>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_fs = 0.0F;
    912e:	ca fb 88    	mov.w     w10, 0x1f78
    9130:	db fb 88    	mov.w     w11, 0x1f7a

  /* InitializeConditions for UnitDelay: '<S99>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE_j = 0.0F;
    9132:	ea fb 88    	mov.w     w10, 0x1f7c
    9134:	fb fb 88    	mov.w     w11, 0x1f7e

  /* InitializeConditions for Delay: '<S83>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_k = 0.0F;
    9136:	0a fc 88    	mov.w     w10, 0x1f80
    9138:	1b fc 88    	mov.w     w11, 0x1f82

  /* InitializeConditions for Delay: '<S83>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_b = 0.0F;
    913a:	2a fc 88    	mov.w     w10, 0x1f84
    913c:	3b fc 88    	mov.w     w11, 0x1f86

  /* InitializeConditions for Delay: '<S69>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_i = 0.0F;
    913e:	4a fc 88    	mov.w     w10, 0x1f88
    9140:	5b fc 88    	mov.w     w11, 0x1f8a

  /* InitializeConditions for Delay: '<S69>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_e = 0.0F;
    9142:	6a fc 88    	mov.w     w10, 0x1f8c
    9144:	7b fc 88    	mov.w     w11, 0x1f8e

  /* InitializeConditions for Merge: '<S80>/Merge' */
  if (rtmIsFirstInitCond(AUAV_V3_TestSensors_M)) {
    9146:	1c 04 e0    	cp0.b     [w12]
    9148:	02 00 32    	bra       Z, 0x914e <.L662>
    AUAV_V3_TestSensors_B.Merge_oo = 0.0F;
    914a:	da c6 88    	mov.w     w10, 0x18da
    914c:	eb c6 88    	mov.w     w11, 0x18dc

0000914e <.L662>:
  }

  /* End of InitializeConditions for Merge: '<S80>/Merge' */

  /* InitializeConditions for Delay: '<S82>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_h = 0.0F;
    914e:	60 00 b8    	mul.uu    w0, #0x0, w0
    9150:	80 fc 88    	mov.w     w0, 0x1f90
    9152:	91 fc 88    	mov.w     w1, 0x1f92

  /* InitializeConditions for Delay: '<S84>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_p = 0.0F;
    9154:	a0 fc 88    	mov.w     w0, 0x1f94
    9156:	b1 fc 88    	mov.w     w1, 0x1f96

  /* InitializeConditions for Delay: '<S84>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[0] = 0.0F;
    9158:	c0 fc 88    	mov.w     w0, 0x1f98
    915a:	d1 fc 88    	mov.w     w1, 0x1f9a
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_ey[1] = 0.0F;
    915c:	e0 fc 88    	mov.w     w0, 0x1f9c
    915e:	f1 fc 88    	mov.w     w1, 0x1f9e

  /* InitializeConditions for Delay: '<S84>/Integer Delay2' */
  AUAV_V3_TestSensors_DWork.IntegerDelay2_DSTATE_g = 0.0F;
    9160:	00 fd 88    	mov.w     w0, 0x1fa0
    9162:	11 fd 88    	mov.w     w1, 0x1fa2

  /* InitializeConditions for Delay: '<S100>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_nz = 0.0F;
    9164:	20 fd 88    	mov.w     w0, 0x1fa4
    9166:	31 fd 88    	mov.w     w1, 0x1fa6

  /* InitializeConditions for Delay: '<S101>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_hh = 0.0F;
    9168:	40 fd 88    	mov.w     w0, 0x1fa8
    916a:	51 fd 88    	mov.w     w1, 0x1faa

  /* End of InitializeConditions for SubSystem: '<S6>/L1 Output Feedback Controller With  Projection Operator' */
  /* Start for InitialCondition: '<S118>/IC' */
  AUAV_V3_TestSensors_DWork.IC_FirstOutputTime_b = true;
    916c:	13 c0 b3    	mov.b     #0x1, w3
    916e:	72 00 22    	mov.w     #0x2007, w2
    9170:	03 49 78    	mov.b     w3, [w2]

  /* InitializeConditions for Enabled SubSystem: '<S102>/Sideslip Compensation' */
  /* InitializeConditions for UnitDelay: '<S126>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE_f = 0.0F;
    9172:	e0 fa 88    	mov.w     w0, 0x1f5c
    9174:	f1 fa 88    	mov.w     w1, 0x1f5e

  /* InitializeConditions for Delay: '<S118>/Integer Delay' */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_ed = 0.0F;
    9176:	00 fb 88    	mov.w     w0, 0x1f60
    9178:	11 fb 88    	mov.w     w1, 0x1f62

  /* InitializeConditions for Delay: '<S118>/Integer Delay1' */
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_n = 0.0F;
    917a:	20 fb 88    	mov.w     w0, 0x1f64
    917c:	31 fb 88    	mov.w     w1, 0x1f66

  /* InitializeConditions for Delay: '<S119>/Integer Delay3' */
  AUAV_V3_TestSensors_DWork.IntegerDelay3_DSTATE_ph = 0.0F;
    917e:	40 fb 88    	mov.w     w0, 0x1f68
    9180:	51 fb 88    	mov.w     w1, 0x1f6a

00009182 <.L0>:

  /* End of InitializeConditions for SubSystem: '<S102>/Sideslip Compensation' */

  /* Start for IfAction SubSystem: '<S682>/If  Control Type Is Selective Passthrough' */

  /* Start for S-Function (MCHP_C_function_Call): '<S687>/Initialize Control MCU' */
  getPassValues(
    9182:	30 a2 21    	mov.w     #0x1a23, w0
    9184:	0a f4 02    	call      0xf40a <_getPassValues>
    9186:	00 00 00 

00009188 <.L0>:
                &AUAV_V3_TestSensors_B.InitializeControlMCU[0]
                );

  /* End of Start for SubSystem: '<S682>/If  Control Type Is Selective Passthrough' */

  /* Start for S-Function (MCHP_OC_HW): '<S20>/Output Compare - HW Drive Servo motor' */
  /* OCxCON1[4108, 4108, 4108, 4108]   PulseTrig1*/
  OC1CON2 = 0x9F;
    9188:	f2 09 20    	mov.w     #0x9f, w2
    918a:	12 48 88    	mov.w     w2, 0x902
  OC1RS = 0x6689;
    918c:	91 68 26    	mov.w     #0x6689, w1
    918e:	21 48 88    	mov.w     w1, 0x904
  OC1R = 1;
    9190:	10 00 20    	mov.w     #0x1, w0
    9192:	30 48 88    	mov.w     w0, 0x906
  OC2CON2 = 0x9F;
    9194:	62 48 88    	mov.w     w2, 0x90c
  OC2RS = 0x6689;
    9196:	71 48 88    	mov.w     w1, 0x90e
  OC2R = 1;
    9198:	80 48 88    	mov.w     w0, 0x910
  OC3CON2 = 0x9F;
    919a:	b2 48 88    	mov.w     w2, 0x916
  OC3RS = 0x6689;
    919c:	c1 48 88    	mov.w     w1, 0x918
  OC3R = 1;
    919e:	d0 48 88    	mov.w     w0, 0x91a
  OC4CON2 = 0x9F;
    91a0:	02 49 88    	mov.w     w2, 0x920
  OC4RS = 0x6689;
    91a2:	11 49 88    	mov.w     w1, 0x922
  OC4R = 1;
    91a4:	20 49 88    	mov.w     w0, 0x924

000091a6 <.L0>:

  /* Start for S-Function (MCHP_MCU_LOAD): '<Root>/MCU Load' */
  TMR3 = 0;                            /* Initialize Timer 3 Value to 0.  Timer 3 is enabled only when the mcu is not idle */
    91a6:	0a 21 ef    	clr.w     0x10a

000091a8 <.L0>:

  /* Start for Atomic SubSystem: '<Root>/Barometer_Driver' */
  AUA_Barometer_Driver_Start();
    91a8:	d8 e6 02    	call      0xe6d8 <_AUA_Barometer_Driver_Start>
    91aa:	00 00 00 

000091ac <.L0>:

  /* End of Start for SubSystem: '<Root>/Barometer_Driver' */

  /* Start for Atomic SubSystem: '<Root>/IMU_Mag_Driver' */
  AUAV__IMU_Mag_Driver_Start();
    91ac:	70 09 02    	call      0x10970 <_AUAV__IMU_Mag_Driver_Start>
    91ae:	01 00 00 

  /* End of Start for SubSystem: '<Root>/IMU_Mag_Driver' */

  /* Start for S-Function (MCHP_BUS_SPI): '<Root>/BUS SPI Initialize MPU 6000 Once at Startup Gyro:+-500//s (65535=>1000) Accelero: +-2G (65535=>4G)' */
  /* SPI Initialisation sequence executed once */
  /* number of SPI blocks : 2 ; Current: 2 ; MCHP_SPI_StartImplemented =  2*/
  if (MCHP_SPI12_Request == 0)         /* Last SPI sequence from this block is finished (not in the queue ?) */
    91b0:	90 44 24    	mov.w     #0x4449, w0
    91b2:	10 04 e0    	cp0.b     [w0]
    91b4:	14 00 3a    	bra       NZ, 0x91de <.L663>

000091b6 <.L0>:
  {
    MCHP_SPI12_Request = 1;
    91b6:	11 c0 b3    	mov.b     #0x1, w1
    91b8:	01 48 78    	mov.b     w1, [w0]

000091ba <.L0>:
    MCHP_SPI1_Queue.buffer[MCHP_SPI1_Queue.head] = 3;
    91ba:	20 45 24    	mov.w     #0x4452, w0
    91bc:	90 00 78    	mov.w     [w0], w1
    91be:	81 80 40    	add.w     w1, w1, w1
    91c0:	68 01 50    	sub.w     w0, #0x8, w2
    91c2:	81 00 41    	add.w     w2, w1, w1
    91c4:	32 00 20    	mov.w     #0x3, w2
    91c6:	82 08 78    	mov.w     w2, [w1]
    if (MCHP_SPI1_Queue.head >= 2)     /* There are 2 blocks SPI1, max idx for queue is 2 */
    91c8:	12 00 20    	mov.w     #0x1, w2
    91ca:	90 0f 11    	subr.w    w2, [w0], [w15]
    91cc:	02 00 36    	bra       LEU, 0x91d2 <.L664>
      MCHP_SPI1_Queue.head = 0;
    91ce:	00 08 eb    	clr.w     [w0]
    91d0:	02 00 37    	bra       0x91d6 <.L665>

000091d2 <.L664>:
    else
      MCHP_SPI1_Queue.head ++;
    91d2:	20 45 24    	mov.w     #0x4452, w0
    91d4:	10 08 e8    	inc.w     [w0], [w0]

000091d6 <.L665>:
    if (MCHP_SPI1_State == 0)
    91d6:	30 22 82    	mov.w     0x4446, w0
    91d8:	00 00 e0    	cp0.w     w0
    91da:	01 00 3a    	bra       NZ, 0x91de <.L663>
      _SPI1IF = 1;                     /* Force Interrupt */
    91dc:	01 48 a8    	bset.b    0x801, #0x2

000091de <.L663>:
  }

  /* Start for DataStoreMemory: '<Root>/Data Store Memory' */
  AUAV_V3_TestSensors_DWork.GS_INIT_FLAG = 1.0;
    91de:	00 00 20    	mov.w     #0x0, w0
    91e0:	01 f8 23    	mov.w     #0x3f80, w1
    91e2:	40 ec 88    	mov.w     w0, 0x1d88
    91e4:	51 ec 88    	mov.w     w1, 0x1d8a

000091e6 <.LBB2>:

  /* MCHP_UART_Config Block for UART 1: <Root>/UART Configuration UAV V3 UART 3/Initialize */
  /* Initialisation sequence for UART 1 */
  {
    const uint8_T InitSequence[11] = { 72, 101, 108, 108, 111, 32, 87, 111, 114,
    91e6:	f6 81 57    	sub.w     w15, #0x16, w3
    91e8:	34 e8 2b    	mov.w     #0xbe83, w4
    91ea:	0a 00 09    	.pword 0x09000a
    91ec:	b4 59 78    	mov.b     [w4++], [w3++]
      108, 100 };

    U1BRG = 0x9B5C;                    /* Baud rate: 110 (-0.00%) */
    91ee:	c0 b5 29    	mov.w     #0x9b5c, w0
    91f0:	40 11 88    	mov.w     w0, 0x228
    U1MODE = 0x8000;
    91f2:	00 00 28    	mov.w     #0x8000, w0
    91f4:	00 11 88    	mov.w     w0, 0x220
    U1STA = 0x2400;
    91f6:	00 40 22    	mov.w     #0x2400, w0
    91f8:	10 11 88    	mov.w     w0, 0x222

000091fa <.L0>:
    __delay32(1909091);                /* Wait for 1909091 cycles */
    91fa:	30 16 22    	mov.w     #0x2163, w0
    91fc:	d1 01 20    	mov.w     #0x1d, w1
    91fe:	38 12 02    	call      0x11238 <L0>
    9200:	01 00 00 
    9202:	77 81 57    	sub.w     w15, #0x17, w2

00009204 <.L0>:
    9204:	ec 81 57    	sub.w     w15, #0xc, w3

00009206 <.LBB3>:

    {
      uint_T i1;
      for (i1 = 0; i1 < 11 ; i1++) {
        while (U1STAbits.UTXBF == 1) ; /* Wait for one empty space within buffer UART */
    9206:	01 20 20    	mov.w     #0x200, w1

00009208 <.L681>:
    9208:	14 11 80    	mov.w     0x222, w4
    920a:	04 80 60    	and.w     w1, w4, w0
    920c:	fd ff 3a    	bra       NZ, 0x9208 <.L681>
        U1TXREG = InitSequence[i1];
    920e:	52 80 fb    	ze        [++w2], w0
    9210:	20 11 88    	mov.w     w0, 0x224
    9212:	83 0f 51    	sub.w     w2, w3, [w15]
    9214:	f9 ff 3a    	bra       NZ, 0x9208 <.L681>

00009216 <.LBE3>:
      }
    }

    while (U1STAbits.TRMT == 0) ;      /* Wait for all value to be sent */
    9216:	01 10 20    	mov.w     #0x100, w1

00009218 <.L676>:
    9218:	12 11 80    	mov.w     0x222, w2
    921a:	02 80 60    	and.w     w1, w2, w0
    921c:	fd ff 32    	bra       Z, 0x9218 <.L676>
    U1MODE = 0;                        /* Then switch off UART */
    921e:	20 22 ef    	clr.w     0x220

00009220 <.LBE2>:
  }

  U1BRG = 0x4B;                        /* Baud rate: 57600 (-0.06%) */
    9220:	b0 04 20    	mov.w     #0x4b, w0
    9222:	40 11 88    	mov.w     w0, 0x228
  U1MODE = 0x8000;
    9224:	02 00 28    	mov.w     #0x8000, w2
    9226:	02 11 88    	mov.w     w2, 0x220
  U1STA = 0x2400;
    9228:	01 40 22    	mov.w     #0x2400, w1
    922a:	11 11 88    	mov.w     w1, 0x222

  /* Configure UART1 Tx Interruption */
  MCHP_UART1_Tx.head = 0;              /* Initialise Circular Buffers */
    922c:	00 00 eb    	clr.w     w0
    922e:	60 e3 89    	mov.w     w0, 0x3c6c
  MCHP_UART1_Tx.tail = 0;
    9230:	50 e3 89    	mov.w     w0, 0x3c6a
  _U1TXIP = 1;                         /*  Tx Interrupt priority set to 1 */
    9232:	30 42 80    	mov.w     0x846, w0
    9234:	00 00 a0    	bset.w    w0, #0x0
    9236:	00 10 a1    	bclr.w    w0, #0x1
    9238:	00 20 a1    	bclr.w    w0, #0x2
    923a:	30 42 88    	mov.w     w0, 0x846
  _U1TXIF = 0;                         /*  */
    923c:	01 88 a9    	bclr.b    0x801, #0x4
  _U1TXIE = 1;                         /* Enable Interrupt */
    923e:	21 88 a8    	bset.b    0x821, #0x4

00009240 <.LBB4>:

  /* MCHP_UART_Config Block for UART 4: <Root>/UART Configuration UAV V3 UART 4 GPS/Initialize */
  /* Initialisation sequence for UART 4 */
  {
    const uint8_T InitSequence[11] = { 72, 101, 108, 108, 111, 32, 87, 111, 114,
    9240:	f6 81 57    	sub.w     w15, #0x16, w3
    9242:	84 e7 2b    	mov.w     #0xbe78, w4
    9244:	0a 00 09    	.pword 0x09000a
    9246:	b4 59 78    	mov.b     [w4++], [w3++]
      108, 100 };

    U4BRG = 0x9B5C;                    /* Baud rate: 110 (-0.00%) */
    9248:	c0 b5 29    	mov.w     #0x9b5c, w0
    924a:	c0 15 88    	mov.w     w0, 0x2b8
    U4MODE = 0x8000;
    924c:	82 15 88    	mov.w     w2, 0x2b0
    U4STA = 0x2400;
    924e:	91 15 88    	mov.w     w1, 0x2b2

00009250 <.L0>:
    __delay32(1909091);                /* Wait for 1909091 cycles */
    9250:	30 16 22    	mov.w     #0x2163, w0
    9252:	d1 01 20    	mov.w     #0x1d, w1
    9254:	38 12 02    	call      0x11238 <L0>
    9256:	01 00 00 
    9258:	77 81 57    	sub.w     w15, #0x17, w2

0000925a <.L0>:
    925a:	ec 81 57    	sub.w     w15, #0xc, w3

0000925c <.LBB5>:

    {
      uint_T i1;
      for (i1 = 0; i1 < 11 ; i1++) {
        while (U4STAbits.UTXBF == 1) ; /* Wait for one empty space within buffer UART */
    925c:	01 20 20    	mov.w     #0x200, w1

0000925e <.L682>:
    925e:	94 15 80    	mov.w     0x2b2, w4
    9260:	04 80 60    	and.w     w1, w4, w0
    9262:	fd ff 3a    	bra       NZ, 0x925e <.L682>
        U4TXREG = InitSequence[i1];
    9264:	52 80 fb    	ze        [++w2], w0
    9266:	a0 15 88    	mov.w     w0, 0x2b4
    9268:	83 0f 51    	sub.w     w2, w3, [w15]
    926a:	f9 ff 3a    	bra       NZ, 0x925e <.L682>

0000926c <.LBE5>:
      }
    }

    while (U4STAbits.TRMT == 0) ;      /* Wait for all value to be sent */
    926c:	01 10 20    	mov.w     #0x100, w1

0000926e <.L675>:
    926e:	92 15 80    	mov.w     0x2b2, w2
    9270:	02 80 60    	and.w     w1, w2, w0
    9272:	fd ff 32    	bra       Z, 0x926e <.L675>
    U4MODE = 0;                        /* Then switch off UART */
    9274:	b0 22 ef    	clr.w     0x2b0

00009276 <.LBE4>:
  }

  U4BRG = 0x71;                        /* Baud rate: 38400 (-0.06%) */
    9276:	10 07 20    	mov.w     #0x71, w0
    9278:	c0 15 88    	mov.w     w0, 0x2b8
  U4MODE = 0x8000;
    927a:	00 00 28    	mov.w     #0x8000, w0
    927c:	80 15 88    	mov.w     w0, 0x2b0
  U4STA = 0x2400;
    927e:	00 40 22    	mov.w     #0x2400, w0
    9280:	90 15 88    	mov.w     w0, 0x2b2

  /* Configure UART4 Tx Interruption */
  MCHP_UART4_Tx.head = 0;              /* Initialise Circular Buffers */
    9282:	00 00 eb    	clr.w     w0
    9284:	80 f3 89    	mov.w     w0, 0x3e70
  MCHP_UART4_Tx.tail = 0;
    9286:	70 f3 89    	mov.w     w0, 0x3e6e
  _U4TXIP = 5;                         /*  Tx Interrupt priority set to 1 */
    9288:	60 43 80    	mov.w     0x86c, w0
    928a:	00 40 a0    	bset.w    w0, #0x4
    928c:	00 50 a1    	bclr.w    w0, #0x5
    928e:	00 60 a0    	bset.w    w0, #0x6
    9290:	60 43 88    	mov.w     w0, 0x86c
  _U4TXIF = 0;                         /*  */
    9292:	0b 28 a9    	bclr.b    0x80b, #0x1

00009294 <.L0>:
  _U4TXIE = 1;                         /* Enable Interrupt */
    9294:	2b 28 a8    	bset.b    0x82b, #0x1

00009296 <.L0>:

  /* InitializeConditions for Atomic SubSystem: '<Root>/Sensor_Data_Adapter' */
  A_Sensor_Data_Adapter_Init();
    9296:	48 d7 02    	call      0xd748 <_A_Sensor_Data_Adapter_Init>
    9298:	00 00 00 

0000929a <.L0>:

  /* End of InitializeConditions for SubSystem: '<Root>/Sensor_Data_Adapter' */

  /* InitializeConditions for Atomic SubSystem: '<Root>/Position_and_Attitude_Filter' */
  Position_and_Attitude_Init();
    929a:	5e ab 02    	call      0xab5e <_Position_and_Attitude_Init>
    929c:	00 00 00 

0000929e <.L0>:

  /* End of InitializeConditions for SubSystem: '<Root>/Position_and_Attitude_Filter' */

  /* InitializeConditions for MATLAB Function: '<S660>/Buffer Failsafe Channel' */
  AUAV__BufferICChannel_Init(&AUAV_V3_TestSensors_DWork.sf_BufferFailsafeChannel);
    929e:	e0 00 22    	mov.w     #0x200e, w0
    92a0:	de de 07    	rcall     0x505e <_AUAV__BufferICChannel_Init> <L0> <.LFB1487> <.LFE1486>

000092a2 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S655>/Buffer IC Channel' */
  AUAV__BufferICChannel_Init(&AUAV_V3_TestSensors_DWork.sf_BufferICChannel);
    92a2:	a0 06 22    	mov.w     #0x206a, w0
    92a4:	dc de 07    	rcall     0x505e <_AUAV__BufferICChannel_Init> <L0> <.LFB1487> <.LFE1486>

000092a6 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S655>/Buffer IC Channel1' */
  AUAV__BufferICChannel_Init(&AUAV_V3_TestSensors_DWork.sf_BufferICChannel1);
    92a6:	c0 05 22    	mov.w     #0x205c, w0
    92a8:	da de 07    	rcall     0x505e <_AUAV__BufferICChannel_Init> <L0> <.LFB1487> <.LFE1486>

000092aa <.L0>:

  /* InitializeConditions for MATLAB Function: '<S655>/Buffer IC Channel2' */
  AUAV__BufferICChannel_Init(&AUAV_V3_TestSensors_DWork.sf_BufferICChannel2);
    92aa:	e0 04 22    	mov.w     #0x204e, w0
    92ac:	d8 de 07    	rcall     0x505e <_AUAV__BufferICChannel_Init> <L0> <.LFB1487> <.LFE1486>

000092ae <.L0>:

  /* InitializeConditions for MATLAB Function: '<S655>/Buffer IC Channel3' */
  AUAV__BufferICChannel_Init(&AUAV_V3_TestSensors_DWork.sf_BufferICChannel3);
    92ae:	00 04 22    	mov.w     #0x2040, w0
    92b0:	d6 de 07    	rcall     0x505e <_AUAV__BufferICChannel_Init> <L0> <.LFB1487> <.LFE1486>

000092b2 <.L0>:

  /* InitializeConditions for Atomic SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */
  /* InitializeConditions for MATLAB Function: '<S165>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_n);
    92b2:	00 1a 22    	mov.w     #0x21a0, w0
    92b4:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    92b6:	01 00 00 

000092b8 <.L0>:

  /* InitializeConditions for UnitDelay: '<S178>/FixPt Unit Delay2' */
  AUAV_V3_TestSensors_DWork.FixPtUnitDelay2_DSTATE = 1U;
    92b8:	11 c0 b3    	mov.b     #0x1, w1
    92ba:	90 ff 21    	mov.w     #0x1ff9, w0
    92bc:	01 48 78    	mov.b     w1, [w0]

000092be <.L0>:

  /* InitializeConditions for MATLAB Function: '<S141>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_i);
    92be:	90 1b b0    	add.w     #0x1b9, w0
    92c0:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    92c2:	01 00 00 

000092c4 <.L0>:

  /* End of InitializeConditions for SubSystem: '<S6>/Longitudinal Channel Encaps [updated 4.28.16]' */

  /* InitializeConditions for Atomic SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */

  /* InitializeConditions for MATLAB Function: '<S104>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_b0);
    92c4:	40 1c 22    	mov.w     #0x21c4, w0
    92c6:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    92c8:	01 00 00 

000092ca <.L0>:

  /* End of InitializeConditions for SubSystem: '<S6>/Lateral Channel Encaps [updated 4.28.16]' */

  /* InitializeConditions for MATLAB Function: '<S665>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction);
    92ca:	e0 02 22    	mov.w     #0x202e, w0
    92cc:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    92ce:	01 00 00 

000092d0 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S666>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_b);
    92d0:	c0 01 22    	mov.w     #0x201c, w0
    92d2:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    92d4:	01 00 00 

000092d6 <.L0>:

  /* InitializeConditions for Atomic SubSystem: '<Root>/Barometer_Driver' */
  AUAV_Barometer_Driver_Init();
    92d6:	cc e6 02    	call      0xe6cc <_AUAV_Barometer_Driver_Init>
    92d8:	00 00 00 

000092da <.L0>:

  /* End of InitializeConditions for SubSystem: '<Root>/Barometer_Driver' */

  /* user code (Initialize function Body) */
  uartBufferInit();
    92da:	98 11 02    	call      0x11198 <_uartBufferInit>
    92dc:	01 00 00 

000092de <.L0>:
  uartMavlinkBufferInit ();
    92de:	10 c9 02    	call      0xc910 <_uartMavlinkBufferInit>
    92e0:	00 00 00 

000092e2 <.L0>:
  InitParameterInterface();
    92e2:	b4 c9 02    	call      0xc9b4 <_InitParameterInterface>
    92e4:	00 00 00 

  /* set "at time zero" to false */
  if (rtmIsFirstInitCond(AUAV_V3_TestSensors_M)) {
    92e6:	40 23 22    	mov.w     #0x2234, w0
    92e8:	10 04 e0    	cp0.b     [w0]
    92ea:	01 00 32    	bra       Z, 0x92ee <.L661>
    rtmSetFirstInitCond(AUAV_V3_TestSensors_M, 0);
    92ec:	00 48 eb    	clr.b     [w0]

000092ee <.L661>:
  }
}
    92ee:	4f 06 78    	mov.w     [--w15], w12
    92f0:	4f 05 be    	mov.d     [--w15], w10
    92f2:	4f 04 be    	mov.d     [--w15], w8
    92f4:	00 80 fa    	ulnk      
    92f6:	00 00 06    	return    

000092f8 <_crc_accumulate>:
{
        /*Accumulate one byte of data into the CRC*/
        uint8_t tmp;

        tmp = data ^ (uint8_t)(*crcAccum &0xff);
    92f8:	11 01 78    	mov.w     [w1], w2
    92fa:	02 40 68    	xor.b     w0, w2, w0
        tmp ^= (tmp<<4);
    92fc:	80 81 fb    	ze        w0, w3
    92fe:	c4 19 dd    	sl.w      w3, #0x4, w3
    9300:	03 40 68    	xor.b     w0, w3, w0
        *crcAccum = (*crcAccum>>8) ^ (tmp<<8) ^ (tmp <<3) ^ (tmp>>4);
    9302:	00 80 fb    	ze        w0, w0
    9304:	c4 01 de    	lsr.w     w0, #0x4, w3
    9306:	48 11 de    	lsr.w     w2, #0x8, w2
    9308:	02 81 69    	xor.w     w3, w2, w2
    930a:	c8 01 dd    	sl.w      w0, #0x8, w3
    930c:	03 01 69    	xor.w     w2, w3, w2
    930e:	43 00 dd    	sl.w      w0, #0x3, w0
    9310:	80 08 69    	xor.w     w2, w0, [w1]
}
    9312:	00 00 06    	return    

00009314 <_crc_init>:
#endif

/**
 * @brief Initiliaze the buffer for the X.25 CRC
 *
 * @param crcAccum the 16 bit X.25 CRC
 */
static inline void crc_init(uint16_t* crcAccum)
{
        *crcAccum = X25_INIT_CRC;
    9314:	00 88 eb    	setm.w    [w0]
}
    9316:	00 00 06    	return    

00009318 <_crc_calculate>:


/**
 * @brief Calculates the X.25 checksum on a byte buffer
 *
 * @param  pBuffer buffer containing the byte array to hash
 * @param  length  length of the byte array
 * @return the checksum over the buffer bytes
 **/
static inline uint16_t crc_calculate(const uint8_t* pBuffer, uint16_t length)
{
    9318:	02 00 fa    	lnk       #0x2
    931a:	88 9f be    	mov.d     w8, [w15++]
    931c:	80 04 78    	mov.w     w0, w9
    931e:	01 04 78    	mov.w     w1, w8

00009320 <.L0>:
        uint16_t crcTmp;
        crc_init(&crcTmp);
    9320:	66 80 57    	sub.w     w15, #0x6, w0
    9322:	f8 ff 07    	rcall     0x9314 <_crc_init> <L0> <.LFB1> <.LFE0>

00009324 <.L0>:
	while (length--) {
    9324:	08 00 e0    	cp0.w     w8
    9326:	05 00 32    	bra       Z, 0x9332 <.L4>

00009328 <.L0>:
                crc_accumulate(*pBuffer++, &crcTmp);
    9328:	39 40 78    	mov.b     [w9++], w0
    932a:	e6 80 57    	sub.w     w15, #0x6, w1
    932c:	e5 ff 07    	rcall     0x92f8 <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1502> <.Letext0> <.Ltext0>
    932e:	08 04 e9    	dec.w     w8, w8

00009330 <.L0>:
    9330:	fb ff 3a    	bra       NZ, 0x9328 <.L0> <.L6>

00009332 <.L4>:
        }
        return crcTmp;
}
    9332:	5f b8 97    	mov.w     [w15-6], w0
    9334:	4f 04 be    	mov.d     [--w15], w8
    9336:	00 80 fa    	ulnk      
    9338:	00 00 06    	return    

0000933a <_mavlink_get_channel_status>:
	// has to be defined externally
#else
	static mavlink_status_t m_mavlink_status[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_status[chan];
    933a:	e2 c0 b3    	mov.b     #0xe, w2
    933c:	04 40 bc    	mul.b     0x4
    933e:	81 1a 23    	mov.w     #0x31a8, w1
    9340:	01 00 41    	add.w     w2, w1, w0
}
    9342:	00 00 06    	return    

00009344 <_mavlink_finalize_message_chan>:
#endif

/*
 * Internal function to give access to the channel buffer for each channel
 */
#ifndef MAVLINK_GET_CHANNEL_BUFFER
MAVLINK_HELPER mavlink_message_t* mavlink_get_channel_buffer(uint8_t chan)
{
	
#if MAVLINK_EXTERNAL_RX_BUFFER
	// No m_mavlink_buffer array defined in function,
	// has to be defined externally
#else
	static mavlink_message_t m_mavlink_buffer[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_buffer[chan];
}
#endif

/**
 * @brief Reset the status of a channel.
 */
MAVLINK_HELPER void mavlink_reset_channel_status(uint8_t chan)
{
	mavlink_status_t *status = mavlink_get_channel_status(chan);
	status->parse_state = MAVLINK_PARSE_STATE_IDLE;
}

/**
 * @brief Finalize a MAVLink message with channel assignment
 *
 * This function calculates the checksum and sets length and aircraft id correctly.
 * It assumes that the message id and the payload are already correctly set. This function
 * can also be used if the message header has already been written before (as in mavlink_msg_xxx_pack
 * instead of mavlink_msg_xxx_pack_headerless), it just introduces little extra overhead.
 *
 * @param msg Message to finalize
 * @param system_id Id of the sending (this) system, 1-127
 * @param length Message length
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length, uint8_t crc_extra)
#else
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length)
#endif
{
    9344:	02 00 fa    	lnk       #0x2
    9346:	88 9f be    	mov.d     w8, [w15++]
    9348:	8a 1f 78    	mov.w     w10, [w15++]
    934a:	00 04 78    	mov.w     w0, w8
    934c:	03 40 78    	mov.b     w3, w0
    934e:	84 44 78    	mov.b     w4, w9
    9350:	05 45 78    	mov.b     w5, w10
	// This code part is the same for all messages;
	uint16_t checksum;
	msg->magic = MAVLINK_STX;
    9352:	e3 cf b3    	mov.b     #0xfe, w3
    9354:	23 44 98    	mov.b     w3, [w8+2]
	msg->len = length;
    9356:	39 44 98    	mov.b     w9, [w8+3]
	msg->sysid = system_id;
    9358:	51 44 98    	mov.b     w1, [w8+5]

0000935a <.L0>:
	msg->compid = component_id;
	// One sequence number per component
	msg->seq = mavlink_get_channel_status(chan)->current_tx_seq;
    935a:	62 44 98    	mov.b     w2, [w8+6]
    935c:	ee ff 07    	rcall     0x933a <_mavlink_get_channel_status> <L0> <.LFB9> <.LFE2>
    935e:	80 48 90    	mov.b     [w0+8], w1
    9360:	41 44 98    	mov.b     w1, [w8+4]
	mavlink_get_channel_status(chan)->current_tx_seq = mavlink_get_channel_status(chan)->current_tx_seq+1;
    9362:	80 48 90    	mov.b     [w0+8], w1
    9364:	81 40 e8    	inc.b     w1, w1
    9366:	01 48 98    	mov.b     w1, [w0+8]

00009368 <.L0>:
	checksum = crc_calculate((uint8_t*)&msg->len, length + MAVLINK_CORE_HEADER_LEN);
    9368:	89 84 fb    	ze        w9, w9
    936a:	e5 80 44    	add.w     w9, #0x5, w1
    936c:	63 00 44    	add.w     w8, #0x3, w0
    936e:	d4 ff 07    	rcall     0x9318 <_crc_calculate> <L0> <.LFB2> <.LFE1>
    9370:	c0 bf 9f    	mov.w     w0, [w15-8]

00009372 <.L0>:
#if MAVLINK_CRC_EXTRA
	crc_accumulate(crc_extra, &checksum);
    9372:	e8 80 57    	sub.w     w15, #0x8, w1
    9374:	0a 40 78    	mov.b     w10, w0
    9376:	c0 ff 07    	rcall     0x92f8 <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1502> <.Letext0> <.Ltext0>

00009378 <.L0>:
#endif
	mavlink_ck_a(msg) = (uint8_t)(checksum & 0xFF);
    9378:	e8 00 44    	add.w     w8, #0x8, w1
    937a:	4f b8 97    	mov.w     [w15-8], w0
    937c:	38 41 90    	mov.b     [w8+3], w2
    937e:	02 81 fb    	ze        w2, w2
    9380:	02 81 40    	add.w     w1, w2, w2
    9382:	00 49 78    	mov.b     w0, [w2]
	mavlink_ck_b(msg) = (uint8_t)(checksum >> 8);
    9384:	38 41 90    	mov.b     [w8+3], w2
    9386:	02 81 fb    	ze        w2, w2
    9388:	82 80 40    	add.w     w1, w2, w1
    938a:	48 00 de    	lsr.w     w0, #0x8, w0
    938c:	90 40 98    	mov.b     w0, [w1+1]

	return length + MAVLINK_NUM_NON_PAYLOAD_BYTES;
    938e:	68 80 44    	add.w     w9, #0x8, w0
}
    9390:	4f 05 78    	mov.w     [--w15], w10
    9392:	4f 04 be    	mov.d     [--w15], w8
    9394:	00 80 fa    	ulnk      
    9396:	00 00 06    	return    

00009398 <_mavlink_finalize_message>:


/**
 * @brief Finalize a MAVLink message with MAVLINK_COMM_0 as default channel
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						 uint8_t length, uint8_t crc_extra)
{
	return mavlink_finalize_message_chan(msg, system_id, component_id, MAVLINK_COMM_0, length, crc_extra);
    9398:	84 42 78    	mov.b     w4, w5
    939a:	03 42 78    	mov.b     w3, w4
    939c:	80 41 eb    	clr.b     w3
    939e:	d2 ff 07    	rcall     0x9344 <_mavlink_finalize_message_chan> <L0> <.LFB12> <.LFE9>

000093a0 <.L0>:
}
    93a0:	00 00 06    	return    

000093a2 <_mavlink_msg_ping_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_ping_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, uint32_t seq, uint8_t target_system, uint8_t target_component)
{
    93a2:	0e 00 fa    	lnk       #0xe
    93a4:	88 1f 78    	mov.w     w8, [w15++]
    93a6:	00 44 78    	mov.b     w0, w8
    93a8:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_PING_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_uint32_t(buf, 8, seq);
	_mav_put_uint8_t(buf, 12, target_system);
	_mav_put_uint8_t(buf, 13, target_component);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PING_LEN);
#else
	mavlink_ping_t packet;
	packet.time_usec = time_usec;
    93aa:	84 bf 9f    	mov.w     w4, [w15-16]
    93ac:	95 bf 9f    	mov.w     w5, [w15-14]
    93ae:	a6 bf 9f    	mov.w     w6, [w15-12]
    93b0:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.seq = seq;
    93b2:	3f b2 97    	mov.w     [w15-26], w4
    93b4:	cf b2 97    	mov.w     [w15-24], w5
    93b6:	c4 bf 9f    	mov.w     w4, [w15-8]
    93b8:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.target_system = target_system;
    93ba:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.target_component = target_component;
    93bc:	cf e2 97    	mov.b     [w15-28], w5
    93be:	d5 ff 9f    	mov.b     w5, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PING_LEN);
    93c0:	68 01 40    	add.w     w0, #0x8, w2
    93c2:	f0 81 57    	sub.w     w15, #0x10, w3
    93c4:	06 00 09    	.pword 0x090006
    93c6:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_PING;
    93c8:	42 c0 b3    	mov.b     #0x4, w2
    93ca:	72 40 98    	mov.b     w2, [w0+7]

000093cc <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PING_LEN, MAVLINK_MSG_ID_PING_CRC);
    93cc:	d4 ce b3    	mov.b     #0xed, w4
    93ce:	e3 c0 b3    	mov.b     #0xe, w3
    93d0:	01 41 78    	mov.b     w1, w2
    93d2:	88 40 78    	mov.b     w8, w1
    93d4:	e1 ff 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000093d6 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PING_LEN);
#endif
}
    93d6:	4f 04 78    	mov.w     [--w15], w8
    93d8:	00 80 fa    	ulnk      
    93da:	00 00 06    	return    

000093dc <_mavlink_msg_gps_raw_int_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_gps_raw_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible)
{
    93dc:	1e 00 fa    	lnk       #0x1e
    93de:	88 1f 78    	mov.w     w8, [w15++]
    93e0:	00 44 78    	mov.b     w0, w8
    93e2:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_GPS_RAW_INT_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int32_t(buf, 8, lat);
	_mav_put_int32_t(buf, 12, lon);
	_mav_put_int32_t(buf, 16, alt);
	_mav_put_uint16_t(buf, 20, eph);
	_mav_put_uint16_t(buf, 22, epv);
	_mav_put_uint16_t(buf, 24, vel);
	_mav_put_uint16_t(buf, 26, cog);
	_mav_put_uint8_t(buf, 28, fix_type);
	_mav_put_uint8_t(buf, 29, satellites_visible);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
#else
	mavlink_gps_raw_int_t packet;
	packet.time_usec = time_usec;
    93e4:	84 b7 9f    	mov.w     w4, [w15-32]
    93e6:	95 b7 9f    	mov.w     w5, [w15-30]
    93e8:	a6 b7 9f    	mov.w     w6, [w15-28]
    93ea:	b7 b7 9f    	mov.w     w7, [w15-26]
	packet.lat = lat;
    93ec:	3f aa 97    	mov.w     [w15-42], w4
    93ee:	cf aa 97    	mov.w     [w15-40], w5
    93f0:	c4 b7 9f    	mov.w     w4, [w15-24]
    93f2:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.lon = lon;
    93f4:	1f aa 97    	mov.w     [w15-46], w4
    93f6:	af aa 97    	mov.w     [w15-44], w5
    93f8:	e4 b7 9f    	mov.w     w4, [w15-20]
    93fa:	f5 b7 9f    	mov.w     w5, [w15-18]
	packet.alt = alt;
    93fc:	7f a2 97    	mov.w     [w15-50], w4
    93fe:	8f aa 97    	mov.w     [w15-48], w5
    9400:	84 bf 9f    	mov.w     w4, [w15-16]
    9402:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.eph = eph;
    9404:	ef a2 97    	mov.w     [w15-52], w5
    9406:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.epv = epv;
    9408:	5f a1 97    	mov.w     [w15-54], w2
    940a:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.vel = vel;
    940c:	4f a2 97    	mov.w     [w15-56], w4
    940e:	c4 bf 9f    	mov.w     w4, [w15-8]
	packet.cog = cog;
    9410:	bf a2 97    	mov.w     [w15-58], w5
    9412:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.fix_type = fix_type;
    9414:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.satellites_visible = satellites_visible;
    9416:	4f c1 97    	mov.b     [w15-60], w2
    9418:	d2 ff 9f    	mov.b     w2, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
    941a:	e8 01 40    	add.w     w0, #0x8, w3
    941c:	04 fe 2f    	mov.w     #0xffe0, w4
    941e:	04 82 47    	add.w     w15, w4, w4
    9420:	0e 00 09    	.pword 0x09000e
    9422:	b4 19 78    	mov.w     [w4++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_GPS_RAW_INT;
    9424:	84 c1 b3    	mov.b     #0x18, w4
    9426:	74 40 98    	mov.b     w4, [w0+7]

00009428 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
    9428:	e3 c1 b3    	mov.b     #0x1e, w3
    942a:	01 41 78    	mov.b     w1, w2
    942c:	88 40 78    	mov.b     w8, w1
    942e:	b4 ff 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009430 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
#endif
}
    9430:	4f 04 78    	mov.w     [--w15], w8
    9432:	00 80 fa    	ulnk      
    9434:	00 00 06    	return    

00009436 <_mavlink_msg_scaled_imu_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_scaled_imu_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
{
    9436:	16 00 fa    	lnk       #0x16
    9438:	88 1f 78    	mov.w     w8, [w15++]
    943a:	00 44 78    	mov.b     w0, w8
    943c:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SCALED_IMU_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_int16_t(buf, 4, xacc);
	_mav_put_int16_t(buf, 6, yacc);
	_mav_put_int16_t(buf, 8, zacc);
	_mav_put_int16_t(buf, 10, xgyro);
	_mav_put_int16_t(buf, 12, ygyro);
	_mav_put_int16_t(buf, 14, zgyro);
	_mav_put_int16_t(buf, 16, xmag);
	_mav_put_int16_t(buf, 18, ymag);
	_mav_put_int16_t(buf, 20, zmag);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
#else
	mavlink_scaled_imu_t packet;
	packet.time_boot_ms = time_boot_ms;
    943e:	c4 b7 9f    	mov.w     w4, [w15-24]
    9440:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.xacc = xacc;
    9442:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.yacc = yacc;
    9444:	f6 b7 9f    	mov.w     w6, [w15-18]
	packet.zacc = zacc;
    9446:	87 bf 9f    	mov.w     w7, [w15-16]
	packet.xgyro = xgyro;
    9448:	0f b1 97    	mov.w     [w15-32], w2
    944a:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.ygyro = ygyro;
    944c:	ff a9 97    	mov.w     [w15-34], w3
    944e:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.zgyro = zgyro;
    9450:	6f a9 97    	mov.w     [w15-36], w2
    9452:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.xmag = xmag;
    9454:	df a9 97    	mov.w     [w15-38], w3
    9456:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.ymag = ymag;
    9458:	4f a9 97    	mov.w     [w15-40], w2
    945a:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.zmag = zmag;
    945c:	bf a9 97    	mov.w     [w15-42], w3
    945e:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
    9460:	68 01 40    	add.w     w0, #0x8, w2
    9462:	f8 81 57    	sub.w     w15, #0x18, w3
    9464:	0a 00 09    	.pword 0x09000a
    9466:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU;
    9468:	a2 c1 b3    	mov.b     #0x1a, w2
    946a:	72 40 98    	mov.b     w2, [w0+7]

0000946c <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
    946c:	a4 ca b3    	mov.b     #0xaa, w4
    946e:	63 c1 b3    	mov.b     #0x16, w3
    9470:	01 41 78    	mov.b     w1, w2
    9472:	88 40 78    	mov.b     w8, w1
    9474:	91 ff 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009476 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_IMU_LEN);
#endif
}
    9476:	4f 04 78    	mov.w     [--w15], w8
    9478:	00 80 fa    	ulnk      
    947a:	00 00 06    	return    

0000947c <_mavlink_msg_scaled_imu_encode>:

/**
 * @brief Pack a scaled_imu message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_boot_ms Timestamp (milliseconds since system boot)
 * @param xacc X acceleration (mg)
 * @param yacc Y acceleration (mg)
 * @param zacc Z acceleration (mg)
 * @param xgyro Angular speed around X axis (millirad /sec)
 * @param ygyro Angular speed around Y axis (millirad /sec)
 * @param zgyro Angular speed around Z axis (millirad /sec)
 * @param xmag X Magnetic field (milli tesla)
 * @param ymag Y Magnetic field (milli tesla)
 * @param zmag Z Magnetic field (milli tesla)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_scaled_imu_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_boot_ms,int16_t xacc,int16_t yacc,int16_t zacc,int16_t xgyro,int16_t ygyro,int16_t zgyro,int16_t xmag,int16_t ymag,int16_t zmag)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SCALED_IMU_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_int16_t(buf, 4, xacc);
	_mav_put_int16_t(buf, 6, yacc);
	_mav_put_int16_t(buf, 8, zacc);
	_mav_put_int16_t(buf, 10, xgyro);
	_mav_put_int16_t(buf, 12, ygyro);
	_mav_put_int16_t(buf, 14, zgyro);
	_mav_put_int16_t(buf, 16, xmag);
	_mav_put_int16_t(buf, 18, ymag);
	_mav_put_int16_t(buf, 20, zmag);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_IMU_LEN);
#else
	mavlink_scaled_imu_t packet;
	packet.time_boot_ms = time_boot_ms;
	packet.xacc = xacc;
	packet.yacc = yacc;
	packet.zacc = zacc;
	packet.xgyro = xgyro;
	packet.ygyro = ygyro;
	packet.zgyro = zgyro;
	packet.xmag = xmag;
	packet.ymag = ymag;
	packet.zmag = zmag;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_IMU_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SCALED_IMU;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU_LEN, MAVLINK_MSG_ID_SCALED_IMU_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_IMU_LEN);
#endif
}

/**
 * @brief Encode a scaled_imu struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param scaled_imu C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_scaled_imu_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_scaled_imu_t* scaled_imu)
{
    947c:	03 02 78    	mov.w     w3, w4

0000947e <.L0>:
	return mavlink_msg_scaled_imu_pack(system_id, component_id, msg, scaled_imu->time_boot_ms, scaled_imu->xacc, scaled_imu->yacc, scaled_imu->zacc, scaled_imu->xgyro, scaled_imu->ygyro, scaled_imu->zgyro, scaled_imu->xmag, scaled_imu->ymag, scaled_imu->zmag);
    947e:	c4 03 90    	mov.w     [w4+8], w7
    9480:	a4 09 90    	mov.w     [w4+20], w3
    9482:	83 1f 78    	mov.w     w3, [w15++]
    9484:	94 09 90    	mov.w     [w4+18], w3
    9486:	83 1f 78    	mov.w     w3, [w15++]
    9488:	84 09 90    	mov.w     [w4+16], w3
    948a:	83 1f 78    	mov.w     w3, [w15++]
    948c:	f4 01 90    	mov.w     [w4+14], w3
    948e:	83 1f 78    	mov.w     w3, [w15++]
    9490:	e4 01 90    	mov.w     [w4+12], w3
    9492:	83 1f 78    	mov.w     w3, [w15++]
    9494:	d4 01 90    	mov.w     [w4+10], w3
    9496:	83 1f 78    	mov.w     w3, [w15++]
    9498:	34 03 90    	mov.w     [w4+6], w6
    949a:	a4 01 90    	mov.w     [w4+4], w3
    949c:	14 02 be    	mov.d     [w4], w4
    949e:	cb ff 07    	rcall     0x9436 <_mavlink_msg_scaled_imu_pack> <L0> <.LFB189> <.LFE163>
    94a0:	ec 87 57    	sub.w     w15, #0xc, w15

000094a2 <.L0>:
}
    94a2:	00 00 06    	return    

000094a4 <_mavlink_msg_raw_imu_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_raw_imu_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
{
    94a4:	1a 00 fa    	lnk       #0x1a
    94a6:	88 1f 78    	mov.w     w8, [w15++]
    94a8:	00 44 78    	mov.b     w0, w8
    94aa:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int16_t(buf, 8, xacc);
	_mav_put_int16_t(buf, 10, yacc);
	_mav_put_int16_t(buf, 12, zacc);
	_mav_put_int16_t(buf, 14, xgyro);
	_mav_put_int16_t(buf, 16, ygyro);
	_mav_put_int16_t(buf, 18, zgyro);
	_mav_put_int16_t(buf, 20, xmag);
	_mav_put_int16_t(buf, 22, ymag);
	_mav_put_int16_t(buf, 24, zmag);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
#else
	mavlink_raw_imu_t packet;
	packet.time_usec = time_usec;
    94ac:	a4 b7 9f    	mov.w     w4, [w15-28]
    94ae:	b5 b7 9f    	mov.w     w5, [w15-26]
    94b0:	c6 b7 9f    	mov.w     w6, [w15-24]
    94b2:	d7 b7 9f    	mov.w     w7, [w15-22]
	packet.xacc = xacc;
    94b4:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.yacc = yacc;
    94b6:	6f a9 97    	mov.w     [w15-36], w2
    94b8:	f2 b7 9f    	mov.w     w2, [w15-18]
	packet.zacc = zacc;
    94ba:	df a9 97    	mov.w     [w15-38], w3
    94bc:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.xgyro = xgyro;
    94be:	4f a9 97    	mov.w     [w15-40], w2
    94c0:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.ygyro = ygyro;
    94c2:	bf a9 97    	mov.w     [w15-42], w3
    94c4:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.zgyro = zgyro;
    94c6:	2f a9 97    	mov.w     [w15-44], w2
    94c8:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.xmag = xmag;
    94ca:	9f a9 97    	mov.w     [w15-46], w3
    94cc:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.ymag = ymag;
    94ce:	0f a9 97    	mov.w     [w15-48], w2
    94d0:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.zmag = zmag;
    94d2:	ff a1 97    	mov.w     [w15-50], w3
    94d4:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
    94d6:	68 01 40    	add.w     w0, #0x8, w2
    94d8:	fc 81 57    	sub.w     w15, #0x1c, w3
    94da:	0c 00 09    	.pword 0x09000c
    94dc:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_RAW_IMU;
    94de:	b2 c1 b3    	mov.b     #0x1b, w2
    94e0:	72 40 98    	mov.b     w2, [w0+7]

000094e2 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
    94e2:	04 c9 b3    	mov.b     #0x90, w4
    94e4:	a3 c1 b3    	mov.b     #0x1a, w3
    94e6:	01 41 78    	mov.b     w1, w2
    94e8:	88 40 78    	mov.b     w8, w1
    94ea:	56 ff 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000094ec <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN);
#endif
}
    94ec:	4f 04 78    	mov.w     [--w15], w8
    94ee:	00 80 fa    	ulnk      
    94f0:	00 00 06    	return    

000094f2 <_mavlink_msg_raw_imu_encode>:

/**
 * @brief Pack a raw_imu message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param xacc X acceleration (raw)
 * @param yacc Y acceleration (raw)
 * @param zacc Z acceleration (raw)
 * @param xgyro Angular speed around X axis (raw)
 * @param ygyro Angular speed around Y axis (raw)
 * @param zgyro Angular speed around Z axis (raw)
 * @param xmag X Magnetic field (raw)
 * @param ymag Y Magnetic field (raw)
 * @param zmag Z Magnetic field (raw)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_raw_imu_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint64_t time_usec,int16_t xacc,int16_t yacc,int16_t zacc,int16_t xgyro,int16_t ygyro,int16_t zgyro,int16_t xmag,int16_t ymag,int16_t zmag)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int16_t(buf, 8, xacc);
	_mav_put_int16_t(buf, 10, yacc);
	_mav_put_int16_t(buf, 12, zacc);
	_mav_put_int16_t(buf, 14, xgyro);
	_mav_put_int16_t(buf, 16, ygyro);
	_mav_put_int16_t(buf, 18, zgyro);
	_mav_put_int16_t(buf, 20, xmag);
	_mav_put_int16_t(buf, 22, ymag);
	_mav_put_int16_t(buf, 24, zmag);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
#else
	mavlink_raw_imu_t packet;
	packet.time_usec = time_usec;
	packet.xacc = xacc;
	packet.yacc = yacc;
	packet.zacc = zacc;
	packet.xgyro = xgyro;
	packet.ygyro = ygyro;
	packet.zgyro = zgyro;
	packet.xmag = xmag;
	packet.ymag = ymag;
	packet.zmag = zmag;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_RAW_IMU;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_IMU_LEN);
#endif
}

/**
 * @brief Encode a raw_imu struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param raw_imu C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_raw_imu_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_raw_imu_t* raw_imu)
{
    94f2:	03 02 78    	mov.w     w3, w4

000094f4 <.L0>:
	return mavlink_msg_raw_imu_pack(system_id, component_id, msg, raw_imu->time_usec, raw_imu->xacc, raw_imu->yacc, raw_imu->zacc, raw_imu->xgyro, raw_imu->ygyro, raw_imu->zgyro, raw_imu->xmag, raw_imu->ymag, raw_imu->zmag);
    94f4:	c4 09 90    	mov.w     [w4+24], w3
    94f6:	83 1f 78    	mov.w     w3, [w15++]
    94f8:	b4 09 90    	mov.w     [w4+22], w3
    94fa:	83 1f 78    	mov.w     w3, [w15++]
    94fc:	a4 09 90    	mov.w     [w4+20], w3
    94fe:	83 1f 78    	mov.w     w3, [w15++]
    9500:	94 09 90    	mov.w     [w4+18], w3
    9502:	83 1f 78    	mov.w     w3, [w15++]
    9504:	84 09 90    	mov.w     [w4+16], w3
    9506:	83 1f 78    	mov.w     w3, [w15++]
    9508:	f4 01 90    	mov.w     [w4+14], w3
    950a:	83 1f 78    	mov.w     w3, [w15++]
    950c:	e4 01 90    	mov.w     [w4+12], w3
    950e:	83 1f 78    	mov.w     w3, [w15++]
    9510:	d4 01 90    	mov.w     [w4+10], w3
    9512:	83 1f 78    	mov.w     w3, [w15++]
    9514:	c4 01 90    	mov.w     [w4+8], w3
    9516:	54 03 be    	mov.d     [++w4], w6
    9518:	44 02 be    	mov.d     [--w4], w4
    951a:	c4 ff 07    	rcall     0x94a4 <_mavlink_msg_raw_imu_pack> <L0> <.LFB204> <.LFE191>
    951c:	f0 87 57    	sub.w     w15, #0x10, w15

0000951e <.L0>:
}
    951e:	00 00 06    	return    

00009520 <_mavlink_msg_raw_pressure_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_raw_pressure_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, int16_t press_abs, int16_t press_diff1, int16_t press_diff2, int16_t temperature)
{
    9520:	10 00 fa    	lnk       #0x10
    9522:	88 1f 78    	mov.w     w8, [w15++]
    9524:	00 44 78    	mov.b     w0, w8
    9526:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RAW_PRESSURE_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int16_t(buf, 8, press_abs);
	_mav_put_int16_t(buf, 10, press_diff1);
	_mav_put_int16_t(buf, 12, press_diff2);
	_mav_put_int16_t(buf, 14, temperature);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
#else
	mavlink_raw_pressure_t packet;
	packet.time_usec = time_usec;
    9528:	f4 b7 9f    	mov.w     w4, [w15-18]
    952a:	85 bf 9f    	mov.w     w5, [w15-16]
    952c:	96 bf 9f    	mov.w     w6, [w15-14]
    952e:	a7 bf 9f    	mov.w     w7, [w15-12]
	packet.press_abs = press_abs;
    9530:	b3 bf 9f    	mov.w     w3, [w15-10]
	packet.press_diff1 = press_diff1;
    9532:	3f b1 97    	mov.w     [w15-26], w2
    9534:	c2 bf 9f    	mov.w     w2, [w15-8]
	packet.press_diff2 = press_diff2;
    9536:	af b1 97    	mov.w     [w15-28], w3
    9538:	d3 bf 9f    	mov.w     w3, [w15-6]
	packet.temperature = temperature;
    953a:	1f b1 97    	mov.w     [w15-30], w2
    953c:	e2 bf 9f    	mov.w     w2, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
    953e:	e8 01 40    	add.w     w0, #0x8, w3
    9540:	72 81 57    	sub.w     w15, #0x12, w2
    9542:	07 00 09    	.pword 0x090007
    9544:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_RAW_PRESSURE;
    9546:	c2 c1 b3    	mov.b     #0x1c, w2
    9548:	72 40 98    	mov.b     w2, [w0+7]

0000954a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
    954a:	34 c4 b3    	mov.b     #0x43, w4
    954c:	03 c1 b3    	mov.b     #0x10, w3
    954e:	01 41 78    	mov.b     w1, w2
    9550:	88 40 78    	mov.b     w8, w1
    9552:	22 ff 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009554 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
#endif
}
    9554:	4f 04 78    	mov.w     [--w15], w8
    9556:	00 80 fa    	ulnk      
    9558:	00 00 06    	return    

0000955a <_mavlink_msg_raw_pressure_encode>:

/**
 * @brief Pack a raw_pressure message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_usec Timestamp (microseconds since UNIX epoch or microseconds since system boot)
 * @param press_abs Absolute pressure (raw)
 * @param press_diff1 Differential pressure 1 (raw)
 * @param press_diff2 Differential pressure 2 (raw)
 * @param temperature Raw Temperature measurement (raw)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_raw_pressure_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint64_t time_usec,int16_t press_abs,int16_t press_diff1,int16_t press_diff2,int16_t temperature)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RAW_PRESSURE_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int16_t(buf, 8, press_abs);
	_mav_put_int16_t(buf, 10, press_diff1);
	_mav_put_int16_t(buf, 12, press_diff2);
	_mav_put_int16_t(buf, 14, temperature);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
#else
	mavlink_raw_pressure_t packet;
	packet.time_usec = time_usec;
	packet.press_abs = press_abs;
	packet.press_diff1 = press_diff1;
	packet.press_diff2 = press_diff2;
	packet.temperature = temperature;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_RAW_PRESSURE;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_PRESSURE_LEN, MAVLINK_MSG_ID_RAW_PRESSURE_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
#endif
}

/**
 * @brief Encode a raw_pressure struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param raw_pressure C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_raw_pressure_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_raw_pressure_t* raw_pressure)
{
    955a:	03 02 78    	mov.w     w3, w4

0000955c <.L0>:
	return mavlink_msg_raw_pressure_pack(system_id, component_id, msg, raw_pressure->time_usec, raw_pressure->press_abs, raw_pressure->press_diff1, raw_pressure->press_diff2, raw_pressure->temperature);
    955c:	f4 01 90    	mov.w     [w4+14], w3
    955e:	83 1f 78    	mov.w     w3, [w15++]
    9560:	e4 01 90    	mov.w     [w4+12], w3
    9562:	83 1f 78    	mov.w     w3, [w15++]
    9564:	d4 01 90    	mov.w     [w4+10], w3
    9566:	83 1f 78    	mov.w     w3, [w15++]
    9568:	c4 01 90    	mov.w     [w4+8], w3
    956a:	54 03 be    	mov.d     [++w4], w6
    956c:	44 02 be    	mov.d     [--w4], w4
    956e:	d8 ff 07    	rcall     0x9520 <_mavlink_msg_raw_pressure_pack> <L0> <.LFB219> <.LFE206>
    9570:	e6 87 57    	sub.w     w15, #0x6, w15

00009572 <.L0>:
}
    9572:	00 00 06    	return    

00009574 <_mavlink_msg_scaled_pressure_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_scaled_pressure_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
{
    9574:	0e 00 fa    	lnk       #0xe
    9576:	88 1f 78    	mov.w     w8, [w15++]
    9578:	00 44 78    	mov.b     w0, w8
    957a:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, press_abs);
	_mav_put_float(buf, 8, press_diff);
	_mav_put_int16_t(buf, 12, temperature);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#else
	mavlink_scaled_pressure_t packet;
	packet.time_boot_ms = time_boot_ms;
    957c:	84 bf 9f    	mov.w     w4, [w15-16]
    957e:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.press_abs = press_abs;
    9580:	a6 bf 9f    	mov.w     w6, [w15-12]
    9582:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.press_diff = press_diff;
    9584:	3f b2 97    	mov.w     [w15-26], w4
    9586:	cf b2 97    	mov.w     [w15-24], w5
    9588:	c4 bf 9f    	mov.w     w4, [w15-8]
    958a:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.temperature = temperature;
    958c:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
    958e:	e8 02 40    	add.w     w0, #0x8, w5
    9590:	70 81 57    	sub.w     w15, #0x10, w2
    9592:	06 00 09    	.pword 0x090006
    9594:	b2 1a 78    	mov.w     [w2++], [w5++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE;
    9596:	d2 c1 b3    	mov.b     #0x1d, w2
    9598:	72 40 98    	mov.b     w2, [w0+7]

0000959a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
    959a:	34 c7 b3    	mov.b     #0x73, w4
    959c:	e3 c0 b3    	mov.b     #0xe, w3
    959e:	01 41 78    	mov.b     w1, w2
    95a0:	88 40 78    	mov.b     w8, w1
    95a2:	fa fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000095a4 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#endif
}
    95a4:	4f 04 78    	mov.w     [--w15], w8
    95a6:	00 80 fa    	ulnk      
    95a8:	00 00 06    	return    

000095aa <_mavlink_msg_scaled_pressure_encode>:

/**
 * @brief Pack a scaled_pressure message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_boot_ms Timestamp (milliseconds since system boot)
 * @param press_abs Absolute pressure (hectopascal)
 * @param press_diff Differential pressure 1 (hectopascal)
 * @param temperature Temperature measurement (0.01 degrees celsius)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_scaled_pressure_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_boot_ms,float press_abs,float press_diff,int16_t temperature)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, press_abs);
	_mav_put_float(buf, 8, press_diff);
	_mav_put_int16_t(buf, 12, temperature);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#else
	mavlink_scaled_pressure_t packet;
	packet.time_boot_ms = time_boot_ms;
	packet.press_abs = press_abs;
	packet.press_diff = press_diff;
	packet.temperature = temperature;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#endif
}

/**
 * @brief Encode a scaled_pressure struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param scaled_pressure C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_scaled_pressure_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_scaled_pressure_t* scaled_pressure)
{
    95aa:	03 02 78    	mov.w     w3, w4

000095ac <.L0>:
	return mavlink_msg_scaled_pressure_pack(system_id, component_id, msg, scaled_pressure->time_boot_ms, scaled_pressure->press_abs, scaled_pressure->press_diff, scaled_pressure->temperature);
    95ac:	44 03 90    	mov.w     [w4+8], w6
    95ae:	d4 03 90    	mov.w     [w4+10], w7
    95b0:	86 9f be    	mov.d     w6, [w15++]
    95b2:	e4 01 90    	mov.w     [w4+12], w3
    95b4:	24 03 90    	mov.w     [w4+4], w6
    95b6:	b4 03 90    	mov.w     [w4+6], w7
    95b8:	14 02 be    	mov.d     [w4], w4
    95ba:	dc ff 07    	rcall     0x9574 <_mavlink_msg_scaled_pressure_pack> <L0> <.LFB229> <.LFE221>
    95bc:	e4 87 57    	sub.w     w15, #0x4, w15

000095be <.L0>:
}
    95be:	00 00 06    	return    

000095c0 <_mavlink_msg_attitude_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_attitude_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed)
{
    95c0:	1c 00 fa    	lnk       #0x1c
    95c2:	88 1f 78    	mov.w     w8, [w15++]
    95c4:	00 44 78    	mov.b     w0, w8
    95c6:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, roll);
	_mav_put_float(buf, 8, pitch);
	_mav_put_float(buf, 12, yaw);
	_mav_put_float(buf, 16, rollspeed);
	_mav_put_float(buf, 20, pitchspeed);
	_mav_put_float(buf, 24, yawspeed);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
#else
	mavlink_attitude_t packet;
	packet.time_boot_ms = time_boot_ms;
    95c8:	94 b7 9f    	mov.w     w4, [w15-30]
    95ca:	a5 b7 9f    	mov.w     w5, [w15-28]
	packet.roll = roll;
    95cc:	b6 b7 9f    	mov.w     w6, [w15-26]
    95ce:	c7 b7 9f    	mov.w     w7, [w15-24]
	packet.pitch = pitch;
    95d0:	4f a9 97    	mov.w     [w15-40], w2
    95d2:	df a9 97    	mov.w     [w15-38], w3
    95d4:	d2 b7 9f    	mov.w     w2, [w15-22]
    95d6:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.yaw = yaw;
    95d8:	2f a9 97    	mov.w     [w15-44], w2
    95da:	bf a9 97    	mov.w     [w15-42], w3
    95dc:	f2 b7 9f    	mov.w     w2, [w15-18]
    95de:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.rollspeed = rollspeed;
    95e0:	0f a9 97    	mov.w     [w15-48], w2
    95e2:	9f a9 97    	mov.w     [w15-46], w3
    95e4:	92 bf 9f    	mov.w     w2, [w15-14]
    95e6:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.pitchspeed = pitchspeed;
    95e8:	6f a1 97    	mov.w     [w15-52], w2
    95ea:	ff a1 97    	mov.w     [w15-50], w3
    95ec:	b2 bf 9f    	mov.w     w2, [w15-10]
    95ee:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.yawspeed = yawspeed;
    95f0:	4f a1 97    	mov.w     [w15-56], w2
    95f2:	df a1 97    	mov.w     [w15-54], w3
    95f4:	d2 bf 9f    	mov.w     w2, [w15-6]
    95f6:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
    95f8:	e8 01 40    	add.w     w0, #0x8, w3
    95fa:	7e 81 57    	sub.w     w15, #0x1e, w2
    95fc:	0d 00 09    	.pword 0x09000d
    95fe:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_ATTITUDE;
    9600:	e2 c1 b3    	mov.b     #0x1e, w2
    9602:	72 40 98    	mov.b     w2, [w0+7]

00009604 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
    9604:	74 c2 b3    	mov.b     #0x27, w4
    9606:	c3 c1 b3    	mov.b     #0x1c, w3
    9608:	01 41 78    	mov.b     w1, w2
    960a:	88 40 78    	mov.b     w8, w1
    960c:	c5 fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000960e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN);
#endif
}
    960e:	4f 04 78    	mov.w     [--w15], w8
    9610:	00 80 fa    	ulnk      
    9612:	00 00 06    	return    

00009614 <_mavlink_msg_attitude_encode>:

/**
 * @brief Pack a attitude message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_boot_ms Timestamp (milliseconds since system boot)
 * @param roll Roll angle (rad, -pi..+pi)
 * @param pitch Pitch angle (rad, -pi..+pi)
 * @param yaw Yaw angle (rad, -pi..+pi)
 * @param rollspeed Roll angular speed (rad/s)
 * @param pitchspeed Pitch angular speed (rad/s)
 * @param yawspeed Yaw angular speed (rad/s)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_attitude_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_boot_ms,float roll,float pitch,float yaw,float rollspeed,float pitchspeed,float yawspeed)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, roll);
	_mav_put_float(buf, 8, pitch);
	_mav_put_float(buf, 12, yaw);
	_mav_put_float(buf, 16, rollspeed);
	_mav_put_float(buf, 20, pitchspeed);
	_mav_put_float(buf, 24, yawspeed);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
#else
	mavlink_attitude_t packet;
	packet.time_boot_ms = time_boot_ms;
	packet.roll = roll;
	packet.pitch = pitch;
	packet.yaw = yaw;
	packet.rollspeed = rollspeed;
	packet.pitchspeed = pitchspeed;
	packet.yawspeed = yawspeed;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_ATTITUDE;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ATTITUDE_LEN);
#endif
}

/**
 * @brief Encode a attitude struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param attitude C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_attitude_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_attitude_t* attitude)
{
	return mavlink_msg_attitude_pack(system_id, component_id, msg, attitude->time_boot_ms, attitude->roll, attitude->pitch, attitude->yaw, attitude->rollspeed, attitude->pitchspeed, attitude->yawspeed);
    9614:	43 0a 90    	mov.w     [w3+24], w4
    9616:	d3 0a 90    	mov.w     [w3+26], w5
    9618:	84 9f be    	mov.d     w4, [w15++]
    961a:	23 0a 90    	mov.w     [w3+20], w4
    961c:	b3 0a 90    	mov.w     [w3+22], w5
    961e:	84 9f be    	mov.d     w4, [w15++]
    9620:	03 0a 90    	mov.w     [w3+16], w4
    9622:	93 0a 90    	mov.w     [w3+18], w5
    9624:	84 9f be    	mov.d     w4, [w15++]
    9626:	63 02 90    	mov.w     [w3+12], w4
    9628:	f3 02 90    	mov.w     [w3+14], w5
    962a:	84 9f be    	mov.d     w4, [w15++]
    962c:	43 02 90    	mov.w     [w3+8], w4
    962e:	d3 02 90    	mov.w     [w3+10], w5
    9630:	84 9f be    	mov.d     w4, [w15++]
    9632:	23 03 90    	mov.w     [w3+4], w6
    9634:	b3 03 90    	mov.w     [w3+6], w7
    9636:	13 02 be    	mov.d     [w3], w4
    9638:	c3 ff 07    	rcall     0x95c0 <_mavlink_msg_attitude_pack> <L0> <.LFB238> <.LFE231>
    963a:	f4 87 57    	sub.w     w15, #0x14, w15

0000963c <.L0>:
}
    963c:	00 00 06    	return    

0000963e <_mavlink_msg_local_position_ned_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_local_position_ned_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float x, float y, float z, float vx, float vy, float vz)
{
    963e:	1c 00 fa    	lnk       #0x1c
    9640:	88 1f 78    	mov.w     w8, [w15++]
    9642:	00 44 78    	mov.b     w0, w8
    9644:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, x);
	_mav_put_float(buf, 8, y);
	_mav_put_float(buf, 12, z);
	_mav_put_float(buf, 16, vx);
	_mav_put_float(buf, 20, vy);
	_mav_put_float(buf, 24, vz);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#else
	mavlink_local_position_ned_t packet;
	packet.time_boot_ms = time_boot_ms;
    9646:	94 b7 9f    	mov.w     w4, [w15-30]
    9648:	a5 b7 9f    	mov.w     w5, [w15-28]
	packet.x = x;
    964a:	b6 b7 9f    	mov.w     w6, [w15-26]
    964c:	c7 b7 9f    	mov.w     w7, [w15-24]
	packet.y = y;
    964e:	4f a9 97    	mov.w     [w15-40], w2
    9650:	df a9 97    	mov.w     [w15-38], w3
    9652:	d2 b7 9f    	mov.w     w2, [w15-22]
    9654:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.z = z;
    9656:	2f a9 97    	mov.w     [w15-44], w2
    9658:	bf a9 97    	mov.w     [w15-42], w3
    965a:	f2 b7 9f    	mov.w     w2, [w15-18]
    965c:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.vx = vx;
    965e:	0f a9 97    	mov.w     [w15-48], w2
    9660:	9f a9 97    	mov.w     [w15-46], w3
    9662:	92 bf 9f    	mov.w     w2, [w15-14]
    9664:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.vy = vy;
    9666:	6f a1 97    	mov.w     [w15-52], w2
    9668:	ff a1 97    	mov.w     [w15-50], w3
    966a:	b2 bf 9f    	mov.w     w2, [w15-10]
    966c:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.vz = vz;
    966e:	4f a1 97    	mov.w     [w15-56], w2
    9670:	df a1 97    	mov.w     [w15-54], w3
    9672:	d2 bf 9f    	mov.w     w2, [w15-6]
    9674:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
    9676:	e8 01 40    	add.w     w0, #0x8, w3
    9678:	7e 81 57    	sub.w     w15, #0x1e, w2
    967a:	0d 00 09    	.pword 0x09000d
    967c:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;
    967e:	02 c2 b3    	mov.b     #0x20, w2
    9680:	72 40 98    	mov.b     w2, [w0+7]

00009682 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
    9682:	94 cb b3    	mov.b     #0xb9, w4
    9684:	c3 c1 b3    	mov.b     #0x1c, w3
    9686:	01 41 78    	mov.b     w1, w2
    9688:	88 40 78    	mov.b     w8, w1
    968a:	86 fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000968c <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#endif
}
    968c:	4f 04 78    	mov.w     [--w15], w8
    968e:	00 80 fa    	ulnk      
    9690:	00 00 06    	return    

00009692 <_mavlink_msg_local_position_ned_encode>:

/**
 * @brief Pack a local_position_ned message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_boot_ms Timestamp (milliseconds since system boot)
 * @param x X Position
 * @param y Y Position
 * @param z Z Position
 * @param vx X Speed
 * @param vy Y Speed
 * @param vz Z Speed
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_local_position_ned_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_boot_ms,float x,float y,float z,float vx,float vy,float vz)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, x);
	_mav_put_float(buf, 8, y);
	_mav_put_float(buf, 12, z);
	_mav_put_float(buf, 16, vx);
	_mav_put_float(buf, 20, vy);
	_mav_put_float(buf, 24, vz);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#else
	mavlink_local_position_ned_t packet;
	packet.time_boot_ms = time_boot_ms;
	packet.x = x;
	packet.y = y;
	packet.z = z;
	packet.vx = vx;
	packet.vy = vy;
	packet.vz = vz;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#endif
}

/**
 * @brief Encode a local_position_ned struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param local_position_ned C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_local_position_ned_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_local_position_ned_t* local_position_ned)
{
	return mavlink_msg_local_position_ned_pack(system_id, component_id, msg, local_position_ned->time_boot_ms, local_position_ned->x, local_position_ned->y, local_position_ned->z, local_position_ned->vx, local_position_ned->vy, local_position_ned->vz);
    9692:	43 0a 90    	mov.w     [w3+24], w4
    9694:	d3 0a 90    	mov.w     [w3+26], w5
    9696:	84 9f be    	mov.d     w4, [w15++]
    9698:	23 0a 90    	mov.w     [w3+20], w4
    969a:	b3 0a 90    	mov.w     [w3+22], w5
    969c:	84 9f be    	mov.d     w4, [w15++]
    969e:	03 0a 90    	mov.w     [w3+16], w4
    96a0:	93 0a 90    	mov.w     [w3+18], w5
    96a2:	84 9f be    	mov.d     w4, [w15++]
    96a4:	63 02 90    	mov.w     [w3+12], w4
    96a6:	f3 02 90    	mov.w     [w3+14], w5
    96a8:	84 9f be    	mov.d     w4, [w15++]
    96aa:	43 02 90    	mov.w     [w3+8], w4
    96ac:	d3 02 90    	mov.w     [w3+10], w5
    96ae:	84 9f be    	mov.d     w4, [w15++]
    96b0:	23 03 90    	mov.w     [w3+4], w6
    96b2:	b3 03 90    	mov.w     [w3+6], w7
    96b4:	13 02 be    	mov.d     [w3], w4
    96b6:	c3 ff 07    	rcall     0x963e <_mavlink_msg_local_position_ned_pack> <L0> <.LFB263> <.LFE240>
    96b8:	f4 87 57    	sub.w     w15, #0x14, w15

000096ba <.L0>:
}
    96ba:	00 00 06    	return    

000096bc <_mavlink_msg_rc_channels_raw_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_rc_channels_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, uint8_t port, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint8_t rssi)
{
    96bc:	16 00 fa    	lnk       #0x16
    96be:	88 1f 78    	mov.w     w8, [w15++]
    96c0:	00 44 78    	mov.b     w0, w8
    96c2:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_uint16_t(buf, 4, chan1_raw);
	_mav_put_uint16_t(buf, 6, chan2_raw);
	_mav_put_uint16_t(buf, 8, chan3_raw);
	_mav_put_uint16_t(buf, 10, chan4_raw);
	_mav_put_uint16_t(buf, 12, chan5_raw);
	_mav_put_uint16_t(buf, 14, chan6_raw);
	_mav_put_uint16_t(buf, 16, chan7_raw);
	_mav_put_uint16_t(buf, 18, chan8_raw);
	_mav_put_uint8_t(buf, 20, port);
	_mav_put_uint8_t(buf, 21, rssi);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#else
	mavlink_rc_channels_raw_t packet;
	packet.time_boot_ms = time_boot_ms;
    96c4:	c4 b7 9f    	mov.w     w4, [w15-24]
    96c6:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.chan1_raw = chan1_raw;
    96c8:	e6 b7 9f    	mov.w     w6, [w15-20]
	packet.chan2_raw = chan2_raw;
    96ca:	f7 b7 9f    	mov.w     w7, [w15-18]
	packet.chan3_raw = chan3_raw;
    96cc:	0f b1 97    	mov.w     [w15-32], w2
    96ce:	82 bf 9f    	mov.w     w2, [w15-16]
	packet.chan4_raw = chan4_raw;
    96d0:	7f a9 97    	mov.w     [w15-34], w2
    96d2:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.chan5_raw = chan5_raw;
    96d4:	6f a9 97    	mov.w     [w15-36], w2
    96d6:	a2 bf 9f    	mov.w     w2, [w15-12]
	packet.chan6_raw = chan6_raw;
    96d8:	5f a9 97    	mov.w     [w15-38], w2
    96da:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.chan7_raw = chan7_raw;
    96dc:	4f a9 97    	mov.w     [w15-40], w2
    96de:	c2 bf 9f    	mov.w     w2, [w15-8]
	packet.chan8_raw = chan8_raw;
    96e0:	3f a9 97    	mov.w     [w15-42], w2
    96e2:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.port = port;
    96e4:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.rssi = rssi;
    96e6:	cf d1 97    	mov.b     [w15-44], w3
    96e8:	d3 ff 9f    	mov.b     w3, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
    96ea:	68 01 40    	add.w     w0, #0x8, w2
    96ec:	f8 81 57    	sub.w     w15, #0x18, w3
    96ee:	0a 00 09    	.pword 0x09000a
    96f0:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_RAW;
    96f2:	32 c2 b3    	mov.b     #0x23, w2
    96f4:	72 40 98    	mov.b     w2, [w0+7]

000096f6 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
    96f6:	44 cf b3    	mov.b     #0xf4, w4
    96f8:	63 c1 b3    	mov.b     #0x16, w3
    96fa:	01 41 78    	mov.b     w1, w2
    96fc:	88 40 78    	mov.b     w8, w1
    96fe:	4c fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009700 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#endif
}
    9700:	4f 04 78    	mov.w     [--w15], w8
    9702:	00 80 fa    	ulnk      
    9704:	00 00 06    	return    

00009706 <_mavlink_msg_rc_channels_raw_encode>:

/**
 * @brief Pack a rc_channels_raw message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_boot_ms Timestamp (milliseconds since system boot)
 * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
 * @param chan1_raw RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan2_raw RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan3_raw RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan4_raw RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan5_raw RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan6_raw RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan7_raw RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param chan8_raw RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
 * @param rssi Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_rc_channels_raw_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_boot_ms,uint8_t port,uint16_t chan1_raw,uint16_t chan2_raw,uint16_t chan3_raw,uint16_t chan4_raw,uint16_t chan5_raw,uint16_t chan6_raw,uint16_t chan7_raw,uint16_t chan8_raw,uint8_t rssi)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_uint16_t(buf, 4, chan1_raw);
	_mav_put_uint16_t(buf, 6, chan2_raw);
	_mav_put_uint16_t(buf, 8, chan3_raw);
	_mav_put_uint16_t(buf, 10, chan4_raw);
	_mav_put_uint16_t(buf, 12, chan5_raw);
	_mav_put_uint16_t(buf, 14, chan6_raw);
	_mav_put_uint16_t(buf, 16, chan7_raw);
	_mav_put_uint16_t(buf, 18, chan8_raw);
	_mav_put_uint8_t(buf, 20, port);
	_mav_put_uint8_t(buf, 21, rssi);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#else
	mavlink_rc_channels_raw_t packet;
	packet.time_boot_ms = time_boot_ms;
	packet.chan1_raw = chan1_raw;
	packet.chan2_raw = chan2_raw;
	packet.chan3_raw = chan3_raw;
	packet.chan4_raw = chan4_raw;
	packet.chan5_raw = chan5_raw;
	packet.chan6_raw = chan6_raw;
	packet.chan7_raw = chan7_raw;
	packet.chan8_raw = chan8_raw;
	packet.port = port;
	packet.rssi = rssi;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_RAW;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#endif
}

/**
 * @brief Encode a rc_channels_raw struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param rc_channels_raw C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_rc_channels_raw_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_rc_channels_raw_t* rc_channels_raw)
{
    9706:	03 02 78    	mov.w     w3, w4

00009708 <.L0>:
	return mavlink_msg_rc_channels_raw_pack(system_id, component_id, msg, rc_channels_raw->time_boot_ms, rc_channels_raw->port, rc_channels_raw->chan1_raw, rc_channels_raw->chan2_raw, rc_channels_raw->chan3_raw, rc_channels_raw->chan4_raw, rc_channels_raw->chan5_raw, rc_channels_raw->chan6_raw, rc_channels_raw->chan7_raw, rc_channels_raw->chan8_raw, rc_channels_raw->rssi);
    9708:	b4 03 90    	mov.w     [w4+6], w7
    970a:	d4 51 90    	mov.b     [w4+21], w3
    970c:	83 1f 78    	mov.w     w3, [w15++]
    970e:	94 09 90    	mov.w     [w4+18], w3
    9710:	83 1f 78    	mov.w     w3, [w15++]
    9712:	84 09 90    	mov.w     [w4+16], w3
    9714:	83 1f 78    	mov.w     w3, [w15++]
    9716:	f4 01 90    	mov.w     [w4+14], w3
    9718:	83 1f 78    	mov.w     w3, [w15++]
    971a:	e4 01 90    	mov.w     [w4+12], w3
    971c:	83 1f 78    	mov.w     w3, [w15++]
    971e:	d4 01 90    	mov.w     [w4+10], w3
    9720:	83 1f 78    	mov.w     w3, [w15++]
    9722:	c4 01 90    	mov.w     [w4+8], w3
    9724:	83 1f 78    	mov.w     w3, [w15++]
    9726:	24 03 90    	mov.w     [w4+4], w6
    9728:	c4 51 90    	mov.b     [w4+20], w3
    972a:	14 02 be    	mov.d     [w4], w4
    972c:	c7 ff 07    	rcall     0x96bc <_mavlink_msg_rc_channels_raw_pack> <L0> <.LFB305> <.LFE265>
    972e:	ee 87 57    	sub.w     w15, #0xe, w15

00009730 <.L0>:
}
    9730:	00 00 06    	return    

00009732 <_mavlink_msg_mission_request_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_request_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t seq)
{
    9732:	88 9f be    	mov.d     w8, [w15++]
    9734:	00 43 78    	mov.b     w0, w6
    9736:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LEN];
	_mav_put_uint16_t(buf, 0, seq);
	_mav_put_uint8_t(buf, 2, target_system);
	_mav_put_uint8_t(buf, 3, target_component);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
#else
	mavlink_mission_request_t packet;
	packet.seq = seq;
    9738:	60 44 b8    	mul.uu    w8, #0x0, w8
    973a:	05 04 78    	mov.w     w5, w8
	packet.target_system = target_system;
    973c:	83 81 fb    	ze        w3, w3
    973e:	02 f0 2f    	mov.w     #0xff00, w2
    9740:	09 01 61    	and.w     w2, w9, w2
    9742:	82 81 71    	ior.w     w3, w2, w3
	packet.target_component = target_component;
    9744:	48 22 dd    	sl.w      w4, #0x8, w4
    9746:	83 81 fb    	ze        w3, w3
    9748:	83 04 72    	ior.w     w4, w3, w9

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
    974a:	48 00 98    	mov.w     w8, [w0+8]
    974c:	59 00 98    	mov.w     w9, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST;
    974e:	82 c2 b3    	mov.b     #0x28, w2
    9750:	72 40 98    	mov.b     w2, [w0+7]

00009752 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
    9752:	64 ce b3    	mov.b     #0xe6, w4
    9754:	43 c0 b3    	mov.b     #0x4, w3
    9756:	01 41 78    	mov.b     w1, w2
    9758:	86 40 78    	mov.b     w6, w1
    975a:	1e fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000975c <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
#endif
}
    975c:	4f 04 be    	mov.d     [--w15], w8
    975e:	00 00 06    	return    

00009760 <_mavlink_msg_mission_current_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_current_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint16_t seq)
{
    9760:	80 42 78    	mov.b     w0, w5
    9762:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_CURRENT_LEN];
	_mav_put_uint16_t(buf, 0, seq);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
#else
	mavlink_mission_current_t packet;
	packet.seq = seq;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
    9764:	43 00 98    	mov.w     w3, [w0+8]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_CURRENT;
    9766:	a2 c2 b3    	mov.b     #0x2a, w2
    9768:	72 40 98    	mov.b     w2, [w0+7]

0000976a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
    976a:	c4 c1 b3    	mov.b     #0x1c, w4
    976c:	23 c0 b3    	mov.b     #0x2, w3
    976e:	01 41 78    	mov.b     w1, w2
    9770:	85 40 78    	mov.b     w5, w1
    9772:	12 fe 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009774 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
#endif
}
    9774:	00 00 06    	return    

00009776 <_mavlink_msg_mission_count_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_count_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t count)
{
    9776:	88 9f be    	mov.d     w8, [w15++]
    9778:	00 43 78    	mov.b     w0, w6
    977a:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_COUNT_LEN];
	_mav_put_uint16_t(buf, 0, count);
	_mav_put_uint8_t(buf, 2, target_system);
	_mav_put_uint8_t(buf, 3, target_component);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
#else
	mavlink_mission_count_t packet;
	packet.count = count;
    977c:	60 44 b8    	mul.uu    w8, #0x0, w8
    977e:	05 04 78    	mov.w     w5, w8
	packet.target_system = target_system;
    9780:	83 81 fb    	ze        w3, w3
    9782:	02 f0 2f    	mov.w     #0xff00, w2
    9784:	09 01 61    	and.w     w2, w9, w2
    9786:	82 81 71    	ior.w     w3, w2, w3
	packet.target_component = target_component;
    9788:	48 22 dd    	sl.w      w4, #0x8, w4
    978a:	83 81 fb    	ze        w3, w3
    978c:	83 04 72    	ior.w     w4, w3, w9

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
    978e:	48 00 98    	mov.w     w8, [w0+8]
    9790:	59 00 98    	mov.w     w9, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_COUNT;
    9792:	c2 c2 b3    	mov.b     #0x2c, w2
    9794:	72 40 98    	mov.b     w2, [w0+7]

00009796 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
    9796:	d4 cd b3    	mov.b     #0xdd, w4
    9798:	43 c0 b3    	mov.b     #0x4, w3
    979a:	01 41 78    	mov.b     w1, w2
    979c:	86 40 78    	mov.b     w6, w1
    979e:	fc fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000097a0 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
#endif
}
    97a0:	4f 04 be    	mov.d     [--w15], w8
    97a2:	00 00 06    	return    

000097a4 <_mavlink_msg_mission_ack_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_ack_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint8_t type)
{
    97a4:	04 00 fa    	lnk       #0x4
    97a6:	00 43 78    	mov.b     w0, w6
    97a8:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_ACK_LEN];
	_mav_put_uint8_t(buf, 0, target_system);
	_mav_put_uint8_t(buf, 1, target_component);
	_mav_put_uint8_t(buf, 2, type);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
#else
	mavlink_mission_ack_t packet;
	packet.target_system = target_system;
    97aa:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.target_component = target_component;
    97ac:	d4 ff 9f    	mov.b     w4, [w15-3]
	packet.type = type;
    97ae:	e5 ff 9f    	mov.b     w5, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
    97b0:	03 48 98    	mov.b     w3, [w0+8]
    97b2:	63 81 57    	sub.w     w15, #0x3, w2
    97b4:	b2 41 78    	mov.b     [w2++], w3
    97b6:	13 48 98    	mov.b     w3, [w0+9]
    97b8:	12 41 78    	mov.b     [w2], w2
    97ba:	22 48 98    	mov.b     w2, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_ACK;
    97bc:	f2 c2 b3    	mov.b     #0x2f, w2
    97be:	72 40 98    	mov.b     w2, [w0+7]

000097c0 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
    97c0:	94 c9 b3    	mov.b     #0x99, w4
    97c2:	33 c0 b3    	mov.b     #0x3, w3
    97c4:	01 41 78    	mov.b     w1, w2
    97c6:	86 40 78    	mov.b     w6, w1
    97c8:	e7 fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000097ca <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN);
#endif
}
    97ca:	00 80 fa    	ulnk      
    97cc:	00 00 06    	return    

000097ce <_mavlink_msg_vfr_hud_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_vfr_hud_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float airspeed, float groundspeed, int16_t heading, uint16_t throttle, float alt, float climb)
{
    97ce:	14 00 fa    	lnk       #0x14
    97d0:	88 1f 78    	mov.w     w8, [w15++]
    97d2:	00 44 78    	mov.b     w0, w8
    97d4:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_VFR_HUD_LEN];
	_mav_put_float(buf, 0, airspeed);
	_mav_put_float(buf, 4, groundspeed);
	_mav_put_float(buf, 8, alt);
	_mav_put_float(buf, 12, climb);
	_mav_put_int16_t(buf, 16, heading);
	_mav_put_uint16_t(buf, 18, throttle);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
#else
	mavlink_vfr_hud_t packet;
	packet.airspeed = airspeed;
    97d6:	d4 b7 9f    	mov.w     w4, [w15-22]
    97d8:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.groundspeed = groundspeed;
    97da:	f6 b7 9f    	mov.w     w6, [w15-18]
    97dc:	87 bf 9f    	mov.w     w7, [w15-16]
	packet.alt = alt;
    97de:	7f aa 97    	mov.w     [w15-34], w4
    97e0:	8f b2 97    	mov.w     [w15-32], w5
    97e2:	94 bf 9f    	mov.w     w4, [w15-14]
    97e4:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.climb = climb;
    97e6:	5f aa 97    	mov.w     [w15-38], w4
    97e8:	ef aa 97    	mov.w     [w15-36], w5
    97ea:	b4 bf 9f    	mov.w     w4, [w15-10]
    97ec:	c5 bf 9f    	mov.w     w5, [w15-8]
	packet.heading = heading;
    97ee:	d3 bf 9f    	mov.w     w3, [w15-6]
	packet.throttle = throttle;
    97f0:	9f b2 97    	mov.w     [w15-30], w5
    97f2:	e5 bf 9f    	mov.w     w5, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
    97f4:	68 01 40    	add.w     w0, #0x8, w2
    97f6:	f6 81 57    	sub.w     w15, #0x16, w3
    97f8:	09 00 09    	.pword 0x090009
    97fa:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_VFR_HUD;
    97fc:	a2 c4 b3    	mov.b     #0x4a, w2
    97fe:	72 40 98    	mov.b     w2, [w0+7]

00009800 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
    9800:	44 c1 b3    	mov.b     #0x14, w4
    9802:	84 41 78    	mov.b     w4, w3
    9804:	01 41 78    	mov.b     w1, w2
    9806:	88 40 78    	mov.b     w8, w1
    9808:	c7 fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000980a <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN);
#endif
}
    980a:	4f 04 78    	mov.w     [--w15], w8
    980c:	00 80 fa    	ulnk      
    980e:	00 00 06    	return    

00009810 <_mavlink_msg_cpu_load_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_cpu_load_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t sensLoad, uint8_t ctrlLoad, uint16_t batVolt)
{
    9810:	88 9f be    	mov.d     w8, [w15++]
    9812:	00 43 78    	mov.b     w0, w6
    9814:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_CPU_LOAD_LEN];
	_mav_put_uint16_t(buf, 0, batVolt);
	_mav_put_uint8_t(buf, 2, sensLoad);
	_mav_put_uint8_t(buf, 3, ctrlLoad);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CPU_LOAD_LEN);
#else
	mavlink_cpu_load_t packet;
	packet.batVolt = batVolt;
    9816:	60 44 b8    	mul.uu    w8, #0x0, w8
    9818:	05 04 78    	mov.w     w5, w8
	packet.sensLoad = sensLoad;
    981a:	83 81 fb    	ze        w3, w3
    981c:	02 f0 2f    	mov.w     #0xff00, w2
    981e:	09 01 61    	and.w     w2, w9, w2
    9820:	82 81 71    	ior.w     w3, w2, w3
	packet.ctrlLoad = ctrlLoad;
    9822:	48 22 dd    	sl.w      w4, #0x8, w4
    9824:	83 81 fb    	ze        w3, w3
    9826:	83 04 72    	ior.w     w4, w3, w9

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CPU_LOAD_LEN);
    9828:	48 00 98    	mov.w     w8, [w0+8]
    982a:	59 00 98    	mov.w     w9, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_CPU_LOAD;
    982c:	a2 ca b3    	mov.b     #0xaa, w2
    982e:	72 40 98    	mov.b     w2, [w0+7]

00009830 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CPU_LOAD_LEN, MAVLINK_MSG_ID_CPU_LOAD_CRC);
    9830:	b4 c4 b3    	mov.b     #0x4b, w4
    9832:	43 c0 b3    	mov.b     #0x4, w3
    9834:	01 41 78    	mov.b     w1, w2
    9836:	86 40 78    	mov.b     w6, w1
    9838:	af fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000983a <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CPU_LOAD_LEN);
#endif
}
    983a:	4f 04 be    	mov.d     [--w15], w8
    983c:	00 00 06    	return    

0000983e <_mavlink_msg_cpu_load_encode>:

/**
 * @brief Pack a cpu_load message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param sensLoad Sensor DSC Load
 * @param ctrlLoad Control DSC Load
 * @param batVolt Battery Voltage in millivolts
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_cpu_load_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t sensLoad,uint8_t ctrlLoad,uint16_t batVolt)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_CPU_LOAD_LEN];
	_mav_put_uint16_t(buf, 0, batVolt);
	_mav_put_uint8_t(buf, 2, sensLoad);
	_mav_put_uint8_t(buf, 3, ctrlLoad);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CPU_LOAD_LEN);
#else
	mavlink_cpu_load_t packet;
	packet.batVolt = batVolt;
	packet.sensLoad = sensLoad;
	packet.ctrlLoad = ctrlLoad;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CPU_LOAD_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_CPU_LOAD;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CPU_LOAD_LEN, MAVLINK_MSG_ID_CPU_LOAD_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_CPU_LOAD_LEN);
#endif
}

/**
 * @brief Encode a cpu_load struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param cpu_load C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_cpu_load_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_cpu_load_t* cpu_load)
{
	return mavlink_msg_cpu_load_pack(system_id, component_id, msg, cpu_load->sensLoad, cpu_load->ctrlLoad, cpu_load->batVolt);
    983e:	93 02 78    	mov.w     [w3], w5
    9840:	33 42 90    	mov.b     [w3+3], w4
    9842:	a3 41 90    	mov.b     [w3+2], w3
    9844:	e5 ff 07    	rcall     0x9810 <_mavlink_msg_cpu_load_pack> <L0> <.LFB1261> <.LFE690>

00009846 <.L0>:
}
    9846:	00 00 06    	return    

00009848 <_mavlink_msg_sensor_bias_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sensor_bias_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float axBias, float ayBias, float azBias, float gxBias, float gyBias, float gzBias)
{
    9848:	18 00 fa    	lnk       #0x18
    984a:	88 1f 78    	mov.w     w8, [w15++]
    984c:	00 44 78    	mov.b     w0, w8
    984e:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SENSOR_BIAS_LEN];
	_mav_put_float(buf, 0, axBias);
	_mav_put_float(buf, 4, ayBias);
	_mav_put_float(buf, 8, azBias);
	_mav_put_float(buf, 12, gxBias);
	_mav_put_float(buf, 16, gyBias);
	_mav_put_float(buf, 20, gzBias);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
#else
	mavlink_sensor_bias_t packet;
	packet.axBias = axBias;
    9850:	b4 b7 9f    	mov.w     w4, [w15-26]
    9852:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.ayBias = ayBias;
    9854:	d6 b7 9f    	mov.w     w6, [w15-22]
    9856:	e7 b7 9f    	mov.w     w7, [w15-20]
	packet.azBias = azBias;
    9858:	6f a9 97    	mov.w     [w15-36], w2
    985a:	ff a9 97    	mov.w     [w15-34], w3
    985c:	f2 b7 9f    	mov.w     w2, [w15-18]
    985e:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.gxBias = gxBias;
    9860:	4f a9 97    	mov.w     [w15-40], w2
    9862:	df a9 97    	mov.w     [w15-38], w3
    9864:	92 bf 9f    	mov.w     w2, [w15-14]
    9866:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.gyBias = gyBias;
    9868:	2f a9 97    	mov.w     [w15-44], w2
    986a:	bf a9 97    	mov.w     [w15-42], w3
    986c:	b2 bf 9f    	mov.w     w2, [w15-10]
    986e:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.gzBias = gzBias;
    9870:	0f a9 97    	mov.w     [w15-48], w2
    9872:	9f a9 97    	mov.w     [w15-46], w3
    9874:	d2 bf 9f    	mov.w     w2, [w15-6]
    9876:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
    9878:	e8 01 40    	add.w     w0, #0x8, w3
    987a:	7a 81 57    	sub.w     w15, #0x1a, w2
    987c:	0b 00 09    	.pword 0x09000b
    987e:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SENSOR_BIAS;
    9880:	c2 ca b3    	mov.b     #0xac, w2
    9882:	72 40 98    	mov.b     w2, [w0+7]

00009884 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SENSOR_BIAS_LEN, MAVLINK_MSG_ID_SENSOR_BIAS_CRC);
    9884:	84 ca b3    	mov.b     #0xa8, w4
    9886:	83 c1 b3    	mov.b     #0x18, w3
    9888:	01 41 78    	mov.b     w1, w2
    988a:	88 40 78    	mov.b     w8, w1
    988c:	85 fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000988e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
#endif
}
    988e:	4f 04 78    	mov.w     [--w15], w8
    9890:	00 80 fa    	ulnk      
    9892:	00 00 06    	return    

00009894 <_mavlink_msg_sensor_bias_encode>:

/**
 * @brief Pack a sensor_bias message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param axBias Accelerometer X bias (m/s)
 * @param ayBias Accelerometer Y bias (m/s)
 * @param azBias Accelerometer Z bias (m/s)
 * @param gxBias Gyro X bias (rad/s)
 * @param gyBias Gyro Y bias (rad/s)
 * @param gzBias Gyro Z bias (rad/s)
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sensor_bias_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           float axBias,float ayBias,float azBias,float gxBias,float gyBias,float gzBias)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SENSOR_BIAS_LEN];
	_mav_put_float(buf, 0, axBias);
	_mav_put_float(buf, 4, ayBias);
	_mav_put_float(buf, 8, azBias);
	_mav_put_float(buf, 12, gxBias);
	_mav_put_float(buf, 16, gyBias);
	_mav_put_float(buf, 20, gzBias);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
#else
	mavlink_sensor_bias_t packet;
	packet.axBias = axBias;
	packet.ayBias = ayBias;
	packet.azBias = azBias;
	packet.gxBias = gxBias;
	packet.gyBias = gyBias;
	packet.gzBias = gzBias;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SENSOR_BIAS;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SENSOR_BIAS_LEN, MAVLINK_MSG_ID_SENSOR_BIAS_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SENSOR_BIAS_LEN);
#endif
}

/**
 * @brief Encode a sensor_bias struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param sensor_bias C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_sensor_bias_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_sensor_bias_t* sensor_bias)
{
	return mavlink_msg_sensor_bias_pack(system_id, component_id, msg, sensor_bias->axBias, sensor_bias->ayBias, sensor_bias->azBias, sensor_bias->gxBias, sensor_bias->gyBias, sensor_bias->gzBias);
    9894:	23 0a 90    	mov.w     [w3+20], w4
    9896:	b3 0a 90    	mov.w     [w3+22], w5
    9898:	84 9f be    	mov.d     w4, [w15++]
    989a:	03 0a 90    	mov.w     [w3+16], w4
    989c:	93 0a 90    	mov.w     [w3+18], w5
    989e:	84 9f be    	mov.d     w4, [w15++]
    98a0:	63 02 90    	mov.w     [w3+12], w4
    98a2:	f3 02 90    	mov.w     [w3+14], w5
    98a4:	84 9f be    	mov.d     w4, [w15++]
    98a6:	43 02 90    	mov.w     [w3+8], w4
    98a8:	d3 02 90    	mov.w     [w3+10], w5
    98aa:	84 9f be    	mov.d     w4, [w15++]
    98ac:	23 03 90    	mov.w     [w3+4], w6
    98ae:	b3 03 90    	mov.w     [w3+6], w7
    98b0:	13 02 be    	mov.d     [w3], w4
    98b2:	ca ff 07    	rcall     0x9848 <_mavlink_msg_sensor_bias_pack> <L0> <.LFB1269> <.LFE1263>
    98b4:	f0 87 57    	sub.w     w15, #0x10, w15

000098b6 <.L0>:
}
    98b6:	00 00 06    	return    

000098b8 <_mavlink_msg_diagnostic_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_diagnostic_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float diagFl1, float diagFl2, float diagFl3, int16_t diagSh1, int16_t diagSh2, int16_t diagSh3)
{
    98b8:	12 00 fa    	lnk       #0x12
    98ba:	88 1f 78    	mov.w     w8, [w15++]
    98bc:	00 44 78    	mov.b     w0, w8
    98be:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_DIAGNOSTIC_LEN];
	_mav_put_float(buf, 0, diagFl1);
	_mav_put_float(buf, 4, diagFl2);
	_mav_put_float(buf, 8, diagFl3);
	_mav_put_int16_t(buf, 12, diagSh1);
	_mav_put_int16_t(buf, 14, diagSh2);
	_mav_put_int16_t(buf, 16, diagSh3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
#else
	mavlink_diagnostic_t packet;
	packet.diagFl1 = diagFl1;
    98c0:	e4 b7 9f    	mov.w     w4, [w15-20]
    98c2:	f5 b7 9f    	mov.w     w5, [w15-18]
	packet.diagFl2 = diagFl2;
    98c4:	86 bf 9f    	mov.w     w6, [w15-16]
    98c6:	97 bf 9f    	mov.w     w7, [w15-14]
	packet.diagFl3 = diagFl3;
    98c8:	1f b2 97    	mov.w     [w15-30], w4
    98ca:	af b2 97    	mov.w     [w15-28], w5
    98cc:	a4 bf 9f    	mov.w     w4, [w15-12]
    98ce:	b5 bf 9f    	mov.w     w5, [w15-10]
	packet.diagSh1 = diagSh1;
    98d0:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.diagSh2 = diagSh2;
    98d2:	8f b2 97    	mov.w     [w15-32], w5
    98d4:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.diagSh3 = diagSh3;
    98d6:	7f a9 97    	mov.w     [w15-34], w2
    98d8:	e2 bf 9f    	mov.w     w2, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
    98da:	e8 01 40    	add.w     w0, #0x8, w3
    98dc:	74 82 57    	sub.w     w15, #0x14, w4
    98de:	08 00 09    	.pword 0x090008
    98e0:	b4 19 78    	mov.w     [w4++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_DIAGNOSTIC;
    98e2:	d2 ca b3    	mov.b     #0xad, w2
    98e4:	72 40 98    	mov.b     w2, [w0+7]

000098e6 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DIAGNOSTIC_LEN, MAVLINK_MSG_ID_DIAGNOSTIC_CRC);
    98e6:	24 c0 b3    	mov.b     #0x2, w4
    98e8:	23 c1 b3    	mov.b     #0x12, w3
    98ea:	01 41 78    	mov.b     w1, w2
    98ec:	88 40 78    	mov.b     w8, w1
    98ee:	54 fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000098f0 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
#endif
}
    98f0:	4f 04 78    	mov.w     [--w15], w8
    98f2:	00 80 fa    	ulnk      
    98f4:	00 00 06    	return    

000098f6 <_mavlink_msg_diagnostic_encode>:

/**
 * @brief Pack a diagnostic message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param diagFl1 Diagnostic float 1
 * @param diagFl2 Diagnostic float 2
 * @param diagFl3 Diagnostic float 3
 * @param diagSh1 Diagnostic short 1
 * @param diagSh2 Diagnostic short 2
 * @param diagSh3 Diagnostic short 3
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_diagnostic_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           float diagFl1,float diagFl2,float diagFl3,int16_t diagSh1,int16_t diagSh2,int16_t diagSh3)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_DIAGNOSTIC_LEN];
	_mav_put_float(buf, 0, diagFl1);
	_mav_put_float(buf, 4, diagFl2);
	_mav_put_float(buf, 8, diagFl3);
	_mav_put_int16_t(buf, 12, diagSh1);
	_mav_put_int16_t(buf, 14, diagSh2);
	_mav_put_int16_t(buf, 16, diagSh3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
#else
	mavlink_diagnostic_t packet;
	packet.diagFl1 = diagFl1;
	packet.diagFl2 = diagFl2;
	packet.diagFl3 = diagFl3;
	packet.diagSh1 = diagSh1;
	packet.diagSh2 = diagSh2;
	packet.diagSh3 = diagSh3;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_DIAGNOSTIC;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DIAGNOSTIC_LEN, MAVLINK_MSG_ID_DIAGNOSTIC_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DIAGNOSTIC_LEN);
#endif
}

/**
 * @brief Encode a diagnostic struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param diagnostic C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_diagnostic_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_diagnostic_t* diagnostic)
{
    98f6:	03 02 78    	mov.w     w3, w4

000098f8 <.L0>:
	return mavlink_msg_diagnostic_pack(system_id, component_id, msg, diagnostic->diagFl1, diagnostic->diagFl2, diagnostic->diagFl3, diagnostic->diagSh1, diagnostic->diagSh2, diagnostic->diagSh3);
    98f8:	84 09 90    	mov.w     [w4+16], w3
    98fa:	83 1f 78    	mov.w     w3, [w15++]
    98fc:	74 03 90    	mov.w     [w4+14], w6
    98fe:	86 1f 78    	mov.w     w6, [w15++]
    9900:	44 03 90    	mov.w     [w4+8], w6
    9902:	d4 03 90    	mov.w     [w4+10], w7
    9904:	86 9f be    	mov.d     w6, [w15++]
    9906:	e4 01 90    	mov.w     [w4+12], w3
    9908:	24 03 90    	mov.w     [w4+4], w6
    990a:	b4 03 90    	mov.w     [w4+6], w7
    990c:	14 02 be    	mov.d     [w4], w4
    990e:	d4 ff 07    	rcall     0x98b8 <_mavlink_msg_diagnostic_pack> <L0> <.LFB1280> <.LFE1271>
    9910:	e8 87 57    	sub.w     w15, #0x8, w15

00009912 <.L0>:
}
    9912:	00 00 06    	return    

00009914 <_mavlink_msg_slugs_navigation_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_slugs_navigation_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float u_m, float phi_c, float theta_c, float psiDot_c, float ay_body, float totalDist, float dist2Go, uint8_t fromWP, uint8_t toWP, uint16_t h_c)
{
    9914:	20 00 fa    	lnk       #0x20
    9916:	88 1f 78    	mov.w     w8, [w15++]
    9918:	00 44 78    	mov.b     w0, w8
    991a:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN];
	_mav_put_float(buf, 0, u_m);
	_mav_put_float(buf, 4, phi_c);
	_mav_put_float(buf, 8, theta_c);
	_mav_put_float(buf, 12, psiDot_c);
	_mav_put_float(buf, 16, ay_body);
	_mav_put_float(buf, 20, totalDist);
	_mav_put_float(buf, 24, dist2Go);
	_mav_put_uint16_t(buf, 28, h_c);
	_mav_put_uint8_t(buf, 30, fromWP);
	_mav_put_uint8_t(buf, 31, toWP);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#else
	mavlink_slugs_navigation_t packet;
	packet.u_m = u_m;
    991c:	f4 af 9f    	mov.w     w4, [w15-34]
    991e:	85 b7 9f    	mov.w     w5, [w15-32]
	packet.phi_c = phi_c;
    9920:	96 b7 9f    	mov.w     w6, [w15-30]
    9922:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.theta_c = theta_c;
    9924:	2f aa 97    	mov.w     [w15-44], w4
    9926:	bf aa 97    	mov.w     [w15-42], w5
    9928:	b4 b7 9f    	mov.w     w4, [w15-26]
    992a:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.psiDot_c = psiDot_c;
    992c:	0f aa 97    	mov.w     [w15-48], w4
    992e:	9f aa 97    	mov.w     [w15-46], w5
    9930:	d4 b7 9f    	mov.w     w4, [w15-22]
    9932:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.ay_body = ay_body;
    9934:	6f a2 97    	mov.w     [w15-52], w4
    9936:	ff a2 97    	mov.w     [w15-50], w5
    9938:	f4 b7 9f    	mov.w     w4, [w15-18]
    993a:	85 bf 9f    	mov.w     w5, [w15-16]
	packet.totalDist = totalDist;
    993c:	4f a2 97    	mov.w     [w15-56], w4
    993e:	df a2 97    	mov.w     [w15-54], w5
    9940:	94 bf 9f    	mov.w     w4, [w15-14]
    9942:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.dist2Go = dist2Go;
    9944:	2f a2 97    	mov.w     [w15-60], w4
    9946:	bf a2 97    	mov.w     [w15-58], w5
    9948:	b4 bf 9f    	mov.w     w4, [w15-10]
    994a:	c5 bf 9f    	mov.w     w5, [w15-8]
	packet.h_c = h_c;
    994c:	8f a2 97    	mov.w     [w15-64], w5
    994e:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.fromWP = fromWP;
    9950:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.toWP = toWP;
    9952:	2f c1 97    	mov.b     [w15-62], w2
    9954:	d2 ff 9f    	mov.b     w2, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
    9956:	e8 01 40    	add.w     w0, #0x8, w3
    9958:	e4 fd 2f    	mov.w     #0xffde, w4
    995a:	04 82 47    	add.w     w15, w4, w4
    995c:	0f 00 09    	.pword 0x09000f
    995e:	b4 19 78    	mov.w     [w4++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SLUGS_NAVIGATION;
    9960:	02 cb b3    	mov.b     #0xb0, w2
    9962:	72 40 98    	mov.b     w2, [w0+7]

00009964 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN, MAVLINK_MSG_ID_SLUGS_NAVIGATION_CRC);
    9964:	44 ce b3    	mov.b     #0xe4, w4
    9966:	03 c2 b3    	mov.b     #0x20, w3
    9968:	01 41 78    	mov.b     w1, w2
    996a:	88 40 78    	mov.b     w8, w1
    996c:	15 fd 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000996e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#endif
}
    996e:	4f 04 78    	mov.w     [--w15], w8
    9970:	00 80 fa    	ulnk      
    9972:	00 00 06    	return    

00009974 <_mavlink_msg_slugs_navigation_encode>:

/**
 * @brief Pack a slugs_navigation message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param u_m Measured Airspeed prior to the nav filter in m/s
 * @param phi_c Commanded Roll
 * @param theta_c Commanded Pitch
 * @param psiDot_c Commanded Turn rate
 * @param ay_body Y component of the body acceleration
 * @param totalDist Total Distance to Run on this leg of Navigation
 * @param dist2Go Remaining distance to Run on this leg of Navigation
 * @param fromWP Origin WP
 * @param toWP Destination WP
 * @param h_c Commanded altitude in 0.1 m
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_slugs_navigation_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           float u_m,float phi_c,float theta_c,float psiDot_c,float ay_body,float totalDist,float dist2Go,uint8_t fromWP,uint8_t toWP,uint16_t h_c)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN];
	_mav_put_float(buf, 0, u_m);
	_mav_put_float(buf, 4, phi_c);
	_mav_put_float(buf, 8, theta_c);
	_mav_put_float(buf, 12, psiDot_c);
	_mav_put_float(buf, 16, ay_body);
	_mav_put_float(buf, 20, totalDist);
	_mav_put_float(buf, 24, dist2Go);
	_mav_put_uint16_t(buf, 28, h_c);
	_mav_put_uint8_t(buf, 30, fromWP);
	_mav_put_uint8_t(buf, 31, toWP);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#else
	mavlink_slugs_navigation_t packet;
	packet.u_m = u_m;
	packet.phi_c = phi_c;
	packet.theta_c = theta_c;
	packet.psiDot_c = psiDot_c;
	packet.ay_body = ay_body;
	packet.totalDist = totalDist;
	packet.dist2Go = dist2Go;
	packet.h_c = h_c;
	packet.fromWP = fromWP;
	packet.toWP = toWP;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SLUGS_NAVIGATION;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN, MAVLINK_MSG_ID_SLUGS_NAVIGATION_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#endif
}

/**
 * @brief Encode a slugs_navigation struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param slugs_navigation C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_slugs_navigation_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_slugs_navigation_t* slugs_navigation)
{
    9974:	03 02 78    	mov.w     w3, w4

00009976 <.L0>:
	return mavlink_msg_slugs_navigation_pack(system_id, component_id, msg, slugs_navigation->u_m, slugs_navigation->phi_c, slugs_navigation->theta_c, slugs_navigation->psiDot_c, slugs_navigation->ay_body, slugs_navigation->totalDist, slugs_navigation->dist2Go, slugs_navigation->fromWP, slugs_navigation->toWP, slugs_navigation->h_c);
    9976:	e4 09 90    	mov.w     [w4+28], w3
    9978:	83 1f 78    	mov.w     w3, [w15++]
    997a:	74 5b 90    	mov.b     [w4+31], w6
    997c:	86 1f 78    	mov.w     w6, [w15++]
    997e:	44 0b 90    	mov.w     [w4+24], w6
    9980:	d4 0b 90    	mov.w     [w4+26], w7
    9982:	86 9f be    	mov.d     w6, [w15++]
    9984:	24 0b 90    	mov.w     [w4+20], w6
    9986:	b4 0b 90    	mov.w     [w4+22], w7
    9988:	86 9f be    	mov.d     w6, [w15++]
    998a:	04 0b 90    	mov.w     [w4+16], w6
    998c:	94 0b 90    	mov.w     [w4+18], w7
    998e:	86 9f be    	mov.d     w6, [w15++]
    9990:	64 03 90    	mov.w     [w4+12], w6
    9992:	f4 03 90    	mov.w     [w4+14], w7
    9994:	86 9f be    	mov.d     w6, [w15++]
    9996:	44 03 90    	mov.w     [w4+8], w6
    9998:	d4 03 90    	mov.w     [w4+10], w7
    999a:	86 9f be    	mov.d     w6, [w15++]
    999c:	e4 59 90    	mov.b     [w4+30], w3
    999e:	24 03 90    	mov.w     [w4+4], w6
    99a0:	b4 03 90    	mov.w     [w4+6], w7
    99a2:	14 02 be    	mov.d     [w4], w4
    99a4:	b7 ff 07    	rcall     0x9914 <_mavlink_msg_slugs_navigation_pack> <L0> <.LFB1291> <.LFE1282>
    99a6:	f8 87 57    	sub.w     w15, #0x18, w15

000099a8 <.L0>:
}
    99a8:	00 00 06    	return    

000099aa <_mavlink_msg_data_log_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_data_log_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float fl_1, float fl_2, float fl_3, float fl_4, float fl_5, float fl_6)
{
    99aa:	18 00 fa    	lnk       #0x18
    99ac:	88 1f 78    	mov.w     w8, [w15++]
    99ae:	00 44 78    	mov.b     w0, w8
    99b0:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_DATA_LOG_LEN];
	_mav_put_float(buf, 0, fl_1);
	_mav_put_float(buf, 4, fl_2);
	_mav_put_float(buf, 8, fl_3);
	_mav_put_float(buf, 12, fl_4);
	_mav_put_float(buf, 16, fl_5);
	_mav_put_float(buf, 20, fl_6);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_LOG_LEN);
#else
	mavlink_data_log_t packet;
	packet.fl_1 = fl_1;
    99b2:	b4 b7 9f    	mov.w     w4, [w15-26]
    99b4:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.fl_2 = fl_2;
    99b6:	d6 b7 9f    	mov.w     w6, [w15-22]
    99b8:	e7 b7 9f    	mov.w     w7, [w15-20]
	packet.fl_3 = fl_3;
    99ba:	6f a9 97    	mov.w     [w15-36], w2
    99bc:	ff a9 97    	mov.w     [w15-34], w3
    99be:	f2 b7 9f    	mov.w     w2, [w15-18]
    99c0:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.fl_4 = fl_4;
    99c2:	4f a9 97    	mov.w     [w15-40], w2
    99c4:	df a9 97    	mov.w     [w15-38], w3
    99c6:	92 bf 9f    	mov.w     w2, [w15-14]
    99c8:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.fl_5 = fl_5;
    99ca:	2f a9 97    	mov.w     [w15-44], w2
    99cc:	bf a9 97    	mov.w     [w15-42], w3
    99ce:	b2 bf 9f    	mov.w     w2, [w15-10]
    99d0:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.fl_6 = fl_6;
    99d2:	0f a9 97    	mov.w     [w15-48], w2
    99d4:	9f a9 97    	mov.w     [w15-46], w3
    99d6:	d2 bf 9f    	mov.w     w2, [w15-6]
    99d8:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_LOG_LEN);
    99da:	e8 01 40    	add.w     w0, #0x8, w3
    99dc:	7a 81 57    	sub.w     w15, #0x1a, w2
    99de:	0b 00 09    	.pword 0x09000b
    99e0:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_DATA_LOG;
    99e2:	12 cb b3    	mov.b     #0xb1, w2
    99e4:	72 40 98    	mov.b     w2, [w0+7]

000099e6 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_LOG_LEN, MAVLINK_MSG_ID_DATA_LOG_CRC);
    99e6:	74 ca b3    	mov.b     #0xa7, w4
    99e8:	83 c1 b3    	mov.b     #0x18, w3
    99ea:	01 41 78    	mov.b     w1, w2
    99ec:	88 40 78    	mov.b     w8, w1
    99ee:	d4 fc 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

000099f0 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_DATA_LOG_LEN);
#endif
}
    99f0:	4f 04 78    	mov.w     [--w15], w8
    99f2:	00 80 fa    	ulnk      
    99f4:	00 00 06    	return    

000099f6 <_mavlink_msg_data_log_encode>:

/**
 * @brief Pack a data_log message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param fl_1 Log value 1 
 * @param fl_2 Log value 2 
 * @param fl_3 Log value 3 
 * @param fl_4 Log value 4 
 * @param fl_5 Log value 5 
 * @param fl_6 Log value 6 
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_data_log_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           float fl_1,float fl_2,float fl_3,float fl_4,float fl_5,float fl_6)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_DATA_LOG_LEN];
	_mav_put_float(buf, 0, fl_1);
	_mav_put_float(buf, 4, fl_2);
	_mav_put_float(buf, 8, fl_3);
	_mav_put_float(buf, 12, fl_4);
	_mav_put_float(buf, 16, fl_5);
	_mav_put_float(buf, 20, fl_6);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_DATA_LOG_LEN);
#else
	mavlink_data_log_t packet;
	packet.fl_1 = fl_1;
	packet.fl_2 = fl_2;
	packet.fl_3 = fl_3;
	packet.fl_4 = fl_4;
	packet.fl_5 = fl_5;
	packet.fl_6 = fl_6;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_DATA_LOG_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_DATA_LOG;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_LOG_LEN, MAVLINK_MSG_ID_DATA_LOG_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_DATA_LOG_LEN);
#endif
}

/**
 * @brief Encode a data_log struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param data_log C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_data_log_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_data_log_t* data_log)
{
	return mavlink_msg_data_log_pack(system_id, component_id, msg, data_log->fl_1, data_log->fl_2, data_log->fl_3, data_log->fl_4, data_log->fl_5, data_log->fl_6);
    99f6:	23 0a 90    	mov.w     [w3+20], w4
    99f8:	b3 0a 90    	mov.w     [w3+22], w5
    99fa:	84 9f be    	mov.d     w4, [w15++]
    99fc:	03 0a 90    	mov.w     [w3+16], w4
    99fe:	93 0a 90    	mov.w     [w3+18], w5
    9a00:	84 9f be    	mov.d     w4, [w15++]
    9a02:	63 02 90    	mov.w     [w3+12], w4
    9a04:	f3 02 90    	mov.w     [w3+14], w5
    9a06:	84 9f be    	mov.d     w4, [w15++]
    9a08:	43 02 90    	mov.w     [w3+8], w4
    9a0a:	d3 02 90    	mov.w     [w3+10], w5
    9a0c:	84 9f be    	mov.d     w4, [w15++]
    9a0e:	23 03 90    	mov.w     [w3+4], w6
    9a10:	b3 03 90    	mov.w     [w3+6], w7
    9a12:	13 02 be    	mov.d     [w3], w4
    9a14:	ca ff 07    	rcall     0x99aa <_mavlink_msg_data_log_pack> <L0> <.LFB1306> <.LFE1293>
    9a16:	f0 87 57    	sub.w     w15, #0x10, w15

00009a18 <.L0>:
}
    9a18:	00 00 06    	return    

00009a1a <_mavlink_msg_gps_date_time_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_gps_date_time_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec, uint8_t clockStat, uint8_t visSat, uint8_t useSat, uint8_t GppGl, uint8_t sigUsedMask, uint8_t percentUsed)
{
    9a1a:	0c 00 fa    	lnk       #0xc
    9a1c:	88 1f 78    	mov.w     w8, [w15++]
    9a1e:	00 44 78    	mov.b     w0, w8
    9a20:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_GPS_DATE_TIME_LEN];
	_mav_put_uint8_t(buf, 0, year);
	_mav_put_uint8_t(buf, 1, month);
	_mav_put_uint8_t(buf, 2, day);
	_mav_put_uint8_t(buf, 3, hour);
	_mav_put_uint8_t(buf, 4, min);
	_mav_put_uint8_t(buf, 5, sec);
	_mav_put_uint8_t(buf, 6, clockStat);
	_mav_put_uint8_t(buf, 7, visSat);
	_mav_put_uint8_t(buf, 8, useSat);
	_mav_put_uint8_t(buf, 9, GppGl);
	_mav_put_uint8_t(buf, 10, sigUsedMask);
	_mav_put_uint8_t(buf, 11, percentUsed);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
#else
	mavlink_gps_date_time_t packet;
	packet.year = year;
    9a22:	a3 f7 9f    	mov.b     w3, [w15-14]
	packet.month = month;
    9a24:	b4 f7 9f    	mov.b     w4, [w15-13]
	packet.day = day;
    9a26:	c5 f7 9f    	mov.b     w5, [w15-12]
	packet.hour = hour;
    9a28:	d6 f7 9f    	mov.b     w6, [w15-11]
	packet.min = min;
    9a2a:	e7 f7 9f    	mov.b     w7, [w15-10]
	packet.sec = sec;
    9a2c:	2f e9 97    	mov.b     [w15-22], w2
    9a2e:	f2 f7 9f    	mov.b     w2, [w15-9]
	packet.clockStat = clockStat;
    9a30:	8f e9 97    	mov.b     [w15-24], w3
    9a32:	83 ff 9f    	mov.b     w3, [w15-8]
	packet.visSat = visSat;
    9a34:	6f e1 97    	mov.b     [w15-26], w2
    9a36:	92 ff 9f    	mov.b     w2, [w15-7]
	packet.useSat = useSat;
    9a38:	cf e1 97    	mov.b     [w15-28], w3
    9a3a:	a3 ff 9f    	mov.b     w3, [w15-6]
	packet.GppGl = GppGl;
    9a3c:	2f e1 97    	mov.b     [w15-30], w2
    9a3e:	b2 ff 9f    	mov.b     w2, [w15-5]
	packet.sigUsedMask = sigUsedMask;
    9a40:	8f e1 97    	mov.b     [w15-32], w3
    9a42:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.percentUsed = percentUsed;
    9a44:	6f d9 97    	mov.b     [w15-34], w2
    9a46:	d2 ff 9f    	mov.b     w2, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
    9a48:	e8 01 40    	add.w     w0, #0x8, w3
    9a4a:	6e 81 57    	sub.w     w15, #0xe, w2
    9a4c:	0b 00 09    	.pword 0x09000b
    9a4e:	b2 59 78    	mov.b     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_GPS_DATE_TIME;
    9a50:	32 cb b3    	mov.b     #0xb3, w2
    9a52:	72 40 98    	mov.b     w2, [w0+7]

00009a54 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN, MAVLINK_MSG_ID_GPS_DATE_TIME_CRC);
    9a54:	44 c8 b3    	mov.b     #0x84, w4
    9a56:	c3 c0 b3    	mov.b     #0xc, w3
    9a58:	01 41 78    	mov.b     w1, w2
    9a5a:	88 40 78    	mov.b     w8, w1
    9a5c:	9d fc 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009a5e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
#endif
}
    9a5e:	4f 04 78    	mov.w     [--w15], w8
    9a60:	00 80 fa    	ulnk      
    9a62:	00 00 06    	return    

00009a64 <_mavlink_msg_gps_date_time_encode>:

/**
 * @brief Pack a gps_date_time message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param year Year reported by Gps 
 * @param month Month reported by Gps 
 * @param day Day reported by Gps 
 * @param hour Hour reported by Gps 
 * @param min Min reported by Gps 
 * @param sec Sec reported by Gps  
 * @param clockStat Clock Status. See table 47 page 211 OEMStar Manual  
 * @param visSat Visible satellites reported by Gps  
 * @param useSat Used satellites in Solution  
 * @param GppGl GPS+GLONASS satellites in Solution  
 * @param sigUsedMask GPS and GLONASS usage mask (bit 0 GPS_used? bit_4 GLONASS_used?)
 * @param percentUsed Percent used GPS
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_gps_date_time_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t year,uint8_t month,uint8_t day,uint8_t hour,uint8_t min,uint8_t sec,uint8_t clockStat,uint8_t visSat,uint8_t useSat,uint8_t GppGl,uint8_t sigUsedMask,uint8_t percentUsed)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_GPS_DATE_TIME_LEN];
	_mav_put_uint8_t(buf, 0, year);
	_mav_put_uint8_t(buf, 1, month);
	_mav_put_uint8_t(buf, 2, day);
	_mav_put_uint8_t(buf, 3, hour);
	_mav_put_uint8_t(buf, 4, min);
	_mav_put_uint8_t(buf, 5, sec);
	_mav_put_uint8_t(buf, 6, clockStat);
	_mav_put_uint8_t(buf, 7, visSat);
	_mav_put_uint8_t(buf, 8, useSat);
	_mav_put_uint8_t(buf, 9, GppGl);
	_mav_put_uint8_t(buf, 10, sigUsedMask);
	_mav_put_uint8_t(buf, 11, percentUsed);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
#else
	mavlink_gps_date_time_t packet;
	packet.year = year;
	packet.month = month;
	packet.day = day;
	packet.hour = hour;
	packet.min = min;
	packet.sec = sec;
	packet.clockStat = clockStat;
	packet.visSat = visSat;
	packet.useSat = useSat;
	packet.GppGl = GppGl;
	packet.sigUsedMask = sigUsedMask;
	packet.percentUsed = percentUsed;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_GPS_DATE_TIME;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN, MAVLINK_MSG_ID_GPS_DATE_TIME_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
#endif
}

/**
 * @brief Encode a gps_date_time struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param gps_date_time C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_gps_date_time_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_gps_date_time_t* gps_date_time)
{
	return mavlink_msg_gps_date_time_pack(system_id, component_id, msg, gps_date_time->year, gps_date_time->month, gps_date_time->day, gps_date_time->hour, gps_date_time->min, gps_date_time->sec, gps_date_time->clockStat, gps_date_time->visSat, gps_date_time->useSat, gps_date_time->GppGl, gps_date_time->sigUsedMask, gps_date_time->percentUsed);
    9a64:	c3 43 90    	mov.b     [w3+4], w7
    9a66:	33 4a 90    	mov.b     [w3+11], w4
    9a68:	84 1f 78    	mov.w     w4, [w15++]
    9a6a:	23 4a 90    	mov.b     [w3+10], w4
    9a6c:	84 1f 78    	mov.w     w4, [w15++]
    9a6e:	13 4a 90    	mov.b     [w3+9], w4
    9a70:	84 1f 78    	mov.w     w4, [w15++]
    9a72:	03 4a 90    	mov.b     [w3+8], w4
    9a74:	84 1f 78    	mov.w     w4, [w15++]
    9a76:	73 42 90    	mov.b     [w3+7], w4
    9a78:	84 1f 78    	mov.w     w4, [w15++]
    9a7a:	63 42 90    	mov.b     [w3+6], w4
    9a7c:	84 1f 78    	mov.w     w4, [w15++]
    9a7e:	53 42 90    	mov.b     [w3+5], w4
    9a80:	84 1f 78    	mov.w     w4, [w15++]
    9a82:	33 43 90    	mov.b     [w3+3], w6
    9a84:	a3 42 90    	mov.b     [w3+2], w5
    9a86:	13 42 90    	mov.b     [w3+1], w4
    9a88:	93 41 78    	mov.b     [w3], w3
    9a8a:	c7 ff 07    	rcall     0x9a1a <_mavlink_msg_gps_date_time_pack> <L0> <.LFB1317> <.LFE1308>
    9a8c:	ee 87 57    	sub.w     w15, #0xe, w15

00009a8e <.L0>:
}
    9a8e:	00 00 06    	return    

00009a90 <_mavlink_msg_isr_location_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_isr_location_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target, float latitude, float longitude, float height, uint8_t option1, uint8_t option2, uint8_t option3)
{
    9a90:	10 00 fa    	lnk       #0x10
    9a92:	88 1f 78    	mov.w     w8, [w15++]
    9a94:	00 44 78    	mov.b     w0, w8
    9a96:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_ISR_LOCATION_LEN];
	_mav_put_float(buf, 0, latitude);
	_mav_put_float(buf, 4, longitude);
	_mav_put_float(buf, 8, height);
	_mav_put_uint8_t(buf, 12, target);
	_mav_put_uint8_t(buf, 13, option1);
	_mav_put_uint8_t(buf, 14, option2);
	_mav_put_uint8_t(buf, 15, option3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
#else
	mavlink_isr_location_t packet;
	packet.latitude = latitude;
    9a98:	f4 b7 9f    	mov.w     w4, [w15-18]
    9a9a:	85 bf 9f    	mov.w     w5, [w15-16]
	packet.longitude = longitude;
    9a9c:	96 bf 9f    	mov.w     w6, [w15-14]
    9a9e:	a7 bf 9f    	mov.w     w7, [w15-12]
	packet.height = height;
    9aa0:	2f b2 97    	mov.w     [w15-28], w4
    9aa2:	bf b2 97    	mov.w     [w15-26], w5
    9aa4:	b4 bf 9f    	mov.w     w4, [w15-10]
    9aa6:	c5 bf 9f    	mov.w     w5, [w15-8]
	packet.target = target;
    9aa8:	a3 ff 9f    	mov.b     w3, [w15-6]
	packet.option1 = option1;
    9aaa:	af e2 97    	mov.b     [w15-30], w5
    9aac:	b5 ff 9f    	mov.b     w5, [w15-5]
	packet.option2 = option2;
    9aae:	0f e1 97    	mov.b     [w15-32], w2
    9ab0:	c2 ff 9f    	mov.b     w2, [w15-4]
	packet.option3 = option3;
    9ab2:	ef d9 97    	mov.b     [w15-34], w3
    9ab4:	d3 ff 9f    	mov.b     w3, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
    9ab6:	68 02 40    	add.w     w0, #0x8, w4
    9ab8:	f2 82 57    	sub.w     w15, #0x12, w5
    9aba:	07 00 09    	.pword 0x090007
    9abc:	35 1a 78    	mov.w     [w5++], [w4++]
#endif

	msg->msgid = MAVLINK_MSG_ID_ISR_LOCATION;
    9abe:	d2 cb b3    	mov.b     #0xbd, w2
    9ac0:	72 40 98    	mov.b     w2, [w0+7]

00009ac2 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ISR_LOCATION_LEN, MAVLINK_MSG_ID_ISR_LOCATION_CRC);
    9ac2:	64 cf b3    	mov.b     #0xf6, w4
    9ac4:	03 c1 b3    	mov.b     #0x10, w3
    9ac6:	01 41 78    	mov.b     w1, w2
    9ac8:	88 40 78    	mov.b     w8, w1
    9aca:	66 fc 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009acc <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
#endif
}
    9acc:	4f 04 78    	mov.w     [--w15], w8
    9ace:	00 80 fa    	ulnk      
    9ad0:	00 00 06    	return    

00009ad2 <_mavlink_msg_isr_location_encode>:

/**
 * @brief Pack a isr_location message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param target The system reporting the action
 * @param latitude ISR Latitude
 * @param longitude ISR Longitude
 * @param height ISR Height
 * @param option1 Option 1
 * @param option2 Option 2
 * @param option3 Option 3
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_isr_location_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t target,float latitude,float longitude,float height,uint8_t option1,uint8_t option2,uint8_t option3)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_ISR_LOCATION_LEN];
	_mav_put_float(buf, 0, latitude);
	_mav_put_float(buf, 4, longitude);
	_mav_put_float(buf, 8, height);
	_mav_put_uint8_t(buf, 12, target);
	_mav_put_uint8_t(buf, 13, option1);
	_mav_put_uint8_t(buf, 14, option2);
	_mav_put_uint8_t(buf, 15, option3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
#else
	mavlink_isr_location_t packet;
	packet.latitude = latitude;
	packet.longitude = longitude;
	packet.height = height;
	packet.target = target;
	packet.option1 = option1;
	packet.option2 = option2;
	packet.option3 = option3;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_ISR_LOCATION;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ISR_LOCATION_LEN, MAVLINK_MSG_ID_ISR_LOCATION_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_ISR_LOCATION_LEN);
#endif
}

/**
 * @brief Encode a isr_location struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param isr_location C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_isr_location_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_isr_location_t* isr_location)
{
	return mavlink_msg_isr_location_pack(system_id, component_id, msg, isr_location->target, isr_location->latitude, isr_location->longitude, isr_location->height, isr_location->option1, isr_location->option2, isr_location->option3);
    9ad2:	73 4a 90    	mov.b     [w3+15], w4
    9ad4:	84 1f 78    	mov.w     w4, [w15++]
    9ad6:	e3 4a 90    	mov.b     [w3+14], w5
    9ad8:	85 1f 78    	mov.w     w5, [w15++]
    9ada:	53 4a 90    	mov.b     [w3+13], w4
    9adc:	84 1f 78    	mov.w     w4, [w15++]
    9ade:	43 02 90    	mov.w     [w3+8], w4
    9ae0:	d3 02 90    	mov.w     [w3+10], w5
    9ae2:	84 9f be    	mov.d     w4, [w15++]
    9ae4:	23 03 90    	mov.w     [w3+4], w6
    9ae6:	b3 03 90    	mov.w     [w3+6], w7
    9ae8:	13 02 be    	mov.d     [w3], w4
    9aea:	c3 49 90    	mov.b     [w3+12], w3
    9aec:	d1 ff 07    	rcall     0x9a90 <_mavlink_msg_isr_location_pack> <L0> <.LFB1385> <.LFE1319>
    9aee:	ea 87 57    	sub.w     w15, #0xa, w15

00009af0 <.L0>:
}
    9af0:	00 00 06    	return    

00009af2 <_mavlink_msg_to_send_buffer>:
/**
 * @brief Pack a message to send it over a serial byte stream
 */
MAVLINK_HELPER uint16_t mavlink_msg_to_send_buffer(uint8_t *buffer, const mavlink_message_t *msg)
{
    9af2:	88 1f 78    	mov.w     w8, [w15++]
    9af4:	01 04 78    	mov.w     w1, w8

00009af6 <.L0>:
	memcpy(buffer, (const uint8_t *)&msg->magic, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len);
    9af6:	38 41 90    	mov.b     [w8+3], w2
    9af8:	02 81 fb    	ze        w2, w2
    9afa:	68 01 41    	add.w     w2, #0x8, w2
    9afc:	88 80 e8    	inc2.w    w8, w1
    9afe:	c8 23 02    	call      0x23c8 <_memcpy>
    9b00:	00 00 00 

00009b02 <.L0>:
	return MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len;
    9b02:	38 40 90    	mov.b     [w8+3], w0
    9b04:	00 80 fb    	ze        w0, w0
    9b06:	68 00 40    	add.w     w0, #0x8, w0
}
    9b08:	4f 04 78    	mov.w     [--w15], w8
    9b0a:	00 00 06    	return    

00009b0c <_mavlink_msg_heartbeat_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_heartbeat_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status)
{
    9b0c:	0a 00 fa    	lnk       #0xa
    9b0e:	88 1f 78    	mov.w     w8, [w15++]
    9b10:	00 44 78    	mov.b     w0, w8
    9b12:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_HEARTBEAT_LEN];
	_mav_put_uint32_t(buf, 0, custom_mode);
	_mav_put_uint8_t(buf, 4, type);
	_mav_put_uint8_t(buf, 5, autopilot);
	_mav_put_uint8_t(buf, 6, base_mode);
	_mav_put_uint8_t(buf, 7, system_status);
	_mav_put_uint8_t(buf, 8, 3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
#else
	mavlink_heartbeat_t packet;
	packet.custom_mode = custom_mode;
    9b14:	a6 bf 9f    	mov.w     w6, [w15-12]
    9b16:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.type = type;
    9b18:	83 ff 9f    	mov.b     w3, [w15-8]
	packet.autopilot = autopilot;
    9b1a:	94 ff 9f    	mov.b     w4, [w15-7]
	packet.base_mode = base_mode;
    9b1c:	a5 ff 9f    	mov.b     w5, [w15-6]
	packet.system_status = system_status;
    9b1e:	4f e9 97    	mov.b     [w15-20], w2
    9b20:	b2 ff 9f    	mov.b     w2, [w15-5]
	packet.mavlink_version = 3;
    9b22:	32 c0 b3    	mov.b     #0x3, w2
    9b24:	c2 ff 9f    	mov.b     w2, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
    9b26:	46 00 98    	mov.w     w6, [w0+8]
    9b28:	57 00 98    	mov.w     w7, [w0+10]
    9b2a:	68 81 57    	sub.w     w15, #0x8, w2
    9b2c:	32 02 be    	mov.d     [w2++], w4
    9b2e:	64 00 98    	mov.w     w4, [w0+12]
    9b30:	75 00 98    	mov.w     w5, [w0+14]
    9b32:	12 41 78    	mov.b     [w2], w2
    9b34:	02 50 98    	mov.b     w2, [w0+16]
#endif

	msg->msgid = MAVLINK_MSG_ID_HEARTBEAT;
    9b36:	00 41 eb    	clr.b     w2
    9b38:	72 40 98    	mov.b     w2, [w0+7]

00009b3a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
    9b3a:	24 c3 b3    	mov.b     #0x32, w4
    9b3c:	93 c0 b3    	mov.b     #0x9, w3
    9b3e:	01 41 78    	mov.b     w1, w2
    9b40:	88 40 78    	mov.b     w8, w1
    9b42:	2a fc 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009b44 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN);
#endif
}
    9b44:	4f 04 78    	mov.w     [--w15], w8
    9b46:	00 80 fa    	ulnk      
    9b48:	00 00 06    	return    

00009b4a <_mavlink_msg_ctrl_srfc_pt_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_ctrl_srfc_pt_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target, uint16_t bitfieldPt)
{
    9b4a:	04 00 fa    	lnk       #0x4
    9b4c:	80 42 78    	mov.b     w0, w5
    9b4e:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_CTRL_SRFC_PT_LEN];
	_mav_put_uint16_t(buf, 0, bitfieldPt);
	_mav_put_uint8_t(buf, 2, target);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_CTRL_SRFC_PT_LEN);
#else
	mavlink_ctrl_srfc_pt_t packet;
	packet.bitfieldPt = bitfieldPt;
    9b50:	e4 bf 9f    	mov.w     w4, [w15-4]
	packet.target = target;
    9b52:	e3 ff 9f    	mov.b     w3, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_CTRL_SRFC_PT_LEN);
    9b54:	68 01 40    	add.w     w0, #0x8, w2
    9b56:	04 09 78    	mov.w     w4, [w2]
    9b58:	23 48 98    	mov.b     w3, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_CTRL_SRFC_PT;
    9b5a:	52 cb b3    	mov.b     #0xb5, w2
    9b5c:	72 40 98    	mov.b     w2, [w0+7]

00009b5e <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CTRL_SRFC_PT_LEN, MAVLINK_MSG_ID_CTRL_SRFC_PT_CRC);
    9b5e:	84 c6 b3    	mov.b     #0x68, w4
    9b60:	33 c0 b3    	mov.b     #0x3, w3
    9b62:	01 41 78    	mov.b     w1, w2
    9b64:	85 40 78    	mov.b     w5, w1
    9b66:	18 fc 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009b68 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_CTRL_SRFC_PT_LEN);
#endif
}
    9b68:	00 80 fa    	ulnk      
    9b6a:	00 00 06    	return    

00009b6c <_mavlink_msg_sensor_diag_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sensor_diag_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float float1, float float2, int16_t int1, int8_t char1)
{
    9b6c:	0c 00 fa    	lnk       #0xc
    9b6e:	88 1f 78    	mov.w     w8, [w15++]
    9b70:	00 44 78    	mov.b     w0, w8
    9b72:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SENSOR_DIAG_LEN];
	_mav_put_float(buf, 0, float1);
	_mav_put_float(buf, 4, float2);
	_mav_put_int16_t(buf, 8, int1);
	_mav_put_int8_t(buf, 10, char1);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
#else
	mavlink_sensor_diag_t packet;
	packet.float1 = float1;
    9b74:	94 bf 9f    	mov.w     w4, [w15-14]
    9b76:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.float2 = float2;
    9b78:	b6 bf 9f    	mov.w     w6, [w15-10]
    9b7a:	c7 bf 9f    	mov.w     w7, [w15-8]
	packet.int1 = int1;
    9b7c:	d3 bf 9f    	mov.w     w3, [w15-6]
	packet.char1 = char1;
    9b7e:	2f e9 97    	mov.b     [w15-22], w2
    9b80:	c2 ff 9f    	mov.b     w2, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
    9b82:	e8 01 40    	add.w     w0, #0x8, w3
    9b84:	6e 81 57    	sub.w     w15, #0xe, w2
    9b86:	04 00 09    	.pword 0x090004
    9b88:	b2 19 78    	mov.w     [w2++], [w3++]
    9b8a:	b2 59 78    	mov.b     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SENSOR_DIAG;
    9b8c:	42 cc b3    	mov.b     #0xc4, w2
    9b8e:	72 40 98    	mov.b     w2, [w0+7]

00009b90 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SENSOR_DIAG_LEN, MAVLINK_MSG_ID_SENSOR_DIAG_CRC);
    9b90:	14 c8 b3    	mov.b     #0x81, w4
    9b92:	b3 c0 b3    	mov.b     #0xb, w3
    9b94:	01 41 78    	mov.b     w1, w2
    9b96:	88 40 78    	mov.b     w8, w1
    9b98:	ff fb 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009b9a <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
#endif
}
    9b9a:	4f 04 78    	mov.w     [--w15], w8
    9b9c:	00 80 fa    	ulnk      
    9b9e:	00 00 06    	return    

00009ba0 <_mavlink_msg_sensor_diag_encode>:

/**
 * @brief Pack a sensor_diag message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param float1 Float field 1
 * @param float2 Float field 2
 * @param int1 Int 16 field 1
 * @param char1 Int 8 field 1
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sensor_diag_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           float float1,float float2,int16_t int1,int8_t char1)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SENSOR_DIAG_LEN];
	_mav_put_float(buf, 0, float1);
	_mav_put_float(buf, 4, float2);
	_mav_put_int16_t(buf, 8, int1);
	_mav_put_int8_t(buf, 10, char1);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
#else
	mavlink_sensor_diag_t packet;
	packet.float1 = float1;
	packet.float2 = float2;
	packet.int1 = int1;
	packet.char1 = char1;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SENSOR_DIAG;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SENSOR_DIAG_LEN, MAVLINK_MSG_ID_SENSOR_DIAG_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SENSOR_DIAG_LEN);
#endif
}

/**
 * @brief Encode a sensor_diag struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param sensor_diag C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_sensor_diag_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_sensor_diag_t* sensor_diag)
{
    9ba0:	03 02 78    	mov.w     w3, w4

00009ba2 <.L0>:
	return mavlink_msg_sensor_diag_pack(system_id, component_id, msg, sensor_diag->float1, sensor_diag->float2, sensor_diag->int1, sensor_diag->char1);
    9ba2:	a4 49 90    	mov.b     [w4+10], w3
    9ba4:	83 1f 78    	mov.w     w3, [w15++]
    9ba6:	c4 01 90    	mov.w     [w4+8], w3
    9ba8:	24 03 90    	mov.w     [w4+4], w6
    9baa:	b4 03 90    	mov.w     [w4+6], w7
    9bac:	14 02 be    	mov.d     [w4], w4
    9bae:	de ff 07    	rcall     0x9b6c <_mavlink_msg_sensor_diag_pack> <L0> <.LFB1448> <.LFE1343>
    9bb0:	8f 87 e9    	dec2.w    w15, w15

00009bb2 <.L0>:
}
    9bb2:	00 00 06    	return    

00009bb4 <_mavlink_msg_sys_status_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sys_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t onboard_control_sensors_present, uint32_t onboard_control_sensors_enabled, uint32_t onboard_control_sensors_health, uint16_t load, uint16_t voltage_battery, int16_t current_battery, int8_t battery_remaining, uint16_t drop_rate_comm, uint16_t errors_comm, uint16_t errors_count1, uint16_t errors_count2, uint16_t errors_count3, uint16_t errors_count4)
{
    9bb4:	20 00 fa    	lnk       #0x20
    9bb6:	88 1f 78    	mov.w     w8, [w15++]
    9bb8:	00 44 78    	mov.b     w0, w8
    9bba:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
	_mav_put_uint16_t(buf, 12, load);
	_mav_put_uint16_t(buf, 14, voltage_battery);
	_mav_put_int16_t(buf, 16, current_battery);
	_mav_put_uint16_t(buf, 18, drop_rate_comm);
	_mav_put_uint16_t(buf, 20, errors_comm);
	_mav_put_uint16_t(buf, 22, errors_count1);
	_mav_put_uint16_t(buf, 24, errors_count2);
	_mav_put_uint16_t(buf, 26, errors_count3);
	_mav_put_uint16_t(buf, 28, errors_count4);
	_mav_put_int8_t(buf, 30, battery_remaining);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#else
	mavlink_sys_status_t packet;
	packet.onboard_control_sensors_present = onboard_control_sensors_present;
    9bbc:	f4 af 9f    	mov.w     w4, [w15-34]
    9bbe:	85 b7 9f    	mov.w     w5, [w15-32]
	packet.onboard_control_sensors_enabled = onboard_control_sensors_enabled;
    9bc0:	96 b7 9f    	mov.w     w6, [w15-30]
    9bc2:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.onboard_control_sensors_health = onboard_control_sensors_health;
    9bc4:	2f aa 97    	mov.w     [w15-44], w4
    9bc6:	bf aa 97    	mov.w     [w15-42], w5
    9bc8:	b4 b7 9f    	mov.w     w4, [w15-26]
    9bca:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.load = load;
    9bcc:	d3 b7 9f    	mov.w     w3, [w15-22]
	packet.voltage_battery = voltage_battery;
    9bce:	9f aa 97    	mov.w     [w15-46], w5
    9bd0:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.current_battery = current_battery;
    9bd2:	0f a9 97    	mov.w     [w15-48], w2
    9bd4:	f2 b7 9f    	mov.w     w2, [w15-18]
	packet.drop_rate_comm = drop_rate_comm;
    9bd6:	ef a1 97    	mov.w     [w15-52], w3
    9bd8:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.errors_comm = errors_comm;
    9bda:	5f a2 97    	mov.w     [w15-54], w4
    9bdc:	94 bf 9f    	mov.w     w4, [w15-14]
	packet.errors_count1 = errors_count1;
    9bde:	cf a2 97    	mov.w     [w15-56], w5
    9be0:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.errors_count2 = errors_count2;
    9be2:	3f a1 97    	mov.w     [w15-58], w2
    9be4:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.errors_count3 = errors_count3;
    9be6:	af a1 97    	mov.w     [w15-60], w3
    9be8:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.errors_count4 = errors_count4;
    9bea:	1f a2 97    	mov.w     [w15-62], w4
    9bec:	d4 bf 9f    	mov.w     w4, [w15-6]
	packet.battery_remaining = battery_remaining;
    9bee:	ef ca 97    	mov.b     [w15-50], w5
    9bf0:	c5 ff 9f    	mov.b     w5, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
    9bf2:	68 01 40    	add.w     w0, #0x8, w2
    9bf4:	e3 fd 2f    	mov.w     #0xffde, w3
    9bf6:	83 81 47    	add.w     w15, w3, w3
    9bf8:	0e 00 09    	.pword 0x09000e
    9bfa:	33 19 78    	mov.w     [w3++], [w2++]
    9bfc:	33 59 78    	mov.b     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SYS_STATUS;
    9bfe:	12 c0 b3    	mov.b     #0x1, w2
    9c00:	72 40 98    	mov.b     w2, [w0+7]

00009c02 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
    9c02:	c4 c7 b3    	mov.b     #0x7c, w4
    9c04:	f3 c1 b3    	mov.b     #0x1f, w3
    9c06:	01 41 78    	mov.b     w1, w2
    9c08:	88 40 78    	mov.b     w8, w1
    9c0a:	c6 fb 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009c0c <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#endif
}
    9c0c:	4f 04 78    	mov.w     [--w15], w8
    9c0e:	00 80 fa    	ulnk      
    9c10:	00 00 06    	return    

00009c12 <_mavlink_msg_sys_status_encode>:

/**
 * @brief Pack a sys_status message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param onboard_control_sensors_present Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param onboard_control_sensors_enabled Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param onboard_control_sensors_health Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
 * @param load Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
 * @param voltage_battery Battery voltage, in millivolts (1 = 1 millivolt)
 * @param current_battery Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
 * @param battery_remaining Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
 * @param drop_rate_comm Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
 * @param errors_comm Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
 * @param errors_count1 Autopilot-specific errors
 * @param errors_count2 Autopilot-specific errors
 * @param errors_count3 Autopilot-specific errors
 * @param errors_count4 Autopilot-specific errors
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sys_status_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t onboard_control_sensors_present,uint32_t onboard_control_sensors_enabled,uint32_t onboard_control_sensors_health,uint16_t load,uint16_t voltage_battery,int16_t current_battery,int8_t battery_remaining,uint16_t drop_rate_comm,uint16_t errors_comm,uint16_t errors_count1,uint16_t errors_count2,uint16_t errors_count3,uint16_t errors_count4)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
	_mav_put_uint16_t(buf, 12, load);
	_mav_put_uint16_t(buf, 14, voltage_battery);
	_mav_put_int16_t(buf, 16, current_battery);
	_mav_put_uint16_t(buf, 18, drop_rate_comm);
	_mav_put_uint16_t(buf, 20, errors_comm);
	_mav_put_uint16_t(buf, 22, errors_count1);
	_mav_put_uint16_t(buf, 24, errors_count2);
	_mav_put_uint16_t(buf, 26, errors_count3);
	_mav_put_uint16_t(buf, 28, errors_count4);
	_mav_put_int8_t(buf, 30, battery_remaining);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#else
	mavlink_sys_status_t packet;
	packet.onboard_control_sensors_present = onboard_control_sensors_present;
	packet.onboard_control_sensors_enabled = onboard_control_sensors_enabled;
	packet.onboard_control_sensors_health = onboard_control_sensors_health;
	packet.load = load;
	packet.voltage_battery = voltage_battery;
	packet.current_battery = current_battery;
	packet.drop_rate_comm = drop_rate_comm;
	packet.errors_comm = errors_comm;
	packet.errors_count1 = errors_count1;
	packet.errors_count2 = errors_count2;
	packet.errors_count3 = errors_count3;
	packet.errors_count4 = errors_count4;
	packet.battery_remaining = battery_remaining;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SYS_STATUS;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#endif
}

/**
 * @brief Encode a sys_status struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param sys_status C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_sys_status_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_sys_status_t* sys_status)
{
    9c12:	03 02 78    	mov.w     w3, w4

00009c14 <.L0>:
	return mavlink_msg_sys_status_pack(system_id, component_id, msg, sys_status->onboard_control_sensors_present, sys_status->onboard_control_sensors_enabled, sys_status->onboard_control_sensors_health, sys_status->load, sys_status->voltage_battery, sys_status->current_battery, sys_status->battery_remaining, sys_status->drop_rate_comm, sys_status->errors_comm, sys_status->errors_count1, sys_status->errors_count2, sys_status->errors_count3, sys_status->errors_count4);
    9c14:	e4 09 90    	mov.w     [w4+28], w3
    9c16:	83 1f 78    	mov.w     w3, [w15++]
    9c18:	54 0b 90    	mov.w     [w4+26], w6
    9c1a:	86 1f 78    	mov.w     w6, [w15++]
    9c1c:	c4 0b 90    	mov.w     [w4+24], w7
    9c1e:	87 1f 78    	mov.w     w7, [w15++]
    9c20:	b4 09 90    	mov.w     [w4+22], w3
    9c22:	83 1f 78    	mov.w     w3, [w15++]
    9c24:	24 0b 90    	mov.w     [w4+20], w6
    9c26:	86 1f 78    	mov.w     w6, [w15++]
    9c28:	94 0b 90    	mov.w     [w4+18], w7
    9c2a:	87 1f 78    	mov.w     w7, [w15++]
    9c2c:	e4 59 90    	mov.b     [w4+30], w3
    9c2e:	83 1f 78    	mov.w     w3, [w15++]
    9c30:	04 0b 90    	mov.w     [w4+16], w6
    9c32:	86 1f 78    	mov.w     w6, [w15++]
    9c34:	f4 03 90    	mov.w     [w4+14], w7
    9c36:	87 1f 78    	mov.w     w7, [w15++]
    9c38:	44 03 90    	mov.w     [w4+8], w6
    9c3a:	d4 03 90    	mov.w     [w4+10], w7
    9c3c:	86 9f be    	mov.d     w6, [w15++]
    9c3e:	e4 01 90    	mov.w     [w4+12], w3
    9c40:	24 03 90    	mov.w     [w4+4], w6
    9c42:	b4 03 90    	mov.w     [w4+6], w7
    9c44:	14 02 be    	mov.d     [w4], w4
    9c46:	b6 ff 07    	rcall     0x9bb4 <_mavlink_msg_sys_status_pack> <L0> <.LFB62> <.LFE1450>
    9c48:	f6 87 57    	sub.w     w15, #0x16, w15

00009c4a <.L0>:
}
    9c4a:	00 00 06    	return    

00009c4c <_mavlink_msg_status_gps_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_status_gps_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint16_t csFails, uint8_t gpsQuality, uint8_t msgsType, uint8_t posStatus, float magVar, int8_t magDir, uint8_t modeInd)
{
    9c4c:	0c 00 fa    	lnk       #0xc
    9c4e:	88 1f 78    	mov.w     w8, [w15++]
    9c50:	8a 9f be    	mov.d     w10, [w15++]
    9c52:	00 44 78    	mov.b     w0, w8
    9c54:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_STATUS_GPS_LEN];
	_mav_put_float(buf, 0, magVar);
	_mav_put_uint16_t(buf, 4, csFails);
	_mav_put_uint8_t(buf, 6, gpsQuality);
	_mav_put_uint8_t(buf, 7, msgsType);
	_mav_put_uint8_t(buf, 8, posStatus);
	_mav_put_int8_t(buf, 9, magDir);
	_mav_put_uint8_t(buf, 10, modeInd);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUS_GPS_LEN);
#else
	mavlink_status_gps_t packet;
	packet.magVar = magVar;
    9c56:	2f b5 97    	mov.w     [w15-28], w10
    9c58:	bf b5 97    	mov.w     [w15-26], w11
    9c5a:	fa b7 9f    	mov.w     w10, [w15-18]
    9c5c:	8b bf 9f    	mov.w     w11, [w15-16]
	packet.csFails = csFails;
    9c5e:	93 bf 9f    	mov.w     w3, [w15-14]
	packet.gpsQuality = gpsQuality;
    9c60:	c4 f7 9f    	mov.b     w4, [w15-12]
	packet.msgsType = msgsType;
    9c62:	d5 f7 9f    	mov.b     w5, [w15-11]
	packet.posStatus = posStatus;
    9c64:	e6 f7 9f    	mov.b     w6, [w15-10]
	packet.magDir = magDir;
    9c66:	f7 f7 9f    	mov.b     w7, [w15-9]
	packet.modeInd = modeInd;
    9c68:	af e5 97    	mov.b     [w15-30], w11
    9c6a:	8b ff 9f    	mov.b     w11, [w15-8]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUS_GPS_LEN);
    9c6c:	68 01 40    	add.w     w0, #0x8, w2
    9c6e:	f2 81 57    	sub.w     w15, #0x12, w3
    9c70:	04 00 09    	.pword 0x090004
    9c72:	33 19 78    	mov.w     [w3++], [w2++]
    9c74:	33 59 78    	mov.b     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_STATUS_GPS;
    9c76:	22 cc b3    	mov.b     #0xc2, w2
    9c78:	72 40 98    	mov.b     w2, [w0+7]

00009c7a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUS_GPS_LEN, MAVLINK_MSG_ID_STATUS_GPS_CRC);
    9c7a:	34 c3 b3    	mov.b     #0x33, w4
    9c7c:	b3 c0 b3    	mov.b     #0xb, w3
    9c7e:	01 41 78    	mov.b     w1, w2
    9c80:	88 40 78    	mov.b     w8, w1
    9c82:	8a fb 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009c84 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUS_GPS_LEN);
#endif
}
    9c84:	4f 05 be    	mov.d     [--w15], w10
    9c86:	4f 04 78    	mov.w     [--w15], w8
    9c88:	00 80 fa    	ulnk      
    9c8a:	00 00 06    	return    

00009c8c <_mavlink_msg_status_gps_encode>:

/**
 * @brief Pack a status_gps message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param csFails Number of times checksum has failed
 * @param gpsQuality The quality indicator, 0=fix not available or invalid, 1=GPS fix, 2=C/A differential GPS, 6=Dead reckoning mode, 7=Manual input mode (fixed position), 8=Simulator mode, 9= WAAS a
 * @param msgsType  Indicates if GN, GL or GP messages are being received
 * @param posStatus  A = data valid, V = data invalid
 * @param magVar Magnetic variation, degrees 
 * @param magDir  Magnetic variation direction E/W. Easterly variation (E) subtracts from True course and Westerly variation (W) adds to True course
 * @param modeInd  Positioning system mode indicator. A - Autonomous;D-Differential; E-Estimated (dead reckoning) mode;M-Manual input; N-Data not valid
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_status_gps_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint16_t csFails,uint8_t gpsQuality,uint8_t msgsType,uint8_t posStatus,float magVar,int8_t magDir,uint8_t modeInd)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_STATUS_GPS_LEN];
	_mav_put_float(buf, 0, magVar);
	_mav_put_uint16_t(buf, 4, csFails);
	_mav_put_uint8_t(buf, 6, gpsQuality);
	_mav_put_uint8_t(buf, 7, msgsType);
	_mav_put_uint8_t(buf, 8, posStatus);
	_mav_put_int8_t(buf, 9, magDir);
	_mav_put_uint8_t(buf, 10, modeInd);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUS_GPS_LEN);
#else
	mavlink_status_gps_t packet;
	packet.magVar = magVar;
	packet.csFails = csFails;
	packet.gpsQuality = gpsQuality;
	packet.msgsType = msgsType;
	packet.posStatus = posStatus;
	packet.magDir = magDir;
	packet.modeInd = modeInd;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUS_GPS_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_STATUS_GPS;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_STATUS_GPS_LEN, MAVLINK_MSG_ID_STATUS_GPS_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_STATUS_GPS_LEN);
#endif
}

/**
 * @brief Encode a status_gps struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param status_gps C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_status_gps_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_status_gps_t* status_gps)
{
	return mavlink_msg_status_gps_pack(system_id, component_id, msg, status_gps->csFails, status_gps->gpsQuality, status_gps->msgsType, status_gps->posStatus, status_gps->magVar, status_gps->magDir, status_gps->modeInd);
    9c8c:	93 4b 90    	mov.b     [w3+9], w7
    9c8e:	23 4a 90    	mov.b     [w3+10], w4
    9c90:	84 1f 78    	mov.w     w4, [w15++]
    9c92:	13 02 be    	mov.d     [w3], w4
    9c94:	84 9f be    	mov.d     w4, [w15++]
    9c96:	03 4b 90    	mov.b     [w3+8], w6
    9c98:	f3 42 90    	mov.b     [w3+7], w5
    9c9a:	63 42 90    	mov.b     [w3+6], w4
    9c9c:	a3 01 90    	mov.w     [w3+4], w3
    9c9e:	d6 ff 07    	rcall     0x9c4c <_mavlink_msg_status_gps_pack> <L0> <.LFB1424> <.LFE64>
    9ca0:	e6 87 57    	sub.w     w15, #0x6, w15

00009ca2 <.L0>:
}
    9ca2:	00 00 06    	return    

00009ca4 <_mavlink_msg_servo_output_raw_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_servo_output_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_usec, uint8_t port, uint16_t servo1_raw, uint16_t servo2_raw, uint16_t servo3_raw, uint16_t servo4_raw, uint16_t servo5_raw, uint16_t servo6_raw, uint16_t servo7_raw, uint16_t servo8_raw)
{
    9ca4:	16 00 fa    	lnk       #0x16
    9ca6:	88 1f 78    	mov.w     w8, [w15++]
    9ca8:	00 44 78    	mov.b     w0, w8
    9caa:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_usec);
	_mav_put_uint16_t(buf, 4, servo1_raw);
	_mav_put_uint16_t(buf, 6, servo2_raw);
	_mav_put_uint16_t(buf, 8, servo3_raw);
	_mav_put_uint16_t(buf, 10, servo4_raw);
	_mav_put_uint16_t(buf, 12, servo5_raw);
	_mav_put_uint16_t(buf, 14, servo6_raw);
	_mav_put_uint16_t(buf, 16, servo7_raw);
	_mav_put_uint16_t(buf, 18, servo8_raw);
	_mav_put_uint8_t(buf, 20, port);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#else
	mavlink_servo_output_raw_t packet;
	packet.time_usec = time_usec;
    9cac:	c4 b7 9f    	mov.w     w4, [w15-24]
    9cae:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.servo1_raw = servo1_raw;
    9cb0:	e6 b7 9f    	mov.w     w6, [w15-20]
	packet.servo2_raw = servo2_raw;
    9cb2:	f7 b7 9f    	mov.w     w7, [w15-18]
	packet.servo3_raw = servo3_raw;
    9cb4:	0f b1 97    	mov.w     [w15-32], w2
    9cb6:	82 bf 9f    	mov.w     w2, [w15-16]
	packet.servo4_raw = servo4_raw;
    9cb8:	7f a9 97    	mov.w     [w15-34], w2
    9cba:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.servo5_raw = servo5_raw;
    9cbc:	6f a9 97    	mov.w     [w15-36], w2
    9cbe:	a2 bf 9f    	mov.w     w2, [w15-12]
	packet.servo6_raw = servo6_raw;
    9cc0:	5f a9 97    	mov.w     [w15-38], w2
    9cc2:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.servo7_raw = servo7_raw;
    9cc4:	4f a9 97    	mov.w     [w15-40], w2
    9cc6:	c2 bf 9f    	mov.w     w2, [w15-8]
	packet.servo8_raw = servo8_raw;
    9cc8:	3f a9 97    	mov.w     [w15-42], w2
    9cca:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.port = port;
    9ccc:	c3 ff 9f    	mov.b     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
    9cce:	e8 01 40    	add.w     w0, #0x8, w3
    9cd0:	78 81 57    	sub.w     w15, #0x18, w2
    9cd2:	09 00 09    	.pword 0x090009
    9cd4:	b2 19 78    	mov.w     [w2++], [w3++]
    9cd6:	b2 59 78    	mov.b     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;
    9cd8:	42 c2 b3    	mov.b     #0x24, w2
    9cda:	72 40 98    	mov.b     w2, [w0+7]

00009cdc <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
    9cdc:	e4 cd b3    	mov.b     #0xde, w4
    9cde:	53 c1 b3    	mov.b     #0x15, w3
    9ce0:	01 41 78    	mov.b     w1, w2
    9ce2:	88 40 78    	mov.b     w8, w1
    9ce4:	59 fb 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009ce6 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#endif
}
    9ce6:	4f 04 78    	mov.w     [--w15], w8
    9ce8:	00 80 fa    	ulnk      
    9cea:	00 00 06    	return    

00009cec <_mavlink_msg_servo_output_raw_encode>:

/**
 * @brief Pack a servo_output_raw message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param time_usec Timestamp (microseconds since system boot)
 * @param port Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
 * @param servo1_raw Servo output 1 value, in microseconds
 * @param servo2_raw Servo output 2 value, in microseconds
 * @param servo3_raw Servo output 3 value, in microseconds
 * @param servo4_raw Servo output 4 value, in microseconds
 * @param servo5_raw Servo output 5 value, in microseconds
 * @param servo6_raw Servo output 6 value, in microseconds
 * @param servo7_raw Servo output 7 value, in microseconds
 * @param servo8_raw Servo output 8 value, in microseconds
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_servo_output_raw_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint32_t time_usec,uint8_t port,uint16_t servo1_raw,uint16_t servo2_raw,uint16_t servo3_raw,uint16_t servo4_raw,uint16_t servo5_raw,uint16_t servo6_raw,uint16_t servo7_raw,uint16_t servo8_raw)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_usec);
	_mav_put_uint16_t(buf, 4, servo1_raw);
	_mav_put_uint16_t(buf, 6, servo2_raw);
	_mav_put_uint16_t(buf, 8, servo3_raw);
	_mav_put_uint16_t(buf, 10, servo4_raw);
	_mav_put_uint16_t(buf, 12, servo5_raw);
	_mav_put_uint16_t(buf, 14, servo6_raw);
	_mav_put_uint16_t(buf, 16, servo7_raw);
	_mav_put_uint16_t(buf, 18, servo8_raw);
	_mav_put_uint8_t(buf, 20, port);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#else
	mavlink_servo_output_raw_t packet;
	packet.time_usec = time_usec;
	packet.servo1_raw = servo1_raw;
	packet.servo2_raw = servo2_raw;
	packet.servo3_raw = servo3_raw;
	packet.servo4_raw = servo4_raw;
	packet.servo5_raw = servo5_raw;
	packet.servo6_raw = servo6_raw;
	packet.servo7_raw = servo7_raw;
	packet.servo8_raw = servo8_raw;
	packet.port = port;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#endif
}

/**
 * @brief Encode a servo_output_raw struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param servo_output_raw C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_servo_output_raw_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_servo_output_raw_t* servo_output_raw)
{
    9cec:	03 02 78    	mov.w     w3, w4

00009cee <.L0>:
	return mavlink_msg_servo_output_raw_pack(system_id, component_id, msg, servo_output_raw->time_usec, servo_output_raw->port, servo_output_raw->servo1_raw, servo_output_raw->servo2_raw, servo_output_raw->servo3_raw, servo_output_raw->servo4_raw, servo_output_raw->servo5_raw, servo_output_raw->servo6_raw, servo_output_raw->servo7_raw, servo_output_raw->servo8_raw);
    9cee:	b4 03 90    	mov.w     [w4+6], w7
    9cf0:	94 09 90    	mov.w     [w4+18], w3
    9cf2:	83 1f 78    	mov.w     w3, [w15++]
    9cf4:	84 09 90    	mov.w     [w4+16], w3
    9cf6:	83 1f 78    	mov.w     w3, [w15++]
    9cf8:	f4 01 90    	mov.w     [w4+14], w3
    9cfa:	83 1f 78    	mov.w     w3, [w15++]
    9cfc:	e4 01 90    	mov.w     [w4+12], w3
    9cfe:	83 1f 78    	mov.w     w3, [w15++]
    9d00:	d4 01 90    	mov.w     [w4+10], w3
    9d02:	83 1f 78    	mov.w     w3, [w15++]
    9d04:	c4 01 90    	mov.w     [w4+8], w3
    9d06:	83 1f 78    	mov.w     w3, [w15++]
    9d08:	24 03 90    	mov.w     [w4+4], w6
    9d0a:	c4 51 90    	mov.b     [w4+20], w3
    9d0c:	14 02 be    	mov.d     [w4], w4
    9d0e:	ca ff 07    	rcall     0x9ca4 <_mavlink_msg_servo_output_raw_pack> <L0> <.LFB321> <.LFE1426>
    9d10:	ec 87 57    	sub.w     w15, #0xc, w15

00009d12 <.L0>:
}
    9d12:	00 00 06    	return    

00009d14 <_mavlink_msg_command_long_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_command_long_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t command, uint8_t confirmation, float param1, float param2, float param3, float param4, float param5, float param6, float param7)
{
    9d14:	22 00 fa    	lnk       #0x22
    9d16:	88 9f be    	mov.d     w8, [w15++]
    9d18:	80 43 78    	mov.b     w0, w7
    9d1a:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_COMMAND_LONG_LEN];
	_mav_put_float(buf, 0, param1);
	_mav_put_float(buf, 4, param2);
	_mav_put_float(buf, 8, param3);
	_mav_put_float(buf, 12, param4);
	_mav_put_float(buf, 16, param5);
	_mav_put_float(buf, 20, param6);
	_mav_put_float(buf, 24, param7);
	_mav_put_uint16_t(buf, 28, command);
	_mav_put_uint8_t(buf, 30, target_system);
	_mav_put_uint8_t(buf, 31, target_component);
	_mav_put_uint8_t(buf, 32, confirmation);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
#else
	mavlink_command_long_t packet;
	packet.param1 = param1;
    9d1c:	0f ac 97    	mov.w     [w15-48], w8
    9d1e:	9f ac 97    	mov.w     [w15-46], w9
    9d20:	d8 af 9f    	mov.w     w8, [w15-38]
    9d22:	e9 af 9f    	mov.w     w9, [w15-36]
	packet.param2 = param2;
    9d24:	6f a4 97    	mov.w     [w15-52], w8
    9d26:	ff a4 97    	mov.w     [w15-50], w9
    9d28:	f8 af 9f    	mov.w     w8, [w15-34]
    9d2a:	89 b7 9f    	mov.w     w9, [w15-32]
	packet.param3 = param3;
    9d2c:	4f a4 97    	mov.w     [w15-56], w8
    9d2e:	df a4 97    	mov.w     [w15-54], w9
    9d30:	98 b7 9f    	mov.w     w8, [w15-30]
    9d32:	a9 b7 9f    	mov.w     w9, [w15-28]
	packet.param4 = param4;
    9d34:	2f a4 97    	mov.w     [w15-60], w8
    9d36:	bf a4 97    	mov.w     [w15-58], w9
    9d38:	b8 b7 9f    	mov.w     w8, [w15-26]
    9d3a:	c9 b7 9f    	mov.w     w9, [w15-24]
	packet.param5 = param5;
    9d3c:	0f a4 97    	mov.w     [w15-64], w8
    9d3e:	9f a4 97    	mov.w     [w15-62], w9
    9d40:	d8 b7 9f    	mov.w     w8, [w15-22]
    9d42:	e9 b7 9f    	mov.w     w9, [w15-20]
	packet.param6 = param6;
    9d44:	6f 9c 97    	mov.w     [w15-68], w8
    9d46:	ff 9c 97    	mov.w     [w15-66], w9
    9d48:	f8 b7 9f    	mov.w     w8, [w15-18]
    9d4a:	89 bf 9f    	mov.w     w9, [w15-16]
	packet.param7 = param7;
    9d4c:	4f 9c 97    	mov.w     [w15-72], w8
    9d4e:	df 9c 97    	mov.w     [w15-70], w9
    9d50:	98 bf 9f    	mov.w     w8, [w15-14]
    9d52:	a9 bf 9f    	mov.w     w9, [w15-12]
	packet.command = command;
    9d54:	b5 bf 9f    	mov.w     w5, [w15-10]
	packet.target_system = target_system;
    9d56:	83 ff 9f    	mov.b     w3, [w15-8]
	packet.target_component = target_component;
    9d58:	94 ff 9f    	mov.b     w4, [w15-7]
	packet.confirmation = confirmation;
    9d5a:	a6 ff 9f    	mov.b     w6, [w15-6]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
    9d5c:	e8 04 40    	add.w     w0, #0x8, w9
    9d5e:	a2 fd 2f    	mov.w     #0xffda, w2
    9d60:	02 81 47    	add.w     w15, w2, w2
    9d62:	0f 00 09    	.pword 0x09000f
    9d64:	b2 1c 78    	mov.w     [w2++], [w9++]
    9d66:	b2 5c 78    	mov.b     [w2++], [w9++]
#endif

	msg->msgid = MAVLINK_MSG_ID_COMMAND_LONG;
    9d68:	c2 c4 b3    	mov.b     #0x4c, w2
    9d6a:	72 40 98    	mov.b     w2, [w0+7]

00009d6c <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
    9d6c:	84 c9 b3    	mov.b     #0x98, w4
    9d6e:	13 c2 b3    	mov.b     #0x21, w3
    9d70:	01 41 78    	mov.b     w1, w2
    9d72:	87 40 78    	mov.b     w7, w1
    9d74:	11 fb 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009d76 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
#endif
}
    9d76:	4f 04 be    	mov.d     [--w15], w8
    9d78:	00 80 fa    	ulnk      
    9d7a:	00 00 06    	return    

00009d7c <_mavlink_msg_command_long_encode>:

/**
 * @brief Pack a command_long message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param target_system System which should execute the command
 * @param target_component Component which should execute the command, 0 for all components
 * @param command Command ID, as defined by MAV_CMD enum.
 * @param confirmation 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
 * @param param1 Parameter 1, as defined by MAV_CMD enum.
 * @param param2 Parameter 2, as defined by MAV_CMD enum.
 * @param param3 Parameter 3, as defined by MAV_CMD enum.
 * @param param4 Parameter 4, as defined by MAV_CMD enum.
 * @param param5 Parameter 5, as defined by MAV_CMD enum.
 * @param param6 Parameter 6, as defined by MAV_CMD enum.
 * @param param7 Parameter 7, as defined by MAV_CMD enum.
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_command_long_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t target_system,uint8_t target_component,uint16_t command,uint8_t confirmation,float param1,float param2,float param3,float param4,float param5,float param6,float param7)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_COMMAND_LONG_LEN];
	_mav_put_float(buf, 0, param1);
	_mav_put_float(buf, 4, param2);
	_mav_put_float(buf, 8, param3);
	_mav_put_float(buf, 12, param4);
	_mav_put_float(buf, 16, param5);
	_mav_put_float(buf, 20, param6);
	_mav_put_float(buf, 24, param7);
	_mav_put_uint16_t(buf, 28, command);
	_mav_put_uint8_t(buf, 30, target_system);
	_mav_put_uint8_t(buf, 31, target_component);
	_mav_put_uint8_t(buf, 32, confirmation);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
#else
	mavlink_command_long_t packet;
	packet.param1 = param1;
	packet.param2 = param2;
	packet.param3 = param3;
	packet.param4 = param4;
	packet.param5 = param5;
	packet.param6 = param6;
	packet.param7 = param7;
	packet.command = command;
	packet.target_system = target_system;
	packet.target_component = target_component;
	packet.confirmation = confirmation;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_COMMAND_LONG;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_LONG_LEN, MAVLINK_MSG_ID_COMMAND_LONG_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_LONG_LEN);
#endif
}

/**
 * @brief Encode a command_long struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param command_long C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_command_long_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_command_long_t* command_long)
{
	return mavlink_msg_command_long_pack(system_id, component_id, msg, command_long->target_system, command_long->target_component, command_long->command, command_long->confirmation, command_long->param1, command_long->param2, command_long->param3, command_long->param4, command_long->param5, command_long->param6, command_long->param7);
    9d7c:	43 0a 90    	mov.w     [w3+24], w4
    9d7e:	d3 0a 90    	mov.w     [w3+26], w5
    9d80:	84 9f be    	mov.d     w4, [w15++]
    9d82:	23 0a 90    	mov.w     [w3+20], w4
    9d84:	b3 0a 90    	mov.w     [w3+22], w5
    9d86:	84 9f be    	mov.d     w4, [w15++]
    9d88:	03 0a 90    	mov.w     [w3+16], w4
    9d8a:	93 0a 90    	mov.w     [w3+18], w5
    9d8c:	84 9f be    	mov.d     w4, [w15++]
    9d8e:	63 02 90    	mov.w     [w3+12], w4
    9d90:	f3 02 90    	mov.w     [w3+14], w5
    9d92:	84 9f be    	mov.d     w4, [w15++]
    9d94:	43 02 90    	mov.w     [w3+8], w4
    9d96:	d3 02 90    	mov.w     [w3+10], w5
    9d98:	84 9f be    	mov.d     w4, [w15++]
    9d9a:	23 02 90    	mov.w     [w3+4], w4
    9d9c:	b3 02 90    	mov.w     [w3+6], w5
    9d9e:	84 9f be    	mov.d     w4, [w15++]
    9da0:	13 02 be    	mov.d     [w3], w4
    9da2:	84 9f be    	mov.d     w4, [w15++]
    9da4:	03 63 90    	mov.b     [w3+32], w6
    9da6:	e3 0a 90    	mov.w     [w3+28], w5
    9da8:	73 5a 90    	mov.b     [w3+31], w4
    9daa:	e3 59 90    	mov.b     [w3+30], w3
    9dac:	b3 ff 07    	rcall     0x9d14 <_mavlink_msg_command_long_pack> <L0> <.LFB701> <.LFE323>
    9dae:	fc 87 57    	sub.w     w15, #0x1c, w15

00009db0 <.L0>:
}
    9db0:	00 00 06    	return    

00009db2 <_mavlink_msg_set_gps_global_origin_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_set_gps_global_origin_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, int32_t latitude, int32_t longitude, int32_t altitude)
{
    9db2:	0e 00 fa    	lnk       #0xe
    9db4:	88 1f 78    	mov.w     w8, [w15++]
    9db6:	00 44 78    	mov.b     w0, w8
    9db8:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN];
	_mav_put_int32_t(buf, 0, latitude);
	_mav_put_int32_t(buf, 4, longitude);
	_mav_put_int32_t(buf, 8, altitude);
	_mav_put_uint8_t(buf, 12, target_system);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
#else
	mavlink_set_gps_global_origin_t packet;
	packet.latitude = latitude;
    9dba:	84 bf 9f    	mov.w     w4, [w15-16]
    9dbc:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.longitude = longitude;
    9dbe:	a6 bf 9f    	mov.w     w6, [w15-12]
    9dc0:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.altitude = altitude;
    9dc2:	3f b2 97    	mov.w     [w15-26], w4
    9dc4:	cf b2 97    	mov.w     [w15-24], w5
    9dc6:	c4 bf 9f    	mov.w     w4, [w15-8]
    9dc8:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.target_system = target_system;
    9dca:	c3 ff 9f    	mov.b     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
    9dcc:	e8 02 40    	add.w     w0, #0x8, w5
    9dce:	70 81 57    	sub.w     w15, #0x10, w2
    9dd0:	05 00 09    	.pword 0x090005
    9dd2:	b2 1a 78    	mov.w     [w2++], [w5++]
    9dd4:	b2 5a 78    	mov.b     [w2++], [w5++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN;
    9dd6:	02 c3 b3    	mov.b     #0x30, w2
    9dd8:	72 40 98    	mov.b     w2, [w0+7]

00009dda <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_CRC);
    9dda:	94 c2 b3    	mov.b     #0x29, w4
    9ddc:	d3 c0 b3    	mov.b     #0xd, w3
    9dde:	01 41 78    	mov.b     w1, w2
    9de0:	88 40 78    	mov.b     w8, w1
    9de2:	da fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009de4 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
#endif
}
    9de4:	4f 04 78    	mov.w     [--w15], w8
    9de6:	00 80 fa    	ulnk      
    9de8:	00 00 06    	return    

00009dea <_mavlink_msg_mission_item_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_item_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, float x, float y, float z)
{
    9dea:	26 00 fa    	lnk       #0x26
    9dec:	88 1f 78    	mov.w     w8, [w15++]
    9dee:	8a 9f be    	mov.d     w10, [w15++]
    9df0:	00 44 78    	mov.b     w0, w8
    9df2:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_ITEM_LEN];
	_mav_put_float(buf, 0, param1);
	_mav_put_float(buf, 4, param2);
	_mav_put_float(buf, 8, param3);
	_mav_put_float(buf, 12, param4);
	_mav_put_float(buf, 16, x);
	_mav_put_float(buf, 20, y);
	_mav_put_float(buf, 24, z);
	_mav_put_uint16_t(buf, 28, seq);
	_mav_put_uint16_t(buf, 30, command);
	_mav_put_uint8_t(buf, 32, target_system);
	_mav_put_uint8_t(buf, 33, target_component);
	_mav_put_uint8_t(buf, 34, frame);
	_mav_put_uint8_t(buf, 35, current);
	_mav_put_uint8_t(buf, 36, autocontinue);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
#else
	mavlink_mission_item_t packet;
	packet.param1 = param1;
    9df4:	3f a5 97    	mov.w     [w15-58], w10
    9df6:	cf a5 97    	mov.w     [w15-56], w11
    9df8:	aa af 9f    	mov.w     w10, [w15-44]
    9dfa:	bb af 9f    	mov.w     w11, [w15-42]
	packet.param2 = param2;
    9dfc:	1f a5 97    	mov.w     [w15-62], w10
    9dfe:	af a5 97    	mov.w     [w15-60], w11
    9e00:	ca af 9f    	mov.w     w10, [w15-40]
    9e02:	db af 9f    	mov.w     w11, [w15-38]
	packet.param3 = param3;
    9e04:	7f 9d 97    	mov.w     [w15-66], w10
    9e06:	8f a5 97    	mov.w     [w15-64], w11
    9e08:	ea af 9f    	mov.w     w10, [w15-36]
    9e0a:	fb af 9f    	mov.w     w11, [w15-34]
	packet.param4 = param4;
    9e0c:	5f 9d 97    	mov.w     [w15-70], w10
    9e0e:	ef 9d 97    	mov.w     [w15-68], w11
    9e10:	8a b7 9f    	mov.w     w10, [w15-32]
    9e12:	9b b7 9f    	mov.w     w11, [w15-30]
	packet.x = x;
    9e14:	3f 9d 97    	mov.w     [w15-74], w10
    9e16:	cf 9d 97    	mov.w     [w15-72], w11
    9e18:	aa b7 9f    	mov.w     w10, [w15-28]
    9e1a:	bb b7 9f    	mov.w     w11, [w15-26]
	packet.y = y;
    9e1c:	1f 9d 97    	mov.w     [w15-78], w10
    9e1e:	af 9d 97    	mov.w     [w15-76], w11
    9e20:	ca b7 9f    	mov.w     w10, [w15-24]
    9e22:	db b7 9f    	mov.w     w11, [w15-22]
	packet.z = z;
    9e24:	7f 95 97    	mov.w     [w15-82], w10
    9e26:	8f 9d 97    	mov.w     [w15-80], w11
    9e28:	ea b7 9f    	mov.w     w10, [w15-20]
    9e2a:	fb b7 9f    	mov.w     w11, [w15-18]
	packet.seq = seq;
    9e2c:	85 bf 9f    	mov.w     w5, [w15-16]
	packet.command = command;
    9e2e:	97 bf 9f    	mov.w     w7, [w15-14]
	packet.target_system = target_system;
    9e30:	c3 f7 9f    	mov.b     w3, [w15-12]
	packet.target_component = target_component;
    9e32:	d4 f7 9f    	mov.b     w4, [w15-11]
	packet.frame = frame;
    9e34:	e6 f7 9f    	mov.b     w6, [w15-10]
	packet.current = current;
    9e36:	cf cd 97    	mov.b     [w15-52], w11
    9e38:	fb f7 9f    	mov.b     w11, [w15-9]
	packet.autocontinue = autocontinue;
    9e3a:	2f c9 97    	mov.b     [w15-54], w2
    9e3c:	82 ff 9f    	mov.b     w2, [w15-8]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
    9e3e:	e8 01 40    	add.w     w0, #0x8, w3
    9e40:	4a fd 2f    	mov.w     #0xffd4, w10
    9e42:	0a 85 47    	add.w     w15, w10, w10
    9e44:	11 00 09    	.pword 0x090011
    9e46:	ba 19 78    	mov.w     [w10++], [w3++]
    9e48:	ba 59 78    	mov.b     [w10++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM;
    9e4a:	72 c2 b3    	mov.b     #0x27, w2
    9e4c:	72 40 98    	mov.b     w2, [w0+7]

00009e4e <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
    9e4e:	e4 cf b3    	mov.b     #0xfe, w4
    9e50:	53 c2 b3    	mov.b     #0x25, w3
    9e52:	01 41 78    	mov.b     w1, w2
    9e54:	88 40 78    	mov.b     w8, w1
    9e56:	a0 fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009e58 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
#endif
}
    9e58:	4f 05 be    	mov.d     [--w15], w10
    9e5a:	4f 04 78    	mov.w     [--w15], w8
    9e5c:	00 80 fa    	ulnk      
    9e5e:	00 00 06    	return    

00009e60 <_mavlink_msg_command_ack_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_command_ack_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint16_t command, uint8_t result)
{
    9e60:	04 00 fa    	lnk       #0x4
    9e62:	80 42 78    	mov.b     w0, w5
    9e64:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_COMMAND_ACK_LEN];
	_mav_put_uint16_t(buf, 0, command);
	_mav_put_uint8_t(buf, 2, result);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
#else
	mavlink_command_ack_t packet;
	packet.command = command;
    9e66:	e3 bf 9f    	mov.w     w3, [w15-4]
	packet.result = result;
    9e68:	e4 ff 9f    	mov.b     w4, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
    9e6a:	68 01 40    	add.w     w0, #0x8, w2
    9e6c:	03 09 78    	mov.w     w3, [w2]
    9e6e:	24 48 98    	mov.b     w4, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_COMMAND_ACK;
    9e70:	d2 c4 b3    	mov.b     #0x4d, w2
    9e72:	72 40 98    	mov.b     w2, [w0+7]

00009e74 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
    9e74:	f4 c8 b3    	mov.b     #0x8f, w4
    9e76:	33 c0 b3    	mov.b     #0x3, w3
    9e78:	01 41 78    	mov.b     w1, w2
    9e7a:	85 40 78    	mov.b     w5, w1
    9e7c:	8d fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009e7e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
#endif
}
    9e7e:	00 80 fa    	ulnk      
    9e80:	00 00 06    	return    

00009e82 <_mavlink_msg_command_ack_encode>:

/**
 * @brief Pack a command_ack message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param command Command ID, as defined by MAV_CMD enum.
 * @param result See MAV_RESULT enum
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_command_ack_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint16_t command,uint8_t result)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_COMMAND_ACK_LEN];
	_mav_put_uint16_t(buf, 0, command);
	_mav_put_uint8_t(buf, 2, result);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
#else
	mavlink_command_ack_t packet;
	packet.command = command;
	packet.result = result;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_COMMAND_ACK;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_ACK_LEN, MAVLINK_MSG_ID_COMMAND_ACK_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_COMMAND_ACK_LEN);
#endif
}

/**
 * @brief Encode a command_ack struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param command_ack C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_command_ack_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_command_ack_t* command_ack)
{
	return mavlink_msg_command_ack_pack(system_id, component_id, msg, command_ack->command, command_ack->result);
    9e82:	23 42 90    	mov.b     [w3+2], w4
    9e84:	93 01 78    	mov.w     [w3], w3
    9e86:	ec ff 07    	rcall     0x9e60 <_mavlink_msg_command_ack_pack> <L0> <.LFB717> <.LFE354>

00009e88 <.L0>:
}
    9e88:	00 00 06    	return    

00009e8a <_mavlink_msg_mid_lvl_cmds_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mid_lvl_cmds_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target, float hCommand, float uCommand, float rCommand)
{
    9e8a:	0e 00 fa    	lnk       #0xe
    9e8c:	88 1f 78    	mov.w     w8, [w15++]
    9e8e:	00 44 78    	mov.b     w0, w8
    9e90:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MID_LVL_CMDS_LEN];
	_mav_put_float(buf, 0, hCommand);
	_mav_put_float(buf, 4, uCommand);
	_mav_put_float(buf, 8, rCommand);
	_mav_put_uint8_t(buf, 12, target);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MID_LVL_CMDS_LEN);
#else
	mavlink_mid_lvl_cmds_t packet;
	packet.hCommand = hCommand;
    9e92:	84 bf 9f    	mov.w     w4, [w15-16]
    9e94:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.uCommand = uCommand;
    9e96:	a6 bf 9f    	mov.w     w6, [w15-12]
    9e98:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.rCommand = rCommand;
    9e9a:	3f b2 97    	mov.w     [w15-26], w4
    9e9c:	cf b2 97    	mov.w     [w15-24], w5
    9e9e:	c4 bf 9f    	mov.w     w4, [w15-8]
    9ea0:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.target = target;
    9ea2:	c3 ff 9f    	mov.b     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MID_LVL_CMDS_LEN);
    9ea4:	e8 02 40    	add.w     w0, #0x8, w5
    9ea6:	70 81 57    	sub.w     w15, #0x10, w2
    9ea8:	05 00 09    	.pword 0x090005
    9eaa:	b2 1a 78    	mov.w     [w2++], [w5++]
    9eac:	b2 5a 78    	mov.b     [w2++], [w5++]
#endif

	msg->msgid = MAVLINK_MSG_ID_MID_LVL_CMDS;
    9eae:	42 cb b3    	mov.b     #0xb4, w2
    9eb0:	72 40 98    	mov.b     w2, [w0+7]

00009eb2 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MID_LVL_CMDS_LEN, MAVLINK_MSG_ID_MID_LVL_CMDS_CRC);
    9eb2:	24 c9 b3    	mov.b     #0x92, w4
    9eb4:	d3 c0 b3    	mov.b     #0xd, w3
    9eb6:	01 41 78    	mov.b     w1, w2
    9eb8:	88 40 78    	mov.b     w8, w1
    9eba:	6e fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009ebc <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MID_LVL_CMDS_LEN);
#endif
}
    9ebc:	4f 04 78    	mov.w     [--w15], w8
    9ebe:	00 80 fa    	ulnk      
    9ec0:	00 00 06    	return    

00009ec2 <_mavlink_msg_ptz_status_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_ptz_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t zoom, int16_t pan, int16_t tilt)
{
    9ec2:	06 00 fa    	lnk       #0x6
    9ec4:	00 43 78    	mov.b     w0, w6
    9ec6:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_PTZ_STATUS_LEN];
	_mav_put_int16_t(buf, 0, pan);
	_mav_put_int16_t(buf, 2, tilt);
	_mav_put_uint8_t(buf, 4, zoom);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
#else
	mavlink_ptz_status_t packet;
	packet.pan = pan;
    9ec8:	d4 bf 9f    	mov.w     w4, [w15-6]
	packet.tilt = tilt;
    9eca:	e5 bf 9f    	mov.w     w5, [w15-4]
	packet.zoom = zoom;
    9ecc:	e3 ff 9f    	mov.b     w3, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
    9ece:	68 01 40    	add.w     w0, #0x8, w2
    9ed0:	5f ba 97    	mov.w     [w15-6], w4
    9ed2:	ef ba 97    	mov.w     [w15-4], w5
    9ed4:	04 89 be    	mov.d     w4, [w2]
    9ed6:	43 48 98    	mov.b     w3, [w0+12]
#endif

	msg->msgid = MAVLINK_MSG_ID_PTZ_STATUS;
    9ed8:	02 cc b3    	mov.b     #0xc0, w2
    9eda:	72 40 98    	mov.b     w2, [w0+7]

00009edc <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PTZ_STATUS_LEN, MAVLINK_MSG_ID_PTZ_STATUS_CRC);
    9edc:	b4 cb b3    	mov.b     #0xbb, w4
    9ede:	53 c0 b3    	mov.b     #0x5, w3
    9ee0:	01 41 78    	mov.b     w1, w2
    9ee2:	86 40 78    	mov.b     w6, w1
    9ee4:	59 fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009ee6 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
#endif
}
    9ee6:	00 80 fa    	ulnk      
    9ee8:	00 00 06    	return    

00009eea <_mavlink_msg_ptz_status_encode>:

/**
 * @brief Pack a ptz_status message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param zoom The actual Zoom Value
 * @param pan The Pan value in 10ths of degree
 * @param tilt The Tilt value in 10ths of degree
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_ptz_status_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t zoom,int16_t pan,int16_t tilt)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_PTZ_STATUS_LEN];
	_mav_put_int16_t(buf, 0, pan);
	_mav_put_int16_t(buf, 2, tilt);
	_mav_put_uint8_t(buf, 4, zoom);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
#else
	mavlink_ptz_status_t packet;
	packet.pan = pan;
	packet.tilt = tilt;
	packet.zoom = zoom;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_PTZ_STATUS;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PTZ_STATUS_LEN, MAVLINK_MSG_ID_PTZ_STATUS_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_PTZ_STATUS_LEN);
#endif
}

/**
 * @brief Encode a ptz_status struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param ptz_status C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_ptz_status_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_ptz_status_t* ptz_status)
{
	return mavlink_msg_ptz_status_pack(system_id, component_id, msg, ptz_status->zoom, ptz_status->pan, ptz_status->tilt);
    9eea:	93 02 90    	mov.w     [w3+2], w5
    9eec:	13 02 78    	mov.w     [w3], w4
    9eee:	c3 41 90    	mov.b     [w3+4], w3
    9ef0:	e8 ff 07    	rcall     0x9ec2 <_mavlink_msg_ptz_status_pack> <L0> <.LFB1405> <.LFE1334>

00009ef2 <.L0>:
}
    9ef2:	00 00 06    	return    

00009ef4 <_mavlink_msg_volt_sensor_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_volt_sensor_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t r2Type, uint16_t voltage, uint16_t reading2)
{
    9ef4:	06 00 fa    	lnk       #0x6
    9ef6:	00 43 78    	mov.b     w0, w6
    9ef8:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_VOLT_SENSOR_LEN];
	_mav_put_uint16_t(buf, 0, voltage);
	_mav_put_uint16_t(buf, 2, reading2);
	_mav_put_uint8_t(buf, 4, r2Type);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
#else
	mavlink_volt_sensor_t packet;
	packet.voltage = voltage;
    9efa:	d4 bf 9f    	mov.w     w4, [w15-6]
	packet.reading2 = reading2;
    9efc:	e5 bf 9f    	mov.w     w5, [w15-4]
	packet.r2Type = r2Type;
    9efe:	e3 ff 9f    	mov.b     w3, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
    9f00:	68 01 40    	add.w     w0, #0x8, w2
    9f02:	5f ba 97    	mov.w     [w15-6], w4
    9f04:	ef ba 97    	mov.w     [w15-4], w5
    9f06:	04 89 be    	mov.d     w4, [w2]
    9f08:	43 48 98    	mov.b     w3, [w0+12]
#endif

	msg->msgid = MAVLINK_MSG_ID_VOLT_SENSOR;
    9f0a:	f2 cb b3    	mov.b     #0xbf, w2
    9f0c:	72 40 98    	mov.b     w2, [w0+7]

00009f0e <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VOLT_SENSOR_LEN, MAVLINK_MSG_ID_VOLT_SENSOR_CRC);
    9f0e:	14 c1 b3    	mov.b     #0x11, w4
    9f10:	53 c0 b3    	mov.b     #0x5, w3
    9f12:	01 41 78    	mov.b     w1, w2
    9f14:	86 40 78    	mov.b     w6, w1
    9f16:	40 fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009f18 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
#endif
}
    9f18:	00 80 fa    	ulnk      
    9f1a:	00 00 06    	return    

00009f1c <_mavlink_msg_volt_sensor_encode>:

/**
 * @brief Pack a volt_sensor message on a channel
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param chan The MAVLink channel this message will be sent over
 * @param msg The MAVLink message to compress the data into
 * @param r2Type It is the value of reading 2: 0 - Current, 1 - Foreward Sonar, 2 - Back Sonar, 3 - RPM
 * @param voltage Voltage in uS of PWM. 0 uS = 0V, 20 uS = 21.5V 
 * @param reading2 Depends on the value of r2Type (0) Current consumption in uS of PWM, 20 uS = 90Amp (1) Distance in cm (2) Distance in cm (3) Absolute value
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_volt_sensor_pack_chan(uint8_t system_id, uint8_t component_id, uint8_t chan,
							   mavlink_message_t* msg,
						           uint8_t r2Type,uint16_t voltage,uint16_t reading2)
{
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_VOLT_SENSOR_LEN];
	_mav_put_uint16_t(buf, 0, voltage);
	_mav_put_uint16_t(buf, 2, reading2);
	_mav_put_uint8_t(buf, 4, r2Type);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
#else
	mavlink_volt_sensor_t packet;
	packet.voltage = voltage;
	packet.reading2 = reading2;
	packet.r2Type = r2Type;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
#endif

	msg->msgid = MAVLINK_MSG_ID_VOLT_SENSOR;
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VOLT_SENSOR_LEN, MAVLINK_MSG_ID_VOLT_SENSOR_CRC);
#else
    return mavlink_finalize_message_chan(msg, system_id, component_id, chan, MAVLINK_MSG_ID_VOLT_SENSOR_LEN);
#endif
}

/**
 * @brief Encode a volt_sensor struct
 *
 * @param system_id ID of this system
 * @param component_id ID of this component (e.g. 200 for IMU)
 * @param msg The MAVLink message to compress the data into
 * @param volt_sensor C-struct to read the message contents from
 */
static inline uint16_t mavlink_msg_volt_sensor_encode(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, const mavlink_volt_sensor_t* volt_sensor)
{
	return mavlink_msg_volt_sensor_pack(system_id, component_id, msg, volt_sensor->r2Type, volt_sensor->voltage, volt_sensor->reading2);
    9f1c:	93 02 90    	mov.w     [w3+2], w5
    9f1e:	13 02 78    	mov.w     [w3], w4
    9f20:	c3 41 90    	mov.b     [w3+4], w3
    9f22:	e8 ff 07    	rcall     0x9ef4 <_mavlink_msg_volt_sensor_pack> <L0> <.LFB1397> <.LFE1407>

00009f24 <.L0>:
}
    9f24:	00 00 06    	return    

00009f26 <_mav_array_memcpy>:
  like memcpy(), but if src is NULL, do a memset to zero
*/
static inline void mav_array_memcpy(void *dest, const void *src, size_t n)
{
	if (src == NULL) {
    9f26:	01 00 e0    	cp0.w     w1
    9f28:	03 00 3a    	bra       NZ, 0x9f30 <.L0> <.L69>

00009f2a <.L0>:
		memset(dest, 0, n);
    9f2a:	d6 23 02    	call      0x23d6 <_memset>
    9f2c:	00 00 00 
    9f2e:	02 00 37    	bra       0x9f34 <.L68>

00009f30 <.L0>:
	} else {
		memcpy(dest, src, n);
    9f30:	c8 23 02    	call      0x23c8 <_memcpy>
    9f32:	00 00 00 

00009f34 <.L68>:
	}
}
    9f34:	00 00 06    	return    

00009f36 <_mavlink_msg_param_value_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_param_value_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       const char *param_id, float param_value, uint8_t param_type, uint16_t param_count, uint16_t param_index)
{
    9f36:	1a 00 fa    	lnk       #0x1a
    9f38:	88 9f be    	mov.d     w8, [w15++]
    9f3a:	8a 1f 78    	mov.w     w10, [w15++]
    9f3c:	00 45 78    	mov.b     w0, w10
    9f3e:	81 44 78    	mov.b     w1, w9
    9f40:	02 04 78    	mov.w     w2, w8
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_PARAM_VALUE_LEN];
	_mav_put_float(buf, 0, param_value);
	_mav_put_uint16_t(buf, 4, param_count);
	_mav_put_uint16_t(buf, 6, param_index);
	_mav_put_uint8_t(buf, 24, param_type);
	_mav_put_char_array(buf, 8, param_id, 16);
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
#else
	mavlink_param_value_t packet;
	packet.param_value = param_value;
    9f42:	84 b7 9f    	mov.w     w4, [w15-32]
    9f44:	95 b7 9f    	mov.w     w5, [w15-30]
	packet.param_count = param_count;
    9f46:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.param_index = param_index;
    9f48:	4f a8 97    	mov.w     [w15-40], w0
    9f4a:	b0 b7 9f    	mov.w     w0, [w15-26]
	packet.param_type = param_type;
    9f4c:	86 ff 9f    	mov.b     w6, [w15-8]

00009f4e <.L0>:
	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
    9f4e:	02 01 20    	mov.w     #0x10, w2
    9f50:	83 00 78    	mov.w     w3, w1
    9f52:	78 80 57    	sub.w     w15, #0x18, w0
    9f54:	e8 ff 07    	rcall     0x9f26 <_mav_array_memcpy> <L0> <.L0> <.LFB20> <.LFE1399>

00009f56 <.L0>:
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
    9f56:	e8 00 44    	add.w     w8, #0x8, w1
    9f58:	00 fe 2f    	mov.w     #0xffe0, w0
    9f5a:	00 80 47    	add.w     w15, w0, w0
    9f5c:	0b 00 09    	.pword 0x09000b
    9f5e:	b0 18 78    	mov.w     [w0++], [w1++]
    9f60:	b0 58 78    	mov.b     [w0++], [w1++]
#endif

	msg->msgid = MAVLINK_MSG_ID_PARAM_VALUE;
    9f62:	60 c1 b3    	mov.b     #0x16, w0
    9f64:	70 44 98    	mov.b     w0, [w8+7]

00009f66 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
    9f66:	c4 cd b3    	mov.b     #0xdc, w4
    9f68:	93 c1 b3    	mov.b     #0x19, w3
    9f6a:	09 41 78    	mov.b     w9, w2
    9f6c:	8a 40 78    	mov.b     w10, w1
    9f6e:	08 00 78    	mov.w     w8, w0
    9f70:	13 fa 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009f72 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
#endif
}
    9f72:	4f 05 78    	mov.w     [--w15], w10
    9f74:	4f 04 be    	mov.d     [--w15], w8
    9f76:	00 80 fa    	ulnk      
    9f78:	00 00 06    	return    

00009f7a <_mavlink_msg_statustext_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_statustext_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t severity, const char *text)
{
    9f7a:	34 00 fa    	lnk       #0x34
    9f7c:	88 9f be    	mov.d     w8, [w15++]
    9f7e:	8a 1f 78    	mov.w     w10, [w15++]
    9f80:	00 45 78    	mov.b     w0, w10
    9f82:	81 44 78    	mov.b     w1, w9
    9f84:	02 04 78    	mov.w     w2, w8
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_STATUSTEXT_LEN];
	_mav_put_uint8_t(buf, 0, severity);
	_mav_put_char_array(buf, 1, text, 50);
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
#else
	mavlink_statustext_t packet;
	packet.severity = severity;
    9f86:	60 fc 2f    	mov.w     #0xffc6, w0
    9f88:	0f 00 40    	add.w     w0, w15, w0
    9f8a:	03 58 78    	mov.b     w3, [w0++]

00009f8c <.L0>:
	mav_array_memcpy(packet.text, text, sizeof(char)*50);
    9f8c:	22 03 20    	mov.w     #0x32, w2
    9f8e:	84 00 78    	mov.w     w4, w1
    9f90:	ca ff 07    	rcall     0x9f26 <_mav_array_memcpy> <L0> <.L0> <.LFB20> <.LFE1399>

00009f92 <.L0>:
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
    9f92:	68 00 44    	add.w     w8, #0x8, w0
    9f94:	61 fc 2f    	mov.w     #0xffc6, w1
    9f96:	81 80 47    	add.w     w15, w1, w1
    9f98:	32 00 09    	.pword 0x090032
    9f9a:	31 58 78    	mov.b     [w1++], [w0++]
#endif

	msg->msgid = MAVLINK_MSG_ID_STATUSTEXT;
    9f9c:	d0 cf b3    	mov.b     #0xfd, w0
    9f9e:	70 44 98    	mov.b     w0, [w8+7]

00009fa0 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
    9fa0:	34 c5 b3    	mov.b     #0x53, w4
    9fa2:	33 c3 b3    	mov.b     #0x33, w3
    9fa4:	09 41 78    	mov.b     w9, w2
    9fa6:	8a 40 78    	mov.b     w10, w1
    9fa8:	08 00 78    	mov.w     w8, w0
    9faa:	f6 f9 07    	rcall     0x9398 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

00009fac <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN);
#endif
}
    9fac:	4f 05 78    	mov.w     [--w15], w10
    9fae:	4f 04 be    	mov.d     [--w15], w8
    9fb0:	00 80 fa    	ulnk      
    9fb2:	00 00 06    	return    

00009fb4 <_uart2Init>:

// UART, DMA and Buffer initialization

void uart2Init(void) {
    sw_debug = 0;
    9fb4:	c0 16 23    	mov.w     #0x316c, w0
    9fb6:	00 48 eb    	clr.b     [w0]

00009fb8 <.L0>:

    // initialize the circular buffers
    uartBufferIn = (struct CircBuffer*) &com2BufferIn;
    9fb8:	80 d5 22    	mov.w     #0x2d58, w0
    9fba:	00 7b 89    	mov.w     w0, 0x2f60

00009fbc <.L0>:
    newCircBuffer(uartBufferIn);
    9fbc:	94 0a 02    	call      0x10a94 <_newCircBuffer>
    9fbe:	01 00 00 

00009fc0 <.L0>:

    uartBufferOut = (struct CircBuffer*) &com1BufferOut;
    9fc0:	20 f6 22    	mov.w     #0x2f62, w0
    9fc2:	50 8b 89    	mov.w     w0, 0x316a

00009fc4 <.L0>:
    newCircBuffer(uartBufferOut);
    9fc4:	94 0a 02    	call      0x10a94 <_newCircBuffer>
    9fc6:	01 00 00 


    // DMA1REQ Register
    // ================
    DMA1REQ = 0x001F;
    9fc8:	f0 01 20    	mov.w     #0x1f, w0
    9fca:	90 58 88    	mov.w     w0, 0xb12

    // DMA1PAD Register
    // ================
    DMA1PAD = (volatile unsigned int) &U2TXREG;
    9fcc:	40 23 20    	mov.w     #0x234, w0
    9fce:	e0 58 88    	mov.w     w0, 0xb1c

    // DMA1CON Register
    // ================
    DMA1CONbits.AMODE = 0; // Register Indirect with post-increment
    9fd0:	f0 fc 2f    	mov.w     #0xffcf, w0
    9fd2:	10 2b b6    	and.w     0xb10
    DMA1CONbits.MODE = 1; // One-shot, No Ping-Pong Mode	
    9fd4:	80 58 80    	mov.w     0xb10, w0
    9fd6:	00 00 a0    	bset.w    w0, #0x0
    9fd8:	00 10 a1    	bclr.w    w0, #0x1
    9fda:	80 58 88    	mov.w     w0, 0xb10
    DMA1CONbits.DIR = 1; // Read from RAM and send to Periphereal
    9fdc:	11 ab a8    	bset.b    0xb11, #0x5
    DMA1CONbits.SIZE = 0; // Word Data Transfer
    9fde:	11 cb a9    	bclr.b    0xb11, #0x6

    // DMA1CNT Register
    // ==============
    DMA1CNT = MAXSEND - 1;
    9fe0:	c0 06 20    	mov.w     #0x6c, w0
    9fe2:	f0 58 88    	mov.w     w0, 0xb1e

    // DMA1STA Register
    // ================
    //DMA1STA = __builtin_dmaoffset(BufferB);

    // Enable DMA1 TX interrupts
    IFS0bits.DMA1IF = 0; // Clear DMA Interrupt Flag
    9fe4:	01 c8 a9    	bclr.b    0x801, #0x6
    IPC3bits.DMA1IP = 6; // interrupt priority to 6
    9fe6:	30 42 80    	mov.w     0x846, w0
    9fe8:	00 80 a1    	bclr.w    w0, #0x8
    9fea:	00 90 a0    	bset.w    w0, #0x9
    9fec:	00 a0 a0    	bset.w    w0, #0xa
    9fee:	30 42 88    	mov.w     w0, 0x846
    IEC0bits.DMA1IE = 1; // Enable DMA interrupt
    9ff0:	21 c8 a8    	bset.b    0x821, #0x6

    // Configure and open the port;
    // U2MODE Register
    // ==============
    U2MODEbits.UARTEN = 0; // Disable the port		
    9ff2:	31 e2 a9    	bclr.b    0x231, #0x7
    U2MODEbits.USIDL = 0; // Stop on idle
    9ff4:	31 a2 a9    	bclr.b    0x231, #0x5
    U2MODEbits.IREN = 0; // No IR decoder
    9ff6:	31 82 a9    	bclr.b    0x231, #0x4
    U2MODEbits.RTSMD = 0; // Ready to send mode (irrelevant)
    9ff8:	31 62 a9    	bclr.b    0x231, #0x3
    U2MODEbits.UEN = 0; // Only RX and TX
    9ffa:	f0 cf 2f    	mov.w     #0xfcff, w0
    9ffc:	30 22 b6    	and.w     0x230
    U2MODEbits.WAKE = 1; // Enable at startup
    9ffe:	30 e2 a8    	bset.b    0x230, #0x7
    U2MODEbits.LPBACK = 0; // Disable loopback
    a000:	30 c2 a9    	bclr.b    0x230, #0x6
    U2MODEbits.ABAUD = 0; // Disable autobaud
    a002:	30 a2 a9    	bclr.b    0x230, #0x5
    U2MODEbits.URXINV = 0; // Normal operation (high is idle)
    a004:	30 82 a9    	bclr.b    0x230, #0x4
    U2MODEbits.PDSEL = 0; // No parity 8 bit
    a006:	90 ff 2f    	mov.w     #0xfff9, w0
    a008:	30 22 b6    	and.w     0x230
    U2MODEbits.STSEL = 0; // 1 stop bit
    a00a:	30 02 a9    	bclr.b    0x230, #0x0
    U2MODEbits.BRGH = 0; // Low speed mode
    a00c:	30 62 a9    	bclr.b    0x230, #0x3

    // U1STA Register
    // ==============
    U2STAbits.UTXISEL0 = 0; // generate interrupt on every char
    a00e:	33 a2 a9    	bclr.b    0x233, #0x5
    U2STAbits.UTXISEL1 = 0; // for the DMA	
    a010:	33 e2 a9    	bclr.b    0x233, #0x7
    U2STAbits.URXISEL = 0; // RX interrupt when a char is in
    a012:	f0 f3 2f    	mov.w     #0xff3f, w0
    a014:	32 22 b6    	and.w     0x232
    U2STAbits.OERR = 0; // clear overun error
    a016:	32 22 a9    	bclr.b    0x232, #0x1

    // U1BRG Register
    // ==============
    U2BRG = LOG_UBRG; // Set the baud rate for 115,200
    a018:	50 01 20    	mov.w     #0x15, w0
    a01a:	c0 11 88    	mov.w     w0, 0x238

    // Initialize the Interrupt  
    // ========================
    IPC7bits.U2RXIP = 7; // Interrupt priority 7  
    a01c:	70 42 80    	mov.w     0x84e, w0
    a01e:	00 30 b3    	ior.w     #0x300, w0
    a020:	00 a0 a0    	bset.w    w0, #0xa
    a022:	70 42 88    	mov.w     w0, 0x84e
    IFS1bits.U2RXIF = 0; // Clear the interrupt flag
    a024:	03 c8 a9    	bclr.b    0x803, #0x6
    IEC1bits.U2RXIE = 1; // Enable interrupts
    a026:	23 c8 a8    	bset.b    0x823, #0x6

    // Enable the port;
    U2MODEbits.UARTEN = 1; // Enable the port	
    a028:	31 e2 a8    	bset.b    0x231, #0x7
    U2STAbits.UTXEN = 1; // Enable TX
    a02a:	33 42 a8    	bset.b    0x233, #0x2

    IEC4bits.U2EIE = 1;
    a02c:	28 48 a8    	bset.b    0x828, #0x2

}
    a02e:	00 00 06    	return    

0000a030 <_gsRead>:

void gsRead(unsigned char* gsChunk) {
    a030:	88 9f be    	mov.d     w8, [w15++]
    a032:	8a 1f 78    	mov.w     w10, [w15++]
    a034:	00 05 78    	mov.w     w0, w10

0000a036 <.L0>:
    // fix the data length so if the interrupt adds data
    // during execution of this block, it will be read
    // until the next gsRead
    unsigned int tmpLen = getLength(uartBufferIn), i = 0;
    a036:	00 7b 81    	mov.w     0x2f60, w0
    a038:	c0 0a 02    	call      0x10ac0 <_getLength>
    a03a:	01 00 00 

0000a03c <.L0>:

    // if the buffer has more data than the max size, set it to max,
    // otherwise set it to the length
    gsChunk[0] = (tmpLen > MAXSPI) ? MAXSPI : tmpLen;
    a03c:	81 0c 20    	mov.w     #0xc8, w1
    a03e:	81 0f 50    	sub.w     w0, w1, [w15]
    a040:	01 00 36    	bra       LEU, 0xa044 <.L75>
    a042:	01 00 78    	mov.w     w1, w0

0000a044 <.L75>:
    a044:	00 4d 78    	mov.b     w0, [w10]

    // read the data 
    for (i = 1; i <= gsChunk[0]; i += 1) {
    a046:	00 04 e0    	cp0.b     w0
    a048:	0a 00 32    	bra       Z, 0xa05e <.L76>
    a04a:	8a 04 78    	mov.w     w10, w9
    a04c:	18 00 20    	mov.w     #0x1, w8

0000a04e <.L0>:
        gsChunk[i] = readFront(uartBufferIn);
    a04e:	00 7b 81    	mov.w     0x2f60, w0
    a050:	14 0b 02    	call      0x10b14 <_readFront>
    a052:	01 00 00 
    a054:	80 6c 78    	mov.b     w0, [++w9]

0000a056 <.L0>:
    a056:	08 04 e8    	inc.w     w8, w8
    a058:	1a 80 fb    	ze        [w10], w0
    a05a:	88 0f 50    	sub.w     w0, w8, [w15]
    a05c:	f8 ff 31    	bra       C, 0xa04e <.L0> <.L77>

0000a05e <.L76>:
    }

    gsChunk[MAXSPI + 1] = 1;
    a05e:	10 c0 b3    	mov.b     #0x1, w0
    a060:	10 cd 99    	mov.b     w0, [w10+201]
}
    a062:	4f 05 78    	mov.w     [--w15], w10
    a064:	4f 04 be    	mov.d     [--w15], w8
    a066:	00 00 06    	return    

0000a068 <_copyBufferToDMA1>:

/* Called at 50 Hz by Simulink, and called sendTelemtry dependent on rate parameter. */
#ifdef MAVLINK_TELEMETRY_RATE
void prepareTelemetryMavlink(unsigned char* dataOut) {

    static uint32_t ticks = 0;
    float telemetryRate = mlParamInterface.param[PAR_RATE_TELEMETRY];
    uint32_t ticksBeforeSend = (telemetryRate >= MAVLINK_TELEMETRY_RATE || telemetryRate < 1.0f)?
            0
            :
            (uint32_t)(MAVLINK_TELEMETRY_RATE - telemetryRate + 1);

    // Send telemetry if we've waited enough ticks or if desired rate is invalid

    if (ticks >= ticksBeforeSend) {
        sendTelemetryMavlink(dataOut);
        ticks = 0;
    }
    else {
        ticks++;
    }
}
#else
void prepareTelemetryMavlink(unsigned char* dataOut) {
    sendTelemetryMavlink(dataOut);
}
#endif

/* Called by Simulink at 50 Hz. */
void sendTelemetryMavlink(unsigned char* dataOut) {

    // Generic message container used to pack the messages
    mavlink_message_t msg;

    // Generic buffer used to hold data to be streamed via serial port
    //uint8_t buf[MAVLINK_MAX_PACKET_LEN];

    // Cycles from 1 to 10 to decide which 
    // message's turn is to be sent
    static uint8_t sampleTelemetry = 1;

    // Contains the total bytes to send via the serial port
    uint8_t bytes2Send = 0;//, paramDelay = 0;

    // String used to send text messages to QGC console
    char vr_message[50];

    memset(&msg, 0, sizeof (mavlink_message_t));

    switch (sampleTelemetry) {
        case 1: // GPS, Heartbeat and Passthrough if necessary
            // Pack the GPS message
            mavlink_msg_gps_raw_int_pack(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                mlGpsData.time_usec,
                mlGpsData.fix_type,
                mlGpsData.lat,
                mlGpsData.lon,
                mlGpsData.alt,
                mlGpsData.eph,
                0.0, // ephv
                mlGpsData.vel,
                mlGpsData.cog,
                0 // sattelites_visible
                );

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg to pack a new variable
            memset(&msg, 0, sizeof (mavlink_message_t));

            // Pack the Heartbeat message
            mavlink_msg_heartbeat_pack(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                MAV_TYPE_FIXED_WING,
                MAV_AUTOPILOT_SLUGS,
                mlHeartbeatLocal.base_mode,
                mlHeartbeatLocal.custom_mode,
                mlHeartbeatLocal.system_status//,
                //mlHeartbeatLocal.mavlink_version
                );

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // If passthrough was requested (never used)
            if (mlPending.pt == TRUE) {
                // clear the message
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_ctrl_srfc_pt_pack(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    GS_SYSTEMID,
                    mlPassthrough.bitfieldPt);
                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                // Clear the flag
                mlPending.pt = FALSE;
            }

            break; //case 1
            
        case 2: // GPS Date Time, diagnostic, air data, 
            mavlink_msg_gps_date_time_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlGpsDateTime);

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_diagnostic_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlDiagnosticData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_scaled_pressure_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlAirData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            break; // case 2

        case 3: // data log, ping, vfr_hud
            mavlink_msg_data_log_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlDataLog);

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            if (mlPending.ping == 1) {
                // clear the msg
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_ping_pack(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    mlPing.seq,
                    SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    mlRawImuData.time_usec);

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);
            }


            memset(&msg, 0, sizeof (mavlink_message_t));
            // Hud data for primary flight display
            mavlink_msg_vfr_hud_pack(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                mlNavigation.u_m,               // air speed (m/s)
                (float)mlGpsData.vel * 0.01f,   // ground speed (m/s)
                //(float)(mlAttitudeData.yaw + M_PI)*(180.0f/M_PI), // heading from 0 to 360 (deg)
                0.0f,
                0,                              // throttle from 0 to 100 (percent)
                mlLocalPositionData.z,          // altitude (m)
                mlLocalPositionData.vz         // climb rate (m/s)
                );

            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);


            break; // case 3

        case 4: // navigation, cpu load, sensor diag

            mavlink_msg_slugs_navigation_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlNavigation);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_cpu_load_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlCpuLoadData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

             // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_sensor_diag_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlSensorDiag);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            break; // case 4

        case 5: // Raw IMU, Parameter Interface
            mavlink_msg_raw_imu_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlRawImuData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            if (!mlPending.piTransaction) break;

            // memset(vr_message,0,sizeof(vr_message));
            // 	sprintf(vr_message, "P = %d, S=%d ", mlPending.piCurrentParamInTransaction, mlPending.piProtState);	
            // 	bytes2Send += sendQGCDebugMessage (vr_message, 0, dataOut, bytes2Send+1);
            // 				
            switch (mlPending.piProtState) {

                case PI_SEND_ALL_PARAM:
                    if (mlPending.piCurrentParamInTransaction < PAR_PARAM_COUNT) {

                        mavlink_msg_param_value_pack(SLUGS_SYSTEMID,
                            SLUGS_COMPID,
                            &msg,
                            mlParamInterface.param_name[mlPending.piCurrentParamInTransaction],
                            mlParamInterface.param[mlPending.piCurrentParamInTransaction],
                            MAV_PARAM_TYPE_REAL32, // TODO: make sure this is correct later on
                            PAR_PARAM_COUNT,
                            mlPending.piCurrentParamInTransaction);

                        mlPending.piCurrentParamInTransaction++;

                        // Copy the message to the send buffer
                        bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                    } else {
                        mlPending.piProtState = PI_IDLE;
                        mlPending.piCurrentParamInTransaction = PAR_PARAM_COUNT;
                        mlPending.piTransaction = 0;
                        mlPending.piBackToList = 0;
                        mlPending.piQIdx = -1;
                    }
                    break;

                case PI_SEND_ONE_PARAM:

                    // memset(vr_message,0,sizeof(vr_message));
                    // 			 		sprintf(vr_message, "b2l = %d, ix = %d, rtx = %d", mlPending.piBackToList, mlPending.piQIdx, mlPending.piQueue[mlPending.piQIdx]);	
                    // 			 		bytes2Send += sendQGCDebugMessage (vr_message, 0, dataOut, bytes2Send+1);
                    // 						

                    if (!mlPending.piBackToList) { // if this is just a single pm read, i.e. not a retransmission
                        mavlink_msg_param_value_pack(SLUGS_SYSTEMID,
                            SLUGS_COMPID,
                            &msg,
                            mlParamInterface.param_name[mlPending.piCurrentParamInTransaction],
                            mlParamInterface.param[mlPending.piCurrentParamInTransaction],
                            MAV_PARAM_TYPE_REAL32,
                            PAR_PARAM_COUNT,
                            mlPending.piCurrentParamInTransaction);

                        // Copy the message to the send buffer
                        bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);


                        mlPending.piCurrentParamInTransaction = PAR_PARAM_COUNT;
                        mlPending.piProtState = PI_IDLE;
                        mlPending.piTransaction = 0;
                    } else { // you will need to go back to send all

                        if (mlPending.piQIdx < 0) { // if you've sent all the requests, then go back to list
                            mlPending.piProtState = PI_SEND_ALL_PARAM;
                            mlPending.piBackToList = 0;

                        } else { // send the requests
                            mavlink_msg_param_value_pack(SLUGS_SYSTEMID,
                                SLUGS_COMPID,
                                &msg,
                                mlParamInterface.param_name[mlPending.piQueue[mlPending.piQIdx]],
                                mlParamInterface.param[mlPending.piQueue[mlPending.piQIdx]],
                                MAV_PARAM_TYPE_REAL32,
                                PAR_PARAM_COUNT,
                                mlPending.piQueue[mlPending.piQIdx]);


                            // Copy the message to the send buffer
                            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                            // decrement the queue index
                            mlPending.piQIdx--;
                        } // QIdx < 0			      
                    }// !backToList

                    break;

            }// switch PI state machine


            break; // case 5

        case 6: // Local Position, System Status, GPS Status

            mavlink_msg_local_position_ned_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlLocalPositionData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);


            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_sys_status_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlSystemStatus);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            memset(&msg, 0, sizeof (mavlink_message_t));
#if USE_NMEA
            mavlink_msg_status_gps_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlGpsStatus);
#else
            mavlink_msg_novatel_diag_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlNovatelStatus);
#endif
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            break; // case 6

        case 7: // PWM Commands, Biases, slugs action

            mavlink_msg_servo_output_raw_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlPwmCommands);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // if in HIL Mode, report PWM commands to Sensor MCU so they
            // are sent to the 6DOF model in Simulink
            if (hasMode(mlHeartbeatLocal.base_mode, MAV_MODE_FLAG_HIL_ENABLED)) {
                addMessageToSpiOut(&msg);
            }

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_sensor_bias_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlSensorBiasData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            //
            if (mlPending.command != FALSE) {
                // clear the msg
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_command_long_encode(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    &mlCommand);

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                mlPending.command = 0;
            }

            break; // case 7

        case 8:// Wp Protocol state machine, raw Pressure
            // This block goes via SPI to the sensor DSC so it does not count
            // towards the Bandwith budget
            if (mlPending.spiSendGSLocation) {
                mavlink_msg_set_gps_global_origin_pack(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    //GS_COMPID,
                    GS_SYSTEMID,
                    mlWpValues.lat[MAX_NUM_WPS - 1],
                    mlWpValues.lon[MAX_NUM_WPS - 1],
                    mlWpValues.alt[MAX_NUM_WPS - 1]);

                addMessageToSpiOut(&msg);

                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "Sensor DSC Reboot.");
                bytes2Send += sendQGCDebugMessage(vr_message, 255, dataOut, bytes2Send + 1);

                mlPending.spiSendGSLocation = 0;
            }

            // end of SPI block

            if (sw_debug == 1) {
                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "hla = %2.4f, hlo =%2.4f  hh = %2.2f", (double)mlWpValues.lat[MAX_NUM_WPS - 1], (double)mlWpValues.lon[MAX_NUM_WPS - 1], (double)mlWpValues.alt[MAX_NUM_WPS - 1]);
                bytes2Send += sendQGCDebugMessage(vr_message, 0, dataOut, bytes2Send + 1);
                sw_debug = 0;
            }
            // 
            if (sw_debug == 4) {
                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "%d %d %d %d %d %d %d %d %d %d", sw_temp[0], sw_temp[1], sw_temp[2], sw_temp[3], sw_temp[4], sw_temp[5], sw_temp[6], sw_temp[7], sw_temp[8], sw_temp[9]);
                bytes2Send += sendQGCDebugMessage(vr_message, 0, dataOut, bytes2Send + 1);
                sw_debug = 0;

            }
            // 						
            // 			if (sw_debug == 3){
            // 				memset(vr_message,0,sizeof(vr_message));
            // 				sprintf(vr_message, "Mode = %d", mlSystemStatus.mode);	
            // 				bytes2Send += sendQGCDebugMessage (vr_message, 0, dataOut, bytes2Send+1);	
            // 				sw_debug = 0;		
            // 			}


            if (mlPending.wpProtState == WP_PROT_TX_WP) {
                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "%d: y =%2.2f x =%2.2f z =%2.2f o =%d  t =%d", mlPending.wpCurrentWpInTransaction, (double)mlWpValues.lat[mlPending.wpCurrentWpInTransaction],
                    (double)mlWpValues.lon[mlPending.wpCurrentWpInTransaction],
                    (double)mlWpValues.alt[mlPending.wpCurrentWpInTransaction],
                    mlWpValues.orbit[mlPending.wpCurrentWpInTransaction],
                    mlWpValues.type[mlPending.wpCurrentWpInTransaction]);
                bytes2Send += sendQGCDebugMessage(vr_message, 0, dataOut, bytes2Send + 1);
            }


            if (mlPending.wpProtState == WP_PROT_GETTING_WP_IDLE) {
                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "com = %d, tb =%2.2f ta = %2.2f", sw_intTemp, (double)fl_temp1, (double)fl_temp2);
                bytes2Send += sendQGCDebugMessage(vr_message, 0, dataOut, bytes2Send + 1);

            }

            // Current mission item (1 off indexing issue in qgc vs et)
            if (mlPending.wpSendCurrent) {
                memset(&msg, 0, sizeof (mavlink_message_t));
                mavlink_msg_mission_current_pack(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg, ((uint16_t)mlNavigation.toWP) - 1);
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);
                mlPending.wpSendCurrent = FALSE;
            }


            // Raw pressure
            memset(&msg, 0, sizeof (mavlink_message_t));
            mavlink_msg_raw_pressure_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlRawPressureData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            if (!mlPending.wpTransaction) break;

            switch (mlPending.wpProtState) {

                case WP_PROT_LIST_REQUESTED:
                    // clear the msg
                    memset(&msg, 0, sizeof (mavlink_message_t));

                    //mlPending.statustext++;
                    //mlStatustext.severity = MAV_SEVERITY_INFO;
                    //strncpy(mlStatustext.text, "Got mission list request. Sending count...", 49);

                    mavlink_msg_mission_count_pack(SLUGS_SYSTEMID,
                        MAV_COMP_ID_MISSIONPLANNER,
                        &msg,
                        GS_SYSTEMID,
                        GS_COMPID,
                        mlWpValues.wpCount);

                    // Copy the message to the send buffer
                    bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                    // Change the state machine state
                    mlPending.wpProtState = WP_PROT_NUM_SENT;

                    // Reset the timeout
                    mlPending.wpTimeOut = 0;
                    break;

                case WP_PROT_GETTING_WP_IDLE:
                    if (mlPending.wpCurrentWpInTransaction < mlPending.wpTotalWps) {

                        // clear the msg
                        memset(&msg, 0, sizeof (mavlink_message_t));

                        mavlink_msg_mission_request_pack(SLUGS_SYSTEMID,
                            MAV_COMP_ID_MISSIONPLANNER,
                            &msg,
                            GS_SYSTEMID,
                            GS_COMPID,
                            mlPending.wpCurrentWpInTransaction++);

                        // Copy the message to the send buffer
                        bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                        // Change the state machine state
                        mlPending.wpProtState = WP_PROT_RX_WP;

                    } else {
                        // clear the msg
                        memset(&msg, 0, sizeof (mavlink_message_t));

                        mavlink_msg_mission_ack_pack(SLUGS_SYSTEMID,
                            MAV_COMP_ID_MISSIONPLANNER,
                            &msg,
                            GS_SYSTEMID,
                            GS_COMPID,
                            MAV_MISSION_ACCEPTED); // 0 is success

                        // Copy the message to the send buffer
                        bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                        // Update the waypoint count
                        mlWpValues.wpCount = mlPending.wpTotalWps;

                        // End the transaction
                        mlPending.wpTransaction = 0;
                        mlPending.wpProtState = WP_PROT_IDLE;
                        mlPending.wpCurrentWpInTransaction = 0;
                        mlPending.wpTotalWps = 0;
                        mlPending.wpSendCurrent = TRUE; // send current waypoint index

                        // put zeros in the rest of the waypoints;
                        clearWaypointsFrom(mlWpValues.wpCount);

                    }

                    // Reset the timeout
                    mlPending.wpTimeOut = 0;
                    break;

                case WP_PROT_TX_WP:
                    memset(&msg, 0, sizeof (mavlink_message_t));

                    mlPending.statustext++;
                    mlStatustext.severity = MAV_SEVERITY_INFO;
                    strncpy(mlStatustext.text, "Sending waypoint.", 25);


                    // Send WP
                    mavlink_msg_mission_item_pack(SLUGS_SYSTEMID,
                        MAV_COMP_ID_MISSIONPLANNER,
                        &msg,
                        GS_SYSTEMID,
                        GS_COMPID,
                        mlPending.wpCurrentWpInTransaction,
                        MAV_FRAME_GLOBAL,
                        mlWpValues.type[mlPending.wpCurrentWpInTransaction],
                        0, // not current
                        1, // autocontinue
                        0.0, // Param 1 not used
                        0.0, // Param 2 not used
                        (float) mlWpValues.orbit[mlPending.wpCurrentWpInTransaction],
                        0.0, // Param 4 not used
                        mlWpValues.lat[mlPending.wpCurrentWpInTransaction],
                        mlWpValues.lon[mlPending.wpCurrentWpInTransaction],
                        mlWpValues.alt[mlPending.wpCurrentWpInTransaction]); // always autocontinue

                    // Copy the message to the send buffer
                    bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                    // Switch the state waiting for the next request
                    // Change the state machine state
                    mlPending.wpProtState = WP_PROT_SENDING_WP_IDLE;

                    // Reset the timeout
                    mlPending.wpTimeOut = 0;
                    break;

            } // switch wpProtState

            mlPending.wpTimeOut++;

            // if Timed out reset the state machine and send an error
            if (mlPending.wpTimeOut > PROTOCOL_TIMEOUT_TICKS) {
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_mission_ack_pack(SLUGS_SYSTEMID,
                    MAV_COMP_ID_MISSIONPLANNER,
                    &msg,
                    GS_SYSTEMID,
                    GS_COMPID,
                    1); // 1 is failure

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                // reset the state machine
                mlPending.wpTransaction = 0;
                mlPending.wpProtState = WP_PROT_IDLE;
                mlPending.wpCurrentWpInTransaction = 0;
                mlPending.wpTimeOut = 0;
                mlPending.wpTotalWps = 0;
            }

            break; // case 8

        case 9: // Action Ack, Pilot Console, Mid Level Commands, boot

            mavlink_msg_rc_channels_raw_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlPilotConsoleData);
            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            if (mlPending.commandAck) {
                mavlink_msg_command_ack_encode(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    &mlCommandAck);

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                mlPending.commandAck = FALSE;
            }


            // if there is a pending request for the Mid Level Commands
            if (mlPending.midLvlCmds == 1) {
                // clear the msg
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_mid_lvl_cmds_pack(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    GS_SYSTEMID,
                    mlMidLevelCommands.hCommand,
                    mlMidLevelCommands.uCommand,
                    mlMidLevelCommands.rCommand);

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                // clear the flag
                mlPending.midLvlCmds = 0;
            }

            if (mlPending.isrLoc == 1) {
                // clear the msg
                memset(&msg, 0, sizeof (mavlink_message_t));

                mavlink_msg_isr_location_encode(SLUGS_SYSTEMID,
                    SLUGS_COMPID,
                    &msg,
                    &mlISR);

                // Copy the message to the send buffer
                bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

                mlPending.isrLoc = 0;
            }

            // if the boot message is set then transmit it urgently
            if (mlBoot.version == 1) {
                memset(vr_message, 0, sizeof (vr_message));
                sprintf(vr_message, "%s DSC Reboot.", "Control");
                bytes2Send += sendQGCDebugMessage(vr_message, 255, dataOut, bytes2Send + 1);
                mlBoot.version = 0;
            }

            break; // case 9

        case 10: // Filtered data, PTZ data, VI Sensor
            mavlink_msg_scaled_imu_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlFilteredData);

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_ptz_status_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlPtzStatus);

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            // clear the msg
            memset(&msg, 0, sizeof (mavlink_message_t));

            mavlink_msg_volt_sensor_encode(SLUGS_SYSTEMID,
                SLUGS_COMPID,
                &msg,
                &mlVISensor);

            // Copy the message to the send buffer
            bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

            break; // case 10

    } // Switch

    // Send additional statustext messages
    if (mlPending.statustext > 0) {
        memset(&msg, 0, sizeof (mavlink_message_t));


        mavlink_msg_statustext_pack(SLUGS_SYSTEMID,
        SLUGS_COMPID,
        &msg,
        mlStatustext.severity,
        mlStatustext.text);

        bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);

        mlPending.statustext = 0;
    }



    memset(&msg, 0, sizeof (mavlink_message_t));

    mavlink_msg_attitude_encode(SLUGS_SYSTEMID,
        SLUGS_COMPID,
        &msg,
        &mlAttitudeRotated);
    // Copy the message to the send buffer	
    bytes2Send += mavlink_msg_to_send_buffer((dataOut + 1 + bytes2Send), &msg);


    // Put the length of the message in the first byte of the outgoing array
    *dataOut = bytes2Send;

    // increment/overflow the samplePeriod counter
    // configured for 10 Hz in non vital messages
    sampleTelemetry = (sampleTelemetry >= 10) ? 1 : sampleTelemetry + 1;

}

// void protDecodeMavlink(uint8_t* dataIn) {

    // uint8_t i, indx, writeSuccess, commChannel = dataIn[MAXSPI + 1];
    // uint32_t temp;
    // mavlink_param_set_t set;
    // //mavlink_set_nav_mode_t mode;



    // //static int16_t packet_drops = 0;
    // mavlink_message_t msg;
    // mavlink_status_t status;

    // // increment the age of heartbeat
    // mlPending.heartbeatAge++;

    // for (i = 1; i <= dataIn[0]; i++) {

        // // Try to get a new message
        // if (mavlink_parse_char(commChannel, dataIn[i], &msg, &status)) {

            // // Handle message
            // switch (msg.msgid) {
                // case MAVLINK_MSG_ID_HEARTBEAT:
                    // mavlink_msg_heartbeat_decode(&msg, &mlHeartbeat);
                    // // Reset the heartbeat
                    // mlPending.heartbeatAge = 0;
                    // break;

                // case MAVLINK_MSG_ID_GPS_RAW_INT:
                    // mavlink_msg_gps_raw_int_decode(&msg, &mlGpsData);
                    // //updateGpsPosition(); // scales raw ints to floats
                    // break;

                // case MAVLINK_MSG_ID_CPU_LOAD:
                    // mavlink_msg_cpu_load_decode(&msg, &mlCpuLoadData);
                    // // Copy battery voltage to system status message
                    // mlSystemStatus.voltage_battery = mlCpuLoadData.batVolt;
                    // break;

                // case MAVLINK_MSG_ID_LOCAL_POSITION_NED:
                    // mavlink_msg_local_position_ned_decode(&msg, &mlLocalPositionData);
                    // break;

                // case MAVLINK_MSG_ID_SCALED_PRESSURE:
                    // mavlink_msg_scaled_pressure_decode(&msg, &mlAirData);
                    // break;

                // case MAVLINK_MSG_ID_BOOT:
                    // temp = mavlink_msg_boot_get_version(&msg);

                    // if (temp) {
                        // mlPending.spiSendGSLocation = 1;
                    // }
                    // /*
                    // if (temp != 0 && mlBoot.version != 0) {
                        // mlBoot.version += temp;
                    // } else if (mlBoot.version == 0) {
                        // mavlink_msg_boot_decode(&msg, &mlBoot);
                    // }
                     // */

                    // break;

                // case MAVLINK_MSG_ID_SENSOR_BIAS:
                    // mavlink_msg_sensor_bias_decode(&msg, &mlSensorBiasData);
                    // break;

                // case MAVLINK_MSG_ID_DIAGNOSTIC:
                    // //mavlink_msg_diagnostic_decode(&msg, &mlDiagnosticData);
                    // break;

                // case MAVLINK_MSG_ID_RC_CHANNELS_RAW:
                    // mavlink_msg_rc_channels_raw_decode(&msg, &mlPilotConsoleData);
                    // break;

                // case MAVLINK_MSG_ID_SCALED_IMU:
                    // mavlink_msg_scaled_imu_decode(&msg, &mlFilteredData);
                    // break;

                // case MAVLINK_MSG_ID_ATTITUDE:
                    // mavlink_msg_attitude_decode(&msg, &mlAttitudeData);
                    // break;

                // case MAVLINK_MSG_ID_RAW_IMU:
                    // mavlink_msg_raw_imu_decode(&msg, &mlRawImuData);
                    // break;

                // case MAVLINK_MSG_ID_RAW_PRESSURE:
                    // mavlink_msg_raw_pressure_decode(&msg, &mlRawPressureData);
                    // break;

                // case MAVLINK_MSG_ID_GPS_DATE_TIME:
                    // mavlink_msg_gps_date_time_decode(&msg, &mlGpsDateTime);
                    // break;

// #if USE_NMEA
                // case MAVLINK_MSG_ID_STATUS_GPS:
                    // mavlink_msg_status_gps_decode(&msg, &mlGpsStatus);
                    // break;
// #else
                // case MAVLINK_MSG_ID_NOVATEL_DIAG:
                    // mavlink_msg_novatel_diag_decode(&msg, &mlNovatelStatus);
                    // break;
// #endif

                // case MAVLINK_MSG_ID_SENSOR_DIAG:
                    // mavlink_msg_sensor_diag_decode(&msg, &mlSensorDiag );
                    // break;
                    // //  End of Sensor MCU exclusive Messages
                    // // =====================================

                // case MAVLINK_MSG_ID_SET_MODE:
                // {
                    // mavlink_set_mode_t mlSetMode;
                    // mavlink_msg_set_mode_decode(&msg, &mlSetMode );
                    // // Can set custom_mode (previously nav_mode) and or base_mode
                    // if (mlSetMode.base_mode != 0) {

                        // if (!hasMode(mlHeartbeatLocal.base_mode,MAV_MODE_FLAG_HIL_ENABLED)
                            // && hasMode(mlSetMode.base_mode, MAV_MODE_FLAG_HIL_ENABLED)) {
                            // // Turned HIL on
                            // mlPending.statustext++;

                            // mlStatustext.severity = MAV_SEVERITY_INFO;
                            // strncpy(mlStatustext.text, "Turning on HIL mode.", 49);
                        // }
                        // else if (hasMode(mlHeartbeatLocal.base_mode, MAV_MODE_FLAG_HIL_ENABLED)
                            // && !hasMode(mlSetMode.base_mode,MAV_MODE_FLAG_HIL_ENABLED)) {
                            // // Turned HIL off
                            // mlPending.statustext++;

                            // mlStatustext.severity = MAV_SEVERITY_INFO;
                            // strncpy(mlStatustext.text, "Turning off HIL mode.", 49);
                        // }
                        // mlHeartbeatLocal.base_mode = mlSetMode.base_mode;

                    // }
                    // if (mlSetMode.custom_mode != SLUGS_MODE_NONE) {
                        // /*
                        // BOOL badMode = FALSE;
                        // // Note: some modes are unused. consider pruning
                        // switch (mlSetMode.custom_mode) {
                            // case SLUGS_MODE_LIFTOFF:
                                // break;
                            // case SLUGS_MODE_PASSTHROUGH:
                                // mlPending.pt = TRUE; // want passthrough mode
                                // break;
                            // case SLUGS_MODE_WAYPOINT:
                                // break;
                            // case SLUGS_MODE_MID_LEVEL:
                                // break;
                            // case SLUGS_MODE_RETURNING:
                                // break;
                            // case SLUGS_MODE_LANDING:
                                // break;
                            // case SLUGS_MODE_LOST:
                                // break;
                            // case SLUGS_MODE_SELECTIVE_PASSTHROUGH:
                                // break;
                            // case SLUGS_MODE_ISR:
                                // break;
                            // case SLUGS_MODE_LINE_PATROL:
                                // break;
                            // default:
                                // badMode = TRUE;
                                // // Send an error message
                                // mlPending.statustext++;

                                // mlStatustext.severity = MAV_SEVERITY_ERROR;
                                // sprintf(mlStatustext.text, "Unknown slugs mode sent: %X.", mlSetMode.custom_mode)
                                // strncpy(mlStatustext.text,"Failed to clear waypoints from EEPROM.", 49);

                        // }
                        // // Set new slugs mode if valid
                        // if (!badMode)
                        // */
                        // //lastNavigationMode = mlHeartbeatLocal.custom_mode;
                        // mlHeartbeatLocal.custom_mode = mlSetMode.custom_mode;
                    // }

                    // break;
                // }
                // case MAVLINK_MSG_ID_MID_LVL_CMDS:
                // {
                    // mavlink_msg_mid_lvl_cmds_decode(&msg, &mlMidLevelCommands);

                    // // Report the Change

                    // mlPending.statustext++;

                    // mlStatustext.severity = MAV_SEVERITY_INFO;
                    // strncpy(mlStatustext.text, "Mid level flight parameters received.", 49);
                    // /*
                    // mlAction.actionId = SLUGS_ACTION_MLC_CHANGE;
                    // mlAction.actionVal = SLUGS_ACTION_SUCCESS;
                     // */

                    // mlPending.midLvlCmds = 1;

                    // break;
                // }
                // // Slugs camera orders not used, but should be moved to command_long
                // /*
                // case MAVLINK_MSG_ID_SLUGS_CAMERA_ORDER:
                    // mavlink_msg_slugs_camera_order_decode(&msg, &mlCameraOrder);

                    // // Report the Change
                    // mlPending.commandAck++;
                    // mlCommandAck.command = MAVLINK_MSG_ID_SLUGS_CAMERA_ORDER;
                    // mlCommandAck.result = MAV_RESULT_ACCEPTED;

                    // break;

                // case MAVLINK_MSG_ID_SLUGS_CONFIGURATION_CAMERA:
                    // mavlink_msg_slugs_configuration_camera_decode(&msg, &mlCameraConfig);

                    // // Report the Change
                    // mlPending.commandAck++;
                    // mlCommandAck.command = MAVLINK_MSG_ID_SLUGS_CONFIGURATION_CAMERA;
                    // mlCommandAck.result = MAV_RESULT_ACCEPTED;

                    // break;
                // */
                // case MAVLINK_MSG_ID_MISSION_COUNT:

                    // if (!mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_IDLE)) {


                        // mavlink_msg_mission_count_decode(&msg, &mlWpCount);

                        // // Start the transaction
                        // mlPending.wpTransaction = 1;

                        // // change the state	
                        // mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;

                        // // reset the rest of the state machine
                        // mlPending.wpTotalWps = mlWpCount.count;
                        // mlPending.wpCurrentWpInTransaction = 0;
                        // mlPending.wpTimeOut = 0;
                    // }

                    // break;

                // case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:

                    // // if there is no transaction going on
                    // if (!mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_IDLE)) {
                        // // Start the transaction
                        // mlPending.wpTransaction = 1;

                        // // change the state
                        // mlPending.wpProtState = WP_PROT_LIST_REQUESTED;



                        // // reset the rest of the state machine
                        // mlPending.wpCurrentWpInTransaction = 0;
                        // mlPending.wpTimeOut = 0;
                    // }
                    // break;

                // case MAVLINK_MSG_ID_MISSION_REQUEST:
                    // mavlink_msg_mission_request_decode(&msg, &mlWpRequest);

                    // if (mlPending.wpTransaction && (mlWpRequest.seq < mlWpValues.wpCount)) {
                        // // change the state
                        // mlPending.wpProtState = WP_PROT_TX_WP;

                        // // reset the rest of the state machine
                        // mlPending.wpCurrentWpInTransaction = mlWpRequest.seq;
                        // mlPending.wpTimeOut = 0;
                    // } else {
                        // // TODO: put here a report for a single WP, i.e. not inside a transaction
                    // }
                    // break;

                // case MAVLINK_MSG_ID_MISSION_ACK:
                    // mavlink_msg_mission_ack_decode(&msg, &mlWpAck);

                    // if (mlPending.wpTransaction) {
                        // // End the transaction
                        // mlPending.wpTransaction = 0;

                        // // change the state
                        // mlPending.wpProtState = WP_PROT_IDLE;

                        // // reset the rest of the state machine
                        // mlPending.wpCurrentWpInTransaction = 0;
                        // mlPending.wpTimeOut = 0;

                        // // send current waypoint index
                        // mlPending.wpSendCurrent = TRUE;
                    // }

                    // break;

                // case MAVLINK_MSG_ID_MISSION_ITEM:
                    // writeSuccess = SUCCESS;
                    // mavlink_msg_mission_item_decode(&msg, &mlSingleWp);

                    // if (mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_RX_WP)) {
                        // mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;

                    // }

                    // indx = (uint8_t) mlSingleWp.seq;

                    // mlWpValues.lat[indx] = mlSingleWp.x;
                    // mlWpValues.lon[indx] = mlSingleWp.y;
                    // mlWpValues.alt[indx] = mlSingleWp.z;

                    // mlWpValues.type[indx] = mlSingleWp.command;

                    // mlWpValues.orbit[indx] = (uint16_t) mlSingleWp.param3;

                    // // Record the data in EEPROM
                    // writeSuccess = storeWaypointInEeprom(&mlSingleWp);

                    // // Set the flag of Aknowledge for the AKN Message
                    // // if the write was not successful
                    // if (writeSuccess != SUCCESS) {
                        // mlPending.wpAck++;

                        // //mlWpAck.target_system =
                        // mlWpAck.target_component = MAV_COMP_ID_MISSIONPLANNER;
                        // mlWpAck.type = MAV_MISSION_ERROR;
                        // /*
                        // mlAction.actionId = SLUGS_ACTION_EEPROM;
                        // mlAction.actionVal = SLUGS_ACTION_FAIL;
                        // */
                    // }

                    // break;

                // case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:

                    // writeSuccess = SUCCESS;

                    // // clear the WP values in memory;
                    // memset(&mlWpValues, 0, sizeof (mavlink_mission_item_values_t));

                    // writeSuccess = clearWaypointsFrom(0);

                    // // Set the flag of Aknowledge fail
                    // // if the write was unsuccessful
                    // if (writeSuccess != SUCCESS) {
                        // mlPending.statustext++;

                        // mlStatustext.severity = MAV_SEVERITY_ERROR;
                        // strncpy(mlStatustext.text, "Failed to clear waypoints from EEPROM.", 49);

                    // }
                    // /*
                        // mlCommandAck.command = MAVLINK_MSG_ID_MISSION_CLEAR_ALL;
                        // mlCommandAck.result = MAV_RESULT_FAILED;
                        
                        // mlAction.actionId = SLUGS_ACTION_EEPROM;
                        // mlAction.actionVal = SLUGS_ACTION_FAIL;
                         
                    // }
                     // * */

                    // // Update the waypoint count
                    // mlWpValues.wpCount = 0;

                    // // Set the state machine ready to send the WP akn
                    // mlPending.wpCurrentWpInTransaction = 0;
                    // mlPending.wpTotalWps = 0;
                    // mlPending.wpTransaction = 1;
                    // mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;

                    // break;

                // case MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN:
                    // writeSuccess = SUCCESS;

                    // memset(&mlSingleWp, 0, sizeof (mavlink_mission_item_t));

                    // mavlink_msg_set_gps_global_origin_decode(&msg, &mlGSLocation);


                    // addMessageToSpiOut(&msg);   

                    // mlSingleWp.x = (float) (mlGSLocation.latitude);
                    // mlSingleWp.y = (float) (mlGSLocation.longitude);
                    // mlSingleWp.z = (float) (mlGSLocation.altitude);

                    // indx = (uint8_t) MAX_NUM_WPS - 1;

                    // mlWpValues.lat[indx] = mlSingleWp.x;
                    // mlWpValues.lon[indx] = mlSingleWp.y;
                    // mlWpValues.alt[indx] = mlSingleWp.z;
                    // mlWpValues.type[indx] = MAV_CMD_NAV_LAND;
                    // mlWpValues.orbit[indx] = 0;

                    // // Record the data in EEPROM
                    // writeSuccess = storeWaypointInEeprom(&mlSingleWp);

                    // if (writeSuccess != SUCCESS) {
                        // mlPending.statustext++;

                        // mlStatustext.severity = MAV_SEVERITY_ERROR;
                        // strncpy(mlStatustext.text, "Failed to write origin to EEPROM.", 49);
                    // }
                    // else {

                        // mlPending.statustext++;

                        // mlStatustext.severity = MAV_SEVERITY_INFO;
                        // strncpy(mlStatustext.text, "Control DSC GPS origin set.", 49);
                    // }

                    // // Set the flag of Aknowledge for the AKN Message
                    // // if the write was not successful
                    // /*
                    // if (writeSuccess != SUCCESS) {
                        
                        // mlAction.actionId = SLUGS_ACTION_EEPROM;
                        // mlAction.actionVal = SLUGS_ACTION_FAIL;
                         
                    // }
                    // */
                    // break;

                // case MAVLINK_MSG_ID_CTRL_SRFC_PT:
                    // mavlink_msg_ctrl_srfc_pt_decode(&msg, &mlPassthrough);

                    // // Report the Change // NOTE: look into this
                    // /*
                    // mlPending.slugsAction++;
                    // mlAction.actionId = SLUGS_ACTION_PT_CHANGE;
                    // mlAction.actionVal = SLUGS_ACTION_SUCCESS;
                    // */

                    // mlPending.statustext++;

                    // mlStatustext.severity = MAV_SEVERITY_INFO;
                    // sprintf(mlStatustext.text, "Control surface passthrough: 0x%X", mlPassthrough.bitfieldPt);
                    // break;

                // case MAVLINK_MSG_ID_PING:
                    // mavlink_msg_ping_decode(&msg, &mlPing);

                    // mlPending.ping = 1;
                    // break;


                // case MAVLINK_MSG_ID_STATUSTEXT:
                    // // Received status message from the sensor MCU -- forward to GS
                    // mavlink_msg_statustext_decode(&msg, &mlStatustext);
                    // mlPending.statustext++;
                    // break;


                // case MAVLINK_MSG_ID_COMMAND_ACK:
                    // // Received a command ack from the sensor MCU
                    // mavlink_msg_command_ack_decode(&msg, &mlCommandAck);

                    // switch (mlCommandAck.command) {
                        // case MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN:
                            // // since this case has no specific action required on this end
                            // // then just increment slugs action and report it
                            // //mlPending.slugsAction++;
                            // mlPending.statustext++;

                            // mlStatustext.severity = MAV_SEVERITY_INFO;
                            // strncpy(mlStatustext.text, "Sensor DSC GPS origin set.", 49);
                            // break;
                    // }

                    // break;

                // // Replaced by COMMAND_ACK above
                // // Action stuff was here

                // case MAVLINK_MSG_ID_COMMAND_LONG:
                    // mavlink_msg_command_long_decode(&msg, &mlCommand);

                    // switch (mlCommand.command) {
                        // // TODO: Only handle this in PREFLIGHT mode
                        // case MAV_CMD_PREFLIGHT_STORAGE:
                            // writeSuccess = FAILURE;
                            // // Parameter storage
                            // if (mlCommand.param1 == 0.0f) { // read
                                // memset(&(mlParamInterface.param[0]), 0, sizeof (float) *PAR_PARAM_COUNT);

                                // // Comment out MAVLINK_TELEMETRY_RATE in apDefinitions.h to disable this feature
// #ifdef MAVLINK_TELEMETRY_RATE
    // // Default parameter
    // mlParamInterface.param[PAR_RATE_TELEMETRY] = MAVLINK_TELEMETRY_RATE; // (Hz)
// #endif

                                // writeSuccess = readParamsInEeprom();
                            // }
                            // else if (mlCommand.param1 == 1.0f) { // write

                                // writeSuccess = storeAllParamsInEeprom();
                            // }
                            // // Waypoint storage (only handle either params or waypoints)
                            // // TODO look into implementing this (again?)
                            // else if (mlCommand.param2 == 0.0f) { // read
                            // }
                            // else if (mlCommand.param2 == 1.0f) { // write
                            // }

                            // mlPending.commandAck = TRUE;

                            // mlCommandAck.command = MAV_CMD_PREFLIGHT_STORAGE;
                            // mlCommandAck.result = (writeSuccess == SUCCESS)?
                                // MAV_RESULT_ACCEPTED : MAV_RESULT_FAILED;

                            // break;
                        // // Store or read mid-level commands to/from eeprom
                        // case MAV_CMD_MIDLEVEL_STORAGE:
                            // writeSuccess = FAILURE;
                            // if (mlCommand.param1 == 0.0f) { // read
                                // mlMidLevelCommands.hCommand = 0.0f;
                                // mlMidLevelCommands.rCommand = 0.0f;
                                // mlMidLevelCommands.uCommand = 0.0f;
                                // writeSuccess = readMidLevelCommandsInEeprom();
                            // }
                            // else if (mlCommand.param1 == 1.0f) { // write
                                // writeSuccess = storeMidLevelCommandsInEeprom();
                                // mlPending.statustext++;

                                // mlStatustext.severity = MAV_SEVERITY_INFO;
                                // strncpy(mlStatustext.text, "Wrote mid-level commands to EEPROM.", 49);
                            // }

                            // mlPending.commandAck = TRUE;
                            // mlCommandAck.command = MAV_CMD_MIDLEVEL_STORAGE;
                            // mlCommandAck.result = (writeSuccess == SUCCESS)?
                                // MAV_RESULT_ACCEPTED : MAV_RESULT_FAILED;

                            // break;
                        // // HIL Stuff Moved to set_mode
                        // case MAV_CMD_RETURN_TO_BASE:
                            // mlRTB.rtb = TRUE;
                            // mlRTB.track_mobile = mlCommand.param1;
                            // mlPending.commandAck = TRUE;
                            // mlCommandAck.command = MAV_CMD_RETURN_TO_BASE;
                            // mlCommandAck.result = MAV_RESULT_ACCEPTED;
                            // break;
                        // case MAV_CMD_TURN_LIGHT:
                            // mlLights.state = mlCommand.param2;
                            // mlLights.type = mlCommand.param1;

                            // mlPending.commandAck = TRUE;
                            // mlCommandAck.command = MAV_CMD_TURN_LIGHT;
                            // mlCommandAck.result = MAV_RESULT_ACCEPTED;
                            // break;
                        // case MAV_CMD_GET_MID_LEVEL_COMMANDS:
                            // mlPending.midLvlCmds = 1;

                            // mlPending.commandAck = TRUE;
                            // mlCommandAck.command = MAV_CMD_GET_MID_LEVEL_COMMANDS;
                            // mlCommandAck.result = MAV_RESULT_ACCEPTED;
                            // break;

                    // } // switch COMMAND_LONG

                    // break;

                // case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
                    // mlPending.piTransaction = 1;
                    // mlPending.piProtState = PI_SEND_ALL_PARAM;
                    // mlPending.piCurrentParamInTransaction = 0;
                    // break;

                // case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
                    // // If it was in the middle of a list transmission or there is already a param enqueued
                    // mlPending.piTransaction = 1;
                    // switch (mlPending.piProtState) {
                        // case PI_IDLE:
                            // mlPending.piBackToList = 0; // no need to go back
                            // mlPending.piQIdx = -1; // no Index
                            // mlPending.piCurrentParamInTransaction = mavlink_msg_param_request_read_get_param_index(&msg); // assign directly
                            // mlPending.piProtState = PI_SEND_ONE_PARAM;
                            // break;

                        // case PI_SEND_ALL_PARAM:
                            // mlPending.piBackToList = 1; // mark to go back
                            // mlPending.piQIdx++; // done like this because when empty index = -1
                            // mlPending.piQueue[mlPending.piQIdx] = mavlink_msg_param_request_read_get_param_index(&msg); // put in in queue
                            // mlPending.piProtState = PI_SEND_ONE_PARAM;
                            // break;

                        // case PI_SEND_ONE_PARAM:
                            // if (mlPending.piBackToList) {
                                // mlPending.piQIdx++; // done like this because when empty index = -1
                                // mlPending.piQueue[mlPending.piQIdx] = mavlink_msg_param_request_read_get_param_index(&msg); // put in in queue				  									  		
                            // }
                            // mlPending.piProtState = PI_SEND_ONE_PARAM;
                            // break;
                    // }
                    // break;

                // case MAVLINK_MSG_ID_PARAM_SET:
                    // mavlink_msg_param_set_decode(&msg, &set);

                    // if ((uint8_t) set.target_system == (uint8_t) SLUGS_SYSTEMID &&
                        // (uint8_t) set.target_component == (uint8_t) SLUGS_COMPID) {


                        // char* key = (char*) set.param_id;
                        // uint8_t i, j;
                        // uint8_t match;
                        // for (i = 0; i < PAR_PARAM_COUNT; i++) {
                            // match = 1;
                            // for (j = 0; j < SLUGS_PARAM_NAME_LENGTH; j++) {
                                // // Compare
                                // if (((char) (mlParamInterface.param_name[i][j]))
                                    // != (char) (key[j])) {
                                    // match = 0;
                                // } // if

                                // // End matching if null termination is reached
                                // if (((char) mlParamInterface.param_name[i][j]) == '\0') {
                                    // break;
                                // } // if
                            // }// for j

                            // // Check if matched
                            // if (match) {
                                // //sw_debug = 1;
                                // // Only write and emit changes if there is actually a difference
                                // // AND only write if new value is NOT "not-a-number"
                                // // AND is NOT infinity

                                // if (isFinite(set.param_value)) {

                                    // mlParamInterface.param[i] = set.param_value;

                                    // // Report back new value
                                    // mlPending.piBackToList = 0; // no need to go back
                                    // mlPending.piQIdx = -1; // no Index
                                    // mlPending.piCurrentParamInTransaction = i; // assign directly
                                    // mlPending.piProtState = PI_SEND_ONE_PARAM;
                                    // mlPending.piTransaction = 1;

                                // } // if different and not nan and not inf
                            // } // if match
                        // }// for i
                    // } // if addressed to this
                    // break;

                    // // case MAVLINK_MSG_ID_SLUGS_CAMERA_ORDER:
                    // // 	mavlink_msg_slugs_camera_order_decode(&msg, &mlCameraOrder); 
                    // // break;
                // // mav_mode moved into custom_mode of set_mode 
                // /*
                // case MAVLINK_MSG_ID_SET_NAV_MODE:
                    // mavlink_msg_set_nav_mode_decode(&msg, &mode);

                    // mlSystemStatus.nav_mode = mode.nav_mode;
                    // break;
                // */
                // // moved to MAV_CMD_RETURN_TO_BASE
                    // /*
                // case MAVLINK_MSG_ID_SLUGS_RTB:
                    // mavlink_msg_slugs_rtb_decode(&msg, &mlRTB);

                    // // Report the Change
                    // //mlPending.
                    // //mlPending.slugsAction++;

                    // if (!mlRTB.rtb) {
                        // mlAction.actionId = SLUGS_ACTION_RTB_OFF;
                    // } else if (!mlRTB.track_mobile) {
                        // mlAction.actionId = SLUGS_ACTION_RTB_ON_NO_MOBILE;
                    // } else {
                        // mlAction.actionId = SLUGS_ACTION_RTB_ON_MOBILE;
                    // }
                    // mlAction.actionVal = SLUGS_ACTION_SUCCESS;
                     
                    // break;
                    // */
                // case MAVLINK_MSG_ID_SLUGS_MOBILE_LOCATION:
                    // mavlink_msg_slugs_mobile_location_decode(&msg, &mlMobileLocation);
                    // break;


                // case MAVLINK_MSG_ID_ISR_LOCATION:
                    // mavlink_msg_isr_location_decode(&msg, &mlISR);

                    // // Report the Change
                    // // Actions removed. TODO: determine reporting for ISR_LOC set
                    // /*
                    // mlPending.slugsAction++;
                    // mlAction.actionId = SLUGS_ACTION_ISR_LOCATION;
                    // mlAction.actionVal = SLUGS_ACTION_SUCCESS;
                    // */

                    // mlPending.statustext++;

                    // mlStatustext.severity = MAV_SEVERITY_INFO;
                    // strncpy(mlStatustext.text, "ISR position recieved.", 49);

                    // mlPending.isrLoc = 1;
                    // break;
                // // Moved to MAV_CMD_TURN_LIGHT
                    // /*
                // case MAVLINK_MSG_ID_TURN_LIGHT:
                    // mavlink_msg_turn_light_decode(&msg, &mlLights);


                    // mlPending.slugsAction++;
                    // mlAction.actionId = SLUGS_ACTION_LIGHTS;
                    // mlAction.actionVal = SLUGS_ACTION_SUCCESS;

                    // break;
                    // */
            // } // switch	
        // } // if

        // // Update global packet drops counter
        // if (commChannel == 1) {
            // mlSystemStatus.errors_comm += status.packet_rx_drop_count;
        // }


    // }// for  
// }

void copyBufferToDMA1(unsigned char size) {
    a068:	88 9f be    	mov.d     w8, [w15++]
    a06a:	8a 1f 78    	mov.w     w10, [w15++]
    a06c:	00 45 78    	mov.b     w0, w10
    unsigned char i;
    for (i = 0; i < size; i += 1) {
    a06e:	0a 04 e0    	cp0.b     w10
    a070:	0a 00 32    	bra       Z, 0xa086 <.L79>
    a072:	c9 c7 22    	mov.w     #0x2c7c, w9
    a074:	00 44 eb    	clr.b     w8

0000a076 <.L0>:
        BufferB[i] = (unsigned int) readFront(uartBufferOut);
    a076:	50 8b 81    	mov.w     0x316a, w0
    a078:	14 0b 02    	call      0x10b14 <_readFront>
    a07a:	01 00 00 
    a07c:	00 80 fb    	ze        w0, w0
    a07e:	80 2c 78    	mov.w     w0, [++w9]

0000a080 <.L0>:
    a080:	08 44 e8    	inc.b     w8, w8
    a082:	88 4f 55    	sub.b     w10, w8, [w15]
    a084:	f8 ff 3e    	bra       GTU, 0xa076 <.L0> <.L81>

0000a086 <.L79>:
    }
}
    a086:	4f 05 78    	mov.w     [--w15], w10
    a088:	4f 04 be    	mov.d     [--w15], w8
    a08a:	00 00 06    	return    

0000a08c <_send2GS>:

void send2GS(unsigned char* protData) {
    a08c:	88 9f be    	mov.d     w8, [w15++]
    a08e:	8a 1f 78    	mov.w     w10, [w15++]
    a090:	00 05 78    	mov.w     w0, w10
    unsigned int bufLen, i;

    // add the data to the circular buffer
    for (i = 1; i <= protData[0]; i += 1) {
    a092:	1a 04 e0    	cp0.b     [w10]
    a094:	0a 00 32    	bra       Z, 0xa0aa <.L0> <.L84>
    a096:	8a 04 78    	mov.w     w10, w9
    a098:	18 00 20    	mov.w     #0x1, w8

0000a09a <.L0>:
        writeBack(uartBufferOut, protData[i]);
    a09a:	d9 40 78    	mov.b     [++w9], w1
    a09c:	50 8b 81    	mov.w     0x316a, w0
    a09e:	42 0b 02    	call      0x10b42 <_writeBack>
    a0a0:	01 00 00 

0000a0a2 <.L0>:
    a0a2:	08 04 e8    	inc.w     w8, w8
    a0a4:	1a 80 fb    	ze        [w10], w0
    a0a6:	88 0f 50    	sub.w     w0, w8, [w15]
    a0a8:	f8 ff 31    	bra       C, 0xa09a <.L0> <.L85>

0000a0aa <.L0>:
    }

    // get the Length of the logBuffer
    bufLen = getLength(uartBufferOut);
    a0aa:	50 8b 81    	mov.w     0x316a, w0
    a0ac:	c0 0a 02    	call      0x10ac0 <_getLength>
    a0ae:	01 00 00 

0000a0b0 <.L0>:


    // if the interrupt catched up with the circularBuffer
    // and new data was added then turn on the DMA 
//    if (!(DMA1CONbits.CHEN) && (bufLen > 0)) {
//        // Configure the bytes to send
//        DMA1CNT = bufLen <= (MAXSEND - 1) ? bufLen - 1 : MAXSEND - 1;
//        // copy the buffer to the DMA channel outgoing buffer
//        copyBufferToDMA1((unsigned char) DMA1CNT + 1);
//        // Enable the DMA
//        DMA1CONbits.CHEN = 1;
//        // Init the transmission
//        DMA1REQbits.FORCE = 1;
//    }

}
    a0b0:	4f 05 78    	mov.w     [--w15], w10
    a0b2:	4f 04 be    	mov.d     [--w15], w8
    a0b4:	00 00 06    	return    

0000a0b6 <_clearWaypointsFrom>:

// Interrupts

//void __attribute__((interrupt, no_auto_psv)) _DMA1Interrupt(void) {
//    // Clear the DMA1 Interrupt Flag;
//    IFS0bits.DMA1IF = 0;
//}
//
//void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {
//
//    // Read the buffer while it has data
//    // and add it to the circular buffer
//    while (U2STAbits.URXDA == 1) {
//        writeBack(uartBufferIn, (unsigned char) U2RXREG);
//    }
//
//    // If there was an overun error clear it and continue
//    if (U2STAbits.OERR == 1) {
//        U2STAbits.OERR = 0;
//    }
//
//    // clear the interrupt
//    IFS1bits.U2RXIF = 0;
//
//}
//
//void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
//
//    // If there was an overun error clear it and continue
//    if (U2STAbits.OERR == 1) {
//        U2STAbits.OERR = 0;
//    }
//
//    // If there was an overun error clear it and continue
//    if (IFS4bits.U2EIF == 1) {
//        IFS4bits.U2EIF = 0; // Clear the UART2 Error Interrupt Flag
//    }
//}

// char sendQGCDebugMessage(const char * dbgMessage, char severity, unsigned char* bytesToAdd, char positionStart) {
    // mavlink_message_t msg;
    // unsigned char bytes2Send = 0; // size in bytes of the mavlink packed message (return value)

    // mavlink_msg_statustext_pack(SLUGS_SYSTEMID,
        // SLUGS_COMPID,
        // &msg,
        // severity,
        // dbgMessage);

    // bytes2Send = mavlink_msg_to_send_buffer((bytesToAdd + positionStart), &msg);

    // return bytes2Send;
// }

// TODO: This probably needs to move to another file since, strictly speaking it has nothing
//				to do with Mavlink comms.

uint8_t clearWaypointsFrom(uint8_t startingWp) {

    uint8_t writeSuccess = 0;
    uint8_t indx, indexOffset;
    tFloatToChar tempFloat;

    // erase the flash values in EEPROM emulation
//    for (indx = startingWp; indx < MAX_NUM_WPS - 1; indx++) {
//        // Compute the adecuate index offset
//        indexOffset = indx * 8;
//
//        // Clear the data from the EEPROM
//        tempFloat.flData = 0.0;
//        writeSuccess += DataEEWrite(tempFloat.shData[0], WPS_OFFSET + indexOffset);
//        writeSuccess += DataEEWrite(tempFloat.shData[1], WPS_OFFSET + indexOffset + 1);
//
//        tempFloat.flData = 0.0;
//        writeSuccess += DataEEWrite(tempFloat.shData[0], WPS_OFFSET + indexOffset + 2);
//        writeSuccess += DataEEWrite(tempFloat.shData[1], WPS_OFFSET + indexOffset + 3);
//
//        tempFloat.flData = 0.0;
//        writeSuccess += DataEEWrite(tempFloat.shData[0], WPS_OFFSET + indexOffset + 4);
//        writeSuccess += DataEEWrite(tempFloat.shData[1], WPS_OFFSET + indexOffset + 5);
//
//
//        writeSuccess += DataEEWrite((unsigned short) 0, WPS_OFFSET + indexOffset + 6);
//
//        writeSuccess += DataEEWrite((unsigned short) 0, WPS_OFFSET + indexOffset + 7);
//    }

    return writeSuccess;
}
    a0b6:	00 40 eb    	clr.b     w0
    a0b8:	00 00 06    	return    

0000a0ba <_addMessageToSpiOut>:

void addMessageToSpiOut(mavlink_message_t* msg) {
    a0ba:	88 9f be    	mov.d     w8, [w15++]
    a0bc:	80 00 78    	mov.w     w0, w1

0000a0be <.L0>:
    // mlPending.spiCurrentIndex = 0;

    mlPending.spiTotalData += mavlink_msg_to_send_buffer(&(mlPending.spiToSensor[mlPending.spiTotalData]), msg);
    a0be:	e9 51 22    	mov.w     #0x251e, w9
    a0c0:	19 44 78    	mov.b     [w9], w8
    a0c2:	08 81 fb    	ze        w8, w2
    a0c4:	20 f9 2f    	mov.w     #0xff92, w0
    a0c6:	09 00 40    	add.w     w0, w9, w0
    a0c8:	00 00 41    	add.w     w2, w0, w0
    a0ca:	13 fd 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a0cc:	80 4c 44    	add.b     w8, w0, [w9]

0000a0ce <.L0>:

}
    a0ce:	4f 04 be    	mov.d     [--w15], w8
    a0d0:	00 00 06    	return    

0000a0d2 <_sendTelemetryMavlink>:
    a0d2:	42 01 fa    	lnk       #0x142
    a0d4:	88 9f be    	mov.d     w8, [w15++]
    a0d6:	8a 9f be    	mov.d     w10, [w15++]
    a0d8:	8c 1f 78    	mov.w     w12, [w15++]
    a0da:	00 06 78    	mov.w     w0, w12
    a0dc:	0f 00 78    	mov.w     w15, w0
    a0de:	c0 14 b1    	sub.w     #0x14c, w0
    a0e0:	87 00 09    	.pword 0x090087
    a0e2:	00 18 eb    	clr.w     [w0++]
    a0e4:	20 4a 24    	mov.w     #0x44a2, w0
    a0e6:	10 80 fb    	ze        [w0], w0
    a0e8:	80 00 eb    	clr.w     w1
    a0ea:	61 00 50    	sub.w     w0, #0x1, w0
    a0ec:	e0 80 58    	subb.w    w1, #0x0, w1
    a0ee:	00 44 eb    	clr.b     w8
    a0f0:	e9 0f 50    	sub.w     w0, #0x9, [w15]
    a0f2:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    a0f4:	7c 04 3e    	bra       GTU, 0xa9ee <.L0> <.L90>
    a0f6:	00 06 01    	.pword 0x010600
    a0f8:	09 00 37    	bra       0xa10c <.L0> <.L91>
    a0fa:	58 00 37    	bra       0xa1ac <.L0> <.L92>
    a0fc:	85 00 37    	bra       0xa208 <.L0> <.L93>
    a0fe:	d3 00 37    	bra       0xa2a6 <.L0> <.L94>
    a100:	00 01 37    	bra       0xa302 <.L0> <.L95>
    a102:	8c 01 37    	bra       0xa41c <.L0> <.L96>
    a104:	b9 01 37    	bra       0xa478 <.L0> <.L97>
    a106:	f5 01 37    	bra       0xa4f2 <.L98>
    a108:	d5 03 37    	bra       0xa8b4 <.L0> <.L99>
    a10a:	44 04 37    	bra       0xa994 <.L0> <.L100>

0000a10c <.L0>:
    a10c:	80 1f eb    	clr.w     [w15++]
    a10e:	74 10 f8    	push      0x1074
    a110:	72 10 f8    	push      0x1072
    a112:	80 1f eb    	clr.w     [w15++]
    a114:	6e 10 f8    	push      0x106e
    a116:	52 83 80    	mov.w     0x106a, w2
    a118:	63 83 80    	mov.w     0x106c, w3
    a11a:	82 9f be    	mov.d     w2, [w15++]
    a11c:	34 83 80    	mov.w     0x1066, w4
    a11e:	45 83 80    	mov.w     0x1068, w5
    a120:	84 9f be    	mov.d     w4, [w15++]
    a122:	10 83 80    	mov.w     0x1062, w0
    a124:	21 83 80    	mov.w     0x1064, w1
    a126:	80 9f be    	mov.d     w0, [w15++]
    a128:	60 07 21    	mov.w     #0x1076, w0
    a12a:	90 41 78    	mov.b     [w0], w3
    a12c:	fc 00 50    	sub.w     w0, #0x1c, w1
    a12e:	31 02 be    	mov.d     [w1++], w4
    a130:	21 03 be    	mov.d     [w1--], w6
    a132:	e2 e9 2f    	mov.w     #0xfe9e, w2
    a134:	0f 01 41    	add.w     w2, w15, w2
    a136:	11 c0 b3    	mov.b     #0x1, w1
    a138:	50 c6 b3    	mov.b     #0x65, w0
    a13a:	50 f9 07    	rcall     0x93dc <_mavlink_msg_gps_raw_int_pack> <L0> <.LFB163> <.LFE87>

0000a13c <.L0>:
    a13c:	0c 00 e8    	inc.w     w12, w0
    a13e:	e1 e9 2f    	mov.w     #0xfe9e, w1
    a140:	8f 80 40    	add.w     w1, w15, w1
    a142:	d7 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a144:	00 44 78    	mov.b     w0, w8

0000a146 <.L0>:
    a146:	0f 01 78    	mov.w     w15, w2
    a148:	22 16 b1    	sub.w     #0x162, w2
    a14a:	87 00 09    	.pword 0x090087
    a14c:	00 19 eb    	clr.w     [w2++]

0000a14e <.L0>:
    a14e:	70 12 21    	mov.w     #0x1127, w0
    a150:	10 40 78    	mov.b     [w0], w0
    a152:	80 1f 78    	mov.w     w0, [w15++]
    a154:	06 89 80    	mov.w     0x1120, w6
    a156:	17 89 80    	mov.w     0x1122, w7
    a158:	60 12 21    	mov.w     #0x1126, w0
    a15a:	90 42 78    	mov.b     [w0], w5
    a15c:	24 c0 b3    	mov.b     #0x2, w4
    a15e:	13 c0 b3    	mov.b     #0x1, w3
    a160:	c2 e9 2f    	mov.w     #0xfe9c, w2
    a162:	0f 01 41    	add.w     w2, w15, w2
    a164:	83 40 78    	mov.b     w3, w1
    a166:	50 c6 b3    	mov.b     #0x65, w0
    a168:	d1 fc 07    	rcall     0x9b0c <_mavlink_msg_heartbeat_pack> <L0> <.LFB51> <.LFE14>

0000a16a <.L0>:
    a16a:	08 80 fb    	ze        w8, w0
    a16c:	00 00 e8    	inc.w     w0, w0
    a16e:	00 00 46    	add.w     w12, w0, w0
    a170:	c1 e9 2f    	mov.w     #0xfe9c, w1
    a172:	8f 80 40    	add.w     w1, w15, w1
    a174:	be fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a176:	00 44 44    	add.b     w8, w0, w8

0000a178 <.L0>:
    a178:	f8 87 57    	sub.w     w15, #0x18, w15
    a17a:	80 49 22    	mov.w     #0x2498, w0
    a17c:	13 c0 b3    	mov.b     #0x1, w3
    a17e:	90 cf 11    	subr.b    w3, [w0], [w15]
    a180:	36 04 3a    	bra       NZ, 0xa9ee <.L0> <.L90>
    a182:	0f 02 78    	mov.w     w15, w4
    a184:	c4 14 b1    	sub.w     #0x14c, w4
    a186:	87 00 09    	.pword 0x090087
    a188:	00 1a eb    	clr.w     [w4++]

0000a18a <.L0>:
    a18a:	34 11 82    	mov.w     0x4226, w4
    a18c:	f3 c7 b3    	mov.b     #0x7f, w3
    a18e:	42 eb 2f    	mov.w     #0xfeb4, w2
    a190:	0f 01 41    	add.w     w2, w15, w2
    a192:	11 c0 b3    	mov.b     #0x1, w1
    a194:	50 c6 b3    	mov.b     #0x65, w0
    a196:	d9 fc 07    	rcall     0x9b4a <_mavlink_msg_ctrl_srfc_pt_pack> <L0> <.LFB1343> <.LFE51>

0000a198 <.L0>:
    a198:	08 80 fb    	ze        w8, w0
    a19a:	00 00 e8    	inc.w     w0, w0
    a19c:	00 00 46    	add.w     w12, w0, w0
    a19e:	41 eb 2f    	mov.w     #0xfeb4, w1
    a1a0:	8f 80 40    	add.w     w1, w15, w1
    a1a2:	a7 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a1a4:	00 44 44    	add.b     w8, w0, w8

0000a1a6 <.L0>:
    a1a6:	80 49 22    	mov.w     #0x2498, w0
    a1a8:	00 48 eb    	clr.b     [w0]
    a1aa:	21 04 37    	bra       0xa9ee <.L0> <.L90>

0000a1ac <.L0>:
    a1ac:	43 1a 24    	mov.w     #0x41a4, w3
    a1ae:	42 eb 2f    	mov.w     #0xfeb4, w2
    a1b0:	0f 01 41    	add.w     w2, w15, w2
    a1b2:	11 c0 b3    	mov.b     #0x1, w1
    a1b4:	50 c6 b3    	mov.b     #0x65, w0
    a1b6:	56 fc 07    	rcall     0x9a64 <_mavlink_msg_gps_date_time_encode> <L0> <.L0> <.LFB1319> <.LFE1317>

0000a1b8 <.L0>:
    a1b8:	0c 00 e8    	inc.w     w12, w0
    a1ba:	41 eb 2f    	mov.w     #0xfeb4, w1
    a1bc:	8f 80 40    	add.w     w1, w15, w1
    a1be:	99 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a1c0:	00 44 78    	mov.b     w0, w8

0000a1c2 <.L0>:
    a1c2:	8f 02 78    	mov.w     w15, w5
    a1c4:	c5 14 b1    	sub.w     #0x14c, w5
    a1c6:	87 00 09    	.pword 0x090087
    a1c8:	80 1a eb    	clr.w     [w5++]

0000a1ca <.L0>:
    a1ca:	83 17 24    	mov.w     #0x4178, w3
    a1cc:	42 eb 2f    	mov.w     #0xfeb4, w2
    a1ce:	0f 01 41    	add.w     w2, w15, w2
    a1d0:	11 c0 b3    	mov.b     #0x1, w1
    a1d2:	50 c6 b3    	mov.b     #0x65, w0
    a1d4:	90 fb 07    	rcall     0x98f6 <_mavlink_msg_diagnostic_encode> <L0> <.LFB1282> <.LFE1280>

0000a1d6 <.L0>:
    a1d6:	08 80 fb    	ze        w8, w0
    a1d8:	00 00 e8    	inc.w     w0, w0
    a1da:	00 00 46    	add.w     w12, w0, w0
    a1dc:	41 eb 2f    	mov.w     #0xfeb4, w1
    a1de:	8f 80 40    	add.w     w1, w15, w1
    a1e0:	88 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a1e2:	00 44 44    	add.b     w8, w0, w8

0000a1e4 <.L0>:
    a1e4:	0f 00 78    	mov.w     w15, w0
    a1e6:	c0 14 b1    	sub.w     #0x14c, w0
    a1e8:	87 00 09    	.pword 0x090087
    a1ea:	00 18 eb    	clr.w     [w0++]

0000a1ec <.L0>:
    a1ec:	83 07 21    	mov.w     #0x1078, w3
    a1ee:	42 eb 2f    	mov.w     #0xfeb4, w2
    a1f0:	0f 01 41    	add.w     w2, w15, w2
    a1f2:	11 c0 b3    	mov.b     #0x1, w1
    a1f4:	50 c6 b3    	mov.b     #0x65, w0
    a1f6:	d9 f9 07    	rcall     0x95aa <_mavlink_msg_scaled_pressure_encode> <L0> <.LFB231> <.LFE229>

0000a1f8 <.L0>:
    a1f8:	08 80 fb    	ze        w8, w0
    a1fa:	00 00 e8    	inc.w     w0, w0
    a1fc:	00 00 46    	add.w     w12, w0, w0
    a1fe:	41 eb 2f    	mov.w     #0xfeb4, w1
    a200:	8f 80 40    	add.w     w1, w15, w1
    a202:	77 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a204:	00 44 44    	add.b     w8, w0, w8

0000a206 <.L0>:
    a206:	f3 03 37    	bra       0xa9ee <.L0> <.L90>

0000a208 <.L0>:
    a208:	e3 20 24    	mov.w     #0x420e, w3
    a20a:	42 eb 2f    	mov.w     #0xfeb4, w2
    a20c:	0f 01 41    	add.w     w2, w15, w2
    a20e:	11 c0 b3    	mov.b     #0x1, w1
    a210:	50 c6 b3    	mov.b     #0x65, w0
    a212:	f1 fb 07    	rcall     0x99f6 <_mavlink_msg_data_log_encode> <L0> <.L0> <.LFB1308> <.LFE1306>

0000a214 <.L0>:
    a214:	0c 00 e8    	inc.w     w12, w0
    a216:	41 eb 2f    	mov.w     #0xfeb4, w1
    a218:	8f 80 40    	add.w     w1, w15, w1
    a21a:	6b fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a21c:	00 44 78    	mov.b     w0, w8

0000a21e <.L0>:
    a21e:	60 49 22    	mov.w     #0x2496, w0
    a220:	11 c0 b3    	mov.b     #0x1, w1
    a222:	90 cf 10    	subr.b    w1, [w0], [w15]
    a224:	1b 00 3a    	bra       NZ, 0xa25c <.L0> <.L102>
    a226:	0f 01 78    	mov.w     w15, w2
    a228:	c2 14 b1    	sub.w     #0x14c, w2
    a22a:	87 00 09    	.pword 0x090087
    a22c:	00 19 eb    	clr.w     [w2++]

0000a22e <.L0>:
    a22e:	c0 09 21    	mov.w     #0x109c, w0
    a230:	10 40 78    	mov.b     [w0], w0
    a232:	80 1f 78    	mov.w     w0, [w15++]
    a234:	50 06 20    	mov.w     #0x65, w0
    a236:	01 00 20    	mov.w     #0x0, w1
    a238:	80 9f be    	mov.d     w0, [w15++]
    a23a:	13 c0 b3    	mov.b     #0x1, w3
    a23c:	00 27 24    	mov.w     #0x4270, w0
    a23e:	10 02 be    	mov.d     [w0], w4
    a240:	60 33 b8    	mul.uu    w6, #0x0, w6
    a242:	e2 ea 2f    	mov.w     #0xfeae, w2
    a244:	0f 01 41    	add.w     w2, w15, w2
    a246:	83 40 78    	mov.b     w3, w1
    a248:	50 c6 b3    	mov.b     #0x65, w0
    a24a:	ab f8 07    	rcall     0x93a2 <_mavlink_msg_ping_pack> <L0> <.LFB87> <.LFE13>

0000a24c <.L0>:
    a24c:	08 80 fb    	ze        w8, w0
    a24e:	00 00 e8    	inc.w     w0, w0
    a250:	00 00 46    	add.w     w12, w0, w0
    a252:	e1 ea 2f    	mov.w     #0xfeae, w1
    a254:	8f 80 40    	add.w     w1, w15, w1
    a256:	4d fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a258:	00 44 44    	add.b     w8, w0, w8
    a25a:	e6 87 57    	sub.w     w15, #0x6, w15

0000a25c <.L0>:
    a25c:	8f 01 78    	mov.w     w15, w3
    a25e:	c3 14 b1    	sub.w     #0x14c, w3
    a260:	87 00 09    	.pword 0x090087
    a262:	80 19 eb    	clr.w     [w3++]

0000a264 <.L0>:
    a264:	90 83 80    	mov.w     0x1072, w0
    a266:	80 00 eb    	clr.w     w1
    a268:	12 19 02    	call      0x1912 <___floatunsisf>
    a26a:	00 00 00 

0000a26c <.L0>:
    a26c:	a2 70 2d    	mov.w     #0xd70a, w2
    a26e:	33 c2 23    	mov.w     #0x3c23, w3
    a270:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    a272:	00 00 00 
    a274:	d4 87 80    	mov.w     0x10fa, w4
    a276:	e5 87 80    	mov.w     0x10fc, w5
    a278:	84 9f be    	mov.d     w4, [w15++]
    a27a:	72 87 80    	mov.w     0x10ee, w2
    a27c:	83 87 80    	mov.w     0x10f0, w3
    a27e:	82 9f be    	mov.d     w2, [w15++]
    a280:	80 1f eb    	clr.w     [w15++]
    a282:	80 01 eb    	clr.w     w3
    a284:	00 03 be    	mov.d     w0, w6
    a286:	d4 91 80    	mov.w     0x123a, w4
    a288:	e5 91 80    	mov.w     0x123c, w5
    a28a:	a2 ea 2f    	mov.w     #0xfeaa, w2
    a28c:	0f 01 41    	add.w     w2, w15, w2
    a28e:	11 c0 b3    	mov.b     #0x1, w1
    a290:	50 c6 b3    	mov.b     #0x65, w0
    a292:	9d fa 07    	rcall     0x97ce <_mavlink_msg_vfr_hud_pack> <L0> <.LFB690> <.LFE423>

0000a294 <.L0>:
    a294:	08 80 fb    	ze        w8, w0
    a296:	00 00 e8    	inc.w     w0, w0
    a298:	00 00 46    	add.w     w12, w0, w0
    a29a:	a1 ea 2f    	mov.w     #0xfeaa, w1
    a29c:	8f 80 40    	add.w     w1, w15, w1
    a29e:	29 fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a2a0:	00 44 44    	add.b     w8, w0, w8

0000a2a2 <.L0>:
    a2a2:	ea 87 57    	sub.w     w15, #0xa, w15
    a2a4:	a4 03 37    	bra       0xa9ee <.L0> <.L90>

0000a2a6 <.L0>:
    a2a6:	a3 23 21    	mov.w     #0x123a, w3
    a2a8:	42 eb 2f    	mov.w     #0xfeb4, w2
    a2aa:	0f 01 41    	add.w     w2, w15, w2
    a2ac:	11 c0 b3    	mov.b     #0x1, w1
    a2ae:	50 c6 b3    	mov.b     #0x65, w0
    a2b0:	61 fb 07    	rcall     0x9974 <_mavlink_msg_slugs_navigation_encode> <L0> <.LFB1293> <.LFE1291>

0000a2b2 <.L0>:
    a2b2:	0c 00 e8    	inc.w     w12, w0
    a2b4:	41 eb 2f    	mov.w     #0xfeb4, w1
    a2b6:	8f 80 40    	add.w     w1, w15, w1
    a2b8:	1c fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a2ba:	00 44 78    	mov.b     w0, w8

0000a2bc <.L0>:
    a2bc:	8f 01 78    	mov.w     w15, w3
    a2be:	c3 14 b1    	sub.w     #0x14c, w3
    a2c0:	87 00 09    	.pword 0x090087
    a2c2:	80 19 eb    	clr.w     [w3++]

0000a2c4 <.L0>:
    a2c4:	c3 15 24    	mov.w     #0x415c, w3
    a2c6:	42 eb 2f    	mov.w     #0xfeb4, w2
    a2c8:	0f 01 41    	add.w     w2, w15, w2
    a2ca:	11 c0 b3    	mov.b     #0x1, w1
    a2cc:	50 c6 b3    	mov.b     #0x65, w0
    a2ce:	b7 fa 07    	rcall     0x983e <_mavlink_msg_cpu_load_encode> <L0> <.L0> <.LFB1263> <.LFE1261>

0000a2d0 <.L0>:
    a2d0:	08 80 fb    	ze        w8, w0
    a2d2:	00 00 e8    	inc.w     w0, w0
    a2d4:	00 00 46    	add.w     w12, w0, w0
    a2d6:	41 eb 2f    	mov.w     #0xfeb4, w1
    a2d8:	8f 80 40    	add.w     w1, w15, w1
    a2da:	0b fc 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a2dc:	00 44 44    	add.b     w8, w0, w8

0000a2de <.L0>:
    a2de:	0f 02 78    	mov.w     w15, w4
    a2e0:	c4 14 b1    	sub.w     #0x14c, w4
    a2e2:	87 00 09    	.pword 0x090087
    a2e4:	00 1a eb    	clr.w     [w4++]

0000a2e6 <.L0>:
    a2e6:	a3 1c 24    	mov.w     #0x41ca, w3
    a2e8:	42 eb 2f    	mov.w     #0xfeb4, w2
    a2ea:	0f 01 41    	add.w     w2, w15, w2
    a2ec:	11 c0 b3    	mov.b     #0x1, w1
    a2ee:	50 c6 b3    	mov.b     #0x65, w0
    a2f0:	57 fc 07    	rcall     0x9ba0 <_mavlink_msg_sensor_diag_encode> <L0> <.LFB1450> <.LFE1448>

0000a2f2 <.L0>:
    a2f2:	08 80 fb    	ze        w8, w0
    a2f4:	00 00 e8    	inc.w     w0, w0
    a2f6:	00 00 46    	add.w     w12, w0, w0
    a2f8:	41 eb 2f    	mov.w     #0xfeb4, w1
    a2fa:	8f 80 40    	add.w     w1, w15, w1
    a2fc:	fa fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a2fe:	00 44 44    	add.b     w8, w0, w8

0000a300 <.L0>:
    a300:	76 03 37    	bra       0xa9ee <.L0> <.L90>

0000a302 <.L0>:
    a302:	c3 09 21    	mov.w     #0x109c, w3
    a304:	42 eb 2f    	mov.w     #0xfeb4, w2
    a306:	0f 01 41    	add.w     w2, w15, w2
    a308:	11 c0 b3    	mov.b     #0x1, w1
    a30a:	50 c6 b3    	mov.b     #0x65, w0
    a30c:	f2 f8 07    	rcall     0x94f2 <_mavlink_msg_raw_imu_encode> <L0> <.LFB206> <.LFE204>

0000a30e <.L0>:
    a30e:	0c 00 e8    	inc.w     w12, w0
    a310:	41 eb 2f    	mov.w     #0xfeb4, w1
    a312:	8f 80 40    	add.w     w1, w15, w1
    a314:	ee fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a316:	00 44 78    	mov.b     w0, w8

0000a318 <.L0>:
    a318:	60 4a 22    	mov.w     #0x24a6, w0
    a31a:	10 04 e0    	cp0.b     [w0]
    a31c:	68 03 32    	bra       Z, 0xa9ee <.L0> <.L90>
    a31e:	00 00 e8    	inc.w     w0, w0
    a320:	10 40 78    	mov.b     [w0], w0
    a322:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    a324:	03 00 32    	bra       Z, 0xa32c <.L103>
    a326:	e2 4f 50    	sub.b     w0, #0x2, [w15]
    a328:	62 03 3a    	bra       NZ, 0xa9ee <.L0> <.L90>
    a32a:	2c 00 37    	bra       0xa384 <.L131>

0000a32c <.L103>:
    a32c:	80 4a 22    	mov.w     #0x24a8, w0
    a32e:	10 40 78    	mov.b     [w0], w0
    a330:	fe 4f 50    	sub.b     w0, #0x1e, [w15]
    a332:	1b 00 3e    	bra       GTU, 0xa36a <.L0> <.L105>
    a334:	00 81 fb    	ze        w0, w2
    a336:	42 10 dd    	sl.w      w2, #0x2, w0
    a338:	a1 25 21    	mov.w     #0x125a, w1
    a33a:	80 80 40    	add.w     w1, w0, w1
    a33c:	44 10 dd    	sl.w      w2, #0x4, w0

0000a33e <.L0>:
    a33e:	82 1f 78    	mov.w     w2, [w15++]
    a340:	f7 01 20    	mov.w     #0x1f, w7
    a342:	96 c0 b3    	mov.b     #0x9, w6
    a344:	11 02 be    	mov.d     [w1], w4
    a346:	63 2d 21    	mov.w     #0x12d6, w3
    a348:	80 81 41    	add.w     w3, w0, w3
    a34a:	22 eb 2f    	mov.w     #0xfeb2, w2
    a34c:	0f 01 41    	add.w     w2, w15, w2
    a34e:	11 c0 b3    	mov.b     #0x1, w1
    a350:	50 c6 b3    	mov.b     #0x65, w0
    a352:	f1 fd 07    	rcall     0x9f36 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE20>

0000a354 <.L0>:
    a354:	80 4a 22    	mov.w     #0x24a8, w0
    a356:	10 48 e8    	inc.b     [w0], [w0]

0000a358 <.L0>:
    a358:	08 80 fb    	ze        w8, w0
    a35a:	00 00 e8    	inc.w     w0, w0
    a35c:	00 00 46    	add.w     w12, w0, w0
    a35e:	21 eb 2f    	mov.w     #0xfeb2, w1
    a360:	8f 80 40    	add.w     w1, w15, w1
    a362:	c7 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a364:	00 44 44    	add.b     w8, w0, w8
    a366:	8f 87 e9    	dec2.w    w15, w15
    a368:	42 03 37    	bra       0xa9ee <.L0> <.L90>

0000a36a <.L0>:
    a36a:	00 40 eb    	clr.b     w0
    a36c:	71 4a 22    	mov.w     #0x24a7, w1
    a36e:	80 48 78    	mov.b     w0, [w1]
    a370:	f2 c1 b3    	mov.b     #0x1f, w2
    a372:	81 00 e8    	inc.w     w1, w1
    a374:	82 48 78    	mov.b     w2, [w1]
    a376:	81 80 e9    	dec2.w    w1, w1
    a378:	80 48 78    	mov.b     w0, [w1]
    a37a:	e3 80 40    	add.w     w1, #0x3, w1
    a37c:	80 48 78    	mov.b     w0, [w1]
    a37e:	66 80 40    	add.w     w1, #0x6, w0
    a380:	00 c8 eb    	setm.b    [w0]
    a382:	35 03 37    	bra       0xa9ee <.L0> <.L90>

0000a384 <.L131>:
    a384:	90 4a 22    	mov.w     #0x24a9, w0
    a386:	10 04 e0    	cp0.b     [w0]
    a388:	21 00 3a    	bra       NZ, 0xa3cc <.L106>
    a38a:	80 04 e9    	dec.w     w0, w9
    a38c:	19 81 fb    	ze        [w9], w2
    a38e:	42 10 dd    	sl.w      w2, #0x2, w0
    a390:	a1 25 21    	mov.w     #0x125a, w1
    a392:	80 80 40    	add.w     w1, w0, w1
    a394:	44 10 dd    	sl.w      w2, #0x4, w0

0000a396 <.L0>:
    a396:	82 1f 78    	mov.w     w2, [w15++]
    a398:	f7 01 20    	mov.w     #0x1f, w7
    a39a:	96 c0 b3    	mov.b     #0x9, w6
    a39c:	11 02 be    	mov.d     [w1], w4
    a39e:	63 2d 21    	mov.w     #0x12d6, w3
    a3a0:	80 81 41    	add.w     w3, w0, w3
    a3a2:	22 eb 2f    	mov.w     #0xfeb2, w2
    a3a4:	0f 01 41    	add.w     w2, w15, w2
    a3a6:	11 c0 b3    	mov.b     #0x1, w1
    a3a8:	50 c6 b3    	mov.b     #0x65, w0
    a3aa:	c5 fd 07    	rcall     0x9f36 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE20>

0000a3ac <.L0>:
    a3ac:	08 80 fb    	ze        w8, w0
    a3ae:	00 00 e8    	inc.w     w0, w0
    a3b0:	00 00 46    	add.w     w12, w0, w0
    a3b2:	21 eb 2f    	mov.w     #0xfeb2, w1
    a3b4:	8f 80 40    	add.w     w1, w15, w1
    a3b6:	9d fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a3b8:	00 44 44    	add.b     w8, w0, w8

0000a3ba <.L0>:
    a3ba:	f0 c1 b3    	mov.b     #0x1f, w0
    a3bc:	80 4c 78    	mov.b     w0, [w9]
    a3be:	00 40 eb    	clr.b     w0
    a3c0:	89 00 e9    	dec.w     w9, w1
    a3c2:	80 48 78    	mov.b     w0, [w1]
    a3c4:	81 00 e9    	dec.w     w1, w1
    a3c6:	80 48 78    	mov.b     w0, [w1]
    a3c8:	8f 87 e9    	dec2.w    w15, w15
    a3ca:	11 03 37    	bra       0xa9ee <.L0> <.L90>

0000a3cc <.L106>:
    a3cc:	f0 4a 22    	mov.w     #0x24af, w0
    a3ce:	10 40 78    	mov.b     [w0], w0
    a3d0:	00 04 e0    	cp0.b     w0
    a3d2:	06 00 3d    	bra       GE, 0xa3e0 <.L107>
    a3d4:	11 c0 b3    	mov.b     #0x1, w1
    a3d6:	70 4a 22    	mov.w     #0x24a7, w0
    a3d8:	01 48 78    	mov.b     w1, [w0]
    a3da:	00 80 e8    	inc2.w    w0, w0
    a3dc:	00 48 eb    	clr.b     [w0]
    a3de:	07 03 37    	bra       0xa9ee <.L0> <.L90>

0000a3e0 <.L107>:
    a3e0:	00 00 fb    	se        w0, w0
    a3e2:	a1 4a 22    	mov.w     #0x24aa, w1
    a3e4:	01 00 40    	add.w     w0, w1, w0
    a3e6:	10 81 fb    	ze        [w0], w2
    a3e8:	42 10 dd    	sl.w      w2, #0x2, w0
    a3ea:	a1 25 21    	mov.w     #0x125a, w1
    a3ec:	80 80 40    	add.w     w1, w0, w1
    a3ee:	44 10 dd    	sl.w      w2, #0x4, w0

0000a3f0 <.L0>:
    a3f0:	82 1f 78    	mov.w     w2, [w15++]
    a3f2:	f7 01 20    	mov.w     #0x1f, w7
    a3f4:	96 c0 b3    	mov.b     #0x9, w6
    a3f6:	11 02 be    	mov.d     [w1], w4
    a3f8:	63 2d 21    	mov.w     #0x12d6, w3
    a3fa:	80 81 41    	add.w     w3, w0, w3
    a3fc:	22 eb 2f    	mov.w     #0xfeb2, w2
    a3fe:	0f 01 41    	add.w     w2, w15, w2
    a400:	11 c0 b3    	mov.b     #0x1, w1
    a402:	50 c6 b3    	mov.b     #0x65, w0
    a404:	98 fd 07    	rcall     0x9f36 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE20>

0000a406 <.L0>:
    a406:	08 80 fb    	ze        w8, w0
    a408:	00 00 e8    	inc.w     w0, w0
    a40a:	00 00 46    	add.w     w12, w0, w0
    a40c:	21 eb 2f    	mov.w     #0xfeb2, w1
    a40e:	8f 80 40    	add.w     w1, w15, w1
    a410:	70 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a412:	00 44 44    	add.b     w8, w0, w8

0000a414 <.L0>:
    a414:	f0 4a 22    	mov.w     #0x24af, w0
    a416:	10 48 e9    	dec.b     [w0], [w0]
    a418:	8f 87 e9    	dec2.w    w15, w15
    a41a:	e9 02 37    	bra       0xa9ee <.L0> <.L90>

0000a41c <.L0>:
    a41c:	23 0e 21    	mov.w     #0x10e2, w3
    a41e:	42 eb 2f    	mov.w     #0xfeb4, w2
    a420:	0f 01 41    	add.w     w2, w15, w2
    a422:	11 c0 b3    	mov.b     #0x1, w1
    a424:	50 c6 b3    	mov.b     #0x65, w0
    a426:	35 f9 07    	rcall     0x9692 <_mavlink_msg_local_position_ned_encode> <L0> <.L0> <.LFB265> <.LFE263>

0000a428 <.L0>:
    a428:	0c 00 e8    	inc.w     w12, w0
    a42a:	41 eb 2f    	mov.w     #0xfeb4, w1
    a42c:	8f 80 40    	add.w     w1, w15, w1
    a42e:	61 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a430:	00 44 78    	mov.b     w0, w8

0000a432 <.L0>:
    a432:	8f 02 78    	mov.w     w15, w5
    a434:	c5 14 b1    	sub.w     #0x14c, w5
    a436:	87 00 09    	.pword 0x090087
    a438:	80 1a eb    	clr.w     [w5++]

0000a43a <.L0>:
    a43a:	63 27 24    	mov.w     #0x4276, w3
    a43c:	42 eb 2f    	mov.w     #0xfeb4, w2
    a43e:	0f 01 41    	add.w     w2, w15, w2
    a440:	11 c0 b3    	mov.b     #0x1, w1
    a442:	50 c6 b3    	mov.b     #0x65, w0
    a444:	e6 fb 07    	rcall     0x9c12 <_mavlink_msg_sys_status_encode> <L0> <.LFB64> <.LFE62>

0000a446 <.L0>:
    a446:	08 80 fb    	ze        w8, w0
    a448:	00 00 e8    	inc.w     w0, w0
    a44a:	00 00 46    	add.w     w12, w0, w0
    a44c:	41 eb 2f    	mov.w     #0xfeb4, w1
    a44e:	8f 80 40    	add.w     w1, w15, w1
    a450:	50 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a452:	00 44 44    	add.b     w8, w0, w8

0000a454 <.L0>:
    a454:	0f 00 78    	mov.w     w15, w0
    a456:	c0 14 b1    	sub.w     #0x14c, w0
    a458:	87 00 09    	.pword 0x090087
    a45a:	00 18 eb    	clr.w     [w0++]

0000a45c <.L0>:
    a45c:	03 1b 24    	mov.w     #0x41b0, w3
    a45e:	42 eb 2f    	mov.w     #0xfeb4, w2
    a460:	0f 01 41    	add.w     w2, w15, w2
    a462:	11 c0 b3    	mov.b     #0x1, w1
    a464:	50 c6 b3    	mov.b     #0x65, w0
    a466:	12 fc 07    	rcall     0x9c8c <_mavlink_msg_status_gps_encode> <L0> <.L0> <.LFB1426> <.LFE1424>

0000a468 <.L0>:
    a468:	08 80 fb    	ze        w8, w0
    a46a:	00 00 e8    	inc.w     w0, w0
    a46c:	00 00 46    	add.w     w12, w0, w0
    a46e:	41 eb 2f    	mov.w     #0xfeb4, w1
    a470:	8f 80 40    	add.w     w1, w15, w1
    a472:	3f fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a474:	00 44 44    	add.b     w8, w0, w8

0000a476 <.L0>:
    a476:	bb 02 37    	bra       0xa9ee <.L0> <.L90>

0000a478 <.L0>:
    a478:	a3 10 21    	mov.w     #0x110a, w3
    a47a:	42 eb 2f    	mov.w     #0xfeb4, w2
    a47c:	0f 01 41    	add.w     w2, w15, w2
    a47e:	11 c0 b3    	mov.b     #0x1, w1
    a480:	50 c6 b3    	mov.b     #0x65, w0
    a482:	34 fc 07    	rcall     0x9cec <_mavlink_msg_servo_output_raw_encode> <L0> <.LFB323> <.LFE321>

0000a484 <.L0>:
    a484:	0c 00 e8    	inc.w     w12, w0
    a486:	41 eb 2f    	mov.w     #0xfeb4, w1
    a488:	8f 80 40    	add.w     w1, w15, w1
    a48a:	33 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a48c:	00 44 78    	mov.b     w0, w8

0000a48e <.L0>:
    a48e:	01 c2 b3    	mov.b     #0x20, w1
    a490:	60 12 21    	mov.w     #0x1126, w0
    a492:	10 40 78    	mov.b     [w0], w0
    a494:	6e 10 02    	call      0x1106e <_hasMode>
    a496:	01 00 00 
    a498:	00 04 e0    	cp0.b     w0
    a49a:	03 00 32    	bra       Z, 0xa4a2 <.L0> <.L108>

0000a49c <.L0>:
    a49c:	40 eb 2f    	mov.w     #0xfeb4, w0
    a49e:	0f 00 40    	add.w     w0, w15, w0
    a4a0:	0c fe 07    	rcall     0xa0ba <_addMessageToSpiOut> <L0> <.LFB1472> <.LFE1471>

0000a4a2 <.L0>:
    a4a2:	8f 00 78    	mov.w     w15, w1
    a4a4:	c1 14 b1    	sub.w     #0x14c, w1
    a4a6:	87 00 09    	.pword 0x090087
    a4a8:	80 18 eb    	clr.w     [w1++]

0000a4aa <.L0>:
    a4aa:	03 16 24    	mov.w     #0x4160, w3
    a4ac:	42 eb 2f    	mov.w     #0xfeb4, w2
    a4ae:	0f 01 41    	add.w     w2, w15, w2
    a4b0:	11 c0 b3    	mov.b     #0x1, w1
    a4b2:	50 c6 b3    	mov.b     #0x65, w0
    a4b4:	ef f9 07    	rcall     0x9894 <_mavlink_msg_sensor_bias_encode> <L0> <.L0> <.LFB1271> <.LFE1269>

0000a4b6 <.L0>:
    a4b6:	08 80 fb    	ze        w8, w0
    a4b8:	00 00 e8    	inc.w     w0, w0
    a4ba:	00 00 46    	add.w     w12, w0, w0
    a4bc:	41 eb 2f    	mov.w     #0xfeb4, w1
    a4be:	8f 80 40    	add.w     w1, w15, w1
    a4c0:	18 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a4c2:	00 44 44    	add.b     w8, w0, w8

0000a4c4 <.L0>:
    a4c4:	d0 49 22    	mov.w     #0x249d, w0
    a4c6:	10 04 e0    	cp0.b     [w0]
    a4c8:	92 02 32    	bra       Z, 0xa9ee <.L0> <.L90>
    a4ca:	0f 01 78    	mov.w     w15, w2
    a4cc:	c2 14 b1    	sub.w     #0x14c, w2
    a4ce:	87 00 09    	.pword 0x090087
    a4d0:	00 19 eb    	clr.w     [w2++]

0000a4d2 <.L0>:
    a4d2:	63 24 24    	mov.w     #0x4246, w3
    a4d4:	42 eb 2f    	mov.w     #0xfeb4, w2
    a4d6:	0f 01 41    	add.w     w2, w15, w2
    a4d8:	11 c0 b3    	mov.b     #0x1, w1
    a4da:	50 c6 b3    	mov.b     #0x65, w0
    a4dc:	4f fc 07    	rcall     0x9d7c <_mavlink_msg_command_long_encode> <L0> <.L0> <.LFB703> <.LFE701>

0000a4de <.L0>:
    a4de:	08 80 fb    	ze        w8, w0
    a4e0:	00 00 e8    	inc.w     w0, w0
    a4e2:	00 00 46    	add.w     w12, w0, w0
    a4e4:	41 eb 2f    	mov.w     #0xfeb4, w1
    a4e6:	8f 80 40    	add.w     w1, w15, w1
    a4e8:	04 fb 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a4ea:	00 44 44    	add.b     w8, w0, w8

0000a4ec <.L0>:
    a4ec:	d0 49 22    	mov.w     #0x249d, w0
    a4ee:	00 48 eb    	clr.b     [w0]
    a4f0:	7e 02 37    	bra       0xa9ee <.L0> <.L90>

0000a4f2 <.L98>:
    a4f2:	00 44 eb    	clr.b     w8
    a4f4:	f0 51 22    	mov.w     #0x251f, w0
    a4f6:	10 04 e0    	cp0.b     [w0]
    a4f8:	2f 00 32    	bra       Z, 0xa558 <.L109>

0000a4fa <.L0>:
    a4fa:	e0 8d 80    	mov.w     0x11bc, w0
    a4fc:	f1 8d 80    	mov.w     0x11be, w1
    a4fe:	94 18 02    	call      0x1894 <___fixsfsi>
    a500:	00 00 00 
    a502:	00 04 be    	mov.d     w0, w8
    a504:	c0 8b 80    	mov.w     0x1178, w0
    a506:	d1 8b 80    	mov.w     0x117a, w1
    a508:	94 18 02    	call      0x1894 <___fixsfsi>
    a50a:	00 00 00 
    a50c:	00 05 be    	mov.d     w0, w10
    a50e:	00 90 80    	mov.w     0x1200, w0
    a510:	11 90 80    	mov.w     0x1202, w1
    a512:	94 18 02    	call      0x1894 <___fixsfsi>
    a514:	00 00 00 
    a516:	80 9f be    	mov.d     w0, [w15++]
    a518:	08 03 be    	mov.d     w8, w6
    a51a:	0a 02 be    	mov.d     w10, w4
    a51c:	f3 c7 b3    	mov.b     #0x7f, w3
    a51e:	02 eb 2f    	mov.w     #0xfeb0, w2
    a520:	0f 01 41    	add.w     w2, w15, w2
    a522:	11 c0 b3    	mov.b     #0x1, w1
    a524:	50 c6 b3    	mov.b     #0x65, w0
    a526:	45 fc 07    	rcall     0x9db2 <_mavlink_msg_set_gps_global_origin_pack> <L0> <.LFB431> <.LFE703>

0000a528 <.L0>:
    a528:	00 eb 2f    	mov.w     #0xfeb0, w0
    a52a:	0f 00 40    	add.w     w0, w15, w0
    a52c:	c6 fd 07    	rcall     0xa0ba <_addMessageToSpiOut> <L0> <.LFB1472> <.LFE1471>

0000a52e <.L0>:
    a52e:	8f 01 78    	mov.w     w15, w3
    a530:	03 04 b1    	sub.w     #0x40, w3
    a532:	18 00 09    	.pword 0x090018
    a534:	80 19 eb    	clr.w     [w3++]
    a536:	20 66 2c    	mov.w     #0xc662, w0
    a538:	04 fc 2f    	mov.w     #0xffc0, w4
    a53a:	04 82 47    	add.w     w15, w4, w4
    a53c:	12 00 09    	.pword 0x090012
    a53e:	30 5a 78    	mov.b     [w0++], [w4++]
    a540:	30 01 b1    	sub.w     #0x13, w0

0000a542 <.L0>:
    a542:	13 c0 b3    	mov.b     #0x1, w3
    a544:	0c 01 78    	mov.w     w12, w2
    a546:	80 c0 eb    	setm.b    w1
    a548:	00 fc 2f    	mov.w     #0xffc0, w0
    a54a:	0f 00 40    	add.w     w0, w15, w0
    a54c:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a54e:	00 00 00 
    a550:	00 44 78    	mov.b     w0, w8

0000a552 <.L0>:
    a552:	f0 51 22    	mov.w     #0x251f, w0
    a554:	00 48 eb    	clr.b     [w0]
    a556:	e4 87 57    	sub.w     w15, #0x4, w15

0000a558 <.L109>:
    a558:	c0 16 23    	mov.w     #0x316c, w0
    a55a:	10 40 78    	mov.b     [w0], w0
    a55c:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    a55e:	1f 00 3a    	bra       NZ, 0xa59e <.L110>
    a560:	8f 02 78    	mov.w     w15, w5
    a562:	c5 03 b1    	sub.w     #0x3c, w5
    a564:	18 00 09    	.pword 0x090018
    a566:	80 1a eb    	clr.w     [w5++]

0000a568 <.L0>:
    a568:	00 90 80    	mov.w     0x1200, w0
    a56a:	11 90 80    	mov.w     0x1202, w1
    a56c:	80 9f be    	mov.d     w0, [w15++]
    a56e:	e2 8d 80    	mov.w     0x11bc, w2
    a570:	f3 8d 80    	mov.w     0x11be, w3
    a572:	82 9f be    	mov.d     w2, [w15++]
    a574:	c4 8b 80    	mov.w     0x1178, w4
    a576:	d5 8b 80    	mov.w     0x117a, w5
    a578:	84 9f be    	mov.d     w4, [w15++]
    a57a:	50 67 2c    	mov.w     #0xc675, w0
    a57c:	80 1f 78    	mov.w     w0, [w15++]
    a57e:	60 fb 2f    	mov.w     #0xffb6, w0
    a580:	0f 00 40    	add.w     w0, w15, w0
    a582:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    a584:	00 00 00 

0000a586 <.L0>:
    a586:	88 41 e8    	inc.b     w8, w3
    a588:	0c 01 78    	mov.w     w12, w2
    a58a:	80 40 eb    	clr.b     w1
    a58c:	60 fb 2f    	mov.w     #0xffb6, w0
    a58e:	0f 00 40    	add.w     w0, w15, w0
    a590:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a592:	00 00 00 
    a594:	00 44 44    	add.b     w8, w0, w8

0000a596 <.L0>:
    a596:	c0 16 23    	mov.w     #0x316c, w0
    a598:	00 48 eb    	clr.b     [w0]
    a59a:	ee 87 57    	sub.w     w15, #0xe, w15
    a59c:	35 00 37    	bra       0xa608 <.L111>

0000a59e <.L110>:
    a59e:	e4 4f 50    	sub.b     w0, #0x4, [w15]
    a5a0:	33 00 3a    	bra       NZ, 0xa608 <.L111>
    a5a2:	8f 02 78    	mov.w     w15, w5
    a5a4:	c5 03 b1    	sub.w     #0x3c, w5
    a5a6:	18 00 09    	.pword 0x090018
    a5a8:	80 1a eb    	clr.w     [w5++]

0000a5aa <.L0>:
    a5aa:	60 17 23    	mov.w     #0x3176, w0
    a5ac:	10 00 fb    	se        [w0], w0
    a5ae:	80 1f 78    	mov.w     w0, [w15++]
    a5b0:	50 17 23    	mov.w     #0x3175, w0
    a5b2:	10 00 fb    	se        [w0], w0
    a5b4:	80 1f 78    	mov.w     w0, [w15++]
    a5b6:	40 17 23    	mov.w     #0x3174, w0
    a5b8:	10 00 fb    	se        [w0], w0
    a5ba:	80 1f 78    	mov.w     w0, [w15++]
    a5bc:	30 17 23    	mov.w     #0x3173, w0
    a5be:	10 00 fb    	se        [w0], w0
    a5c0:	80 1f 78    	mov.w     w0, [w15++]
    a5c2:	20 17 23    	mov.w     #0x3172, w0
    a5c4:	10 00 fb    	se        [w0], w0
    a5c6:	80 1f 78    	mov.w     w0, [w15++]
    a5c8:	10 17 23    	mov.w     #0x3171, w0
    a5ca:	10 00 fb    	se        [w0], w0
    a5cc:	80 1f 78    	mov.w     w0, [w15++]
    a5ce:	00 17 23    	mov.w     #0x3170, w0
    a5d0:	10 00 fb    	se        [w0], w0
    a5d2:	80 1f 78    	mov.w     w0, [w15++]
    a5d4:	f0 16 23    	mov.w     #0x316f, w0
    a5d6:	10 00 fb    	se        [w0], w0
    a5d8:	80 1f 78    	mov.w     w0, [w15++]
    a5da:	e0 16 23    	mov.w     #0x316e, w0
    a5dc:	10 00 fb    	se        [w0], w0
    a5de:	80 1f 78    	mov.w     w0, [w15++]
    a5e0:	d0 16 23    	mov.w     #0x316d, w0
    a5e2:	10 00 fb    	se        [w0], w0
    a5e4:	80 1f 78    	mov.w     w0, [w15++]
    a5e6:	90 69 2c    	mov.w     #0xc699, w0
    a5e8:	80 1f 78    	mov.w     w0, [w15++]
    a5ea:	e0 fa 2f    	mov.w     #0xffae, w0
    a5ec:	0f 00 40    	add.w     w0, w15, w0
    a5ee:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    a5f0:	00 00 00 

0000a5f2 <.L0>:
    a5f2:	88 41 e8    	inc.b     w8, w3
    a5f4:	0c 01 78    	mov.w     w12, w2
    a5f6:	80 40 eb    	clr.b     w1
    a5f8:	e0 fa 2f    	mov.w     #0xffae, w0
    a5fa:	0f 00 40    	add.w     w0, w15, w0
    a5fc:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a5fe:	00 00 00 
    a600:	00 44 44    	add.b     w8, w0, w8

0000a602 <.L0>:
    a602:	c0 16 23    	mov.w     #0x316c, w0
    a604:	00 48 eb    	clr.b     [w0]
    a606:	f6 87 57    	sub.w     w15, #0x16, w15

0000a608 <.L111>:
    a608:	f0 49 22    	mov.w     #0x249f, w0
    a60a:	31 c0 b3    	mov.b     #0x3, w1
    a60c:	90 cf 10    	subr.b    w1, [w0], [w15]
    a60e:	30 00 3a    	bra       NZ, 0xa670 <.L0> <.L112>
    a610:	0f 01 78    	mov.w     w15, w2
    a612:	c2 03 b1    	sub.w     #0x3c, w2
    a614:	18 00 09    	.pword 0x090018
    a616:	00 19 eb    	clr.w     [w2++]
    a618:	00 00 e8    	inc.w     w0, w0
    a61a:	10 80 fb    	ze        [w0], w0
    a61c:	c2 0c 20    	mov.w     #0xcc, w2
    a61e:	00 01 41    	add.w     w2, w0, w2
    a620:	81 13 21    	mov.w     #0x1138, w1
    a622:	02 81 40    	add.w     w1, w2, w2
    a624:	12 81 fb    	ze        [w2], w2
    a626:	82 1f 78    	mov.w     w2, [w15++]
    a628:	f2 06 20    	mov.w     #0x6f, w2
    a62a:	00 01 41    	add.w     w2, w0, w2
    a62c:	02 01 41    	add.w     w2, w2, w2
    a62e:	02 81 40    	add.w     w1, w2, w2
    a630:	92 1f 78    	mov.w     [w2], [w15++]
    a632:	22 02 20    	mov.w     #0x22, w2
    a634:	00 01 41    	add.w     w2, w0, w2
    a636:	42 11 dd    	sl.w      w2, #0x2, w2
    a638:	02 81 40    	add.w     w1, w2, w2
    a63a:	12 02 be    	mov.d     [w2], w4
    a63c:	84 9f be    	mov.d     w4, [w15++]
    a63e:	71 01 40    	add.w     w0, #0x11, w2
    a640:	42 11 dd    	sl.w      w2, #0x2, w2
    a642:	02 81 40    	add.w     w1, w2, w2

0000a644 <.L0>:
    a644:	12 02 be    	mov.d     [w2], w4
    a646:	84 9f be    	mov.d     w4, [w15++]
    a648:	42 01 dd    	sl.w      w0, #0x2, w2
    a64a:	82 80 40    	add.w     w1, w2, w1
    a64c:	11 01 be    	mov.d     [w1], w2
    a64e:	82 9f be    	mov.d     w2, [w15++]
    a650:	80 1f 78    	mov.w     w0, [w15++]
    a652:	70 6b 2c    	mov.w     #0xc6b7, w0
    a654:	80 1f 78    	mov.w     w0, [w15++]
    a656:	00 fb 2f    	mov.w     #0xffb0, w0
    a658:	0f 00 40    	add.w     w0, w15, w0
    a65a:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    a65c:	00 00 00 

0000a65e <.L0>:
    a65e:	88 41 e8    	inc.b     w8, w3
    a660:	0c 01 78    	mov.w     w12, w2
    a662:	80 40 eb    	clr.b     w1
    a664:	00 fb 2f    	mov.w     #0xffb0, w0
    a666:	0f 00 40    	add.w     w0, w15, w0
    a668:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a66a:	00 00 00 
    a66c:	00 44 44    	add.b     w8, w0, w8
    a66e:	f4 87 57    	sub.w     w15, #0x14, w15

0000a670 <.L0>:
    a670:	f0 49 22    	mov.w     #0x249f, w0
    a672:	63 c0 b3    	mov.b     #0x6, w3
    a674:	90 cf 11    	subr.b    w3, [w0], [w15]
    a676:	1c 00 3a    	bra       NZ, 0xa6b0 <.L0> <.L113>
    a678:	0f 02 78    	mov.w     w15, w4
    a67a:	c4 03 b1    	sub.w     #0x3c, w4
    a67c:	18 00 09    	.pword 0x090018
    a67e:	00 1a eb    	clr.w     [w4++]

0000a680 <.L0>:
    a680:	20 8d 81    	mov.w     0x31a4, w0
    a682:	31 8d 81    	mov.w     0x31a6, w1
    a684:	80 9f be    	mov.d     w0, [w15++]
    a686:	02 8d 81    	mov.w     0x31a0, w2
    a688:	13 8d 81    	mov.w     0x31a2, w3
    a68a:	82 9f be    	mov.d     w2, [w15++]
    a68c:	f0 19 23    	mov.w     #0x319f, w0
    a68e:	10 00 fb    	se        [w0], w0
    a690:	80 1f 78    	mov.w     w0, [w15++]
    a692:	30 6e 2c    	mov.w     #0xc6e3, w0
    a694:	80 1f 78    	mov.w     w0, [w15++]
    a696:	80 fb 2f    	mov.w     #0xffb8, w0
    a698:	0f 00 40    	add.w     w0, w15, w0
    a69a:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    a69c:	00 00 00 

0000a69e <.L0>:
    a69e:	88 41 e8    	inc.b     w8, w3
    a6a0:	0c 01 78    	mov.w     w12, w2
    a6a2:	80 40 eb    	clr.b     w1
    a6a4:	80 fb 2f    	mov.w     #0xffb8, w0
    a6a6:	0f 00 40    	add.w     w0, w15, w0
    a6a8:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a6aa:	00 00 00 
    a6ac:	00 44 44    	add.b     w8, w0, w8
    a6ae:	ec 87 57    	sub.w     w15, #0xc, w15

0000a6b0 <.L0>:
    a6b0:	30 4a 22    	mov.w     #0x24a3, w0
    a6b2:	10 04 e0    	cp0.b     [w0]
    a6b4:	15 00 32    	bra       Z, 0xa6e0 <.L114>
    a6b6:	8f 01 78    	mov.w     w15, w3
    a6b8:	c3 14 b1    	sub.w     #0x14c, w3
    a6ba:	87 00 09    	.pword 0x090087
    a6bc:	80 19 eb    	clr.w     [w3++]
    a6be:	90 25 21    	mov.w     #0x1259, w0
    a6c0:	90 81 fb    	ze        [w0], w3

0000a6c2 <.L0>:
    a6c2:	83 01 e9    	dec.w     w3, w3
    a6c4:	42 eb 2f    	mov.w     #0xfeb4, w2
    a6c6:	0f 01 41    	add.w     w2, w15, w2
    a6c8:	11 c0 b3    	mov.b     #0x1, w1
    a6ca:	50 c6 b3    	mov.b     #0x65, w0
    a6cc:	49 f8 07    	rcall     0x9760 <_mavlink_msg_mission_current_pack> <L0> <.LFB389> <.LFE373>

0000a6ce <.L0>:
    a6ce:	08 80 fb    	ze        w8, w0
    a6d0:	00 00 e8    	inc.w     w0, w0
    a6d2:	00 00 46    	add.w     w12, w0, w0
    a6d4:	41 eb 2f    	mov.w     #0xfeb4, w1
    a6d6:	8f 80 40    	add.w     w1, w15, w1
    a6d8:	0c fa 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a6da:	00 44 44    	add.b     w8, w0, w8

0000a6dc <.L0>:
    a6dc:	30 4a 22    	mov.w     #0x24a3, w0
    a6de:	00 48 eb    	clr.b     [w0]

0000a6e0 <.L114>:
    a6e0:	0f 02 78    	mov.w     w15, w4
    a6e2:	c4 14 b1    	sub.w     #0x14c, w4
    a6e4:	87 00 09    	.pword 0x090087
    a6e6:	00 1a eb    	clr.w     [w4++]

0000a6e8 <.L0>:
    a6e8:	63 0b 21    	mov.w     #0x10b6, w3
    a6ea:	42 eb 2f    	mov.w     #0xfeb4, w2
    a6ec:	0f 01 41    	add.w     w2, w15, w2
    a6ee:	11 c0 b3    	mov.b     #0x1, w1
    a6f0:	50 c6 b3    	mov.b     #0x65, w0
    a6f2:	33 f7 07    	rcall     0x955a <_mavlink_msg_raw_pressure_encode> <L0> <.LFB221> <.LFE219>

0000a6f4 <.L0>:
    a6f4:	08 80 fb    	ze        w8, w0
    a6f6:	00 00 e8    	inc.w     w0, w0
    a6f8:	00 00 46    	add.w     w12, w0, w0
    a6fa:	41 eb 2f    	mov.w     #0xfeb4, w1
    a6fc:	8f 80 40    	add.w     w1, w15, w1
    a6fe:	f9 f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a700:	00 44 44    	add.b     w8, w0, w8

0000a702 <.L0>:
    a702:	e0 49 22    	mov.w     #0x249e, w0
    a704:	10 04 e0    	cp0.b     [w0]
    a706:	73 01 32    	bra       Z, 0xa9ee <.L0> <.L90>
    a708:	00 00 e8    	inc.w     w0, w0
    a70a:	10 40 78    	mov.b     [w0], w0
    a70c:	e3 4f 50    	sub.b     w0, #0x3, [w15]
    a70e:	60 00 32    	bra       Z, 0xa7d0 <.L117>
    a710:	e6 4f 50    	sub.b     w0, #0x6, [w15]
    a712:	1c 00 32    	bra       Z, 0xa74c <.L118>
    a714:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    a716:	aa 00 3a    	bra       NZ, 0xa86c <.L130>

0000a718 <.L0>:
    a718:	8f 02 78    	mov.w     w15, w5
    a71a:	c5 14 b1    	sub.w     #0x14c, w5
    a71c:	87 00 09    	.pword 0x090087
    a71e:	80 1a eb    	clr.w     [w5++]

0000a720 <.L0>:
    a720:	80 23 21    	mov.w     #0x1238, w0
    a722:	90 82 fb    	ze        [w0], w5
    a724:	00 42 eb    	clr.b     w4
    a726:	f3 c7 b3    	mov.b     #0x7f, w3
    a728:	42 eb 2f    	mov.w     #0xfeb4, w2
    a72a:	0f 01 41    	add.w     w2, w15, w2
    a72c:	e1 cb b3    	mov.b     #0xbe, w1
    a72e:	50 c6 b3    	mov.b     #0x65, w0
    a730:	22 f8 07    	rcall     0x9776 <_mavlink_msg_mission_count_pack> <L0> <.LFB402> <.LFE389>

0000a732 <.L0>:
    a732:	08 80 fb    	ze        w8, w0
    a734:	00 00 e8    	inc.w     w0, w0
    a736:	00 00 46    	add.w     w12, w0, w0
    a738:	41 eb 2f    	mov.w     #0xfeb4, w1
    a73a:	8f 80 40    	add.w     w1, w15, w1
    a73c:	da f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a73e:	00 44 44    	add.b     w8, w0, w8

0000a740 <.L0>:
    a740:	21 c0 b3    	mov.b     #0x2, w1
    a742:	f0 49 22    	mov.w     #0x249f, w0
    a744:	01 48 78    	mov.b     w1, [w0]
    a746:	00 80 e8    	inc2.w    w0, w0
    a748:	00 48 eb    	clr.b     [w0]
    a74a:	87 01 37    	bra       0xaa5a <.L0> <.L119>

0000a74c <.L118>:
    a74c:	00 4a 22    	mov.w     #0x24a0, w0
    a74e:	90 42 78    	mov.b     [w0], w5
    a750:	00 80 e8    	inc2.w    w0, w0
    a752:	90 cf 52    	sub.b     w5, [w0], [w15]
    a754:	19 00 31    	bra       C, 0xa788 <.L120>
    a756:	0f 00 78    	mov.w     w15, w0
    a758:	c0 14 b1    	sub.w     #0x14c, w0
    a75a:	87 00 09    	.pword 0x090087
    a75c:	00 18 eb    	clr.w     [w0++]
    a75e:	00 4a 22    	mov.w     #0x24a0, w0
    a760:	05 48 e8    	inc.b     w5, [w0]

0000a762 <.L0>:
    a762:	85 82 fb    	ze        w5, w5
    a764:	00 42 eb    	clr.b     w4
    a766:	f3 c7 b3    	mov.b     #0x7f, w3
    a768:	42 eb 2f    	mov.w     #0xfeb4, w2
    a76a:	0f 01 41    	add.w     w2, w15, w2
    a76c:	e1 cb b3    	mov.b     #0xbe, w1
    a76e:	50 c6 b3    	mov.b     #0x65, w0
    a770:	e0 f7 07    	rcall     0x9732 <_mavlink_msg_mission_request_pack> <L0> <.LFB373> <.LFE307>

0000a772 <.L0>:
    a772:	08 80 fb    	ze        w8, w0
    a774:	00 00 e8    	inc.w     w0, w0
    a776:	00 00 46    	add.w     w12, w0, w0
    a778:	41 eb 2f    	mov.w     #0xfeb4, w1
    a77a:	8f 80 40    	add.w     w1, w15, w1
    a77c:	ba f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a77e:	00 44 44    	add.b     w8, w0, w8

0000a780 <.L0>:
    a780:	41 c0 b3    	mov.b     #0x4, w1
    a782:	f0 49 22    	mov.w     #0x249f, w0
    a784:	01 48 78    	mov.b     w1, [w0]
    a786:	21 00 37    	bra       0xa7ca <.L121>

0000a788 <.L120>:
    a788:	8f 00 78    	mov.w     w15, w1
    a78a:	c1 14 b1    	sub.w     #0x14c, w1
    a78c:	87 00 09    	.pword 0x090087
    a78e:	80 18 eb    	clr.w     [w1++]

0000a790 <.L0>:
    a790:	80 42 eb    	clr.b     w5
    a792:	05 42 78    	mov.b     w5, w4
    a794:	f3 c7 b3    	mov.b     #0x7f, w3
    a796:	42 eb 2f    	mov.w     #0xfeb4, w2
    a798:	0f 01 41    	add.w     w2, w15, w2
    a79a:	e1 cb b3    	mov.b     #0xbe, w1
    a79c:	50 c6 b3    	mov.b     #0x65, w0
    a79e:	02 f8 07    	rcall     0x97a4 <_mavlink_msg_mission_ack_pack> <L0> <.LFB423> <.LFE402>

0000a7a0 <.L0>:
    a7a0:	08 80 fb    	ze        w8, w0
    a7a2:	00 00 e8    	inc.w     w0, w0
    a7a4:	00 00 46    	add.w     w12, w0, w0
    a7a6:	41 eb 2f    	mov.w     #0xfeb4, w1
    a7a8:	8f 80 40    	add.w     w1, w15, w1
    a7aa:	a3 f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a7ac:	00 44 44    	add.b     w8, w0, w8

0000a7ae <.L0>:
    a7ae:	21 4a 22    	mov.w     #0x24a2, w1
    a7b0:	80 23 21    	mov.w     #0x1238, w0
    a7b2:	11 48 78    	mov.b     [w1], [w0]
    a7b4:	00 40 eb    	clr.b     w0
    a7b6:	64 81 50    	sub.w     w1, #0x4, w2
    a7b8:	00 49 78    	mov.b     w0, [w2]
    a7ba:	02 01 e8    	inc.w     w2, w2
    a7bc:	00 49 78    	mov.b     w0, [w2]
    a7be:	02 01 e8    	inc.w     w2, w2
    a7c0:	00 49 78    	mov.b     w0, [w2]
    a7c2:	80 48 78    	mov.b     w0, [w1]
    a7c4:	11 c0 b3    	mov.b     #0x1, w1
    a7c6:	63 00 41    	add.w     w2, #0x3, w0
    a7c8:	01 48 78    	mov.b     w1, [w0]

0000a7ca <.L121>:
    a7ca:	10 4a 22    	mov.w     #0x24a1, w0
    a7cc:	00 48 eb    	clr.b     [w0]
    a7ce:	45 01 37    	bra       0xaa5a <.L0> <.L119>

0000a7d0 <.L117>:
    a7d0:	0f 01 78    	mov.w     w15, w2
    a7d2:	c2 14 b1    	sub.w     #0x14c, w2
    a7d4:	87 00 09    	.pword 0x090087
    a7d6:	00 19 eb    	clr.w     [w2++]
    a7d8:	c0 49 22    	mov.w     #0x249c, w0
    a7da:	10 48 e8    	inc.b     [w0], [w0]
    a7dc:	61 c0 b3    	mov.b     #0x6, w1
    a7de:	a0 1d 24    	mov.w     #0x41da, w0
    a7e0:	01 48 78    	mov.b     w1, [w0]

0000a7e2 <.L0>:
    a7e2:	92 01 20    	mov.w     #0x19, w2
    a7e4:	21 70 2c    	mov.w     #0xc702, w1
    a7e6:	00 00 e8    	inc.w     w0, w0
    a7e8:	04 24 02    	call      0x2404 <_strncpy>
    a7ea:	00 00 00 

0000a7ec <.L0>:
    a7ec:	00 4a 22    	mov.w     #0x24a0, w0
    a7ee:	10 85 fb    	ze        [w0], w10
    a7f0:	c1 0c 20    	mov.w     #0xcc, w1
    a7f2:	8a 80 40    	add.w     w1, w10, w1
    a7f4:	80 13 21    	mov.w     #0x1138, w0
    a7f6:	81 00 40    	add.w     w0, w1, w1
    a7f8:	91 85 fb    	ze        [w1], w11
    a7fa:	21 02 20    	mov.w     #0x22, w1
    a7fc:	8a 80 40    	add.w     w1, w10, w1
    a7fe:	c2 08 dd    	sl.w      w1, #0x2, w1
    a800:	81 00 40    	add.w     w0, w1, w1
    a802:	11 02 be    	mov.d     [w1], w4
    a804:	84 9f be    	mov.d     w4, [w15++]
    a806:	f1 00 45    	add.w     w10, #0x11, w1
    a808:	c2 08 dd    	sl.w      w1, #0x2, w1
    a80a:	81 00 40    	add.w     w0, w1, w1
    a80c:	11 01 be    	mov.d     [w1], w2
    a80e:	82 9f be    	mov.d     w2, [w15++]
    a810:	c2 50 dd    	sl.w      w10, #0x2, w1
    a812:	81 00 40    	add.w     w0, w1, w1
    a814:	11 02 be    	mov.d     [w1], w4
    a816:	84 9f be    	mov.d     w4, [w15++]
    a818:	60 11 b8    	mul.uu    w2, #0x0, w2
    a81a:	82 9f be    	mov.d     w2, [w15++]
    a81c:	f1 06 20    	mov.w     #0x6f, w1
    a81e:	8a 80 40    	add.w     w1, w10, w1
    a820:	81 80 40    	add.w     w1, w1, w1
    a822:	01 00 40    	add.w     w0, w1, w0

0000a824 <.L0>:
    a824:	10 00 78    	mov.w     [w0], w0
    a826:	80 00 eb    	clr.w     w1
    a828:	12 19 02    	call      0x1912 <___floatunsisf>
    a82a:	00 00 00 
    a82c:	80 9f be    	mov.d     w0, [w15++]
    a82e:	60 22 b8    	mul.uu    w4, #0x0, w4
    a830:	84 9f be    	mov.d     w4, [w15++]
    a832:	84 9f be    	mov.d     w4, [w15++]
    a834:	10 c0 b3    	mov.b     #0x1, w0
    a836:	80 1f 78    	mov.w     w0, [w15++]
    a838:	80 44 eb    	clr.b     w9
    a83a:	89 1f 78    	mov.w     w9, [w15++]
    a83c:	8b 03 78    	mov.w     w11, w7
    a83e:	09 43 78    	mov.b     w9, w6
    a840:	8a 02 78    	mov.w     w10, w5
    a842:	09 42 78    	mov.b     w9, w4
    a844:	f3 c7 b3    	mov.b     #0x7f, w3
    a846:	42 e9 2f    	mov.w     #0xfe94, w2
    a848:	0f 01 41    	add.w     w2, w15, w2
    a84a:	e1 cb b3    	mov.b     #0xbe, w1
    a84c:	50 c6 b3    	mov.b     #0x65, w0
    a84e:	cd fa 07    	rcall     0x9dea <_mavlink_msg_mission_item_pack> <L0> <.LFB354> <.LFE431>

0000a850 <.L0>:
    a850:	0f 02 b1    	sub.w     #0x20, w15
    a852:	08 80 fb    	ze        w8, w0
    a854:	00 00 e8    	inc.w     w0, w0
    a856:	00 00 46    	add.w     w12, w0, w0
    a858:	41 eb 2f    	mov.w     #0xfeb4, w1
    a85a:	8f 80 40    	add.w     w1, w15, w1
    a85c:	4a f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a85e:	00 44 44    	add.b     w8, w0, w8

0000a860 <.L0>:
    a860:	51 c0 b3    	mov.b     #0x5, w1
    a862:	f0 49 22    	mov.w     #0x249f, w0
    a864:	01 48 78    	mov.b     w1, [w0]
    a866:	00 80 e8    	inc2.w    w0, w0
    a868:	09 48 78    	mov.b     w9, [w0]
    a86a:	f7 00 37    	bra       0xaa5a <.L0> <.L119>

0000a86c <.L130>:
    a86c:	11 4a 22    	mov.w     #0x24a1, w1
    a86e:	11 40 e8    	inc.b     [w1], w0
    a870:	80 48 78    	mov.b     w0, [w1]
    a872:	f4 4f 50    	sub.b     w0, #0x14, [w15]
    a874:	bc 00 36    	bra       LEU, 0xa9ee <.L0> <.L90>
    a876:	8f 02 78    	mov.w     w15, w5
    a878:	c5 14 b1    	sub.w     #0x14c, w5
    a87a:	87 00 09    	.pword 0x090087
    a87c:	80 1a eb    	clr.w     [w5++]

0000a87e <.L0>:
    a87e:	15 c0 b3    	mov.b     #0x1, w5
    a880:	00 42 eb    	clr.b     w4
    a882:	f3 c7 b3    	mov.b     #0x7f, w3
    a884:	42 eb 2f    	mov.w     #0xfeb4, w2
    a886:	0f 01 41    	add.w     w2, w15, w2
    a888:	e1 cb b3    	mov.b     #0xbe, w1
    a88a:	50 c6 b3    	mov.b     #0x65, w0
    a88c:	8b f7 07    	rcall     0x97a4 <_mavlink_msg_mission_ack_pack> <L0> <.LFB423> <.LFE402>

0000a88e <.L0>:
    a88e:	08 80 fb    	ze        w8, w0
    a890:	00 00 e8    	inc.w     w0, w0
    a892:	00 00 46    	add.w     w12, w0, w0
    a894:	41 eb 2f    	mov.w     #0xfeb4, w1
    a896:	8f 80 40    	add.w     w1, w15, w1
    a898:	2c f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a89a:	00 44 44    	add.b     w8, w0, w8

0000a89c <.L0>:
    a89c:	00 40 eb    	clr.b     w0
    a89e:	e1 49 22    	mov.w     #0x249e, w1
    a8a0:	80 48 78    	mov.b     w0, [w1]
    a8a2:	81 00 e8    	inc.w     w1, w1
    a8a4:	80 48 78    	mov.b     w0, [w1]
    a8a6:	81 00 e8    	inc.w     w1, w1
    a8a8:	80 48 78    	mov.b     w0, [w1]
    a8aa:	81 00 e8    	inc.w     w1, w1
    a8ac:	80 48 78    	mov.b     w0, [w1]
    a8ae:	81 00 e8    	inc.w     w1, w1
    a8b0:	80 48 78    	mov.b     w0, [w1]
    a8b2:	9d 00 37    	bra       0xa9ee <.L0> <.L90>

0000a8b4 <.L0>:
    a8b4:	63 08 21    	mov.w     #0x1086, w3
    a8b6:	42 eb 2f    	mov.w     #0xfeb4, w2
    a8b8:	0f 01 41    	add.w     w2, w15, w2
    a8ba:	11 c0 b3    	mov.b     #0x1, w1
    a8bc:	50 c6 b3    	mov.b     #0x65, w0
    a8be:	23 f7 07    	rcall     0x9706 <_mavlink_msg_rc_channels_raw_encode> <L0> <.LFB307> <.LFE305>

0000a8c0 <.L0>:
    a8c0:	0c 00 e8    	inc.w     w12, w0
    a8c2:	41 eb 2f    	mov.w     #0xfeb4, w1
    a8c4:	8f 80 40    	add.w     w1, w15, w1
    a8c6:	15 f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a8c8:	00 44 78    	mov.b     w0, w8

0000a8ca <.L0>:
    a8ca:	a0 49 22    	mov.w     #0x249a, w0
    a8cc:	10 04 e0    	cp0.b     [w0]
    a8ce:	0f 00 32    	bra       Z, 0xa8ee <.L122>

0000a8d0 <.L0>:
    a8d0:	63 1d 24    	mov.w     #0x41d6, w3
    a8d2:	42 eb 2f    	mov.w     #0xfeb4, w2
    a8d4:	0f 01 41    	add.w     w2, w15, w2
    a8d6:	11 c0 b3    	mov.b     #0x1, w1
    a8d8:	50 c6 b3    	mov.b     #0x65, w0
    a8da:	d3 fa 07    	rcall     0x9e82 <_mavlink_msg_command_ack_encode> <L0> <.L0> <.LFB719> <.LFE717>

0000a8dc <.L0>:
    a8dc:	08 80 fb    	ze        w8, w0
    a8de:	00 00 e8    	inc.w     w0, w0
    a8e0:	00 00 46    	add.w     w12, w0, w0
    a8e2:	41 eb 2f    	mov.w     #0xfeb4, w1
    a8e4:	8f 80 40    	add.w     w1, w15, w1
    a8e6:	05 f9 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a8e8:	00 44 44    	add.b     w8, w0, w8

0000a8ea <.L0>:
    a8ea:	a0 49 22    	mov.w     #0x249a, w0
    a8ec:	00 48 eb    	clr.b     [w0]

0000a8ee <.L122>:
    a8ee:	70 49 22    	mov.w     #0x2497, w0
    a8f0:	11 c0 b3    	mov.b     #0x1, w1
    a8f2:	90 cf 10    	subr.b    w1, [w0], [w15]
    a8f4:	1a 00 3a    	bra       NZ, 0xa92a <.L123>
    a8f6:	0f 01 78    	mov.w     w15, w2
    a8f8:	c2 14 b1    	sub.w     #0x14c, w2
    a8fa:	87 00 09    	.pword 0x090087
    a8fc:	00 19 eb    	clr.w     [w2++]

0000a8fe <.L0>:
    a8fe:	94 89 80    	mov.w     0x1132, w4
    a900:	a5 89 80    	mov.w     0x1134, w5
    a902:	84 9f be    	mov.d     w4, [w15++]
    a904:	76 89 80    	mov.w     0x112e, w6
    a906:	87 89 80    	mov.w     0x1130, w7
    a908:	54 89 80    	mov.w     0x112a, w4
    a90a:	65 89 80    	mov.w     0x112c, w5
    a90c:	f3 c7 b3    	mov.b     #0x7f, w3
    a90e:	02 eb 2f    	mov.w     #0xfeb0, w2
    a910:	0f 01 41    	add.w     w2, w15, w2
    a912:	50 c6 b3    	mov.b     #0x65, w0
    a914:	ba fa 07    	rcall     0x9e8a <_mavlink_msg_mid_lvl_cmds_pack> <L0> <.LFB1334> <.LFE719>

0000a916 <.L0>:
    a916:	08 80 fb    	ze        w8, w0
    a918:	00 00 e8    	inc.w     w0, w0
    a91a:	00 00 46    	add.w     w12, w0, w0
    a91c:	01 eb 2f    	mov.w     #0xfeb0, w1
    a91e:	8f 80 40    	add.w     w1, w15, w1
    a920:	e8 f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a922:	00 44 44    	add.b     w8, w0, w8

0000a924 <.L0>:
    a924:	70 49 22    	mov.w     #0x2497, w0
    a926:	00 48 eb    	clr.b     [w0]
    a928:	e4 87 57    	sub.w     w15, #0x4, w15

0000a92a <.L123>:
    a92a:	90 49 22    	mov.w     #0x2499, w0
    a92c:	15 c0 b3    	mov.b     #0x1, w5
    a92e:	90 cf 12    	subr.b    w5, [w0], [w15]
    a930:	13 00 3a    	bra       NZ, 0xa958 <.L124>
    a932:	0f 00 78    	mov.w     w15, w0
    a934:	c0 14 b1    	sub.w     #0x14c, w0
    a936:	87 00 09    	.pword 0x090087
    a938:	00 18 eb    	clr.w     [w0++]

0000a93a <.L0>:
    a93a:	03 4d 21    	mov.w     #0x14d0, w3
    a93c:	42 eb 2f    	mov.w     #0xfeb4, w2
    a93e:	0f 01 41    	add.w     w2, w15, w2
    a940:	85 40 78    	mov.b     w5, w1
    a942:	50 c6 b3    	mov.b     #0x65, w0
    a944:	c6 f8 07    	rcall     0x9ad2 <_mavlink_msg_isr_location_encode> <L0> <.L0> <.LFB1387> <.LFE1385>

0000a946 <.L0>:
    a946:	08 80 fb    	ze        w8, w0
    a948:	00 00 e8    	inc.w     w0, w0
    a94a:	00 00 46    	add.w     w12, w0, w0
    a94c:	41 eb 2f    	mov.w     #0xfeb4, w1
    a94e:	8f 80 40    	add.w     w1, w15, w1
    a950:	d0 f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a952:	00 44 44    	add.b     w8, w0, w8

0000a954 <.L0>:
    a954:	90 49 22    	mov.w     #0x2499, w0
    a956:	00 48 eb    	clr.b     [w0]

0000a958 <.L124>:
    a958:	00 0d 82    	mov.w     0x41a0, w0
    a95a:	11 0d 82    	mov.w     0x41a2, w1
    a95c:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    a95e:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    a960:	46 00 3a    	bra       NZ, 0xa9ee <.L0> <.L90>
    a962:	8f 00 78    	mov.w     w15, w1
    a964:	c1 03 b1    	sub.w     #0x3c, w1
    a966:	18 00 09    	.pword 0x090018
    a968:	80 18 eb    	clr.w     [w1++]

0000a96a <.L0>:
    a96a:	40 71 2c    	mov.w     #0xc714, w0
    a96c:	80 1f 78    	mov.w     w0, [w15++]
    a96e:	c0 71 2c    	mov.w     #0xc71c, w0
    a970:	80 1f 78    	mov.w     w0, [w15++]
    a972:	00 fc 2f    	mov.w     #0xffc0, w0
    a974:	0f 00 40    	add.w     w0, w15, w0
    a976:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    a978:	00 00 00 

0000a97a <.L0>:
    a97a:	88 41 e8    	inc.b     w8, w3
    a97c:	0c 01 78    	mov.w     w12, w2
    a97e:	80 c0 eb    	setm.b    w1
    a980:	00 fc 2f    	mov.w     #0xffc0, w0
    a982:	0f 00 40    	add.w     w0, w15, w0
    a984:	a0 d3 02    	call      0xd3a0 <_sendQGCDebugMessage>
    a986:	00 00 00 
    a988:	00 44 44    	add.b     w8, w0, w8

0000a98a <.L0>:
    a98a:	60 00 b8    	mul.uu    w0, #0x0, w0
    a98c:	00 0d 8a    	mov.w     w0, 0x41a0
    a98e:	11 0d 8a    	mov.w     w1, 0x41a2
    a990:	e4 87 57    	sub.w     w15, #0x4, w15
    a992:	2d 00 37    	bra       0xa9ee <.L0> <.L90>

0000a994 <.L0>:
    a994:	a3 18 24    	mov.w     #0x418a, w3
    a996:	42 eb 2f    	mov.w     #0xfeb4, w2
    a998:	0f 01 41    	add.w     w2, w15, w2
    a99a:	11 c0 b3    	mov.b     #0x1, w1
    a99c:	50 c6 b3    	mov.b     #0x65, w0
    a99e:	6e f5 07    	rcall     0x947c <_mavlink_msg_scaled_imu_encode> <L0> <.LFB191> <.LFE189>

0000a9a0 <.L0>:
    a9a0:	0c 00 e8    	inc.w     w12, w0
    a9a2:	41 eb 2f    	mov.w     #0xfeb4, w1
    a9a4:	8f 80 40    	add.w     w1, w15, w1
    a9a6:	a5 f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a9a8:	00 44 78    	mov.b     w0, w8

0000a9aa <.L0>:
    a9aa:	0f 01 78    	mov.w     w15, w2
    a9ac:	c2 14 b1    	sub.w     #0x14c, w2
    a9ae:	87 00 09    	.pword 0x090087
    a9b0:	00 19 eb    	clr.w     [w2++]

0000a9b2 <.L0>:
    a9b2:	43 2a 24    	mov.w     #0x42a4, w3
    a9b4:	42 eb 2f    	mov.w     #0xfeb4, w2
    a9b6:	0f 01 41    	add.w     w2, w15, w2
    a9b8:	11 c0 b3    	mov.b     #0x1, w1
    a9ba:	50 c6 b3    	mov.b     #0x65, w0
    a9bc:	96 fa 07    	rcall     0x9eea <_mavlink_msg_ptz_status_encode> <L0> <.L0> <.LFB1407> <.LFE1405>

0000a9be <.L0>:
    a9be:	08 80 fb    	ze        w8, w0
    a9c0:	00 00 e8    	inc.w     w0, w0
    a9c2:	00 00 46    	add.w     w12, w0, w0
    a9c4:	41 eb 2f    	mov.w     #0xfeb4, w1
    a9c6:	8f 80 40    	add.w     w1, w15, w1
    a9c8:	94 f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a9ca:	00 44 44    	add.b     w8, w0, w8

0000a9cc <.L0>:
    a9cc:	8f 01 78    	mov.w     w15, w3
    a9ce:	c3 14 b1    	sub.w     #0x14c, w3
    a9d0:	87 00 09    	.pword 0x090087
    a9d2:	80 19 eb    	clr.w     [w3++]

0000a9d4 <.L0>:
    a9d4:	03 4e 21    	mov.w     #0x14e0, w3
    a9d6:	42 eb 2f    	mov.w     #0xfeb4, w2
    a9d8:	0f 01 41    	add.w     w2, w15, w2
    a9da:	11 c0 b3    	mov.b     #0x1, w1
    a9dc:	50 c6 b3    	mov.b     #0x65, w0
    a9de:	9e fa 07    	rcall     0x9f1c <_mavlink_msg_volt_sensor_encode> <L0> <.L0> <.LFB1399> <.LFE1397>

0000a9e0 <.L0>:
    a9e0:	08 80 fb    	ze        w8, w0
    a9e2:	00 00 e8    	inc.w     w0, w0
    a9e4:	00 00 46    	add.w     w12, w0, w0
    a9e6:	41 eb 2f    	mov.w     #0xfeb4, w1
    a9e8:	8f 80 40    	add.w     w1, w15, w1
    a9ea:	83 f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    a9ec:	00 44 44    	add.b     w8, w0, w8

0000a9ee <.L0>:
    a9ee:	c0 49 22    	mov.w     #0x249c, w0
    a9f0:	10 04 e0    	cp0.b     [w0]
    a9f2:	15 00 32    	bra       Z, 0xaa1e <.L125>
    a9f4:	0f 02 78    	mov.w     w15, w4
    a9f6:	c4 14 b1    	sub.w     #0x14c, w4
    a9f8:	87 00 09    	.pword 0x090087
    a9fa:	00 1a eb    	clr.w     [w4++]

0000a9fc <.L0>:
    a9fc:	b4 1d 24    	mov.w     #0x41db, w4
    a9fe:	04 00 e9    	dec.w     w4, w0
    aa00:	90 41 78    	mov.b     [w0], w3
    aa02:	42 eb 2f    	mov.w     #0xfeb4, w2
    aa04:	0f 01 41    	add.w     w2, w15, w2
    aa06:	11 c0 b3    	mov.b     #0x1, w1
    aa08:	50 c6 b3    	mov.b     #0x65, w0
    aa0a:	b7 fa 07    	rcall     0x9f7a <_mavlink_msg_statustext_pack> <L0> <.LFB1246> <.LFE143>

0000aa0c <.L0>:
    aa0c:	08 80 fb    	ze        w8, w0
    aa0e:	00 00 e8    	inc.w     w0, w0
    aa10:	00 00 46    	add.w     w12, w0, w0
    aa12:	41 eb 2f    	mov.w     #0xfeb4, w1
    aa14:	8f 80 40    	add.w     w1, w15, w1
    aa16:	6d f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    aa18:	00 44 44    	add.b     w8, w0, w8

0000aa1a <.L0>:
    aa1a:	c0 49 22    	mov.w     #0x249c, w0
    aa1c:	00 48 eb    	clr.b     [w0]

0000aa1e <.L125>:
    aa1e:	8f 02 78    	mov.w     w15, w5
    aa20:	c5 14 b1    	sub.w     #0x14c, w5
    aa22:	87 00 09    	.pword 0x090087
    aa24:	80 1a eb    	clr.w     [w5++]

0000aa26 <.L0>:
    aa26:	a3 22 24    	mov.w     #0x422a, w3
    aa28:	42 eb 2f    	mov.w     #0xfeb4, w2
    aa2a:	0f 01 41    	add.w     w2, w15, w2
    aa2c:	11 c0 b3    	mov.b     #0x1, w1
    aa2e:	50 c6 b3    	mov.b     #0x65, w0
    aa30:	f1 f5 07    	rcall     0x9614 <_mavlink_msg_attitude_encode> <L0> <.L0> <.LFB240> <.LFE238>

0000aa32 <.L0>:
    aa32:	08 80 fb    	ze        w8, w0
    aa34:	00 00 e8    	inc.w     w0, w0
    aa36:	00 00 46    	add.w     w12, w0, w0
    aa38:	41 eb 2f    	mov.w     #0xfeb4, w1
    aa3a:	8f 80 40    	add.w     w1, w15, w1
    aa3c:	5a f8 07    	rcall     0x9af2 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1387>
    aa3e:	00 4e 44    	add.b     w8, w0, [w12]

0000aa40 <.L0>:
    aa40:	20 4a 24    	mov.w     #0x44a2, w0
    aa42:	90 40 78    	mov.b     [w0], w1
    aa44:	10 c0 b3    	mov.b     #0x1, w0
    aa46:	e9 cf 50    	sub.b     w1, #0x9, [w15]
    aa48:	01 00 3e    	bra       GTU, 0xaa4c <.L126>
    aa4a:	01 40 e8    	inc.b     w1, w0

0000aa4c <.L126>:
    aa4c:	21 4a 24    	mov.w     #0x44a2, w1
    aa4e:	80 48 78    	mov.b     w0, [w1]
    aa50:	4f 06 78    	mov.w     [--w15], w12
    aa52:	4f 05 be    	mov.d     [--w15], w10
    aa54:	4f 04 be    	mov.d     [--w15], w8
    aa56:	00 80 fa    	ulnk      
    aa58:	00 00 06    	return    

0000aa5a <.L0>:
    aa5a:	10 4a 22    	mov.w     #0x24a1, w0
    aa5c:	10 48 e8    	inc.b     [w0], [w0]

0000aa5e <.L0>:
    aa5e:	c7 ff 37    	bra       0xa9ee <.L0> <.L90>

0000aa60 <_prepareTelemetryMavlink>:
    aa60:	38 fb 07    	rcall     0xa0d2 <_sendTelemetryMavlink> <L0> <.LFB1468> <.LFE1472>
    aa62:	00 00 06    	return    

0000aa64 <_AUAV_V3_TestSens_myMuxFun1>:
    aa64:	00 8b be    	mov.d     w0, [w6]
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S501>:1:5' */
  localB->y[0] = rtu_u1;
  localB->y[1] = rtu_u2;
    aa66:	22 03 98    	mov.w     w2, [w6+4]
    aa68:	33 03 98    	mov.w     w3, [w6+6]
  localB->y[2] = rtu_u3;
    aa6a:	44 03 98    	mov.w     w4, [w6+8]
    aa6c:	55 03 98    	mov.w     w5, [w6+10]
}
    aa6e:	00 00 06    	return    

0000aa70 <_A_EmbeddedMATLABFunction_o>:

/*
 * Output and update for atomic system:
 *    '<S513>/Embedded MATLAB Function'
 *    '<S518>/Embedded MATLAB Function'
 */
void A_EmbeddedMATLABFunction_o(const real32_T rtu_x[3],
  rtB_EmbeddedMATLABFunction_g_T *localB)
{
    aa70:	88 9f be    	mov.d     w8, [w15++]
    aa72:	8a 9f be    	mov.d     w10, [w15++]
    aa74:	8c 9f be    	mov.d     w12, [w15++]
    aa76:	8e 1f 78    	mov.w     w14, [w15++]
    aa78:	00 01 78    	mov.w     w0, w2
    aa7a:	01 07 78    	mov.w     w1, w14
  /* MATLAB Function 'Position_and_Attitude_Filter/Attitude Complimentary Filter COG/Normalize Vector1/Norm/Subsystem3/Embedded MATLAB Function': '<S515>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S515>:1:5' */
  localB->xDoty = (rtu_x[0] * rtu_x[0] + rtu_x[1] * rtu_x[1]) + rtu_x[2] *
    aa7c:	12 00 be    	mov.d     [w2], w0
    aa7e:	22 05 90    	mov.w     [w2+4], w10
    aa80:	b2 05 90    	mov.w     [w2+6], w11
    rtu_x[2];
    aa82:	42 06 90    	mov.w     [w2+8], w12
    aa84:	d2 06 90    	mov.w     [w2+10], w13

0000aa86 <.L0>:
    aa86:	00 01 be    	mov.d     w0, w2
    aa88:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aa8a:	00 00 00 
    aa8c:	00 04 be    	mov.d     w0, w8
    aa8e:	0a 01 be    	mov.d     w10, w2
    aa90:	0a 00 be    	mov.d     w10, w0
    aa92:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aa94:	00 00 00 
    aa96:	00 01 be    	mov.d     w0, w2
    aa98:	08 00 be    	mov.d     w8, w0
    aa9a:	92 14 02    	call      0x1492 <___addsf3>
    aa9c:	00 00 00 
    aa9e:	00 04 be    	mov.d     w0, w8
    aaa0:	0c 01 be    	mov.d     w12, w2
    aaa2:	0c 00 be    	mov.d     w12, w0
    aaa4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aaa6:	00 00 00 
    aaa8:	00 01 be    	mov.d     w0, w2
    aaaa:	08 00 be    	mov.d     w8, w0
    aaac:	92 14 02    	call      0x1492 <___addsf3>
    aaae:	00 00 00 
    aab0:	00 8f be    	mov.d     w0, [w14]

0000aab2 <.L0>:
}
    aab2:	4f 07 78    	mov.w     [--w15], w14
    aab4:	4f 06 be    	mov.d     [--w15], w12
    aab6:	4f 05 be    	mov.d     [--w15], w10
    aab8:	4f 04 be    	mov.d     [--w15], w8
    aaba:	00 00 06    	return    

0000aabc <_EmbeddedMATLABFunct_c_Init>:

/*
 * Initial conditions for atomic system:
 *    '<S560>/Embedded MATLAB Function1'
 *    '<S560>/Embedded MATLAB Function2'
 */
void EmbeddedMATLABFunct_c_Init(rtDW_EmbeddedMATLABFunction1__T *localDW)
{
  localDW->LastU_not_empty = false;
    aabc:	80 40 eb    	clr.b     w1
    aabe:	01 50 98    	mov.b     w1, [w0+16]
  localDW->LastU = 0.0F;
    aac0:	60 11 b8    	mul.uu    w2, #0x0, w2
    aac2:	02 88 be    	mov.d     w2, [w0]
  localDW->rate = 0.0F;
    aac4:	42 00 98    	mov.w     w2, [w0+8]
    aac6:	53 00 98    	mov.w     w3, [w0+10]
  localDW->OldRate = 0.0F;
    aac8:	62 00 98    	mov.w     w2, [w0+12]
    aaca:	73 00 98    	mov.w     w3, [w0+14]
}
    aacc:	00 00 06    	return    

0000aace <_AU_EmbeddedMATLABFunction1>:

/*
 * Output and update for atomic system:
 *    '<S560>/Embedded MATLAB Function1'
 *    '<S560>/Embedded MATLAB Function2'
 */
void AU_EmbeddedMATLABFunction1(real32_T rtu_u, uint8_T rtu_NewGPS,
  rtB_EmbeddedMATLABFunction1_A_T *localB, rtDW_EmbeddedMATLABFunction1__T
  *localDW)
{
    aace:	88 9f be    	mov.d     w8, [w15++]
    aad0:	8a 9f be    	mov.d     w10, [w15++]
    aad2:	8c 9f be    	mov.d     w12, [w15++]
    aad4:	00 05 be    	mov.d     w0, w10
    aad6:	83 06 78    	mov.w     w3, w13
    aad8:	04 06 78    	mov.w     w4, w12
  /* MATLAB Function 'Position_and_Attitude_Filter/Position Filter/BlendPosVel/Subsystem/Embedded MATLAB Function1': '<S576>:1' */
  if (!localDW->LastU_not_empty) {
    aada:	0c 50 90    	mov.b     [w12+16], w0
    aadc:	00 04 e0    	cp0.b     w0
    aade:	06 00 3a    	bra       NZ, 0xaaec <.L5>
    /* '<S576>:1:7' */
    localDW->LastU_not_empty = true;
    aae0:	10 c0 b3    	mov.b     #0x1, w0
    aae2:	00 56 98    	mov.b     w0, [w12+16]

    /* '<S576>:1:9' */
    localDW->TimeSinceLast = 0.01F;
    aae4:	a0 70 2d    	mov.w     #0xd70a, w0
    aae6:	31 c2 23    	mov.w     #0x3c23, w1
    aae8:	20 06 98    	mov.w     w0, [w12+4]
    aaea:	31 06 98    	mov.w     w1, [w12+6]

0000aaec <.L5>:
  }

  if (rtu_NewGPS != 0) {
    aaec:	02 04 e0    	cp0.b     w2
    aaee:	12 00 32    	bra       Z, 0xab14 <.L0> <.L6>
    /* '<S576>:1:15' */
    localDW->OldRate = localDW->rate;
    aaf0:	4c 00 90    	mov.w     [w12+8], w0
    aaf2:	dc 00 90    	mov.w     [w12+10], w1
    aaf4:	60 06 98    	mov.w     w0, [w12+12]
    aaf6:	71 06 98    	mov.w     w1, [w12+14]

0000aaf8 <.L0>:

    /* '<S576>:1:16' */
    localDW->rate = (rtu_u - localDW->LastU) / localDW->TimeSinceLast;
    aaf8:	1c 01 be    	mov.d     [w12], w2
    aafa:	0a 00 be    	mov.d     w10, w0
    aafc:	90 14 02    	call      0x1490 <___subsf3>
    aafe:	00 00 00 
    ab00:	2c 01 90    	mov.w     [w12+4], w2
    ab02:	bc 01 90    	mov.w     [w12+6], w3
    ab04:	26 17 02    	call      0x1726 <___divsf3>
    ab06:	00 00 00 
    ab08:	40 06 98    	mov.w     w0, [w12+8]
    ab0a:	51 06 98    	mov.w     w1, [w12+10]

0000ab0c <.L0>:

    /* '<S576>:1:17' */
    localDW->TimeSinceLast = 0.0F;
    ab0c:	60 00 b8    	mul.uu    w0, #0x0, w0
    ab0e:	20 06 98    	mov.w     w0, [w12+4]
    ab10:	31 06 98    	mov.w     w1, [w12+6]

    /* '<S576>:1:18' */
    localDW->LastU = rtu_u;
    ab12:	0a 8e be    	mov.d     w10, [w12]

0000ab14 <.L0>:
  }

  /* '<S576>:1:20' */
  localB->y = (0.5F * localDW->rate + 0.5F * localDW->OldRate) *
    ab14:	02 00 20    	mov.w     #0x0, w2
    ab16:	03 f0 23    	mov.w     #0x3f00, w3
    ab18:	4c 00 90    	mov.w     [w12+8], w0
    ab1a:	dc 00 90    	mov.w     [w12+10], w1
    ab1c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ab1e:	00 00 00 
    ab20:	00 04 be    	mov.d     w0, w8
    ab22:	02 00 20    	mov.w     #0x0, w2
    ab24:	03 f0 23    	mov.w     #0x3f00, w3
    ab26:	6c 00 90    	mov.w     [w12+12], w0
    ab28:	fc 00 90    	mov.w     [w12+14], w1
    ab2a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ab2c:	00 00 00 
    ab2e:	00 01 be    	mov.d     w0, w2
    ab30:	08 00 be    	mov.d     w8, w0
    ab32:	92 14 02    	call      0x1492 <___addsf3>
    ab34:	00 00 00 
    ab36:	2c 01 90    	mov.w     [w12+4], w2
    ab38:	bc 01 90    	mov.w     [w12+6], w3
    ab3a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ab3c:	00 00 00 

0000ab3e <.L0>:
    localDW->TimeSinceLast + rtu_u;
    ab3e:	0a 01 be    	mov.d     w10, w2
    ab40:	92 14 02    	call      0x1492 <___addsf3>
    ab42:	00 00 00 

0000ab44 <.L0>:
    ab44:	80 8e be    	mov.d     w0, [w13]

0000ab46 <.L0>:

  /* '<S576>:1:21' */
  localDW->TimeSinceLast += 0.01F;
    ab46:	a2 70 2d    	mov.w     #0xd70a, w2
    ab48:	33 c2 23    	mov.w     #0x3c23, w3
    ab4a:	2c 00 90    	mov.w     [w12+4], w0
    ab4c:	bc 00 90    	mov.w     [w12+6], w1
    ab4e:	92 14 02    	call      0x1492 <___addsf3>
    ab50:	00 00 00 
    ab52:	20 06 98    	mov.w     w0, [w12+4]
    ab54:	31 06 98    	mov.w     w1, [w12+6]

0000ab56 <.L0>:
}
    ab56:	4f 06 be    	mov.d     [--w15], w12
    ab58:	4f 05 be    	mov.d     [--w15], w10
    ab5a:	4f 04 be    	mov.d     [--w15], w8
    ab5c:	00 00 06    	return    

0000ab5e <_Position_and_Attitude_Init>:

/* Initial conditions for atomic system: '<Root>/Position_and_Attitude_Filter' */
void Position_and_Attitude_Init(void)
{
  int16_T i;

  /* InitializeConditions for DiscreteIntegrator: '<S478>/Discrete-Time Integrator1' */
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] = 1.0F;
    ab5e:	00 00 20    	mov.w     #0x0, w0
    ab60:	01 f8 23    	mov.w     #0x3f80, w1
    ab62:	20 ed 88    	mov.w     w0, 0x1da4
    ab64:	31 ed 88    	mov.w     w1, 0x1da6
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] = 0.0F;
    ab66:	60 00 b8    	mul.uu    w0, #0x0, w0
    ab68:	40 ed 88    	mov.w     w0, 0x1da8
    ab6a:	51 ed 88    	mov.w     w1, 0x1daa
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] = 0.0F;
    ab6c:	60 ed 88    	mov.w     w0, 0x1dac
    ab6e:	71 ed 88    	mov.w     w1, 0x1dae
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] = 0.0F;
    ab70:	80 ed 88    	mov.w     w0, 0x1db0
    ab72:	91 ed 88    	mov.w     w1, 0x1db2

  /* InitializeConditions for MATLAB Function: '<S553>/Embedded MATLAB Function3' */
  AUAV_V3_TestSensors_DWork.lastGps_h_not_empty = false;
    ab74:	02 00 22    	mov.w     #0x2000, w2
    ab76:	00 49 eb    	clr.b     [w2]
  AUAV_V3_TestSensors_DWork.lastGps_h = 0.0F;
    ab78:	a0 fe 88    	mov.w     w0, 0x1fd4
    ab7a:	b1 fe 88    	mov.w     w1, 0x1fd6

0000ab7c <.L0>:

  /* InitializeConditions for MATLAB Function: '<S564>/Embedded MATLAB Function' */
  EmbeddedMATLABFunctio_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_ph);
    ab7c:	e0 18 20    	mov.w     #0x18e, w0
    ab7e:	02 00 40    	add.w     w0, w2, w0
    ab80:	e8 0e 02    	call      0x10ee8 <_EmbeddedMATLABFunctio_Init>
    ab82:	01 00 00 
    ab84:	c0 dc 21    	mov.w     #0x1dcc, w0
    ab86:	c1 03 20    	mov.w     #0x3c, w1
    ab88:	80 80 40    	add.w     w1, w0, w1

0000ab8a <.L0>:
    ab8a:	01 02 78    	mov.w     w1, w4
  for (i = 0; i < 15; i++) {
    /* InitializeConditions for Delay: '<S489>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[i] = 19.5F;
    ab8c:	02 00 20    	mov.w     #0x0, w2
    ab8e:	c3 19 24    	mov.w     #0x419c, w3

0000ab90 <.L8>:
    ab90:	02 a8 be    	mov.d     w2, [++w0]

    /* InitializeConditions for Delay: '<S559>/Integer Delay1' */
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[i] = 19.5F;
    ab92:	82 a8 be    	mov.d     w2, [++w1]
    ab94:	84 0f 50    	sub.w     w0, w4, [w15]
    ab96:	fc ff 3a    	bra       NZ, 0xab90 <.L8>
  }

  /* InitializeConditions for RateLimiter: '<S552>/Rate Limiter' */
  AUAV_V3_TestSensors_DWork.PrevY[0] = 0.0F;
    ab98:	60 00 b8    	mul.uu    w0, #0x0, w0
    ab9a:	e0 fd 88    	mov.w     w0, 0x1fbc
    ab9c:	f1 fd 88    	mov.w     w1, 0x1fbe
  AUAV_V3_TestSensors_DWork.PrevY[1] = 0.0F;
    ab9e:	00 fe 88    	mov.w     w0, 0x1fc0
    aba0:	11 fe 88    	mov.w     w1, 0x1fc2
  AUAV_V3_TestSensors_DWork.PrevY[2] = 0.0F;
    aba2:	20 fe 88    	mov.w     w0, 0x1fc4
    aba4:	31 fe 88    	mov.w     w1, 0x1fc6

  /* InitializeConditions for RateLimiter: '<S478>/Bias Rate Limiter' */
  AUAV_V3_TestSensors_DWork.PrevY_n[0] = 0.0F;
    aba6:	40 fe 88    	mov.w     w0, 0x1fc8
    aba8:	51 fe 88    	mov.w     w1, 0x1fca
  AUAV_V3_TestSensors_DWork.PrevY_n[1] = 0.0F;
    abaa:	60 fe 88    	mov.w     w0, 0x1fcc
    abac:	71 fe 88    	mov.w     w1, 0x1fce
  AUAV_V3_TestSensors_DWork.PrevY_n[2] = 0.0F;
    abae:	80 fe 88    	mov.w     w0, 0x1fd0
    abb0:	91 fe 88    	mov.w     w1, 0x1fd2
}
    abb2:	00 00 06    	return    

0000abb4 <_Position_and_Attitud_Start>:

/* Start for atomic system: '<Root>/Position_and_Attitude_Filter' */
void Position_and_Attitud_Start(void)
{
  /* InitializeConditions for Enabled SubSystem: '<S552>/Subsystem' */

  /* InitializeConditions for MATLAB Function: '<S560>/Embedded MATLAB Function1' */
  EmbeddedMATLABFunct_c_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_k);
    abb4:	c0 17 22    	mov.w     #0x217c, w0
    abb6:	82 ff 07    	rcall     0xaabc <_EmbeddedMATLABFunct_c_Init> <L0> <.LFB1467> <.LFE1466>

0000abb8 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S560>/Embedded MATLAB Function2' */
  EmbeddedMATLABFunct_c_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2);
    abb8:	a0 16 22    	mov.w     #0x216a, w0
    abba:	80 ff 07    	rcall     0xaabc <_EmbeddedMATLABFunct_c_Init> <L0> <.LFB1467> <.LFE1466>

0000abbc <.L0>:

  /* End of InitializeConditions for SubSystem: '<S552>/Subsystem' */
}
    abbc:	00 00 06    	return    

0000abbe <_Position_and_Attitude_Filt>:

/* Output and update for atomic system: '<Root>/Position_and_Attitude_Filter' */
void Position_and_Attitude_Filt(void)
{
    abbe:	2f 11 b0    	add.w     #0x112, w15
    abc0:	88 9f be    	mov.d     w8, [w15++]
    abc2:	8a 9f be    	mov.d     w10, [w15++]
    abc4:	8c 9f be    	mov.d     w12, [w15++]
    abc6:	8e 1f 78    	mov.w     w14, [w15++]
  /* local block i/o variables */
  real_T rtb_DataTypeConversion2_g[3];
  real_T rtb_DiscreteZeroPole_f;
  real_T rtb_DiscreteZeroPole_c;
  real_T rtb_DiscreteZeroPole_ck;
  real_T rtb_DataTypeConversion2_e2[3];
  real_T rtb_DiscreteZeroPole_k;
  real_T rtb_DiscreteZeroPole_o;
  real_T rtb_DiscreteZeroPole_g;
  real_T rtb_DataTypeConversion2_b;
  real_T rtb_DataTypeConversion2_j;
  real_T rtb_DataTypeConversion2_gb;
  real_T rtb_DiscreteZeroPole_ki;
  real32_T rtb_RhhcosphicoslambXe;
  real32_T rtb_Product_pc;
  real32_T rtb_Product1_gz;
  real32_T rtb_Product2_noi;
  real32_T rtb_Product3_ap;
  real32_T rtb_Deg2R1;
  real32_T rtb_RhhcosphisinlambYe;
  real32_T rtb_jxi;
  int32_T yIdx;
  int16_T colIdx;
  real32_T rtb_y_ox[3];
  real32_T rtb_ixk;
  real32_T rtb_kxj;
  real32_T rtb_ixj;
  real32_T rtb_kxi;
  real32_T rtb_Sum_bf;
  uint8_T rtb_DataTypeConversion2_h;
  real32_T rtb_Product1_e[3];
  real32_T rtb_Product1_kx[3];
  real32_T rtb_Add[3];
  real32_T rtb_VectorConcatenate[7];
  real32_T rtb_q_dot[4];
  real32_T tmp[9];
  real32_T tmp_0[3];
  real32_T rtb_TmpSignalConversionAtSFun_0[9];
  real32_T rtb_y_e;
  real32_T rtb_Deg2R_idx_0;
  real32_T rtb_Deg2R_idx_1;

  /* Sqrt: '<S521>/sqrt' incorporates:
   *  DiscreteIntegrator: '<S478>/Discrete-Time Integrator1'
   *  Product: '<S522>/Product'
   *  Product: '<S522>/Product1'
   *  Product: '<S522>/Product2'
   *  Product: '<S522>/Product3'
   *  Sum: '<S522>/Sum'
   */
  rtb_RhhcosphicoslambXe = (real32_T)sqrt
    (((AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] *
       AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] +
    abc8:	4e da 21    	mov.w     #0x1da4, w14
    abca:	1e 00 be    	mov.d     [w14], w0
       AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] *
       AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1]) +
    abcc:	64 01 47    	add.w     w14, #0x4, w2
    abce:	12 05 be    	mov.d     [w2], w10
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] *
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2]) +
    abd0:	e4 01 41    	add.w     w2, #0x4, w3
    abd2:	13 06 be    	mov.d     [w3], w12
     AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] *
     AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3]);
    abd4:	e8 02 41    	add.w     w2, #0x8, w5
    abd6:	15 02 be    	mov.d     [w5], w4
    abd8:	f4 b7 9f    	mov.w     w4, [w15-18]
    abda:	85 bf 9f    	mov.w     w5, [w15-16]

0000abdc <.L0>:
    abdc:	00 01 be    	mov.d     w0, w2
    abde:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    abe0:	00 00 00 
    abe2:	00 04 be    	mov.d     w0, w8

0000abe4 <.L0>:
    abe4:	0a 01 be    	mov.d     w10, w2
    abe6:	0a 00 be    	mov.d     w10, w0
    abe8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    abea:	00 00 00 
    abec:	00 01 be    	mov.d     w0, w2

0000abee <.L0>:
    abee:	08 00 be    	mov.d     w8, w0
    abf0:	92 14 02    	call      0x1492 <___addsf3>
    abf2:	00 00 00 
    abf4:	00 04 be    	mov.d     w0, w8

0000abf6 <.L0>:
    abf6:	0c 01 be    	mov.d     w12, w2
    abf8:	0c 00 be    	mov.d     w12, w0
    abfa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    abfc:	00 00 00 
    abfe:	00 01 be    	mov.d     w0, w2

0000ac00 <.L0>:
    ac00:	08 00 be    	mov.d     w8, w0
    ac02:	92 14 02    	call      0x1492 <___addsf3>
    ac04:	00 00 00 
    ac06:	00 04 be    	mov.d     w0, w8

0000ac08 <.L0>:
    ac08:	7f b1 97    	mov.w     [w15-18], w2
    ac0a:	8f b9 97    	mov.w     [w15-16], w3
    ac0c:	02 00 be    	mov.d     w2, w0
    ac0e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ac10:	00 00 00 
    ac12:	00 01 be    	mov.d     w0, w2

0000ac14 <.L0>:
    ac14:	08 00 be    	mov.d     w8, w0
    ac16:	92 14 02    	call      0x1492 <___addsf3>
    ac18:	00 00 00 
    ac1a:	ba 1d 02    	call      0x1dba <_sqrtf>
    ac1c:	00 00 00 
    ac1e:	00 04 be    	mov.d     w0, w8

0000ac20 <.L0>:

  /* Product: '<S494>/Product' incorporates:
   *  DiscreteIntegrator: '<S478>/Discrete-Time Integrator1'
   */
  rtb_Product_pc = AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] /
    ac20:	00 01 be    	mov.d     w0, w2
    ac22:	1e 00 be    	mov.d     [w14], w0
    ac24:	26 17 02    	call      0x1726 <___divsf3>
    ac26:	00 00 00 
    ac28:	b0 a7 9f    	mov.w     w0, [w15-58]
    ac2a:	c1 a7 9f    	mov.w     w1, [w15-56]

0000ac2c <.L0>:
    rtb_RhhcosphicoslambXe;

  /* Product: '<S494>/Product1' incorporates:
   *  DiscreteIntegrator: '<S478>/Discrete-Time Integrator1'
   */
  rtb_Product1_gz = AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] /
    ac2c:	08 01 be    	mov.d     w8, w2
    ac2e:	64 02 47    	add.w     w14, #0x4, w4
    ac30:	14 00 be    	mov.d     [w4], w0
    ac32:	26 17 02    	call      0x1726 <___divsf3>
    ac34:	00 00 00 
    ac36:	90 9f 9f    	mov.w     w0, [w15-78]
    ac38:	a1 9f 9f    	mov.w     w1, [w15-76]

0000ac3a <.L0>:
    rtb_RhhcosphicoslambXe;

  /* Product: '<S494>/Product2' incorporates:
   *  DiscreteIntegrator: '<S478>/Discrete-Time Integrator1'
   */
  rtb_Product2_noi = AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2]
    ac3a:	08 01 be    	mov.d     w8, w2
    ac3c:	68 02 47    	add.w     w14, #0x8, w4
    ac3e:	14 00 be    	mov.d     [w4], w0
    ac40:	26 17 02    	call      0x1726 <___divsf3>
    ac42:	00 00 00 
    ac44:	f0 97 9f    	mov.w     w0, [w15-82]
    ac46:	81 9f 9f    	mov.w     w1, [w15-80]

0000ac48 <.L0>:
    / rtb_RhhcosphicoslambXe;

  /* Product: '<S494>/Product3' incorporates:
   *  DiscreteIntegrator: '<S478>/Discrete-Time Integrator1'
   */
  rtb_Product3_ap = AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] /
    ac48:	08 01 be    	mov.d     w8, w2
    ac4a:	6c 02 47    	add.w     w14, #0xc, w4
    ac4c:	14 00 be    	mov.d     [w4], w0
    ac4e:	26 17 02    	call      0x1726 <___divsf3>
    ac50:	00 00 00 
    ac52:	d0 97 9f    	mov.w     w0, [w15-86]
    ac54:	e1 97 9f    	mov.w     w1, [w15-84]

0000ac56 <.L0>:
    rtb_RhhcosphicoslambXe;

  /* Sqrt: '<S534>/sqrt' incorporates:
   *  Product: '<S535>/Product'
   *  Product: '<S535>/Product1'
   *  Product: '<S535>/Product2'
   *  Product: '<S535>/Product3'
   *  Sum: '<S535>/Sum'
   */
  rtb_RhhcosphicoslambXe = (real32_T)sqrt(((rtb_Product_pc * rtb_Product_pc +
    ac56:	3f a1 97    	mov.w     [w15-58], w2
    ac58:	cf a1 97    	mov.w     [w15-56], w3
    ac5a:	02 00 be    	mov.d     w2, w0
    ac5c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ac5e:	00 00 00 
    ac60:	00 04 be    	mov.d     w0, w8

0000ac62 <.L0>:
    rtb_Product1_gz * rtb_Product1_gz) + rtb_Product2_noi * rtb_Product2_noi) +
    ac62:	1f 99 97    	mov.w     [w15-78], w2
    ac64:	af 99 97    	mov.w     [w15-76], w3
    ac66:	02 00 be    	mov.d     w2, w0
    ac68:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ac6a:	00 00 00 
    ac6c:	00 01 be    	mov.d     w0, w2

0000ac6e <.L0>:
    ac6e:	08 00 be    	mov.d     w8, w0
    ac70:	92 14 02    	call      0x1492 <___addsf3>
    ac72:	00 00 00 
    ac74:	00 04 be    	mov.d     w0, w8

0000ac76 <.L0>:
    ac76:	7f 91 97    	mov.w     [w15-82], w2
    ac78:	8f 99 97    	mov.w     [w15-80], w3
    ac7a:	02 00 be    	mov.d     w2, w0
    ac7c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ac7e:	00 00 00 
    ac80:	00 01 be    	mov.d     w0, w2
    ac82:	08 00 be    	mov.d     w8, w0
    ac84:	92 14 02    	call      0x1492 <___addsf3>
    ac86:	00 00 00 
    ac88:	00 04 be    	mov.d     w0, w8

0000ac8a <.L0>:
    rtb_Product3_ap * rtb_Product3_ap);
    ac8a:	5f 91 97    	mov.w     [w15-86], w2
    ac8c:	ef 91 97    	mov.w     [w15-84], w3
    ac8e:	02 00 be    	mov.d     w2, w0
    ac90:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ac92:	00 00 00 
    ac94:	00 01 be    	mov.d     w0, w2

0000ac96 <.L0>:
    ac96:	08 00 be    	mov.d     w8, w0
    ac98:	92 14 02    	call      0x1492 <___addsf3>
    ac9a:	00 00 00 
    ac9c:	ba 1d 02    	call      0x1dba <_sqrtf>
    ac9e:	00 00 00 
    aca0:	00 04 be    	mov.d     w0, w8

0000aca2 <.L0>:

  /* Product: '<S533>/Product' */
  rtb_Deg2R1 = rtb_Product_pc / rtb_RhhcosphicoslambXe;
    aca2:	00 01 be    	mov.d     w0, w2
    aca4:	3f a0 97    	mov.w     [w15-58], w0
    aca6:	cf a0 97    	mov.w     [w15-56], w1
    aca8:	26 17 02    	call      0x1726 <___divsf3>
    acaa:	00 00 00 
    acac:	00 06 be    	mov.d     w0, w12

0000acae <.L0>:

  /* Product: '<S533>/Product1' */
  rtb_RhhcosphisinlambYe = rtb_Product1_gz / rtb_RhhcosphicoslambXe;
    acae:	08 01 be    	mov.d     w8, w2
    acb0:	1f 98 97    	mov.w     [w15-78], w0
    acb2:	af 98 97    	mov.w     [w15-76], w1
    acb4:	26 17 02    	call      0x1726 <___divsf3>
    acb6:	00 00 00 
    acb8:	00 05 be    	mov.d     w0, w10

0000acba <.L0>:

  /* Product: '<S533>/Product2' */
  rtb_jxi = rtb_Product2_noi / rtb_RhhcosphicoslambXe;
    acba:	08 01 be    	mov.d     w8, w2
    acbc:	7f 90 97    	mov.w     [w15-82], w0
    acbe:	8f 98 97    	mov.w     [w15-80], w1
    acc0:	26 17 02    	call      0x1726 <___divsf3>
    acc2:	00 00 00 
    acc4:	d0 b7 9f    	mov.w     w0, [w15-22]
    acc6:	e1 b7 9f    	mov.w     w1, [w15-20]

0000acc8 <.L0>:

  /* Product: '<S533>/Product3' */
  rtb_RhhcosphicoslambXe = rtb_Product3_ap / rtb_RhhcosphicoslambXe;
    acc8:	08 01 be    	mov.d     w8, w2
    acca:	5f 90 97    	mov.w     [w15-86], w0
    accc:	ef 90 97    	mov.w     [w15-84], w1
    acce:	26 17 02    	call      0x1726 <___divsf3>
    acd0:	00 00 00 
    acd2:	90 b7 9f    	mov.w     w0, [w15-30]
    acd4:	a1 b7 9f    	mov.w     w1, [w15-28]

0000acd6 <.L0>:

  /* Sum: '<S523>/Sum' incorporates:
   *  Product: '<S523>/Product'
   *  Product: '<S523>/Product1'
   *  Product: '<S523>/Product2'
   *  Product: '<S523>/Product3'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[0] = ((rtb_Deg2R1 * rtb_Deg2R1 +
    acd6:	0c 01 be    	mov.d     w12, w2
    acd8:	0c 00 be    	mov.d     w12, w0
    acda:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    acdc:	00 00 00 
    acde:	90 af 9f    	mov.w     w0, [w15-46]
    ace0:	a1 af 9f    	mov.w     w1, [w15-44]

0000ace2 <.L0>:
    rtb_RhhcosphisinlambYe * rtb_RhhcosphisinlambYe) - rtb_jxi * rtb_jxi) -
    ace2:	0a 01 be    	mov.d     w10, w2
    ace4:	0a 00 be    	mov.d     w10, w0
    ace6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ace8:	00 00 00 
    acea:	f0 af 9f    	mov.w     w0, [w15-34]
    acec:	81 b7 9f    	mov.w     w1, [w15-32]
    acee:	5f b1 97    	mov.w     [w15-22], w2
    acf0:	ef b1 97    	mov.w     [w15-20], w3
    acf2:	02 00 be    	mov.d     w2, w0
    acf4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    acf6:	00 00 00 
    acf8:	f0 a7 9f    	mov.w     w0, [w15-50]
    acfa:	81 af 9f    	mov.w     w1, [w15-48]

0000acfc <.L0>:
    rtb_RhhcosphicoslambXe * rtb_RhhcosphicoslambXe;
    acfc:	1f b1 97    	mov.w     [w15-30], w2
    acfe:	af b1 97    	mov.w     [w15-28], w3
    ad00:	02 00 be    	mov.d     w2, w0
    ad02:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ad04:	00 00 00 
    ad06:	b0 b7 9f    	mov.w     w0, [w15-26]
    ad08:	c1 b7 9f    	mov.w     w1, [w15-24]

0000ad0a <.L0>:
    ad0a:	7f a9 97    	mov.w     [w15-34], w2
    ad0c:	8f b1 97    	mov.w     [w15-32], w3
    ad0e:	1f a8 97    	mov.w     [w15-46], w0
    ad10:	af a8 97    	mov.w     [w15-44], w1
    ad12:	92 14 02    	call      0x1492 <___addsf3>
    ad14:	00 00 00 

0000ad16 <.L0>:
    ad16:	7f a1 97    	mov.w     [w15-50], w2
    ad18:	8f a9 97    	mov.w     [w15-48], w3
    ad1a:	90 14 02    	call      0x1490 <___subsf3>
    ad1c:	00 00 00 
    ad1e:	3f b1 97    	mov.w     [w15-26], w2
    ad20:	cf b1 97    	mov.w     [w15-24], w3
    ad22:	90 14 02    	call      0x1490 <___subsf3>
    ad24:	00 00 00 
    ad26:	90 b7 9e    	mov.w     w0, [w15-286]
    ad28:	a1 b7 9e    	mov.w     w1, [w15-284]

0000ad2a <.L0>:
    ad2a:	30 b7 88    	mov.w     w0, 0x16e6
    ad2c:	41 b7 88    	mov.w     w1, 0x16e8

0000ad2e <.L0>:

  /* Gain: '<S526>/Gain' incorporates:
   *  Product: '<S526>/Product2'
   *  Product: '<S526>/Product3'
   *  Sum: '<S526>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[1] = (rtb_RhhcosphisinlambYe * rtb_jxi
    ad2e:	5f b1 97    	mov.w     [w15-22], w2
    ad30:	ef b1 97    	mov.w     [w15-20], w3
    ad32:	0a 00 be    	mov.d     w10, w0
    ad34:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ad36:	00 00 00 
    ad38:	00 04 be    	mov.d     w0, w8

0000ad3a <.L0>:
    - rtb_RhhcosphicoslambXe * rtb_Deg2R1) * 2.0F;
    ad3a:	0c 01 be    	mov.d     w12, w2
    ad3c:	1f b0 97    	mov.w     [w15-30], w0
    ad3e:	af b0 97    	mov.w     [w15-28], w1
    ad40:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ad42:	00 00 00 
    ad44:	00 01 be    	mov.d     w0, w2
    ad46:	d0 af 9f    	mov.w     w0, [w15-38]
    ad48:	e1 af 9f    	mov.w     w1, [w15-36]
    ad4a:	08 00 be    	mov.d     w8, w0
    ad4c:	90 14 02    	call      0x1490 <___subsf3>
    ad4e:	00 00 00 
    ad50:	00 01 be    	mov.d     w0, w2
    ad52:	92 14 02    	call      0x1492 <___addsf3>
    ad54:	00 00 00 

0000ad56 <.L0>:
    ad56:	50 b7 88    	mov.w     w0, 0x16ea
    ad58:	61 b7 88    	mov.w     w1, 0x16ec

0000ad5a <.L0>:

  /* Gain: '<S529>/Gain' incorporates:
   *  Product: '<S529>/Product1'
   *  Product: '<S529>/Product2'
   *  Sum: '<S529>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[2] = (rtb_Deg2R1 * rtb_jxi +
    ad5a:	5f b1 97    	mov.w     [w15-22], w2
    ad5c:	ef b1 97    	mov.w     [w15-20], w3
    ad5e:	0c 00 be    	mov.d     w12, w0
    ad60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ad62:	00 00 00 
    ad64:	b0 af 9f    	mov.w     w0, [w15-42]
    ad66:	c1 af 9f    	mov.w     w1, [w15-40]

0000ad68 <.L0>:
    rtb_RhhcosphisinlambYe * rtb_RhhcosphicoslambXe) * 2.0F;
    ad68:	1f b1 97    	mov.w     [w15-30], w2
    ad6a:	af b1 97    	mov.w     [w15-28], w3
    ad6c:	0a 00 be    	mov.d     w10, w0
    ad6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ad70:	00 00 00 
    ad72:	00 01 be    	mov.d     w0, w2
    ad74:	d0 9f 9f    	mov.w     w0, [w15-70]
    ad76:	e1 9f 9f    	mov.w     w1, [w15-68]

0000ad78 <.L0>:
    ad78:	3f a8 97    	mov.w     [w15-42], w0
    ad7a:	cf a8 97    	mov.w     [w15-40], w1
    ad7c:	92 14 02    	call      0x1492 <___addsf3>
    ad7e:	00 00 00 

0000ad80 <.L0>:
    ad80:	00 01 be    	mov.d     w0, w2
    ad82:	92 14 02    	call      0x1492 <___addsf3>
    ad84:	00 00 00 

0000ad86 <.L0>:
    ad86:	70 b7 88    	mov.w     w0, 0x16ee
    ad88:	81 b7 88    	mov.w     w1, 0x16f0

0000ad8a <.L0>:

  /* Gain: '<S524>/Gain' incorporates:
   *  Product: '<S524>/Product2'
   *  Product: '<S524>/Product3'
   *  Sum: '<S524>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[3] = (rtb_RhhcosphicoslambXe *
    rtb_Deg2R1 + rtb_RhhcosphisinlambYe * rtb_jxi) * 2.0F;
    ad8a:	5f a9 97    	mov.w     [w15-38], w2
    ad8c:	ef a9 97    	mov.w     [w15-36], w3
    ad8e:	08 00 be    	mov.d     w8, w0
    ad90:	92 14 02    	call      0x1492 <___addsf3>
    ad92:	00 00 00 
    ad94:	00 01 be    	mov.d     w0, w2
    ad96:	92 14 02    	call      0x1492 <___addsf3>
    ad98:	00 00 00 
    ad9a:	b0 b7 9e    	mov.w     w0, [w15-282]
    ad9c:	c1 b7 9e    	mov.w     w1, [w15-280]

0000ad9e <.L0>:
    ad9e:	90 b7 88    	mov.w     w0, 0x16f2
    ada0:	a1 b7 88    	mov.w     w1, 0x16f4

0000ada2 <.L0>:

  /* Sum: '<S527>/Sum' incorporates:
   *  Product: '<S527>/Product'
   *  Product: '<S527>/Product1'
   *  Product: '<S527>/Product2'
   *  Product: '<S527>/Product3'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[4] = ((rtb_Deg2R1 * rtb_Deg2R1 -
    ada2:	7f a9 97    	mov.w     [w15-34], w2
    ada4:	8f b1 97    	mov.w     [w15-32], w3
    ada6:	1f a8 97    	mov.w     [w15-46], w0
    ada8:	af a8 97    	mov.w     [w15-44], w1
    adaa:	90 14 02    	call      0x1490 <___subsf3>
    adac:	00 00 00 
    adae:	00 01 be    	mov.d     w0, w2
    adb0:	90 af 9f    	mov.w     w0, [w15-46]
    adb2:	a1 af 9f    	mov.w     w1, [w15-44]

0000adb4 <.L0>:
    rtb_RhhcosphisinlambYe * rtb_RhhcosphisinlambYe) + rtb_jxi * rtb_jxi) -
    adb4:	7f a0 97    	mov.w     [w15-50], w0
    adb6:	8f a8 97    	mov.w     [w15-48], w1
    adb8:	92 14 02    	call      0x1492 <___addsf3>
    adba:	00 00 00 
    adbc:	3f b1 97    	mov.w     [w15-26], w2
    adbe:	cf b1 97    	mov.w     [w15-24], w3
    adc0:	90 14 02    	call      0x1490 <___subsf3>
    adc2:	00 00 00 

0000adc4 <.L0>:
    adc4:	b0 b7 88    	mov.w     w0, 0x16f6
    adc6:	c1 b7 88    	mov.w     w1, 0x16f8

0000adc8 <.L0>:
    rtb_RhhcosphicoslambXe * rtb_RhhcosphicoslambXe;

  /* Gain: '<S530>/Gain' incorporates:
   *  Product: '<S530>/Product1'
   *  Product: '<S530>/Product2'
   *  Sum: '<S530>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[5] = (rtb_jxi * rtb_RhhcosphicoslambXe
    adc8:	1f b1 97    	mov.w     [w15-30], w2
    adca:	af b1 97    	mov.w     [w15-28], w3
    adcc:	5f b0 97    	mov.w     [w15-22], w0
    adce:	ef b0 97    	mov.w     [w15-20], w1
    add0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    add2:	00 00 00 
    add4:	00 04 be    	mov.d     w0, w8

0000add6 <.L0>:
    - rtb_Deg2R1 * rtb_RhhcosphisinlambYe) * 2.0F;
    add6:	0a 01 be    	mov.d     w10, w2
    add8:	0c 00 be    	mov.d     w12, w0
    adda:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    addc:	00 00 00 
    adde:	00 05 be    	mov.d     w0, w10
    ade0:	00 01 be    	mov.d     w0, w2
    ade2:	08 00 be    	mov.d     w8, w0
    ade4:	90 14 02    	call      0x1490 <___subsf3>
    ade6:	00 00 00 
    ade8:	00 01 be    	mov.d     w0, w2
    adea:	92 14 02    	call      0x1492 <___addsf3>
    adec:	00 00 00 

0000adee <.L0>:
    adee:	d0 b7 88    	mov.w     w0, 0x16fa
    adf0:	e1 b7 88    	mov.w     w1, 0x16fc

0000adf2 <.L0>:

  /* Gain: '<S525>/Gain' incorporates:
   *  Product: '<S525>/Product1'
   *  Product: '<S525>/Product2'
   *  Sum: '<S525>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[6] = (rtb_RhhcosphisinlambYe *
    rtb_RhhcosphicoslambXe - rtb_Deg2R1 * rtb_jxi) * 2.0F;
    adf2:	3f a9 97    	mov.w     [w15-42], w2
    adf4:	cf a9 97    	mov.w     [w15-40], w3
    adf6:	5f 98 97    	mov.w     [w15-70], w0
    adf8:	ef 98 97    	mov.w     [w15-68], w1
    adfa:	90 14 02    	call      0x1490 <___subsf3>
    adfc:	00 00 00 
    adfe:	00 01 be    	mov.d     w0, w2
    ae00:	92 14 02    	call      0x1492 <___addsf3>
    ae02:	00 00 00 
    ae04:	00 06 be    	mov.d     w0, w12

0000ae06 <.L0>:
    ae06:	f0 b7 88    	mov.w     w0, 0x16fe
    ae08:	01 b8 88    	mov.w     w1, 0x1700

0000ae0a <.L0>:

  /* Gain: '<S528>/Gain' incorporates:
   *  Product: '<S528>/Product1'
   *  Product: '<S528>/Product2'
   *  Sum: '<S528>/Sum'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[7] = (rtb_Deg2R1 *
    rtb_RhhcosphisinlambYe + rtb_jxi * rtb_RhhcosphicoslambXe) * 2.0F;
    ae0a:	0a 01 be    	mov.d     w10, w2
    ae0c:	08 00 be    	mov.d     w8, w0
    ae0e:	92 14 02    	call      0x1492 <___addsf3>
    ae10:	00 00 00 
    ae12:	00 01 be    	mov.d     w0, w2
    ae14:	92 14 02    	call      0x1492 <___addsf3>
    ae16:	00 00 00 

0000ae18 <.L0>:
    ae18:	10 b8 88    	mov.w     w0, 0x1702
    ae1a:	21 b8 88    	mov.w     w1, 0x1704

0000ae1c <.L0>:

  /* Sum: '<S531>/Sum' incorporates:
   *  Product: '<S531>/Product'
   *  Product: '<S531>/Product1'
   *  Product: '<S531>/Product2'
   *  Product: '<S531>/Product3'
   */
  AUAV_V3_TestSensors_B.VectorConcatenate[8] = ((rtb_Deg2R1 * rtb_Deg2R1 -
    rtb_RhhcosphisinlambYe * rtb_RhhcosphisinlambYe) - rtb_jxi * rtb_jxi) +
    ae1c:	7f a1 97    	mov.w     [w15-50], w2
    ae1e:	8f a9 97    	mov.w     [w15-48], w3
    ae20:	1f a8 97    	mov.w     [w15-46], w0
    ae22:	af a8 97    	mov.w     [w15-44], w1
    ae24:	90 14 02    	call      0x1490 <___subsf3>
    ae26:	00 00 00 
    ae28:	00 01 be    	mov.d     w0, w2
    ae2a:	3f b0 97    	mov.w     [w15-26], w0
    ae2c:	cf b0 97    	mov.w     [w15-24], w1
    ae2e:	92 14 02    	call      0x1492 <___addsf3>
    ae30:	00 00 00 

0000ae32 <.L0>:
    ae32:	30 b8 88    	mov.w     w0, 0x1706
    ae34:	41 b8 88    	mov.w     w1, 0x1708
    rtb_RhhcosphicoslambXe * rtb_RhhcosphicoslambXe;

  /* S-Function (sdspsubmtrx): '<S478>/Submatrix1' */
  yIdx = 0L;
  for (colIdx = 0; colIdx < 3; colIdx++) {
    AUAV_V3_TestSensors_B.Submatrix1[yIdx] =
    ae36:	1f b2 96    	mov.w     [w15-286], w4
    ae38:	af b2 96    	mov.w     [w15-284], w5
    ae3a:	54 b8 88    	mov.w     w4, 0x170a
    ae3c:	65 b8 88    	mov.w     w5, 0x170c
    ae3e:	3f b0 96    	mov.w     [w15-282], w0
    ae40:	cf b0 96    	mov.w     [w15-280], w1
    ae42:	70 b8 88    	mov.w     w0, 0x170e
    ae44:	81 b8 88    	mov.w     w1, 0x1710
    ae46:	9c b8 88    	mov.w     w12, 0x1712
    ae48:	ad b8 88    	mov.w     w13, 0x1714
      AUAV_V3_TestSensors_B.VectorConcatenate[(int32_T)(colIdx * 3)];
    yIdx++;
  }

  /* End of S-Function (sdspsubmtrx): '<S478>/Submatrix1' */

  /* MATLAB Function: '<S478>/myMux Fun2' incorporates:
   *  Constant: '<S478>/Constant1'
   */
  /* MATLAB Function 'Position_and_Attitude_Filter/Attitude Complimentary Filter COG/myMux Fun2': '<S496>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S496>:1:5' */
  rtb_y_ox[0] = AUAV_V3_TestSensors_B.Submatrix1[0];
  rtb_y_ox[1] = AUAV_V3_TestSensors_B.Submatrix1[1];
  rtb_y_ox[2] = 0.0F;
    ae4a:	60 00 b8    	mul.uu    w0, #0x0, w0
    ae4c:	d0 b7 9e    	mov.w     w0, [w15-278]
    ae4e:	e1 b7 9e    	mov.w     w1, [w15-276]

0000ae50 <.L0>:

  /* MATLAB Function: '<S518>/Embedded MATLAB Function' */
  A_EmbeddedMATLABFunction_o(rtb_y_ox,
    ae50:	c1 c0 21    	mov.w     #0x1c0c, w1
    ae52:	20 ee 2f    	mov.w     #0xfee2, w0
    ae54:	0f 00 40    	add.w     w0, w15, w0
    ae56:	0c fe 07    	rcall     0xaa70 <_A_EmbeddedMATLABFunction_o> <L0> <.LFB1466> <.LFE1465>

0000ae58 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_a);

  /* MATLAB Function: '<S517>/negprotect' */
  AUAV_V3_TestSen_negprotect
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_a.xDoty,
    ae58:	02 c1 21    	mov.w     #0x1c10, w2
    ae5a:	60 e0 80    	mov.w     0x1c0c, w0
    ae5c:	71 e0 80    	mov.w     0x1c0e, w1
    ae5e:	14 12 02    	call      0x11214 <_AUAV_V3_TestSen_negprotect>
    ae60:	01 00 00 

0000ae62 <.L0>:
     &AUAV_V3_TestSensors_B.sf_negprotect_m);

  /* S-Function (MCHP_C_function_Call): '<S517>/[apUtils.c]' */
  AUAV_V3_TestSensors_B.apUtilsc = mySqrt(
    ae62:	80 e0 80    	mov.w     0x1c10, w0
    ae64:	91 e0 80    	mov.w     0x1c12, w1
    ae66:	16 10 02    	call      0x11016 <_mySqrt>
    ae68:	01 00 00 
    ae6a:	00 04 be    	mov.d     w0, w8
    ae6c:	b0 b8 88    	mov.w     w0, 0x1716
    ae6e:	c1 b8 88    	mov.w     w1, 0x1718

0000ae70 <.L0>:
    AUAV_V3_TestSensors_B.sf_negprotect_m.zpVal
    );

  /* Saturate: '<S493>/Zero Bound' */
  if (AUAV_V3_TestSensors_B.apUtilsc <= 0.001F) {
    ae70:	f2 26 21    	mov.w     #0x126f, w2
    ae72:	33 a8 23    	mov.w     #0x3a83, w3
    ae74:	8c 18 02    	call      0x188c <___eqsf2>
    ae76:	00 00 00 
    ae78:	00 00 e0    	cp0.w     w0
    ae7a:	02 00 3c    	bra       GT, 0xae80 <.L0> <.L12>

0000ae7c <.L0>:
    rtb_RhhcosphicoslambXe = 0.001F;
    ae7c:	f8 26 21    	mov.w     #0x126f, w8
    ae7e:	39 a8 23    	mov.w     #0x3a83, w9

0000ae80 <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_B.apUtilsc;
  }

  /* End of Saturate: '<S493>/Zero Bound' */

  /* Product: '<S493>/Divide' incorporates:
   *  MATLAB Function: '<S478>/myMux Fun2'
   */
  rtb_y_ox[0] = AUAV_V3_TestSensors_B.Submatrix1[0] / rtb_RhhcosphicoslambXe;
    ae80:	08 01 be    	mov.d     w8, w2
    ae82:	50 b8 80    	mov.w     0x170a, w0
    ae84:	61 b8 80    	mov.w     0x170c, w1
    ae86:	26 17 02    	call      0x1726 <___divsf3>
    ae88:	00 00 00 
    ae8a:	90 b7 9e    	mov.w     w0, [w15-286]
    ae8c:	a1 b7 9e    	mov.w     w1, [w15-284]

0000ae8e <.L0>:
  rtb_y_e = AUAV_V3_TestSensors_B.Submatrix1[1] / rtb_RhhcosphicoslambXe;
    ae8e:	08 01 be    	mov.d     w8, w2
    ae90:	70 b8 80    	mov.w     0x170e, w0
    ae92:	81 b8 80    	mov.w     0x1710, w1
    ae94:	26 17 02    	call      0x1726 <___divsf3>
    ae96:	00 00 00 
    ae98:	90 97 9f    	mov.w     w0, [w15-94]
    ae9a:	a1 97 9f    	mov.w     w1, [w15-92]

0000ae9c <.L0>:
  rtb_y_ox[2] = 0.0F / rtb_RhhcosphicoslambXe;
    ae9c:	08 01 be    	mov.d     w8, w2
    ae9e:	60 00 b8    	mul.uu    w0, #0x0, w0
    aea0:	26 17 02    	call      0x1726 <___divsf3>
    aea2:	00 00 00 
    aea4:	d0 b7 9e    	mov.w     w0, [w15-278]
    aea6:	e1 b7 9e    	mov.w     w1, [w15-276]

0000aea8 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S14>/Get the GS Location [updateSensorMCUState.c]1' */
  getGSLocation(
    aea8:	a0 71 21    	mov.w     #0x171a, w0
    aeaa:	c8 fd 02    	call      0xfdc8 <_getGSLocation>
    aeac:	00 00 00 

0000aeae <.L0>:
                &AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[0]
                );

  /* Gain: '<S547>/Deg2R' */
  rtb_Deg2R_idx_0 = 0.0174532924F *
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[2];
    aeae:	14 b9 80    	mov.w     0x1722, w4
    aeb0:	25 b9 80    	mov.w     0x1724, w5
    aeb2:	94 af 9f    	mov.w     w4, [w15-46]
    aeb4:	a5 af 9f    	mov.w     w5, [w15-44]
  rtb_Deg2R_idx_1 = 0.0174532924F *
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[1];
    aeb6:	f0 b8 80    	mov.w     0x171e, w0
    aeb8:	01 b9 80    	mov.w     0x1720, w1
    aeba:	f0 af 9f    	mov.w     w0, [w15-34]
    aebc:	81 b7 9f    	mov.w     w1, [w15-32]

0000aebe <.L0>:

  /* Gain: '<S548>/Deg2R' */
  rtb_Sum_bf = 0.0174532924F * AUAV_V3_TestSensors_B.Switch1[0];
    aebe:	52 a3 2f    	mov.w     #0xfa35, w2
    aec0:	e3 c8 23    	mov.w     #0x3c8e, w3
    aec2:	d0 b4 80    	mov.w     0x169a, w0
    aec4:	e1 b4 80    	mov.w     0x169c, w1
    aec6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aec8:	00 00 00 
    aeca:	00 04 be    	mov.d     w0, w8

0000aecc <.L0>:

  /* Trigonometry: '<S548>/sin(phi)' */
  rtb_kxi = (real32_T)sin(rtb_Sum_bf);
    aecc:	b6 1d 02    	call      0x1db6 <_sinf>
    aece:	00 00 00 
    aed0:	00 01 be    	mov.d     w0, w2
    aed2:	d0 b7 9f    	mov.w     w0, [w15-22]
    aed4:	e1 b7 9f    	mov.w     w1, [w15-20]

0000aed6 <.L0>:

  /* Sum: '<S548>/Sum1' incorporates:
   *  Constant: '<S548>/const'
   *  Product: '<S548>/Product1'
   *  Product: '<S548>/sin(phi)^2'
   */
  rtb_RhhcosphicoslambXe = 1.0F - rtb_kxi * rtb_kxi * 0.00669425726F;
    aed6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aed8:	00 00 00 
    aeda:	02 b8 25    	mov.w     #0x5b80, w2
    aedc:	b3 bd 23    	mov.w     #0x3bdb, w3
    aede:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aee0:	00 00 00 
    aee2:	00 01 be    	mov.d     w0, w2
    aee4:	00 00 20    	mov.w     #0x0, w0
    aee6:	01 f8 23    	mov.w     #0x3f80, w1
    aee8:	90 14 02    	call      0x1490 <___subsf3>
    aeea:	00 00 00 
    aeec:	00 05 be    	mov.d     w0, w10

0000aeee <.L0>:

  /* Fcn: '<S548>/f' */
  if (rtb_RhhcosphicoslambXe < 0.0F) {
    aeee:	60 11 b8    	mul.uu    w2, #0x0, w2
    aef0:	8c 18 02    	call      0x188c <___eqsf2>
    aef2:	00 00 00 
    aef4:	00 00 e0    	cp0.w     w0
    aef6:	09 00 3d    	bra       GE, 0xaf0a <.L0> <.L0> <.L135>

0000aef8 <.L0>:
    rtb_RhhcosphicoslambXe = -(real32_T)sqrt(-rtb_RhhcosphicoslambXe);
    aef8:	0a 00 be    	mov.d     w10, w0
    aefa:	01 f0 a2    	btg.w     w1, #0xf
    aefc:	ba 1d 02    	call      0x1dba <_sqrtf>
    aefe:	00 00 00 
    af00:	00 02 be    	mov.d     w0, w4
    af02:	05 f0 a2    	btg.w     w5, #0xf
    af04:	d4 a7 9f    	mov.w     w4, [w15-54]
    af06:	e5 a7 9f    	mov.w     w5, [w15-52]
    af08:	05 00 37    	bra       0xaf14 <.L0> <.L16>

0000af0a <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = (real32_T)sqrt(rtb_RhhcosphicoslambXe);
    af0a:	0a 00 be    	mov.d     w10, w0
    af0c:	ba 1d 02    	call      0x1dba <_sqrtf>
    af0e:	00 00 00 
    af10:	d0 a7 9f    	mov.w     w0, [w15-54]
    af12:	e1 a7 9f    	mov.w     w1, [w15-52]

0000af14 <.L0>:
  }

  /* End of Fcn: '<S548>/f' */

  /* Product: '<S548>/Rh' incorporates:
   *  Constant: '<S548>/Re=equatorial radius'
   */
  rtb_ixj = 6.378137E+6F / rtb_RhhcosphicoslambXe;

  /* Sum: '<S548>/Sum2' */
  rtb_kxj = AUAV_V3_TestSensors_B.Switch1[2] + rtb_ixj;
    af14:	14 b5 80    	mov.w     0x16a2, w4
    af16:	25 b5 80    	mov.w     0x16a4, w5
    af18:	f4 a7 9f    	mov.w     w4, [w15-50]
    af1a:	85 af 9f    	mov.w     w5, [w15-48]

0000af1c <.L0>:

  /* Trigonometry: '<S548>/cos(phi)' */
  rtb_Sum_bf = (real32_T)cos(rtb_Sum_bf);
    af1c:	08 00 be    	mov.d     w8, w0
    af1e:	22 17 02    	call      0x1722 <_cosf>
    af20:	00 00 00 
    af22:	b0 af 9f    	mov.w     w0, [w15-42]
    af24:	c1 af 9f    	mov.w     w1, [w15-40]

0000af26 <.L0>:

  /* Gain: '<S548>/Deg2R1' */
  rtb_ixk = 0.0174532924F * AUAV_V3_TestSensors_B.Switch1[1];
    af26:	52 a3 2f    	mov.w     #0xfa35, w2
    af28:	e3 c8 23    	mov.w     #0x3c8e, w3
    af2a:	f0 b4 80    	mov.w     0x169e, w0
    af2c:	01 b5 80    	mov.w     0x16a0, w1
    af2e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    af30:	00 00 00 
    af32:	00 04 be    	mov.d     w0, w8

0000af34 <.L0>:

  /* Product: '<S548>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
   *  Trigonometry: '<S548>/cos(lamb)'
   */
  rtb_jxi = rtb_kxj * rtb_Sum_bf * (real32_T)cos(rtb_ixk);
    af34:	22 17 02    	call      0x1722 <_cosf>
    af36:	00 00 00 
    af38:	d0 9f 9f    	mov.w     w0, [w15-70]
    af3a:	e1 9f 9f    	mov.w     w1, [w15-68]

0000af3c <.L0>:

  /* Product: '<S548>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
   *  Trigonometry: '<S548>/sin(lamb)'
   */
  rtb_kxj = rtb_kxj * rtb_Sum_bf * (real32_T)sin(rtb_ixk);
    af3c:	08 00 be    	mov.d     w8, w0
    af3e:	b6 1d 02    	call      0x1db6 <_sinf>
    af40:	00 00 00 
    af42:	90 a7 9f    	mov.w     w0, [w15-62]
    af44:	a1 a7 9f    	mov.w     w1, [w15-60]

0000af46 <.L0>:

  /* Product: '<S548>/Ze' incorporates:
   *  Product: '<S548>/Rh(1-e^2)'
   *  Sum: '<S548>/Sum4'
   */
  rtb_kxi *= 0.993305743F * rtb_ixj + AUAV_V3_TestSensors_B.Switch1[2];

  /* Gain: '<S539>/Deg2R' */
  rtb_Sum_bf = 0.0174532924F *
    af46:	52 a3 2f    	mov.w     #0xfa35, w2
    af48:	e3 c8 23    	mov.w     #0x3c8e, w3
    af4a:	f0 b8 80    	mov.w     0x171e, w0
    af4c:	01 b9 80    	mov.w     0x1720, w1
    af4e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    af50:	00 00 00 
    af52:	00 04 be    	mov.d     w0, w8

0000af54 <.L0>:
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[1];

  /* Trigonometry: '<S539>/sin(phi)' */
  rtb_ixj = (real32_T)sin(rtb_Sum_bf);
    af54:	b6 1d 02    	call      0x1db6 <_sinf>
    af56:	00 00 00 
    af58:	90 b7 9f    	mov.w     w0, [w15-30]
    af5a:	a1 b7 9f    	mov.w     w1, [w15-28]

0000af5c <.L0>:

  /* Sum: '<S539>/Sum1' incorporates:
   *  Constant: '<S539>/const'
   *  Product: '<S539>/Product1'
   *  Product: '<S539>/sin(phi)^2'
   */
  rtb_RhhcosphicoslambXe = 1.0F - rtb_ixj * rtb_ixj * 0.00669425726F;
    af5c:	00 01 be    	mov.d     w0, w2
    af5e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    af60:	00 00 00 
    af62:	02 b8 25    	mov.w     #0x5b80, w2
    af64:	b3 bd 23    	mov.w     #0x3bdb, w3
    af66:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    af68:	00 00 00 
    af6a:	00 01 be    	mov.d     w0, w2
    af6c:	00 00 20    	mov.w     #0x0, w0
    af6e:	01 f8 23    	mov.w     #0x3f80, w1
    af70:	90 14 02    	call      0x1490 <___subsf3>
    af72:	00 00 00 
    af74:	00 05 be    	mov.d     w0, w10

0000af76 <.L0>:

  /* Fcn: '<S539>/f' */
  if (rtb_RhhcosphicoslambXe < 0.0F) {
    af76:	60 11 b8    	mul.uu    w2, #0x0, w2
    af78:	8c 18 02    	call      0x188c <___eqsf2>
    af7a:	00 00 00 
    af7c:	00 00 e0    	cp0.w     w0
    af7e:	09 00 3d    	bra       GE, 0xaf92 <.L0> <.L0> <.L136>

0000af80 <.L0>:
    rtb_RhhcosphicoslambXe = -(real32_T)sqrt(-rtb_RhhcosphicoslambXe);
    af80:	0a 00 be    	mov.d     w10, w0
    af82:	01 f0 a2    	btg.w     w1, #0xf
    af84:	ba 1d 02    	call      0x1dba <_sqrtf>
    af86:	00 00 00 
    af88:	00 01 be    	mov.d     w0, w2
    af8a:	03 f0 a2    	btg.w     w3, #0xf
    af8c:	d2 af 9f    	mov.w     w2, [w15-38]
    af8e:	e3 af 9f    	mov.w     w3, [w15-36]
    af90:	05 00 37    	bra       0xaf9c <.L0> <.L19>

0000af92 <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = (real32_T)sqrt(rtb_RhhcosphicoslambXe);
    af92:	0a 00 be    	mov.d     w10, w0
    af94:	ba 1d 02    	call      0x1dba <_sqrtf>
    af96:	00 00 00 
    af98:	d0 af 9f    	mov.w     w0, [w15-38]
    af9a:	e1 af 9f    	mov.w     w1, [w15-36]

0000af9c <.L0>:
  }

  /* End of Fcn: '<S539>/f' */

  /* Product: '<S539>/Rh' incorporates:
   *  Constant: '<S539>/Re=equatorial radius'
   */
  rtb_ixk = 6.378137E+6F / rtb_RhhcosphicoslambXe;

  /* Sum: '<S539>/Sum2' */
  rtb_RhhcosphisinlambYe =
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[0] + rtb_ixk;
    af9c:	d0 b8 80    	mov.w     0x171a, w0
    af9e:	e1 b8 80    	mov.w     0x171c, w1
    afa0:	b0 b7 9f    	mov.w     w0, [w15-26]
    afa2:	c1 b7 9f    	mov.w     w1, [w15-24]

0000afa4 <.L0>:

  /* Trigonometry: '<S539>/cos(phi)' */
  rtb_Sum_bf = (real32_T)cos(rtb_Sum_bf);
    afa4:	08 00 be    	mov.d     w8, w0
    afa6:	22 17 02    	call      0x1722 <_cosf>
    afa8:	00 00 00 
    afaa:	00 06 be    	mov.d     w0, w12

0000afac <.L0>:

  /* Gain: '<S539>/Deg2R1' */
  rtb_Deg2R1 = 0.0174532924F *
    afac:	52 a3 2f    	mov.w     #0xfa35, w2
    afae:	e3 c8 23    	mov.w     #0x3c8e, w3
    afb0:	10 b9 80    	mov.w     0x1722, w0
    afb2:	21 b9 80    	mov.w     0x1724, w1
    afb4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    afb6:	00 00 00 
    afb8:	00 04 be    	mov.d     w0, w8

0000afba <.L0>:
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[2];

  /* Product: '<S539>/(Rh+h)cos(phi)*cos(lamb)=Xe' incorporates:
   *  Trigonometry: '<S539>/cos(lamb)'
   */
  rtb_RhhcosphicoslambXe = rtb_RhhcosphisinlambYe * rtb_Sum_bf * (real32_T)cos
    afba:	22 17 02    	call      0x1722 <_cosf>
    afbc:	00 00 00 
    afbe:	f0 9f 9f    	mov.w     w0, [w15-66]
    afc0:	81 a7 9f    	mov.w     w1, [w15-64]

0000afc2 <.L0>:
    (rtb_Deg2R1);

  /* Product: '<S539>/(Rh+h)cos(phi)*sin(lamb)=Ye' incorporates:
   *  Trigonometry: '<S539>/sin(lamb)'
   */
  rtb_RhhcosphisinlambYe = rtb_RhhcosphisinlambYe * rtb_Sum_bf * (real32_T)sin
    afc2:	08 00 be    	mov.d     w8, w0
    afc4:	b6 1d 02    	call      0x1db6 <_sinf>
    afc6:	00 00 00 
    afc8:	b0 9f 9f    	mov.w     w0, [w15-74]
    afca:	c1 9f 9f    	mov.w     w1, [w15-72]

0000afcc <.L0>:
    (rtb_Deg2R1);

  /* Product: '<S539>/Ze' incorporates:
   *  Product: '<S539>/Rh(1-e^2)'
   *  Sum: '<S539>/Sum4'
   */
  rtb_ixj *= 0.993305743F * rtb_ixk +
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorM_c[0];

  /* S-Function (MCHP_C_function_Call): '<S14>/Checks if FixType is 3 [updateSensorMCUState.c]1' */
  AUAV_V3_TestSensors_B.ChecksifFixTypeis3updateSenso_p = isFixValid(
    afcc:	3c ff 02    	call      0xff3c <_isFixValid>
    afce:	00 00 00 
    afd0:	80 40 78    	mov.b     w0, w1
    afd2:	80 a9 21    	mov.w     #0x1a98, w0
    afd4:	01 48 78    	mov.b     w1, [w0]
    );

  /* Outputs for Enabled SubSystem: '<S14>/Enabled Subsystem' incorporates:
   *  EnablePort: '<S481>/Enable'
   */
  if (AUAV_V3_TestSensors_B.ChecksifFixTypeis3updateSenso_p > 0) {
    afd6:	01 04 e0    	cp0.b     w1
    afd8:	29 01 32    	bra       Z, 0xb22c <.L0> <.L20>

0000afda <.L0>:
    afda:	52 a3 2f    	mov.w     #0xfa35, w2
    afdc:	e3 c8 23    	mov.w     #0x3c8e, w3
    afde:	1f a8 97    	mov.w     [w15-46], w0
    afe0:	af a8 97    	mov.w     [w15-44], w1
    afe2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    afe4:	00 00 00 
    afe6:	00 04 be    	mov.d     w0, w8

0000afe8 <.L0>:
    afe8:	52 a3 2f    	mov.w     #0xfa35, w2
    afea:	e3 c8 23    	mov.w     #0x3c8e, w3
    afec:	7f a8 97    	mov.w     [w15-34], w0
    afee:	8f b0 97    	mov.w     [w15-32], w1
    aff0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    aff2:	00 00 00 
    aff4:	00 05 be    	mov.d     w0, w10

0000aff6 <.L0>:
    aff6:	5f a1 97    	mov.w     [w15-54], w2
    aff8:	ef a1 97    	mov.w     [w15-52], w3
    affa:	20 53 2a    	mov.w     #0xa532, w0
    affc:	21 ac 24    	mov.w     #0x4ac2, w1
    affe:	26 17 02    	call      0x1726 <___divsf3>
    b000:	00 00 00 
    b002:	00 01 be    	mov.d     w0, w2
    b004:	90 af 9f    	mov.w     w0, [w15-46]
    b006:	a1 af 9f    	mov.w     w1, [w15-44]

0000b008 <.L0>:
    b008:	7f a0 97    	mov.w     [w15-50], w0
    b00a:	8f a8 97    	mov.w     [w15-48], w1
    b00c:	92 14 02    	call      0x1492 <___addsf3>
    b00e:	00 00 00 

0000b010 <.L0>:
    b010:	3f a9 97    	mov.w     [w15-42], w2
    b012:	cf a9 97    	mov.w     [w15-40], w3
    b014:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b016:	00 00 00 
    b018:	f0 af 9f    	mov.w     w0, [w15-34]
    b01a:	81 b7 9f    	mov.w     w1, [w15-32]

0000b01c <.L0>:
    b01c:	5f a9 97    	mov.w     [w15-38], w2
    b01e:	ef a9 97    	mov.w     [w15-36], w3
    b020:	20 53 2a    	mov.w     #0xa532, w0
    b022:	21 ac 24    	mov.w     #0x4ac2, w1
    b024:	26 17 02    	call      0x1726 <___divsf3>
    b026:	00 00 00 
    b028:	00 01 be    	mov.d     w0, w2
    b02a:	b0 af 9f    	mov.w     w0, [w15-42]
    b02c:	c1 af 9f    	mov.w     w1, [w15-40]

0000b02e <.L0>:
    b02e:	3f b0 97    	mov.w     [w15-26], w0
    b030:	cf b0 97    	mov.w     [w15-24], w1
    b032:	92 14 02    	call      0x1492 <___addsf3>
    b034:	00 00 00 

0000b036 <.L0>:
    b036:	0c 01 be    	mov.d     w12, w2
    b038:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b03a:	00 00 00 
    b03c:	b0 97 9f    	mov.w     w0, [w15-90]
    b03e:	c1 97 9f    	mov.w     w1, [w15-88]

0000b040 <.L0>:
    /* SignalConversion: '<S547>/TmpSignal ConversionAtProduct1Inport1' incorporates:
     *  Fcn: '<S550>/11'
     *  Fcn: '<S550>/12'
     *  Fcn: '<S550>/13'
     *  Fcn: '<S550>/21'
     *  Fcn: '<S550>/22'
     *  Fcn: '<S550>/23'
     *  Fcn: '<S550>/31'
     *  Fcn: '<S550>/32'
     *  Fcn: '<S550>/33'
     */
    tmp[0] = (real32_T)cos(rtb_Deg2R_idx_0) * (real32_T)cos(rtb_Deg2R_idx_1);
    b040:	08 00 be    	mov.d     w8, w0
    b042:	22 17 02    	call      0x1722 <_cosf>
    b044:	00 00 00 
    b046:	00 06 be    	mov.d     w0, w12
    b048:	0a 00 be    	mov.d     w10, w0
    b04a:	22 17 02    	call      0x1722 <_cosf>
    b04c:	00 00 00 
    b04e:	00 01 be    	mov.d     w0, w2
    b050:	f0 2f 9f    	mov.w     w0, [w15-162]
    b052:	81 37 9f    	mov.w     w1, [w15-160]
    b054:	0c 00 be    	mov.d     w12, w0
    b056:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b058:	00 00 00 
    b05a:	f0 1f 9f    	mov.w     w0, [w15-194]
    b05c:	81 27 9f    	mov.w     w1, [w15-192]

0000b05e <.L0>:
    tmp[1] = -(real32_T)sin(rtb_Deg2R_idx_0);
    b05e:	08 00 be    	mov.d     w8, w0
    b060:	b6 1d 02    	call      0x1db6 <_sinf>
    b062:	00 00 00 
    b064:	00 04 be    	mov.d     w0, w8
    b066:	00 02 be    	mov.d     w0, w4
    b068:	05 f0 a2    	btg.w     w5, #0xf
    b06a:	d4 af 9f    	mov.w     w4, [w15-38]
    b06c:	e5 af 9f    	mov.w     w5, [w15-36]
    b06e:	94 27 9f    	mov.w     w4, [w15-190]
    b070:	a5 27 9f    	mov.w     w5, [w15-188]

0000b072 <.L0>:
    tmp[2] = -(real32_T)sin(rtb_Deg2R_idx_1) * (real32_T)cos(rtb_Deg2R_idx_0);
    b072:	0a 00 be    	mov.d     w10, w0
    b074:	b6 1d 02    	call      0x1db6 <_sinf>
    b076:	00 00 00 
    b078:	00 05 be    	mov.d     w0, w10
    b07a:	00 01 be    	mov.d     w0, w2
    b07c:	03 f0 a2    	btg.w     w3, #0xf
    b07e:	0c 00 be    	mov.d     w12, w0
    b080:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b082:	00 00 00 
    b084:	b0 27 9f    	mov.w     w0, [w15-186]
    b086:	c1 27 9f    	mov.w     w1, [w15-184]

0000b088 <.L0>:
    tmp[3] = (real32_T)sin(rtb_Deg2R_idx_0) * (real32_T)cos(rtb_Deg2R_idx_1);
    b088:	08 01 be    	mov.d     w8, w2
    b08a:	7f 28 97    	mov.w     [w15-162], w0
    b08c:	8f 30 97    	mov.w     [w15-160], w1
    b08e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b090:	00 00 00 
    b092:	d0 27 9f    	mov.w     w0, [w15-182]
    b094:	e1 27 9f    	mov.w     w1, [w15-180]

0000b096 <.L0>:
    tmp[4] = (real32_T)cos(rtb_Deg2R_idx_0);
    b096:	fc 27 9f    	mov.w     w12, [w15-178]
    b098:	8d 2f 9f    	mov.w     w13, [w15-176]

0000b09a <.L0>:
    tmp[5] = -(real32_T)sin(rtb_Deg2R_idx_0) * (real32_T)sin(rtb_Deg2R_idx_1);
    b09a:	0a 01 be    	mov.d     w10, w2
    b09c:	5f a8 97    	mov.w     [w15-38], w0
    b09e:	ef a8 97    	mov.w     [w15-36], w1
    b0a0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b0a2:	00 00 00 
    b0a4:	90 2f 9f    	mov.w     w0, [w15-174]
    b0a6:	a1 2f 9f    	mov.w     w1, [w15-172]

0000b0a8 <.L0>:
    tmp[6] = (real32_T)sin(rtb_Deg2R_idx_1);
    b0a8:	ba 2f 9f    	mov.w     w10, [w15-170]
    b0aa:	cb 2f 9f    	mov.w     w11, [w15-168]
    tmp[7] = 0.0F;
    b0ac:	60 00 b8    	mul.uu    w0, #0x0, w0
    b0ae:	d0 2f 9f    	mov.w     w0, [w15-166]
    b0b0:	e1 2f 9f    	mov.w     w1, [w15-164]

0000b0b2 <.L0>:
    b0b2:	5f 99 97    	mov.w     [w15-70], w2
    b0b4:	ef 99 97    	mov.w     [w15-68], w3
    b0b6:	7f a8 97    	mov.w     [w15-34], w0
    b0b8:	8f b0 97    	mov.w     [w15-32], w1
    b0ba:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b0bc:	00 00 00 
    b0be:	00 04 be    	mov.d     w0, w8

0000b0c0 <.L0>:
    b0c0:	7f 99 97    	mov.w     [w15-66], w2
    b0c2:	8f a1 97    	mov.w     [w15-64], w3
    b0c4:	3f 90 97    	mov.w     [w15-90], w0
    b0c6:	cf 90 97    	mov.w     [w15-88], w1
    b0c8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b0ca:	00 00 00 
    b0cc:	00 01 be    	mov.d     w0, w2

0000b0ce <.L0>:
    tmp[8] = (real32_T)cos(rtb_Deg2R_idx_1);

    /* Sum: '<S483>/Sum1' */
    rtb_ixk = rtb_jxi - rtb_RhhcosphicoslambXe;
    b0ce:	08 00 be    	mov.d     w8, w0
    b0d0:	90 14 02    	call      0x1490 <___subsf3>
    b0d2:	00 00 00 
    b0d4:	d0 a7 9f    	mov.w     w0, [w15-54]
    b0d6:	e1 a7 9f    	mov.w     w1, [w15-52]

0000b0d8 <.L0>:
    b0d8:	1f a1 97    	mov.w     [w15-62], w2
    b0da:	af a1 97    	mov.w     [w15-60], w3
    b0dc:	7f a8 97    	mov.w     [w15-34], w0
    b0de:	8f b0 97    	mov.w     [w15-32], w1
    b0e0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b0e2:	00 00 00 
    b0e4:	00 04 be    	mov.d     w0, w8

0000b0e6 <.L0>:
    b0e6:	3f 99 97    	mov.w     [w15-74], w2
    b0e8:	cf 99 97    	mov.w     [w15-72], w3
    b0ea:	3f 90 97    	mov.w     [w15-90], w0
    b0ec:	cf 90 97    	mov.w     [w15-88], w1
    b0ee:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b0f0:	00 00 00 
    b0f2:	00 01 be    	mov.d     w0, w2

0000b0f4 <.L0>:
    rtb_Deg2R1 = rtb_kxj - rtb_RhhcosphisinlambYe;
    b0f4:	08 00 be    	mov.d     w8, w0
    b0f6:	90 14 02    	call      0x1490 <___subsf3>
    b0f8:	00 00 00 
    b0fa:	d0 af 9f    	mov.w     w0, [w15-38]
    b0fc:	e1 af 9f    	mov.w     w1, [w15-36]

0000b0fe <.L0>:
    b0fe:	92 94 24    	mov.w     #0x4949, w2
    b100:	e3 f7 23    	mov.w     #0x3f7e, w3
    b102:	1f a8 97    	mov.w     [w15-46], w0
    b104:	af a8 97    	mov.w     [w15-44], w1
    b106:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b108:	00 00 00 
    b10a:	00 01 be    	mov.d     w0, w2
    b10c:	7f a0 97    	mov.w     [w15-50], w0
    b10e:	8f a8 97    	mov.w     [w15-48], w1
    b110:	92 14 02    	call      0x1492 <___addsf3>
    b112:	00 00 00 
    b114:	5f b1 97    	mov.w     [w15-22], w2
    b116:	ef b1 97    	mov.w     [w15-20], w3
    b118:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b11a:	00 00 00 
    b11c:	00 04 be    	mov.d     w0, w8

0000b11e <.L0>:
    b11e:	92 94 24    	mov.w     #0x4949, w2
    b120:	e3 f7 23    	mov.w     #0x3f7e, w3
    b122:	3f a8 97    	mov.w     [w15-42], w0
    b124:	cf a8 97    	mov.w     [w15-40], w1
    b126:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b128:	00 00 00 
    b12a:	00 01 be    	mov.d     w0, w2
    b12c:	3f b0 97    	mov.w     [w15-26], w0
    b12e:	cf b0 97    	mov.w     [w15-24], w1
    b130:	92 14 02    	call      0x1492 <___addsf3>
    b132:	00 00 00 
    b134:	1f b1 97    	mov.w     [w15-30], w2
    b136:	af b1 97    	mov.w     [w15-28], w3
    b138:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b13a:	00 00 00 
    b13c:	00 01 be    	mov.d     w0, w2

0000b13e <.L0>:
    rtb_RhhcosphicoslambXe = rtb_kxi - rtb_ixj;
    b13e:	08 00 be    	mov.d     w8, w0
    b140:	90 14 02    	call      0x1490 <___subsf3>
    b142:	00 00 00 
    b144:	00 06 be    	mov.d     w0, w12
    b146:	e5 f3 2f    	mov.w     #0xff3e, w5
    b148:	8f 82 42    	add.w     w5, w15, w5
    b14a:	f4 82 42    	add.w     w5, #0x14, w5
    b14c:	95 b7 9f    	mov.w     w5, [w15-30]
    b14e:	e0 f3 2f    	mov.w     #0xff3e, w0
    b150:	0f 00 40    	add.w     w0, w15, w0
    b152:	68 00 40    	add.w     w0, #0x8, w0
    b154:	d0 b7 9f    	mov.w     w0, [w15-22]
    b156:	e1 f3 2f    	mov.w     #0xff3e, w1
    b158:	8f 80 40    	add.w     w1, w15, w1
    b15a:	e4 80 50    	sub.w     w1, #0x4, w1
    b15c:	f1 a7 9f    	mov.w     w1, [w15-50]
    b15e:	e2 f5 2f    	mov.w     #0xff5e, w2
    b160:	02 81 47    	add.w     w15, w2, w2
    b162:	b2 b7 9f    	mov.w     w2, [w15-26]

0000b164 <.L0>:

    /* Product: '<S547>/Product1' incorporates:
     *  Gain: '<S483>/UEN 2 NEU'
     */
    for (colIdx = 0; colIdx < 3; colIdx++) {
    b164:	00 07 eb    	clr.w     w14

0000b166 <.L0>:
      tmp_0[colIdx] = tmp[colIdx + 6] * rtb_RhhcosphicoslambXe + (tmp[colIdx + 3]
    b166:	1f b2 97    	mov.w     [w15-30], w4
    b168:	54 01 be    	mov.d     [++w4], w2
    b16a:	94 b7 9f    	mov.w     w4, [w15-30]
    b16c:	0c 00 be    	mov.d     w12, w0
    b16e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b170:	00 00 00 
    b172:	00 05 be    	mov.d     w0, w10

0000b174 <.L0>:
        * rtb_Deg2R1 + tmp[colIdx] * rtb_ixk);
    b174:	df b2 97    	mov.w     [w15-22], w5
    b176:	55 01 be    	mov.d     [++w5], w2
    b178:	d5 b7 9f    	mov.w     w5, [w15-22]
    b17a:	5f a8 97    	mov.w     [w15-38], w0
    b17c:	ef a8 97    	mov.w     [w15-36], w1
    b17e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b180:	00 00 00 
    b182:	00 04 be    	mov.d     w0, w8
    b184:	7f a0 97    	mov.w     [w15-50], w0
    b186:	50 01 be    	mov.d     [++w0], w2
    b188:	f0 a7 9f    	mov.w     w0, [w15-50]
    b18a:	5f a0 97    	mov.w     [w15-54], w0
    b18c:	ef a0 97    	mov.w     [w15-52], w1
    b18e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b190:	00 00 00 
    b192:	00 01 be    	mov.d     w0, w2
    b194:	08 00 be    	mov.d     w8, w0
    b196:	92 14 02    	call      0x1492 <___addsf3>
    b198:	00 00 00 
    b19a:	00 01 be    	mov.d     w0, w2

0000b19c <.L0>:
    b19c:	0a 00 be    	mov.d     w10, w0
    b19e:	92 14 02    	call      0x1492 <___addsf3>
    b1a0:	00 00 00 
    b1a2:	3f b1 97    	mov.w     [w15-26], w2
    b1a4:	00 a9 be    	mov.d     w0, [++w2]
    b1a6:	b2 b7 9f    	mov.w     w2, [w15-26]

0000b1a8 <.L0>:
    b1a8:	0e 07 e8    	inc.w     w14, w14
    b1aa:	e3 0f 57    	sub.w     w14, #0x3, [w15]
    b1ac:	dc ff 3a    	bra       NZ, 0xb166 <.L0> <.L21>
    }

    /* End of Product: '<S547>/Product1' */

    /* Inport: '<S481>/In1' */
    for (colIdx = 0; colIdx < 3; colIdx++) {
      /* Gain: '<S483>/UEN 2 NEU' */
      AUAV_V3_TestSensors_B.In1[colIdx] = 0.0F;
      AUAV_V3_TestSensors_B.In1[colIdx] +=
        AUAV_V3_TestSensors_ConstP.pooled62[colIdx] * tmp_0[0];
    b1ae:	1f 35 97    	mov.w     [w15-158], w10
    b1b0:	af 35 97    	mov.w     [w15-156], w11
      AUAV_V3_TestSensors_B.In1[colIdx] +=
        AUAV_V3_TestSensors_ConstP.pooled62[colIdx + 3] * tmp_0[1];
    b1b2:	3f 36 97    	mov.w     [w15-154], w12
    b1b4:	cf 36 97    	mov.w     [w15-152], w13
      AUAV_V3_TestSensors_B.In1[colIdx] +=
        AUAV_V3_TestSensors_ConstP.pooled62[colIdx + 6] * tmp_0[2];
    b1b6:	5f 32 97    	mov.w     [w15-150], w4
    b1b8:	ef 32 97    	mov.w     [w15-148], w5
    b1ba:	d4 a7 9f    	mov.w     w4, [w15-54]
    b1bc:	e5 a7 9f    	mov.w     w5, [w15-52]
    b1be:	c5 73 2c    	mov.w     #0xc73c, w5
    b1c0:	95 b7 9f    	mov.w     w5, [w15-30]
    b1c2:	6c 80 42    	add.w     w5, #0xc, w0
    b1c4:	d0 b7 9f    	mov.w     w0, [w15-22]
    b1c6:	ec 00 40    	add.w     w0, #0xc, w1
    b1c8:	f1 a7 9f    	mov.w     w1, [w15-50]
    b1ca:	e2 76 21    	mov.w     #0x176e, w2
    b1cc:	b2 b7 9f    	mov.w     w2, [w15-26]
    b1ce:	00 07 eb    	clr.w     w14

0000b1d0 <.L0>:
    b1d0:	1f b2 97    	mov.w     [w15-30], w4
    b1d2:	54 01 be    	mov.d     [++w4], w2
    b1d4:	94 b7 9f    	mov.w     w4, [w15-30]
    b1d6:	0a 00 be    	mov.d     w10, w0
    b1d8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b1da:	00 00 00 

0000b1dc <.L0>:
    b1dc:	60 11 b8    	mul.uu    w2, #0x0, w2
    b1de:	92 14 02    	call      0x1492 <___addsf3>
    b1e0:	00 00 00 
    b1e2:	00 04 be    	mov.d     w0, w8

0000b1e4 <.L0>:
    b1e4:	df b2 97    	mov.w     [w15-22], w5
    b1e6:	55 01 be    	mov.d     [++w5], w2
    b1e8:	d5 b7 9f    	mov.w     w5, [w15-22]
    b1ea:	0c 00 be    	mov.d     w12, w0
    b1ec:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b1ee:	00 00 00 
    b1f0:	00 01 be    	mov.d     w0, w2

0000b1f2 <.L0>:
    b1f2:	08 00 be    	mov.d     w8, w0
    b1f4:	92 14 02    	call      0x1492 <___addsf3>
    b1f6:	00 00 00 
    b1f8:	00 04 be    	mov.d     w0, w8

0000b1fa <.L0>:
    b1fa:	7f a0 97    	mov.w     [w15-50], w0
    b1fc:	50 01 be    	mov.d     [++w0], w2
    b1fe:	f0 a7 9f    	mov.w     w0, [w15-50]
    b200:	5f a0 97    	mov.w     [w15-54], w0
    b202:	ef a0 97    	mov.w     [w15-52], w1
    b204:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b206:	00 00 00 
    b208:	00 01 be    	mov.d     w0, w2

0000b20a <.L0>:
    b20a:	08 00 be    	mov.d     w8, w0
    b20c:	92 14 02    	call      0x1492 <___addsf3>
    b20e:	00 00 00 
    b210:	3f b1 97    	mov.w     [w15-26], w2
    b212:	00 a9 be    	mov.d     w0, [++w2]
    b214:	b2 b7 9f    	mov.w     w2, [w15-26]

0000b216 <.L0>:
    b216:	0e 07 e8    	inc.w     w14, w14
    b218:	e3 0f 57    	sub.w     w14, #0x3, [w15]
    b21a:	da ff 3a    	bra       NZ, 0xb1d0 <.L0> <.L22>
    }

    /* End of Inport: '<S481>/In1' */

    /* Inport: '<S481>/In2' */
    AUAV_V3_TestSensors_B.In2 = AUAV_V3_TestSensors_B.Switch1[3];
    b21c:	34 b5 80    	mov.w     0x16a6, w4
    b21e:	45 b5 80    	mov.w     0x16a8, w5
    b220:	f4 bb 88    	mov.w     w4, 0x177e
    b222:	05 bc 88    	mov.w     w5, 0x1780

    /* Inport: '<S481>/In3' */
    AUAV_V3_TestSensors_B.In3 = AUAV_V3_TestSensors_B.Switch1[4];
    b224:	50 b5 80    	mov.w     0x16aa, w0
    b226:	61 b5 80    	mov.w     0x16ac, w1
    b228:	10 bc 88    	mov.w     w0, 0x1782
    b22a:	21 bc 88    	mov.w     w1, 0x1784

0000b22c <.L0>:
  }

  /* End of Outputs for SubSystem: '<S14>/Enabled Subsystem' */

  /* Gain: '<S536>/Unit Conversion' */
  AUAV_V3_TestSensors_B.UnitConversion = 0.0174532924F *
    b22c:	52 a3 2f    	mov.w     #0xfa35, w2
    b22e:	e3 c8 23    	mov.w     #0x3c8e, w3
    b230:	f0 bb 80    	mov.w     0x177e, w0
    b232:	01 bc 80    	mov.w     0x1780, w1
    b234:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b236:	00 00 00 
    b238:	68 72 21    	mov.w     #0x1726, w8
    b23a:	00 8c be    	mov.d     w0, [w8]

0000b23c <.L0>:
    AUAV_V3_TestSensors_B.In2;

  /* S-Function (MCHP_C_function_Call): '<S537>/[apUtils.c]1' */
  AUAV_V3_TestSensors_B.apUtilsc1 = myCos(
    b23c:	32 10 02    	call      0x11032 <_myCos>
    b23e:	01 00 00 
    b240:	64 06 44    	add.w     w8, #0x4, w12
    b242:	00 8e be    	mov.d     w0, [w12]

0000b244 <.L0>:
    AUAV_V3_TestSensors_B.UnitConversion
    );

  /* S-Function (MCHP_C_function_Call): '<S537>/[apUtils.c]' */
  AUAV_V3_TestSensors_B.apUtilsc_a = mySin(
    b244:	18 00 be    	mov.d     [w8], w0
    b246:	2c 10 02    	call      0x1102c <_mySin>
    b248:	01 00 00 
    b24a:	00 04 be    	mov.d     w0, w8
    b24c:	70 b9 88    	mov.w     w0, 0x172e
    b24e:	81 b9 88    	mov.w     w1, 0x1730

0000b250 <.L0>:
    AUAV_V3_TestSensors_B.UnitConversion
    );

  /* Product: '<S479>/Product1' */
  /* MATLAB Function 'Position_and_Attitude_Filter/COG.SOG2V/myMux Fun2': '<S538>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S538>:1:5' */
  rtb_Deg2R_idx_0 = AUAV_V3_TestSensors_B.In3 * AUAV_V3_TestSensors_B.apUtilsc1;
    b250:	1a bc 80    	mov.w     0x1782, w10
    b252:	2b bc 80    	mov.w     0x1784, w11
    b254:	1c 01 be    	mov.d     [w12], w2
    b256:	0a 00 be    	mov.d     w10, w0
    b258:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b25a:	00 00 00 
    b25c:	b0 8f 9f    	mov.w     w0, [w15-106]
    b25e:	c1 8f 9f    	mov.w     w1, [w15-104]

0000b260 <.L0>:

  /* Product: '<S479>/Product' */
  rtb_Deg2R_idx_1 = AUAV_V3_TestSensors_B.apUtilsc_a * AUAV_V3_TestSensors_B.In3;
    b260:	0a 01 be    	mov.d     w10, w2
    b262:	08 00 be    	mov.d     w8, w0
    b264:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b266:	00 00 00 
    b268:	90 8f 9f    	mov.w     w0, [w15-110]
    b26a:	a1 8f 9f    	mov.w     w1, [w15-108]

0000b26c <.L0>:

  /* Abs: '<S541>/Abs1' incorporates:
   *  Sum: '<S544>/Diff'
   *  UnitDelay: '<S544>/UD'
   */
  rtb_ixk = (real32_T)fabs(AUAV_V3_TestSensors_B.In1[0] -
    b26c:	02 ee 80    	mov.w     0x1dc0, w2
    b26e:	13 ee 80    	mov.w     0x1dc2, w3
    b270:	90 bb 80    	mov.w     0x1772, w0
    b272:	a1 bb 80    	mov.w     0x1774, w1
    b274:	90 14 02    	call      0x1490 <___subsf3>
    b276:	00 00 00 
    b278:	00 04 be    	mov.d     w0, w8
    b27a:	09 f0 a1    	bclr.w    w9, #0xf

0000b27c <.L0>:
    AUAV_V3_TestSensors_DWork.UD_DSTATE);

  /* Abs: '<S542>/Abs1' incorporates:
   *  Sum: '<S545>/Diff'
   *  UnitDelay: '<S545>/UD'
   */
  rtb_Deg2R1 = (real32_T)fabs(AUAV_V3_TestSensors_B.In1[1] -
    b27c:	22 ee 80    	mov.w     0x1dc4, w2
    b27e:	33 ee 80    	mov.w     0x1dc6, w3
    b280:	b0 bb 80    	mov.w     0x1776, w0
    b282:	c1 bb 80    	mov.w     0x1778, w1
    b284:	90 14 02    	call      0x1490 <___subsf3>
    b286:	00 00 00 
    b288:	00 05 be    	mov.d     w0, w10
    b28a:	0b f0 a1    	bclr.w    w11, #0xf

0000b28c <.L0>:
    AUAV_V3_TestSensors_DWork.UD_DSTATE_o);

  /* Abs: '<S543>/Abs1' incorporates:
   *  Sum: '<S546>/Diff'
   *  UnitDelay: '<S546>/UD'
   */
  rtb_RhhcosphicoslambXe = (real32_T)fabs(AUAV_V3_TestSensors_B.In1[2] -
    b28c:	42 ee 80    	mov.w     0x1dc8, w2
    b28e:	53 ee 80    	mov.w     0x1dca, w3
    b290:	d0 bb 80    	mov.w     0x177a, w0
    b292:	e1 bb 80    	mov.w     0x177c, w1
    b294:	90 14 02    	call      0x1490 <___subsf3>
    b296:	00 00 00 
    b298:	00 06 be    	mov.d     w0, w12
    b29a:	0d f0 a1    	bclr.w    w13, #0xf

0000b29c <.L0>:
    AUAV_V3_TestSensors_DWork.UD_DSTATE_o2);

  /* Saturate: '<S541>/Saturation1' */
  if (rtb_ixk > 1.0F) {
    b29c:	02 00 20    	mov.w     #0x0, w2
    b29e:	03 f8 23    	mov.w     #0x3f80, w3
    b2a0:	08 00 be    	mov.d     w8, w0
    b2a2:	90 18 02    	call      0x1890 <___gesf2>
    b2a4:	00 00 00 
    b2a6:	00 00 e0    	cp0.w     w0
    b2a8:	02 00 34    	bra       LE, 0xb2ae <.L0> <.L23>

0000b2aa <.L0>:
    rtb_ixk = 1.0F;
    b2aa:	08 00 20    	mov.w     #0x0, w8
    b2ac:	09 f8 23    	mov.w     #0x3f80, w9

0000b2ae <.L0>:
  }

  /* Saturate: '<S542>/Saturation1' */
  if (rtb_Deg2R1 > 1.0F) {
    b2ae:	02 00 20    	mov.w     #0x0, w2
    b2b0:	03 f8 23    	mov.w     #0x3f80, w3
    b2b2:	0a 00 be    	mov.d     w10, w0
    b2b4:	90 18 02    	call      0x1890 <___gesf2>
    b2b6:	00 00 00 
    b2b8:	00 00 e0    	cp0.w     w0
    b2ba:	02 00 34    	bra       LE, 0xb2c0 <.L0> <.L24>

0000b2bc <.L0>:
    rtb_Deg2R1 = 1.0F;
    b2bc:	0a 00 20    	mov.w     #0x0, w10
    b2be:	0b f8 23    	mov.w     #0x3f80, w11

0000b2c0 <.L0>:
  }

  /* Saturate: '<S543>/Saturation1' */
  if (rtb_RhhcosphicoslambXe > 1.0F) {
    b2c0:	02 00 20    	mov.w     #0x0, w2
    b2c2:	03 f8 23    	mov.w     #0x3f80, w3
    b2c4:	0c 00 be    	mov.d     w12, w0
    b2c6:	90 18 02    	call      0x1890 <___gesf2>
    b2c8:	00 00 00 
    b2ca:	00 00 e0    	cp0.w     w0
    b2cc:	02 00 34    	bra       LE, 0xb2d2 <.L0> <.L25>

0000b2ce <.L0>:
    rtb_RhhcosphicoslambXe = 1.0F;
    b2ce:	0c 00 20    	mov.w     #0x0, w12
    b2d0:	0d f8 23    	mov.w     #0x3f80, w13

0000b2d2 <.L0>:
  }

  /* Sum: '<S482>/Sum' incorporates:
   *  Saturate: '<S541>/Saturation1'
   *  Saturate: '<S542>/Saturation1'
   *  Saturate: '<S543>/Saturation1'
   */
  rtb_ixk = (rtb_ixk + rtb_Deg2R1) + rtb_RhhcosphicoslambXe;
    b2d2:	0a 01 be    	mov.d     w10, w2
    b2d4:	08 00 be    	mov.d     w8, w0
    b2d6:	92 14 02    	call      0x1492 <___addsf3>
    b2d8:	00 00 00 
    b2da:	0c 01 be    	mov.d     w12, w2
    b2dc:	92 14 02    	call      0x1492 <___addsf3>
    b2de:	00 00 00 
    b2e0:	00 04 be    	mov.d     w0, w8

0000b2e2 <.L0>:

  /* Saturate: '<S482>/Saturation1' */
  if (rtb_ixk > 1.0F) {
    b2e2:	02 00 20    	mov.w     #0x0, w2
    b2e4:	03 f8 23    	mov.w     #0x3f80, w3
    b2e6:	90 18 02    	call      0x1890 <___gesf2>
    b2e8:	00 00 00 
    b2ea:	00 00 e0    	cp0.w     w0
    b2ec:	02 00 34    	bra       LE, 0xb2f2 <.L0> <.L26>

0000b2ee <.L0>:
    rtb_ixk = 1.0F;
    b2ee:	08 00 20    	mov.w     #0x0, w8
    b2f0:	09 f8 23    	mov.w     #0x3f80, w9

0000b2f2 <.L0>:
  }

  /* DataTypeConversion: '<S482>/Data Type Conversion2' incorporates:
   *  Saturate: '<S482>/Saturation1'
   */
  rtb_RhhcosphicoslambXe = (real32_T)floor(rtb_ixk);
    b2f2:	08 00 be    	mov.d     w8, w0
    b2f4:	16 19 02    	call      0x1916 <_floorf>
    b2f6:	00 00 00 
    b2f8:	00 04 be    	mov.d     w0, w8

0000b2fa <.L0>:
  if (rtIsNaNF(rtb_RhhcosphicoslambXe) || rtIsInfF(rtb_RhhcosphicoslambXe)) {
    b2fa:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    b2fc:	01 00 00 
    rtb_DataTypeConversion2_h = 0U;
    b2fe:	00 45 eb    	clr.b     w10

0000b300 <.L0>:
    b300:	00 04 e0    	cp0.b     w0
    b302:	0d 00 3a    	bra       NZ, 0xb31e <.L0> <.L0> <.L27>
    b304:	08 00 be    	mov.d     w8, w0
    b306:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    b308:	01 00 00 
    b30a:	00 04 e0    	cp0.b     w0
    b30c:	08 00 3a    	bra       NZ, 0xb31e <.L0> <.L0> <.L27>

0000b30e <.L0>:
  } else {
    rtb_DataTypeConversion2_h = (uint8_T)(real32_T)fmod(rtb_RhhcosphicoslambXe,
    b30e:	02 00 20    	mov.w     #0x0, w2
    b310:	03 38 24    	mov.w     #0x4380, w3
    b312:	08 00 be    	mov.d     w8, w0
    b314:	26 19 02    	call      0x1926 <_fmodf>
    b316:	00 00 00 
    b318:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    b31a:	00 00 00 
    b31c:	00 45 78    	mov.b     w0, w10

0000b31e <.L0>:
      256.0F);
  }

  /* End of DataTypeConversion: '<S482>/Data Type Conversion2' */

  /* Outputs for Enabled SubSystem: '<S552>/Subsystem' incorporates:
   *  EnablePort: '<S560>/Enable'
   */
  /* RelationalOperator: '<S558>/Compare' incorporates:
   *  Constant: '<S558>/Constant'
   */
  if ((AUAV_V3_TestSensors_B.In3 > 7.0F) > 0) {
    b31e:	02 00 20    	mov.w     #0x0, w2
    b320:	03 0e 24    	mov.w     #0x40e0, w3
    b322:	10 bc 80    	mov.w     0x1782, w0
    b324:	21 bc 80    	mov.w     0x1784, w1
    b326:	90 18 02    	call      0x1890 <___gesf2>
    b328:	00 00 00 
    b32a:	00 00 e0    	cp0.w     w0
    b32c:	12 00 34    	bra       LE, 0xb352 <.L0> <.L137>

0000b32e <.L0>:
    if (!AUAV_V3_TestSensors_DWork.Subsystem_MODE) {
    b32e:	b0 00 22    	mov.w     #0x200b, w0
    b330:	10 04 e0    	cp0.b     [w0]
    b332:	02 00 3a    	bra       NZ, 0xb338 <.L0> <.L30>
      AUAV_V3_TestSensors_DWork.Subsystem_MODE = true;
    b334:	11 c0 b3    	mov.b     #0x1, w1
    b336:	01 48 78    	mov.b     w1, [w0]

0000b338 <.L0>:
    }

    /* MATLAB Function: '<S560>/Embedded MATLAB Function1' */
    AU_EmbeddedMATLABFunction1(rtb_Deg2R_idx_1, rtb_DataTypeConversion2_h,
    b338:	c4 17 22    	mov.w     #0x217c, w4
    b33a:	83 bf 21    	mov.w     #0x1bf8, w3
    b33c:	0a 41 78    	mov.b     w10, w2
    b33e:	1f 88 97    	mov.w     [w15-110], w0
    b340:	af 88 97    	mov.w     [w15-108], w1
    b342:	c5 fb 07    	rcall     0xaace <_AU_EmbeddedMATLABFunction1> <L0> <.LFB1468> <.LFE1467>

0000b344 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_k,
      &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_k);

    /* MATLAB Function: '<S560>/Embedded MATLAB Function2' */
    AU_EmbeddedMATLABFunction1(rtb_Deg2R_idx_0, rtb_DataTypeConversion2_h,
    b344:	a4 16 22    	mov.w     #0x216a, w4
    b346:	43 bf 21    	mov.w     #0x1bf4, w3
    b348:	0a 41 78    	mov.b     w10, w2
    b34a:	3f 88 97    	mov.w     [w15-106], w0
    b34c:	cf 88 97    	mov.w     [w15-104], w1
    b34e:	bf fb 07    	rcall     0xaace <_AU_EmbeddedMATLABFunction1> <L0> <.LFB1468> <.LFE1467>
    b350:	0a 00 37    	bra       0xb366 <.L31>

0000b352 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2,
      &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2);
  } else {
    if (AUAV_V3_TestSensors_DWork.Subsystem_MODE) {
    b352:	b0 00 22    	mov.w     #0x200b, w0
    b354:	10 04 e0    	cp0.b     [w0]
    b356:	07 00 32    	bra       Z, 0xb366 <.L31>
      /* Disable for Outport: '<S560>/Vn_fil' */
      AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2.y = 0.0F;
    b358:	60 00 b8    	mul.uu    w0, #0x0, w0
    b35a:	a0 df 88    	mov.w     w0, 0x1bf4
    b35c:	b1 df 88    	mov.w     w1, 0x1bf6

      /* Disable for Outport: '<S560>/Ve_fil' */
      AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_k.y = 0.0F;
    b35e:	c0 df 88    	mov.w     w0, 0x1bf8
    b360:	d1 df 88    	mov.w     w1, 0x1bfa
      AUAV_V3_TestSensors_DWork.Subsystem_MODE = false;
    b362:	b0 00 22    	mov.w     #0x200b, w0
    b364:	00 48 eb    	clr.b     [w0]

0000b366 <.L31>:
    }
  }

  /* End of RelationalOperator: '<S558>/Compare' */
  /* End of Outputs for SubSystem: '<S552>/Subsystem' */

  /* MATLAB Function: '<S553>/Embedded MATLAB Function3' incorporates:
   *  Gain: '<S14>/[1 1 -1]'
   */
  /* MATLAB Function 'Position_and_Attitude_Filter/Position Filter/BlendPosVel/2 FIlter Blend/Embedded MATLAB Function3': '<S563>:1' */
  /*  persistent lastH; */
  if (!AUAV_V3_TestSensors_DWork.lastGps_h_not_empty) {
    b366:	00 00 22    	mov.w     #0x2000, w0
    b368:	10 04 e0    	cp0.b     [w0]
    b36a:	06 00 3a    	bra       NZ, 0xb378 <.L32>
    /* '<S563>:1:7' */
    AUAV_V3_TestSensors_DWork.lastGps_h_not_empty = true;
    b36c:	11 c0 b3    	mov.b     #0x1, w1
    b36e:	01 48 78    	mov.b     w1, [w0]

    /* '<S563>:1:9' */
    AUAV_V3_TestSensors_DWork.TimeSinceLast = 0.01F;
    b370:	a0 70 2d    	mov.w     #0xd70a, w0
    b372:	31 c2 23    	mov.w     #0x3c23, w1
    b374:	c0 fe 88    	mov.w     w0, 0x1fd8
    b376:	d1 fe 88    	mov.w     w1, 0x1fda

0000b378 <.L32>:

    /*      lastH           = single(-baseHeight); */
    /*      h_rate          = single(0); */
  }

  if (rtb_DataTypeConversion2_h != 0) {
    /* '<S563>:1:16' */
    rtb_RhhcosphicoslambXe = (-AUAV_V3_TestSensors_B.In1[2] -
      AUAV_V3_TestSensors_DWork.lastGps_h) /
      AUAV_V3_TestSensors_DWork.TimeSinceLast;

    /* '<S563>:1:17' */
    AUAV_V3_TestSensors_DWork.TimeSinceLast = 0.0F;
    if (!((rtb_RhhcosphicoslambXe > -10.6) && (rtb_RhhcosphicoslambXe < 17.67)))
    {
      /*          h = lastH; */
      /* '<S563>:1:23' */
      rtb_RhhcosphicoslambXe = 0.0F;
    } else {
      /* '<S563>:1:18' */
      /*          h = lastH + gps_h - lastGps_h; */
      /* '<S563>:1:20' */
    }

    /* '<S563>:1:25' */
    AUAV_V3_TestSensors_DWork.lastGps_h = -AUAV_V3_TestSensors_B.In1[2];
  } else {
    /*      h = lastH; */
    /* '<S563>:1:28' */
    rtb_RhhcosphicoslambXe = 0.0F;
    b378:	60 44 b8    	mul.uu    w8, #0x0, w8
    b37a:	0a 04 e0    	cp0.b     w10
    b37c:	2b 00 32    	bra       Z, 0xb3d4 <.L0> <.L33>

0000b37e <.L0>:
    b37e:	da bb 80    	mov.w     0x177a, w10
    b380:	eb bb 80    	mov.w     0x177c, w11
    b382:	0b f0 a2    	btg.w     w11, #0xf
    b384:	a2 fe 80    	mov.w     0x1fd4, w2
    b386:	b3 fe 80    	mov.w     0x1fd6, w3
    b388:	0a 00 be    	mov.d     w10, w0
    b38a:	90 14 02    	call      0x1490 <___subsf3>
    b38c:	00 00 00 

0000b38e <.L0>:
    b38e:	8c fd 21    	mov.w     #0x1fd8, w12

0000b390 <.L0>:
    b390:	1c 01 be    	mov.d     [w12], w2
    b392:	26 17 02    	call      0x1726 <___divsf3>
    b394:	00 00 00 
    b396:	00 04 be    	mov.d     w0, w8

0000b398 <.L0>:
    b398:	60 00 b8    	mul.uu    w0, #0x0, w0
    b39a:	00 8e be    	mov.d     w0, [w12]

0000b39c <.L0>:
    b39c:	1c c0 b3    	mov.b     #0x1, w12
    b39e:	a2 99 29    	mov.w     #0x999a, w2
    b3a0:	93 12 2c    	mov.w     #0xc129, w3
    b3a2:	08 00 be    	mov.d     w8, w0
    b3a4:	90 18 02    	call      0x1890 <___gesf2>
    b3a6:	00 00 00 
    b3a8:	00 00 e0    	cp0.w     w0
    b3aa:	01 00 3c    	bra       GT, 0xb3ae <.L35>
    b3ac:	00 46 eb    	clr.b     w12

0000b3ae <.L35>:
    b3ae:	0c 04 e0    	cp0.b     w12
    b3b0:	0c 00 32    	bra       Z, 0xb3ca <.L0> <.L98>
    b3b2:	1c c0 b3    	mov.b     #0x1, w12
    b3b4:	92 c2 25    	mov.w     #0x5c29, w2
    b3b6:	d3 18 24    	mov.w     #0x418d, w3
    b3b8:	08 00 be    	mov.d     w8, w0
    b3ba:	8c 18 02    	call      0x188c <___eqsf2>
    b3bc:	00 00 00 
    b3be:	00 00 e0    	cp0.w     w0
    b3c0:	01 00 35    	bra       LT, 0xb3c4 <.L36>
    b3c2:	00 46 eb    	clr.b     w12

0000b3c4 <.L36>:
    b3c4:	0c 04 e0    	cp0.b     w12
    b3c6:	03 00 32    	bra       Z, 0xb3ce <.L99>
    b3c8:	03 00 37    	bra       0xb3d0 <.L34>

0000b3ca <.L0>:
    b3ca:	60 44 b8    	mul.uu    w8, #0x0, w8
    b3cc:	01 00 37    	bra       0xb3d0 <.L34>

0000b3ce <.L99>:
    b3ce:	60 44 b8    	mul.uu    w8, #0x0, w8

0000b3d0 <.L34>:
    b3d0:	aa fe 88    	mov.w     w10, 0x1fd4
    b3d2:	bb fe 88    	mov.w     w11, 0x1fd6

0000b3d4 <.L0>:
  }

  /* '<S563>:1:31' */
  AUAV_V3_TestSensors_DWork.TimeSinceLast += 0.01F;
    b3d4:	8a fd 21    	mov.w     #0x1fd8, w10
    b3d6:	a2 70 2d    	mov.w     #0xd70a, w2
    b3d8:	33 c2 23    	mov.w     #0x3c23, w3
    b3da:	1a 00 be    	mov.d     [w10], w0
    b3dc:	92 14 02    	call      0x1492 <___addsf3>
    b3de:	00 00 00 
    b3e0:	00 8d be    	mov.d     w0, [w10]

0000b3e2 <.L0>:

  /* End of MATLAB Function: '<S553>/Embedded MATLAB Function3' */

  /* MATLAB Function: '<S564>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S564>/Constant'
   *  Constant: '<S564>/Constant1'
   *  Gain: '<S552>/Gain'
   *  Gain: '<S553>/Gain'
   *  Sum: '<S553>/Sum'
   */
  /*  lastH = h; */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5 */
  /*  persistent lastGps_h; */
  /*  persistent TimeSinceLast; */
  /*  persistent rate; */
  /*  persistent lastH; */
  /*   */
  /*  if (isempty(lastGps_h)) */
  /*      lastGps_h       = single(0.0); */
  /*      TimeSinceLast   = single(apSampleTime); */
  /*      rate            = single(0); */
  /*      lastH           = single(-baseHeight); */
  /*      h_rate          = single(0); */
  /*  end */
  /*   */
  /*  if (NewGPS) */
  /*      rate = single((gps_h - lastGps_h)/TimeSinceLast); */
  /*      TimeSinceLast = single(0); */
  /*      if (rate > -10.6) && (rate < 17.67) */
  /*          h = lastH + gps_h - lastGps_h; */
  /*  %         h_rate = rate; */
  /*      else */
  /*          h = lastH; */
  /*  %         h_rate = single(0); */
  /*      end */
  /*      lastGps_h = gps_h; */
  /*  else */
  /*      h = lastH; */
  /*  %     h_rate = single(0); */
  /*  end */
  /*   */
  /*  TimeSinceLast = TimeSinceLast + apSampleTime; */
  /*  lastH = h; */
  AUA_EmbeddedMATLABFunction(0.5F * rtb_RhhcosphicoslambXe +
    b3e2:	02 00 20    	mov.w     #0x0, w2
    b3e4:	03 f0 23    	mov.w     #0x3f00, w3
    b3e6:	08 00 be    	mov.d     w8, w0
    b3e8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b3ea:	00 00 00 
    b3ec:	82 db 80    	mov.w     0x1b70, w2
    b3ee:	93 db 80    	mov.w     0x1b72, w3
    b3f0:	90 14 02    	call      0x1490 <___subsf3>
    b3f2:	00 00 00 
    b3f4:	67 1b 20    	mov.w     #0x1b6, w7
    b3f6:	8a 83 43    	add.w     w7, w10, w7
    b3f8:	86 c0 21    	mov.w     #0x1c08, w6
    b3fa:	34 98 2f    	mov.w     #0xf983, w4
    b3fc:	25 ea 23    	mov.w     #0x3ea2, w5
    b3fe:	a2 70 2d    	mov.w     #0xd70a, w2
    b400:	33 c2 23    	mov.w     #0x3c23, w3
    b402:	ee 0e 02    	call      0x10eee <_AUA_EmbeddedMATLABFunction>
    b404:	01 00 00 

0000b406 <.L0>:
    -AUAV_V3_TestSensors_B.EnabledSubsystem_m.In1, 0.01, 0.31830988618379069,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ph,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_ph);

  /* Gain: '<S557>/Gain' incorporates:
   *  Sum: '<S557>/Sum1'
   *  UnitDelay: '<S557>/Unit Delay'
   */
  rtb_jxi = (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ph.y -
    b406:	62 ee 80    	mov.w     0x1dcc, w2
    b408:	73 ee 80    	mov.w     0x1dce, w3
    b40a:	40 e0 80    	mov.w     0x1c08, w0
    b40c:	51 e0 80    	mov.w     0x1c0a, w1
    b40e:	90 14 02    	call      0x1490 <___subsf3>
    b410:	00 00 00 
    b412:	00 01 be    	mov.d     w0, w2
    b414:	92 14 02    	call      0x1492 <___addsf3>
    b416:	00 00 00 
    b418:	d0 9f 9f    	mov.w     w0, [w15-70]
    b41a:	e1 9f 9f    	mov.w     w1, [w15-68]

0000b41c <.L0>:
             AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE) * 2.0F;

  /* MATLAB Function: '<S552>/myMux Fun2' */
  AUAV_V3_TestSe_myMuxFun1_e(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2.y,
    b41c:	c6 bd 21    	mov.w     #0x1bdc, w6
    b41e:	00 02 be    	mov.d     w0, w4
    b420:	c2 df 80    	mov.w     0x1bf8, w2
    b422:	d3 df 80    	mov.w     0x1bfa, w3
    b424:	a0 df 80    	mov.w     0x1bf4, w0
    b426:	b1 df 80    	mov.w     0x1bf6, w1
    b428:	68 12 02    	call      0x11268 <_AUAV_V3_TestSe_myMuxFun1_e>
    b42a:	01 00 00 

0000b42c <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_k.y, rtb_jxi,
    &AUAV_V3_TestSensors_B.sf_myMuxFun2_a);

  /* Product: '<S478>/Product1' */
  for (colIdx = 0; colIdx < 3; colIdx++) {
    rtb_Product1_e[colIdx] = AUAV_V3_TestSensors_B.VectorConcatenate[colIdx + 6]
      * AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[2] +
    b42c:	2c df 80    	mov.w     0x1be4, w12
    b42e:	3d df 80    	mov.w     0x1be6, w13
      (AUAV_V3_TestSensors_B.VectorConcatenate[colIdx + 3] *
       AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[1] +
    b430:	04 df 80    	mov.w     0x1be0, w4
    b432:	15 df 80    	mov.w     0x1be2, w5
    b434:	b4 b7 9f    	mov.w     w4, [w15-26]
    b436:	c5 b7 9f    	mov.w     w5, [w15-24]
       AUAV_V3_TestSensors_B.VectorConcatenate[colIdx] *
       AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[0]);
    b438:	e0 de 80    	mov.w     0x1bdc, w0
    b43a:	f1 de 80    	mov.w     0x1bde, w1
    b43c:	d0 a7 9f    	mov.w     w0, [w15-54]
    b43e:	e1 a7 9f    	mov.w     w1, [w15-52]
    b440:	a1 6f 21    	mov.w     #0x16fa, w1
    b442:	91 b7 9f    	mov.w     w1, [w15-30]
    b444:	6c 81 50    	sub.w     w1, #0xc, w2
    b446:	f2 a7 9f    	mov.w     w2, [w15-50]
    b448:	f8 81 50    	sub.w     w1, #0x18, w3
    b44a:	d3 b7 9f    	mov.w     w3, [w15-22]
    b44c:	a4 ee 2f    	mov.w     #0xfeea, w4
    b44e:	04 82 47    	add.w     w15, w4, w4
    b450:	b4 af 9f    	mov.w     w4, [w15-42]
    b452:	83 02 78    	mov.w     w3, w5
    b454:	f5 af 9f    	mov.w     w5, [w15-34]
    b456:	02 00 78    	mov.w     w2, w0
    b458:	d0 af 9f    	mov.w     w0, [w15-38]
    b45a:	91 af 9f    	mov.w     w1, [w15-46]
    b45c:	3e 00 20    	mov.w     #0x3, w14

0000b45e <.L0>:
    b45e:	1f aa 97    	mov.w     [w15-46], w4
    b460:	54 01 be    	mov.d     [++w4], w2
    b462:	94 af 9f    	mov.w     w4, [w15-46]
    b464:	0c 00 be    	mov.d     w12, w0
    b466:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b468:	00 00 00 
    b46a:	00 05 be    	mov.d     w0, w10

0000b46c <.L0>:
    b46c:	df aa 97    	mov.w     [w15-38], w5
    b46e:	55 01 be    	mov.d     [++w5], w2
    b470:	d5 af 9f    	mov.w     w5, [w15-38]
    b472:	3f b0 97    	mov.w     [w15-26], w0
    b474:	cf b0 97    	mov.w     [w15-24], w1
    b476:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b478:	00 00 00 
    b47a:	00 04 be    	mov.d     w0, w8

0000b47c <.L0>:
    b47c:	7f a8 97    	mov.w     [w15-34], w0
    b47e:	50 01 be    	mov.d     [++w0], w2
    b480:	f0 af 9f    	mov.w     w0, [w15-34]
    b482:	5f a0 97    	mov.w     [w15-54], w0
    b484:	ef a0 97    	mov.w     [w15-52], w1
    b486:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b488:	00 00 00 
    b48a:	00 01 be    	mov.d     w0, w2

0000b48c <.L0>:
    b48c:	08 00 be    	mov.d     w8, w0
    b48e:	92 14 02    	call      0x1492 <___addsf3>
    b490:	00 00 00 
    b492:	00 01 be    	mov.d     w0, w2

0000b494 <.L0>:
    b494:	0a 00 be    	mov.d     w10, w0
    b496:	92 14 02    	call      0x1492 <___addsf3>
    b498:	00 00 00 

0000b49a <.L0>:
    b49a:	3f a9 97    	mov.w     [w15-42], w2
    b49c:	00 a9 be    	mov.d     w0, [++w2]
    b49e:	b2 af 9f    	mov.w     w2, [w15-42]
    b4a0:	0e 07 e9    	dec.w     w14, w14
    b4a2:	dd ff 3a    	bra       NZ, 0xb45e <.L0> <.L37>
    b4a4:	63 ef 2f    	mov.w     #0xfef6, w3
    b4a6:	83 81 47    	add.w     w15, w3, w3
    b4a8:	b3 af 9f    	mov.w     w3, [w15-42]
    b4aa:	5f b2 97    	mov.w     [w15-22], w4
    b4ac:	f4 af 9f    	mov.w     w4, [w15-34]
    b4ae:	ff a2 97    	mov.w     [w15-50], w5
    b4b0:	d5 af 9f    	mov.w     w5, [w15-38]
    b4b2:	1f b0 97    	mov.w     [w15-30], w0
    b4b4:	90 af 9f    	mov.w     w0, [w15-46]
    b4b6:	3e 00 20    	mov.w     #0x3, w14

0000b4b8 <.L0>:
  }

  /* End of Product: '<S478>/Product1' */

  /* Product: '<S552>/Product1' */
  for (colIdx = 0; colIdx < 3; colIdx++) {
    rtb_Product1_kx[colIdx] = AUAV_V3_TestSensors_B.VectorConcatenate[colIdx + 6]
      * AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[2] +
    b4b8:	9f a8 97    	mov.w     [w15-46], w1
    b4ba:	51 01 be    	mov.d     [++w1], w2
    b4bc:	91 af 9f    	mov.w     w1, [w15-46]
    b4be:	0c 00 be    	mov.d     w12, w0
    b4c0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b4c2:	00 00 00 
    b4c4:	00 05 be    	mov.d     w0, w10

0000b4c6 <.L0>:
      (AUAV_V3_TestSensors_B.VectorConcatenate[colIdx + 3] *
    b4c6:	5f aa 97    	mov.w     [w15-38], w4
    b4c8:	54 01 be    	mov.d     [++w4], w2
    b4ca:	d4 af 9f    	mov.w     w4, [w15-38]
    b4cc:	3f b0 97    	mov.w     [w15-26], w0
    b4ce:	cf b0 97    	mov.w     [w15-24], w1
    b4d0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b4d2:	00 00 00 
    b4d4:	00 04 be    	mov.d     w0, w8

0000b4d6 <.L0>:
       AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[1] +
       AUAV_V3_TestSensors_B.VectorConcatenate[colIdx] *
    b4d6:	ff aa 97    	mov.w     [w15-34], w5
    b4d8:	55 01 be    	mov.d     [++w5], w2
    b4da:	f5 af 9f    	mov.w     w5, [w15-34]
    b4dc:	5f a0 97    	mov.w     [w15-54], w0
    b4de:	ef a0 97    	mov.w     [w15-52], w1
    b4e0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b4e2:	00 00 00 
    b4e4:	00 01 be    	mov.d     w0, w2

0000b4e6 <.L0>:
    b4e6:	08 00 be    	mov.d     w8, w0
    b4e8:	92 14 02    	call      0x1492 <___addsf3>
    b4ea:	00 00 00 
    b4ec:	00 01 be    	mov.d     w0, w2

0000b4ee <.L0>:
    b4ee:	0a 00 be    	mov.d     w10, w0
    b4f0:	92 14 02    	call      0x1492 <___addsf3>
    b4f2:	00 00 00 

0000b4f4 <.L0>:
    b4f4:	3f a9 97    	mov.w     [w15-42], w2
    b4f6:	00 a9 be    	mov.d     w0, [++w2]
    b4f8:	b2 af 9f    	mov.w     w2, [w15-42]
    b4fa:	0e 07 e9    	dec.w     w14, w14
    b4fc:	dd ff 3a    	bra       NZ, 0xb4b8 <.L0> <.L38>

0000b4fe <.L0>:
       AUAV_V3_TestSensors_B.sf_myMuxFun2_a.y[0]);
  }

  /* End of Product: '<S552>/Product1' */

  /* Sum: '<S552>/Sum' incorporates:
   *  Delay: '<S559>/Integer Delay1'
   *  Gain: '<S559>/Gain2'
   *  Sum: '<S559>/Sum5'
   */
  rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_B.DataTypeConversion3[0] -
    (rtb_Product1_kx[0] - AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[0]) *
    b4fe:	62 f0 80    	mov.w     0x1e0c, w2
    b500:	73 f0 80    	mov.w     0x1e0e, w3
    b502:	5f b8 96    	mov.w     [w15-262], w0
    b504:	ef b8 96    	mov.w     [w15-260], w1
    b506:	90 14 02    	call      0x1490 <___subsf3>
    b508:	00 00 00 
    b50a:	02 00 20    	mov.w     #0x0, w2
    b50c:	03 1a 24    	mov.w     #0x41a0, w3
    b50e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b510:	00 00 00 
    b512:	00 01 be    	mov.d     w0, w2

0000b514 <.L0>:
    b514:	b0 b3 80    	mov.w     0x1676, w0
    b516:	c1 b3 80    	mov.w     0x1678, w1
    b518:	90 14 02    	call      0x1490 <___subsf3>
    b51a:	00 00 00 
    b51c:	d0 a7 9f    	mov.w     w0, [w15-54]
    b51e:	e1 a7 9f    	mov.w     w1, [w15-52]

0000b520 <.L0>:
    20.0F;
  rtb_Deg2R1 = AUAV_V3_TestSensors_B.DataTypeConversion3[1] - (rtb_Product1_kx[1]
    - AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[1]) * 20.0F;
    b520:	82 f0 80    	mov.w     0x1e10, w2
    b522:	93 f0 80    	mov.w     0x1e12, w3
    b524:	7f b8 96    	mov.w     [w15-258], w0
    b526:	8f 00 97    	mov.w     [w15-256], w1
    b528:	90 14 02    	call      0x1490 <___subsf3>
    b52a:	00 00 00 
    b52c:	02 00 20    	mov.w     #0x0, w2
    b52e:	03 1a 24    	mov.w     #0x41a0, w3
    b530:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b532:	00 00 00 
    b534:	00 01 be    	mov.d     w0, w2

0000b536 <.L0>:
    b536:	d0 b3 80    	mov.w     0x167a, w0
    b538:	e1 b3 80    	mov.w     0x167c, w1
    b53a:	90 14 02    	call      0x1490 <___subsf3>
    b53c:	00 00 00 
    b53e:	d0 af 9f    	mov.w     w0, [w15-38]
    b540:	e1 af 9f    	mov.w     w1, [w15-36]

0000b542 <.L0>:
  rtb_ixk = AUAV_V3_TestSensors_B.DataTypeConversion3[2] - (rtb_Product1_kx[2] -
    b542:	a2 f0 80    	mov.w     0x1e14, w2
    b544:	b3 f0 80    	mov.w     0x1e16, w3
    b546:	1f 00 97    	mov.w     [w15-254], w0
    b548:	af 00 97    	mov.w     [w15-252], w1
    b54a:	90 14 02    	call      0x1490 <___subsf3>
    b54c:	00 00 00 

0000b54e <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[2]) * 20.0F;
    b54e:	02 00 20    	mov.w     #0x0, w2
    b550:	03 1a 24    	mov.w     #0x41a0, w3
    b552:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b554:	00 00 00 
    b556:	00 01 be    	mov.d     w0, w2

0000b558 <.L0>:
    b558:	f0 b3 80    	mov.w     0x167e, w0
    b55a:	01 b4 80    	mov.w     0x1680, w1
    b55c:	90 14 02    	call      0x1490 <___subsf3>
    b55e:	00 00 00 
    b560:	90 af 9f    	mov.w     w0, [w15-46]
    b562:	a1 af 9f    	mov.w     w1, [w15-44]

0000b564 <.L0>:

  /* RateLimiter: '<S552>/Rate Limiter' */
  rtb_Add[0] = rtb_RhhcosphicoslambXe - AUAV_V3_TestSensors_DWork.PrevY[0];
    b564:	e0 fd 80    	mov.w     0x1fbc, w0
    b566:	f1 fd 80    	mov.w     0x1fbe, w1
    b568:	b0 b7 9f    	mov.w     w0, [w15-26]
    b56a:	c1 b7 9f    	mov.w     w1, [w15-24]
    b56c:	00 01 be    	mov.d     w0, w2
    b56e:	5f a0 97    	mov.w     [w15-54], w0
    b570:	ef a0 97    	mov.w     [w15-52], w1
    b572:	90 14 02    	call      0x1490 <___subsf3>
    b574:	00 00 00 
    b576:	00 04 be    	mov.d     w0, w8
    b578:	b0 07 9f    	mov.w     w0, [w15-250]
    b57a:	c1 07 9f    	mov.w     w1, [w15-248]

0000b57c <.L0>:
  rtb_Add[1] = rtb_Deg2R1 - AUAV_V3_TestSensors_DWork.PrevY[1];
    b57c:	02 fe 80    	mov.w     0x1fc0, w2
    b57e:	13 fe 80    	mov.w     0x1fc2, w3
    b580:	f2 af 9f    	mov.w     w2, [w15-34]
    b582:	83 b7 9f    	mov.w     w3, [w15-32]
    b584:	5f a8 97    	mov.w     [w15-38], w0
    b586:	ef a8 97    	mov.w     [w15-36], w1
    b588:	90 14 02    	call      0x1490 <___subsf3>
    b58a:	00 00 00 
    b58c:	00 05 be    	mov.d     w0, w10
    b58e:	d0 07 9f    	mov.w     w0, [w15-246]
    b590:	e1 07 9f    	mov.w     w1, [w15-244]

0000b592 <.L0>:
  rtb_Add[2] = rtb_ixk - AUAV_V3_TestSensors_DWork.PrevY[2];
    b592:	24 fe 80    	mov.w     0x1fc4, w4
    b594:	35 fe 80    	mov.w     0x1fc6, w5
    b596:	b4 af 9f    	mov.w     w4, [w15-42]
    b598:	c5 af 9f    	mov.w     w5, [w15-40]
    b59a:	04 01 be    	mov.d     w4, w2
    b59c:	1f a8 97    	mov.w     [w15-46], w0
    b59e:	af a8 97    	mov.w     [w15-44], w1
    b5a0:	90 14 02    	call      0x1490 <___subsf3>
    b5a2:	00 00 00 
    b5a4:	00 06 be    	mov.d     w0, w12
    b5a6:	f0 07 9f    	mov.w     w0, [w15-242]
    b5a8:	81 0f 9f    	mov.w     w1, [w15-240]

0000b5aa <.L0>:
  rtb_RhhcosphisinlambYe = rtb_RhhcosphicoslambXe;
  if (rtb_Add[0] > 9.896E-9F) {
    b5aa:	12 31 20    	mov.w     #0x311, w2
    b5ac:	a3 22 23    	mov.w     #0x322a, w3
    b5ae:	08 00 be    	mov.d     w8, w0
    b5b0:	90 18 02    	call      0x1890 <___gesf2>
    b5b2:	00 00 00 
    b5b4:	00 00 e0    	cp0.w     w0
    b5b6:	09 00 34    	bra       LE, 0xb5ca <.L0> <.L0> <.L138>

0000b5b8 <.L0>:
    rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[0] + 9.896E-9F;
    b5b8:	12 31 20    	mov.w     #0x311, w2
    b5ba:	a3 22 23    	mov.w     #0x322a, w3
    b5bc:	3f b0 97    	mov.w     [w15-26], w0
    b5be:	cf b0 97    	mov.w     [w15-24], w1
    b5c0:	92 14 02    	call      0x1492 <___addsf3>
    b5c2:	00 00 00 
    b5c4:	d0 a7 9f    	mov.w     w0, [w15-54]
    b5c6:	e1 a7 9f    	mov.w     w1, [w15-52]
    b5c8:	0f 00 37    	bra       0xb5e8 <.L0> <.L0> <.L41>

0000b5ca <.L0>:
  } else {
    if (rtb_Add[0] < -9.896E-9F) {
    b5ca:	12 31 20    	mov.w     #0x311, w2
    b5cc:	a3 22 2b    	mov.w     #0xb22a, w3
    b5ce:	08 00 be    	mov.d     w8, w0
    b5d0:	8c 18 02    	call      0x188c <___eqsf2>
    b5d2:	00 00 00 
    b5d4:	00 00 e0    	cp0.w     w0
    b5d6:	08 00 3d    	bra       GE, 0xb5e8 <.L0> <.L0> <.L41>

0000b5d8 <.L0>:
      rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[0] + -9.896E-9F;
    b5d8:	12 31 20    	mov.w     #0x311, w2
    b5da:	a3 22 23    	mov.w     #0x322a, w3
    b5dc:	3f b0 97    	mov.w     [w15-26], w0
    b5de:	cf b0 97    	mov.w     [w15-24], w1
    b5e0:	90 14 02    	call      0x1490 <___subsf3>
    b5e2:	00 00 00 
    b5e4:	d0 a7 9f    	mov.w     w0, [w15-54]
    b5e6:	e1 a7 9f    	mov.w     w1, [w15-52]

0000b5e8 <.L0>:
    }
  }

  rtb_RhhcosphicoslambXe = rtb_RhhcosphisinlambYe;
  rtb_RhhcosphisinlambYe = rtb_Deg2R1;
  if (rtb_Add[1] > 9.896E-9F) {
    b5e8:	12 31 20    	mov.w     #0x311, w2
    b5ea:	a3 22 23    	mov.w     #0x322a, w3
    b5ec:	0a 00 be    	mov.d     w10, w0
    b5ee:	90 18 02    	call      0x1890 <___gesf2>
    b5f0:	00 00 00 
    b5f2:	00 00 e0    	cp0.w     w0
    b5f4:	09 00 34    	bra       LE, 0xb608 <.L0> <.L0> <.L140>

0000b5f6 <.L0>:
    rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[1] + 9.896E-9F;
    b5f6:	12 31 20    	mov.w     #0x311, w2
    b5f8:	a3 22 23    	mov.w     #0x322a, w3
    b5fa:	7f a8 97    	mov.w     [w15-34], w0
    b5fc:	8f b0 97    	mov.w     [w15-32], w1
    b5fe:	92 14 02    	call      0x1492 <___addsf3>
    b600:	00 00 00 
    b602:	d0 af 9f    	mov.w     w0, [w15-38]
    b604:	e1 af 9f    	mov.w     w1, [w15-36]
    b606:	0f 00 37    	bra       0xb626 <.L0> <.L0> <.L45>

0000b608 <.L0>:
  } else {
    if (rtb_Add[1] < -9.896E-9F) {
    b608:	12 31 20    	mov.w     #0x311, w2
    b60a:	a3 22 2b    	mov.w     #0xb22a, w3
    b60c:	0a 00 be    	mov.d     w10, w0
    b60e:	8c 18 02    	call      0x188c <___eqsf2>
    b610:	00 00 00 
    b612:	00 00 e0    	cp0.w     w0
    b614:	08 00 3d    	bra       GE, 0xb626 <.L0> <.L0> <.L45>

0000b616 <.L0>:
      rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[1] + -9.896E-9F;
    b616:	12 31 20    	mov.w     #0x311, w2
    b618:	a3 22 23    	mov.w     #0x322a, w3
    b61a:	7f a8 97    	mov.w     [w15-34], w0
    b61c:	8f b0 97    	mov.w     [w15-32], w1
    b61e:	90 14 02    	call      0x1490 <___subsf3>
    b620:	00 00 00 
    b622:	d0 af 9f    	mov.w     w0, [w15-38]
    b624:	e1 af 9f    	mov.w     w1, [w15-36]

0000b626 <.L0>:
    }
  }

  rtb_Deg2R1 = rtb_RhhcosphisinlambYe;
  rtb_RhhcosphisinlambYe = rtb_ixk;
  if (rtb_Add[2] > 9.896E-9F) {
    b626:	12 31 20    	mov.w     #0x311, w2
    b628:	a3 22 23    	mov.w     #0x322a, w3
    b62a:	0c 00 be    	mov.d     w12, w0
    b62c:	90 18 02    	call      0x1890 <___gesf2>
    b62e:	00 00 00 
    b630:	00 00 e0    	cp0.w     w0
    b632:	09 00 34    	bra       LE, 0xb646 <.L0> <.L0> <.L142>

0000b634 <.L0>:
    rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[2] + 9.896E-9F;
    b634:	12 31 20    	mov.w     #0x311, w2
    b636:	a3 22 23    	mov.w     #0x322a, w3
    b638:	3f a8 97    	mov.w     [w15-42], w0
    b63a:	cf a8 97    	mov.w     [w15-40], w1
    b63c:	92 14 02    	call      0x1492 <___addsf3>
    b63e:	00 00 00 
    b640:	90 af 9f    	mov.w     w0, [w15-46]
    b642:	a1 af 9f    	mov.w     w1, [w15-44]
    b644:	0f 00 37    	bra       0xb664 <.L0> <.L49>

0000b646 <.L0>:
  } else {
    if (rtb_Add[2] < -9.896E-9F) {
    b646:	12 31 20    	mov.w     #0x311, w2
    b648:	a3 22 2b    	mov.w     #0xb22a, w3
    b64a:	0c 00 be    	mov.d     w12, w0
    b64c:	8c 18 02    	call      0x188c <___eqsf2>
    b64e:	00 00 00 
    b650:	00 00 e0    	cp0.w     w0
    b652:	08 00 3d    	bra       GE, 0xb664 <.L0> <.L49>

0000b654 <.L0>:
      rtb_RhhcosphisinlambYe = AUAV_V3_TestSensors_DWork.PrevY[2] + -9.896E-9F;
    b654:	12 31 20    	mov.w     #0x311, w2
    b656:	a3 22 23    	mov.w     #0x322a, w3
    b658:	3f a8 97    	mov.w     [w15-42], w0
    b65a:	cf a8 97    	mov.w     [w15-40], w1
    b65c:	90 14 02    	call      0x1490 <___subsf3>
    b65e:	00 00 00 
    b660:	90 af 9f    	mov.w     w0, [w15-46]
    b662:	a1 af 9f    	mov.w     w1, [w15-44]

0000b664 <.L0>:
    }
  }

  AUAV_V3_TestSensors_DWork.PrevY[0] = rtb_RhhcosphicoslambXe;
    b664:	5f a1 97    	mov.w     [w15-54], w2
    b666:	ef a1 97    	mov.w     [w15-52], w3
    b668:	e2 fd 88    	mov.w     w2, 0x1fbc
    b66a:	f3 fd 88    	mov.w     w3, 0x1fbe
  AUAV_V3_TestSensors_DWork.PrevY[1] = rtb_Deg2R1;
    b66c:	5f aa 97    	mov.w     [w15-38], w4
    b66e:	ef aa 97    	mov.w     [w15-36], w5
    b670:	04 fe 88    	mov.w     w4, 0x1fc0
    b672:	15 fe 88    	mov.w     w5, 0x1fc2
  AUAV_V3_TestSensors_DWork.PrevY[2] = rtb_RhhcosphisinlambYe;
    b674:	1f a8 97    	mov.w     [w15-46], w0
    b676:	af a8 97    	mov.w     [w15-44], w1
    b678:	20 fe 88    	mov.w     w0, 0x1fc4
    b67a:	31 fe 88    	mov.w     w1, 0x1fc6

0000b67c <.L0>:

  /* End of RateLimiter: '<S552>/Rate Limiter' */

  /* DataTypeConversion: '<S554>/Data Type Conversion2' */
  rtb_DataTypeConversion2_g[0] = rtb_RhhcosphicoslambXe;
  rtb_DataTypeConversion2_g[1] = rtb_Deg2R1;
  rtb_DataTypeConversion2_g[2] = rtb_RhhcosphisinlambYe;

  /* DiscreteZeroPole: '<S566>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_f = 9.8940417712526327E-7*rtb_DataTypeConversion2_g[0];
    b67c:	b2 ba 2c    	mov.w     #0xcbab, w2
    b67e:	43 58 23    	mov.w     #0x3584, w3
    b680:	5f a0 97    	mov.w     [w15-54], w0
    b682:	ef a0 97    	mov.w     [w15-52], w1
    b684:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b686:	00 00 00 
    b688:	00 06 be    	mov.d     w0, w12

0000b68a <.L0>:
    rtb_DiscreteZeroPole_f += 3.9156825028515473E-10*
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_o;
  }

  /* DiscreteZeroPole: '<S567>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_c = 9.8940417712526327E-7*rtb_DataTypeConversion2_g[1];
    b68a:	b2 ba 2c    	mov.w     #0xcbab, w2
    b68c:	43 58 23    	mov.w     #0x3584, w3
    b68e:	5f a8 97    	mov.w     [w15-38], w0
    b690:	ef a8 97    	mov.w     [w15-36], w1
    b692:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b694:	00 00 00 
    b696:	00 05 be    	mov.d     w0, w10

0000b698 <.L0>:
    rtb_DiscreteZeroPole_c += 3.9156825028515473E-10*
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_j;
  }

  /* DiscreteZeroPole: '<S568>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_ck = 9.8940417712526327E-7*rtb_DataTypeConversion2_g[2];
    b698:	b2 ba 2c    	mov.w     #0xcbab, w2
    b69a:	43 58 23    	mov.w     #0x3584, w3
    b69c:	1f a8 97    	mov.w     [w15-46], w0
    b69e:	af a8 97    	mov.w     [w15-44], w1
    b6a0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b6a2:	00 00 00 
    b6a4:	00 04 be    	mov.d     w0, w8

0000b6a6 <.L0>:
    rtb_DiscreteZeroPole_ck += 3.9156825028515473E-10*
    b6a6:	52 45 24    	mov.w     #0x4455, w2
    b6a8:	73 fd 22    	mov.w     #0x2fd7, w3
    b6aa:	40 eb 80    	mov.w     0x1d68, w0
    b6ac:	51 eb 80    	mov.w     0x1d6a, w1
    b6ae:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b6b0:	00 00 00 
    b6b2:	08 01 be    	mov.d     w8, w2
    b6b4:	92 14 02    	call      0x1492 <___addsf3>
    b6b6:	00 00 00 
    b6b8:	b0 b7 9f    	mov.w     w0, [w15-26]
    b6ba:	c1 b7 9f    	mov.w     w1, [w15-24]

0000b6bc <.L0>:
    b6bc:	52 45 24    	mov.w     #0x4455, w2
    b6be:	73 fd 22    	mov.w     #0x2fd7, w3
    b6c0:	20 eb 80    	mov.w     0x1d64, w0
    b6c2:	31 eb 80    	mov.w     0x1d66, w1
    b6c4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b6c6:	00 00 00 
    b6c8:	0a 01 be    	mov.d     w10, w2
    b6ca:	92 14 02    	call      0x1492 <___addsf3>
    b6cc:	00 00 00 
    b6ce:	00 04 be    	mov.d     w0, w8

0000b6d0 <.L0>:
    b6d0:	52 45 24    	mov.w     #0x4455, w2
    b6d2:	73 fd 22    	mov.w     #0x2fd7, w3
    b6d4:	00 eb 80    	mov.w     0x1d60, w0
    b6d6:	11 eb 80    	mov.w     0x1d62, w1
    b6d8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b6da:	00 00 00 
    b6dc:	0c 01 be    	mov.d     w12, w2
    b6de:	92 14 02    	call      0x1492 <___addsf3>
    b6e0:	00 00 00 

0000b6e2 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_k;
  }

  /* MATLAB Function: '<S554>/myMux Fun1' */
  AUAV_V3_TestSens_myMuxFun1(rtb_DiscreteZeroPole_f, rtb_DiscreteZeroPole_c,
    b6e2:	c6 bf 21    	mov.w     #0x1bfc, w6
    b6e4:	3f b2 97    	mov.w     [w15-26], w4
    b6e6:	cf b2 97    	mov.w     [w15-24], w5
    b6e8:	08 01 be    	mov.d     w8, w2
    b6ea:	bc f9 07    	rcall     0xaa64 <_AUAV_V3_TestSens_myMuxFun1> <L0> <.L0> <.LFB1465> <.LFE1467> <.Letext0> <.Ltext0>

0000b6ec <.L0>:
    rtb_DiscreteZeroPole_ck, &AUAV_V3_TestSensors_B.sf_myMuxFun1_d);

  /* DataTypeConversion: '<S554>/Data Type Conversion1' */
  AUAV_V3_TestSensors_B.DataTypeConversion1[0] = (real32_T)
    AUAV_V3_TestSensors_B.sf_myMuxFun1_d.y[0];
    b6ec:	ea df 80    	mov.w     0x1bfc, w10
    b6ee:	fb df 80    	mov.w     0x1bfe, w11
    b6f0:	9a b9 88    	mov.w     w10, 0x1732
    b6f2:	ab b9 88    	mov.w     w11, 0x1734
  AUAV_V3_TestSensors_B.DataTypeConversion1[1] = (real32_T)
    b6f4:	04 e0 80    	mov.w     0x1c00, w4
    b6f6:	15 e0 80    	mov.w     0x1c02, w5
    b6f8:	b4 b9 88    	mov.w     w4, 0x1736
    b6fa:	c5 b9 88    	mov.w     w5, 0x1738
    AUAV_V3_TestSensors_B.sf_myMuxFun1_d.y[1];
  AUAV_V3_TestSensors_B.DataTypeConversion1[2] = (real32_T)
    b6fc:	20 e0 80    	mov.w     0x1c04, w0
    b6fe:	31 e0 80    	mov.w     0x1c06, w1
    b700:	d0 b9 88    	mov.w     w0, 0x173a
    b702:	e1 b9 88    	mov.w     w1, 0x173c
    AUAV_V3_TestSensors_B.sf_myMuxFun1_d.y[2];

  /* Sum: '<S478>/Add' incorporates:
   *  Delay: '<S478>/Integer Delay'
   *  Delay: '<S489>/Integer Delay1'
   *  Gain: '<S489>/Gain2'
   *  Product: '<S504>/i x j'
   *  Product: '<S504>/j x k'
   *  Product: '<S504>/k x i'
   *  Product: '<S505>/i x k'
   *  Product: '<S505>/j x i'
   *  Product: '<S505>/k x j'
   *  Sum: '<S487>/Sum'
   *  Sum: '<S489>/Sum5'
   */
  rtb_Add[0] = (((AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[1] *
                  rtb_Product1_e[2] -
                  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[2] *
    b704:	ec ed 80    	mov.w     0x1dbc, w12
    b706:	fd ed 80    	mov.w     0x1dbe, w13

0000b708 <.L0>:
    b708:	3f b9 96    	mov.w     [w15-266], w2
    b70a:	cf b9 96    	mov.w     [w15-264], w3
    b70c:	c0 ed 80    	mov.w     0x1db8, w0
    b70e:	d1 ed 80    	mov.w     0x1dba, w1
    b710:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b712:	00 00 00 
    b714:	00 04 be    	mov.d     w0, w8

0000b716 <.L0>:
    b716:	1f b9 96    	mov.w     [w15-270], w2
    b718:	af b9 96    	mov.w     [w15-268], w3
    b71a:	0c 00 be    	mov.d     w12, w0
    b71c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b71e:	00 00 00 
    b720:	00 01 be    	mov.d     w0, w2

0000b722 <.L0>:
    b722:	08 00 be    	mov.d     w8, w0
    b724:	90 14 02    	call      0x1490 <___subsf3>
    b726:	00 00 00 
    b728:	00 04 be    	mov.d     w0, w8

0000b72a <.L0>:
                  rtb_Product1_e[1]) + (rtb_Product1_e[0] -
    b72a:	82 ee 80    	mov.w     0x1dd0, w2
    b72c:	93 ee 80    	mov.w     0x1dd2, w3
    b72e:	7f b0 96    	mov.w     [w15-274], w0
    b730:	8f b8 96    	mov.w     [w15-272], w1
    b732:	90 14 02    	call      0x1490 <___subsf3>
    b734:	00 00 00 

0000b736 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[0]) * 20.0F) -
    b736:	02 00 20    	mov.w     #0x0, w2
    b738:	03 1a 24    	mov.w     #0x41a0, w3
    b73a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b73c:	00 00 00 
    b73e:	00 01 be    	mov.d     w0, w2

0000b740 <.L0>:
    b740:	08 00 be    	mov.d     w8, w0
    b742:	92 14 02    	call      0x1492 <___addsf3>
    b744:	00 00 00 

0000b746 <.L0>:
    b746:	b2 b3 80    	mov.w     0x1676, w2
    b748:	c3 b3 80    	mov.w     0x1678, w3
    b74a:	90 14 02    	call      0x1490 <___subsf3>
    b74c:	00 00 00 

0000b74e <.L0>:
                AUAV_V3_TestSensors_B.DataTypeConversion3[0]) -
    b74e:	0a 01 be    	mov.d     w10, w2
    b750:	90 14 02    	call      0x1490 <___subsf3>
    b752:	00 00 00 

0000b754 <.L0>:
    b754:	b0 07 9f    	mov.w     w0, [w15-250]
    b756:	c1 07 9f    	mov.w     w1, [w15-248]
    AUAV_V3_TestSensors_B.DataTypeConversion1[0];
  rtb_Add[1] = (((AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[2] *
                  rtb_Product1_e[0] -
                  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[0] *
    b758:	aa ed 80    	mov.w     0x1db4, w10
    b75a:	bb ed 80    	mov.w     0x1db6, w11

0000b75c <.L0>:
    b75c:	7f b1 96    	mov.w     [w15-274], w2
    b75e:	8f b9 96    	mov.w     [w15-272], w3
    b760:	0c 00 be    	mov.d     w12, w0
    b762:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b764:	00 00 00 
    b766:	00 04 be    	mov.d     w0, w8

0000b768 <.L0>:
    b768:	0a 01 be    	mov.d     w10, w2
    b76a:	3f b8 96    	mov.w     [w15-266], w0
    b76c:	cf b8 96    	mov.w     [w15-264], w1
    b76e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b770:	00 00 00 
    b772:	00 01 be    	mov.d     w0, w2

0000b774 <.L0>:
    b774:	08 00 be    	mov.d     w8, w0
    b776:	90 14 02    	call      0x1490 <___subsf3>
    b778:	00 00 00 
    b77a:	00 04 be    	mov.d     w0, w8

0000b77c <.L0>:
                  rtb_Product1_e[2]) + (rtb_Product1_e[1] -
    b77c:	a2 ee 80    	mov.w     0x1dd4, w2
    b77e:	b3 ee 80    	mov.w     0x1dd6, w3
    b780:	1f b8 96    	mov.w     [w15-270], w0
    b782:	af b8 96    	mov.w     [w15-268], w1
    b784:	90 14 02    	call      0x1490 <___subsf3>
    b786:	00 00 00 

0000b788 <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[1]) * 20.0F) -
    b788:	02 00 20    	mov.w     #0x0, w2
    b78a:	03 1a 24    	mov.w     #0x41a0, w3
    b78c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b78e:	00 00 00 
    b790:	00 01 be    	mov.d     w0, w2

0000b792 <.L0>:
    b792:	08 00 be    	mov.d     w8, w0
    b794:	92 14 02    	call      0x1492 <___addsf3>
    b796:	00 00 00 

0000b798 <.L0>:
    b798:	d2 b3 80    	mov.w     0x167a, w2
    b79a:	e3 b3 80    	mov.w     0x167c, w3
    b79c:	90 14 02    	call      0x1490 <___subsf3>
    b79e:	00 00 00 

0000b7a0 <.L0>:
                AUAV_V3_TestSensors_B.DataTypeConversion3[1]) -
    b7a0:	02 e0 80    	mov.w     0x1c00, w2
    b7a2:	13 e0 80    	mov.w     0x1c02, w3
    b7a4:	90 14 02    	call      0x1490 <___subsf3>
    b7a6:	00 00 00 

0000b7a8 <.L0>:
    b7a8:	d0 07 9f    	mov.w     w0, [w15-246]
    b7aa:	e1 07 9f    	mov.w     w1, [w15-244]

0000b7ac <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1[1];
  rtb_Add[2] = (((AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[0] *
    b7ac:	0a 01 be    	mov.d     w10, w2
    b7ae:	1f b8 96    	mov.w     [w15-270], w0
    b7b0:	af b8 96    	mov.w     [w15-268], w1
    b7b2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b7b4:	00 00 00 
    b7b6:	00 04 be    	mov.d     w0, w8

0000b7b8 <.L0>:
                  rtb_Product1_e[1] -
                  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[1] *
    b7b8:	7f b1 96    	mov.w     [w15-274], w2
    b7ba:	8f b9 96    	mov.w     [w15-272], w3
    b7bc:	c0 ed 80    	mov.w     0x1db8, w0
    b7be:	d1 ed 80    	mov.w     0x1dba, w1
    b7c0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b7c2:	00 00 00 
    b7c4:	00 01 be    	mov.d     w0, w2

0000b7c6 <.L0>:
    b7c6:	08 00 be    	mov.d     w8, w0
    b7c8:	90 14 02    	call      0x1490 <___subsf3>
    b7ca:	00 00 00 
    b7cc:	00 04 be    	mov.d     w0, w8

0000b7ce <.L0>:
                  rtb_Product1_e[0]) + (rtb_Product1_e[2] -
    b7ce:	c2 ee 80    	mov.w     0x1dd8, w2
    b7d0:	d3 ee 80    	mov.w     0x1dda, w3
    b7d2:	3f b8 96    	mov.w     [w15-266], w0
    b7d4:	cf b8 96    	mov.w     [w15-264], w1
    b7d6:	90 14 02    	call      0x1490 <___subsf3>
    b7d8:	00 00 00 

0000b7da <.L0>:
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[2]) * 20.0F) -
    b7da:	02 00 20    	mov.w     #0x0, w2
    b7dc:	03 1a 24    	mov.w     #0x41a0, w3
    b7de:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b7e0:	00 00 00 
    b7e2:	00 01 be    	mov.d     w0, w2

0000b7e4 <.L0>:
    b7e4:	08 00 be    	mov.d     w8, w0
    b7e6:	92 14 02    	call      0x1492 <___addsf3>
    b7e8:	00 00 00 

0000b7ea <.L0>:
    b7ea:	f2 b3 80    	mov.w     0x167e, w2
    b7ec:	03 b4 80    	mov.w     0x1680, w3
    b7ee:	90 14 02    	call      0x1490 <___subsf3>
    b7f0:	00 00 00 

0000b7f2 <.L0>:
                AUAV_V3_TestSensors_B.DataTypeConversion3[2]) -
    b7f2:	22 e0 80    	mov.w     0x1c04, w2
    b7f4:	33 e0 80    	mov.w     0x1c06, w3
    b7f6:	90 14 02    	call      0x1490 <___subsf3>
    b7f8:	00 00 00 

0000b7fa <.L0>:
    b7fa:	f0 07 9f    	mov.w     w0, [w15-242]
    b7fc:	81 0f 9f    	mov.w     w1, [w15-240]

0000b7fe <.L0>:
    AUAV_V3_TestSensors_B.DataTypeConversion1[2];

  /* MATLAB Function: '<S513>/Embedded MATLAB Function' */
  A_EmbeddedMATLABFunction_o(rtb_Add,
    b7fe:	41 c1 21    	mov.w     #0x1c14, w1
    b800:	60 f0 2f    	mov.w     #0xff06, w0
    b802:	0f 00 40    	add.w     w0, w15, w0
    b804:	35 f9 07    	rcall     0xaa70 <_A_EmbeddedMATLABFunction_o> <L0> <.LFB1466> <.LFE1465>

0000b806 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_op);

  /* MATLAB Function: '<S512>/negprotect' */
  AUAV_V3_TestSen_negprotect
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_op.xDoty,
    b806:	82 c1 21    	mov.w     #0x1c18, w2
    b808:	a0 e0 80    	mov.w     0x1c14, w0
    b80a:	b1 e0 80    	mov.w     0x1c16, w1
    b80c:	14 12 02    	call      0x11214 <_AUAV_V3_TestSen_negprotect>
    b80e:	01 00 00 

0000b810 <.L0>:
     &AUAV_V3_TestSensors_B.sf_negprotect_k);

  /* S-Function (MCHP_C_function_Call): '<S512>/[apUtils.c]' */
  AUAV_V3_TestSensors_B.apUtilsc_f = mySqrt(
    b810:	c0 e0 80    	mov.w     0x1c18, w0
    b812:	d1 e0 80    	mov.w     0x1c1a, w1
    b814:	16 10 02    	call      0x11016 <_mySqrt>
    b816:	01 00 00 
    b818:	00 04 be    	mov.d     w0, w8
    b81a:	f0 b9 88    	mov.w     w0, 0x173e
    b81c:	01 ba 88    	mov.w     w1, 0x1740

0000b81e <.L0>:
    AUAV_V3_TestSensors_B.sf_negprotect_k.zpVal
    );

  /* Saturate: '<S492>/Zero Bound' */
  if (AUAV_V3_TestSensors_B.apUtilsc_f <= 0.001F) {
    b81e:	f2 26 21    	mov.w     #0x126f, w2
    b820:	33 a8 23    	mov.w     #0x3a83, w3
    b822:	8c 18 02    	call      0x188c <___eqsf2>
    b824:	00 00 00 
    b826:	00 00 e0    	cp0.w     w0
    b828:	02 00 3c    	bra       GT, 0xb82e <.L0> <.L51>

0000b82a <.L0>:
    rtb_RhhcosphicoslambXe = 0.001F;
    b82a:	f8 26 21    	mov.w     #0x126f, w8
    b82c:	39 a8 23    	mov.w     #0x3a83, w9

0000b82e <.L0>:
  } else {
    rtb_RhhcosphicoslambXe = AUAV_V3_TestSensors_B.apUtilsc_f;
  }

  /* End of Saturate: '<S492>/Zero Bound' */

  /* Product: '<S492>/Divide' */
  rtb_Add[0] /= rtb_RhhcosphicoslambXe;
    b82e:	08 01 be    	mov.d     w8, w2
    b830:	3f 00 97    	mov.w     [w15-250], w0
    b832:	cf 00 97    	mov.w     [w15-248], w1
    b834:	26 17 02    	call      0x1726 <___divsf3>
    b836:	00 00 00 
    b838:	b0 97 9f    	mov.w     w0, [w15-90]
    b83a:	c1 97 9f    	mov.w     w1, [w15-88]

0000b83c <.L0>:
  rtb_Add[1] /= rtb_RhhcosphicoslambXe;
    b83c:	08 01 be    	mov.d     w8, w2
    b83e:	5f 00 97    	mov.w     [w15-246], w0
    b840:	ef 00 97    	mov.w     [w15-244], w1
    b842:	26 17 02    	call      0x1726 <___divsf3>
    b844:	00 00 00 
    b846:	f0 8f 9f    	mov.w     w0, [w15-98]
    b848:	81 97 9f    	mov.w     w1, [w15-96]

0000b84a <.L0>:
  rtb_RhhcosphisinlambYe = rtb_Add[2] / rtb_RhhcosphicoslambXe;
    b84a:	08 01 be    	mov.d     w8, w2
    b84c:	7f 00 97    	mov.w     [w15-242], w0
    b84e:	8f 08 97    	mov.w     [w15-240], w1
    b850:	26 17 02    	call      0x1726 <___divsf3>
    b852:	00 00 00 
    b854:	d0 8f 9f    	mov.w     w0, [w15-102]
    b856:	e1 8f 9f    	mov.w     w1, [w15-100]

0000b858 <.L0>:

  /* S-Function (sdspsubmtrx): '<S478>/Submatrix' */
  yIdx = 0L;
  colIdx = 2;
  while (colIdx <= 2) {
    AUAV_V3_TestSensors_B.g_hat[yIdx] = AUAV_V3_TestSensors_B.VectorConcatenate
      [6L];
    b858:	f4 b7 80    	mov.w     0x16fe, w4
    b85a:	05 b8 80    	mov.w     0x1700, w5
    b85c:	f4 af 9f    	mov.w     w4, [w15-34]
    b85e:	85 b7 9f    	mov.w     w5, [w15-32]
    b860:	14 ba 88    	mov.w     w4, 0x1742
    b862:	25 ba 88    	mov.w     w5, 0x1744
    AUAV_V3_TestSensors_B.g_hat[1L + yIdx] =
      AUAV_V3_TestSensors_B.VectorConcatenate[7L];
    b864:	10 b8 80    	mov.w     0x1702, w0
    b866:	21 b8 80    	mov.w     0x1704, w1
    b868:	b0 af 9f    	mov.w     w0, [w15-42]
    b86a:	c1 af 9f    	mov.w     w1, [w15-40]
    b86c:	30 ba 88    	mov.w     w0, 0x1746
    b86e:	41 ba 88    	mov.w     w1, 0x1748
    AUAV_V3_TestSensors_B.g_hat[2L + yIdx] =
      AUAV_V3_TestSensors_B.VectorConcatenate[8L];
    b870:	32 b8 80    	mov.w     0x1706, w2
    b872:	43 b8 80    	mov.w     0x1708, w3
    b874:	92 a7 9f    	mov.w     w2, [w15-62]
    b876:	a3 a7 9f    	mov.w     w3, [w15-60]
    b878:	52 ba 88    	mov.w     w2, 0x174a
    b87a:	63 ba 88    	mov.w     w3, 0x174c

0000b87c <.L0>:
    yIdx += 3L;
    colIdx = 3;
  }

  /* End of S-Function (sdspsubmtrx): '<S478>/Submatrix' */

  /* Sum: '<S488>/Sum' incorporates:
   *  MATLAB Function: '<S479>/myMux Fun2'
   *  Product: '<S506>/i x j'
   *  Product: '<S506>/j x k'
   *  Product: '<S506>/k x i'
   *  Product: '<S507>/i x k'
   *  Product: '<S507>/j x i'
   *  Product: '<S507>/k x j'
   */
  rtb_Deg2R1 = rtb_y_e * 0.0F - rtb_y_ox[2] * AUAV_V3_TestSensors_B.apUtilsc_a;
    b87c:	5f b5 96    	mov.w     [w15-278], w10
    b87e:	ef b5 96    	mov.w     [w15-276], w11
    b880:	60 11 b8    	mul.uu    w2, #0x0, w2
    b882:	1f 90 97    	mov.w     [w15-94], w0
    b884:	af 90 97    	mov.w     [w15-92], w1
    b886:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b888:	00 00 00 
    b88a:	00 04 be    	mov.d     w0, w8
    b88c:	72 b9 80    	mov.w     0x172e, w2
    b88e:	83 b9 80    	mov.w     0x1730, w3
    b890:	0a 00 be    	mov.d     w10, w0
    b892:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b894:	00 00 00 
    b896:	00 01 be    	mov.d     w0, w2
    b898:	08 00 be    	mov.d     w8, w0
    b89a:	90 14 02    	call      0x1490 <___subsf3>
    b89c:	00 00 00 
    b89e:	f0 9f 9f    	mov.w     w0, [w15-66]
    b8a0:	81 a7 9f    	mov.w     w1, [w15-64]

0000b8a2 <.L0>:
  rtb_ixk = rtb_y_ox[2] * AUAV_V3_TestSensors_B.apUtilsc1 - rtb_y_ox[0] * 0.0F;
    b8a2:	5c b9 80    	mov.w     0x172a, w12
    b8a4:	6d b9 80    	mov.w     0x172c, w13
    b8a6:	0c 01 be    	mov.d     w12, w2
    b8a8:	0a 00 be    	mov.d     w10, w0
    b8aa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b8ac:	00 00 00 
    b8ae:	00 04 be    	mov.d     w0, w8
    b8b0:	60 11 b8    	mul.uu    w2, #0x0, w2
    b8b2:	1f b0 96    	mov.w     [w15-286], w0
    b8b4:	af b0 96    	mov.w     [w15-284], w1
    b8b6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b8b8:	00 00 00 
    b8ba:	00 01 be    	mov.d     w0, w2
    b8bc:	08 00 be    	mov.d     w8, w0
    b8be:	90 14 02    	call      0x1490 <___subsf3>
    b8c0:	00 00 00 
    b8c2:	b0 9f 9f    	mov.w     w0, [w15-74]
    b8c4:	c1 9f 9f    	mov.w     w1, [w15-72]

0000b8c6 <.L0>:
  rtb_RhhcosphicoslambXe = rtb_y_ox[0] * AUAV_V3_TestSensors_B.apUtilsc_a -
    b8c6:	1f b1 96    	mov.w     [w15-286], w2
    b8c8:	af b1 96    	mov.w     [w15-284], w3
    b8ca:	70 b9 80    	mov.w     0x172e, w0
    b8cc:	81 b9 80    	mov.w     0x1730, w1
    b8ce:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b8d0:	00 00 00 
    b8d2:	00 04 be    	mov.d     w0, w8

0000b8d4 <.L0>:
    rtb_y_e * AUAV_V3_TestSensors_B.apUtilsc1;
    b8d4:	0c 01 be    	mov.d     w12, w2
    b8d6:	1f 90 97    	mov.w     [w15-94], w0
    b8d8:	af 90 97    	mov.w     [w15-92], w1
    b8da:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b8dc:	00 00 00 
    b8de:	00 01 be    	mov.d     w0, w2

0000b8e0 <.L0>:
    b8e0:	08 00 be    	mov.d     w8, w0
    b8e2:	90 14 02    	call      0x1490 <___subsf3>
    b8e4:	00 00 00 
    b8e6:	00 06 be    	mov.d     w0, w12
    b8e8:	e3 f5 2f    	mov.w     #0xff5e, w3
    b8ea:	83 81 47    	add.w     w15, w3, w3
    b8ec:	b3 b7 9f    	mov.w     w3, [w15-26]
    b8ee:	3e 00 20    	mov.w     #0x3, w14

0000b8f0 <.L0>:

  /* Product: '<S478>/Product2' incorporates:
   *  Gain: '<S478>/Gain1'
   */
  for (colIdx = 0; colIdx < 3; colIdx++) {
    tmp_0[colIdx] = AUAV_V3_TestSensors_B.VectorConcatenate[colIdx + 6] *
    b8f0:	1f b2 97    	mov.w     [w15-30], w4
    b8f2:	54 01 be    	mov.d     [++w4], w2
    b8f4:	94 b7 9f    	mov.w     w4, [w15-30]
    b8f6:	0c 00 be    	mov.d     w12, w0
    b8f8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b8fa:	00 00 00 
    b8fc:	00 05 be    	mov.d     w0, w10

0000b8fe <.L0>:
      rtb_RhhcosphicoslambXe + (AUAV_V3_TestSensors_B.VectorConcatenate[colIdx +
      3] * rtb_ixk + AUAV_V3_TestSensors_B.VectorConcatenate[colIdx] *
    b8fe:	ff a2 97    	mov.w     [w15-50], w5
    b900:	55 01 be    	mov.d     [++w5], w2
    b902:	f5 a7 9f    	mov.w     w5, [w15-50]
    b904:	3f 98 97    	mov.w     [w15-74], w0
    b906:	cf 98 97    	mov.w     [w15-72], w1
    b908:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b90a:	00 00 00 
    b90c:	00 04 be    	mov.d     w0, w8
    b90e:	5f b0 97    	mov.w     [w15-22], w0
    b910:	50 01 be    	mov.d     [++w0], w2
    b912:	d0 b7 9f    	mov.w     w0, [w15-22]
    b914:	7f 98 97    	mov.w     [w15-66], w0
    b916:	8f a0 97    	mov.w     [w15-64], w1
    b918:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b91a:	00 00 00 
    b91c:	00 01 be    	mov.d     w0, w2
    b91e:	08 00 be    	mov.d     w8, w0
    b920:	92 14 02    	call      0x1492 <___addsf3>
    b922:	00 00 00 
    b924:	00 01 be    	mov.d     w0, w2

0000b926 <.L0>:
    b926:	0a 00 be    	mov.d     w10, w0
    b928:	92 14 02    	call      0x1492 <___addsf3>
    b92a:	00 00 00 

0000b92c <.L0>:
    b92c:	3f b1 97    	mov.w     [w15-26], w2
    b92e:	00 a9 be    	mov.d     w0, [++w2]
    b930:	b2 b7 9f    	mov.w     w2, [w15-26]
    b932:	0e 07 e9    	dec.w     w14, w14
    b934:	dd ff 3a    	bra       NZ, 0xb8f0 <.L0> <.L0> <.L53>

0000b936 <.L0>:
      rtb_Deg2R1);
  }

  /* End of Product: '<S478>/Product2' */

  /* Product: '<S502>/i x j' */
  rtb_RhhcosphicoslambXe = rtb_Add[0];

  /* Product: '<S503>/i x k' */
  rtb_Deg2R1 = rtb_Add[0];

  /* Product: '<S503>/j x i' */
  rtb_ixk = rtb_Add[1];

  /* Sum: '<S478>/Sum4' incorporates:
   *  Gain: '<S478>/Gain1'
   *  Product: '<S502>/i x j'
   *  Product: '<S502>/j x k'
   *  Product: '<S502>/k x i'
   *  Product: '<S503>/i x k'
   *  Product: '<S503>/j x i'
   *  Product: '<S503>/k x j'
   *  Sum: '<S486>/Sum'
   */
  rtb_Add[0] = (rtb_Add[1] * AUAV_V3_TestSensors_B.g_hat[2] -
    b936:	1f a1 97    	mov.w     [w15-62], w2
    b938:	af a1 97    	mov.w     [w15-60], w3
    b93a:	7f 88 97    	mov.w     [w15-98], w0
    b93c:	8f 90 97    	mov.w     [w15-96], w1
    b93e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b940:	00 00 00 
    b942:	00 04 be    	mov.d     w0, w8

0000b944 <.L0>:
                rtb_RhhcosphisinlambYe * AUAV_V3_TestSensors_B.g_hat[1]) + 30.0F
    b944:	3f a9 97    	mov.w     [w15-42], w2
    b946:	cf a9 97    	mov.w     [w15-40], w3
    b948:	5f 88 97    	mov.w     [w15-102], w0
    b94a:	ef 88 97    	mov.w     [w15-100], w1
    b94c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b94e:	00 00 00 
    b950:	00 01 be    	mov.d     w0, w2

0000b952 <.L0>:
    b952:	08 00 be    	mov.d     w8, w0
    b954:	90 14 02    	call      0x1490 <___subsf3>
    b956:	00 00 00 
    b958:	00 04 be    	mov.d     w0, w8

0000b95a <.L0>:
    * tmp_0[0];
    b95a:	02 00 20    	mov.w     #0x0, w2
    b95c:	03 1f 24    	mov.w     #0x41f0, w3
    b95e:	1f 30 97    	mov.w     [w15-158], w0
    b960:	af 30 97    	mov.w     [w15-156], w1
    b962:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b964:	00 00 00 
    b966:	00 01 be    	mov.d     w0, w2

0000b968 <.L0>:
    b968:	08 00 be    	mov.d     w8, w0
    b96a:	92 14 02    	call      0x1492 <___addsf3>
    b96c:	00 00 00 
    b96e:	f0 9f 9f    	mov.w     w0, [w15-66]
    b970:	81 a7 9f    	mov.w     w1, [w15-64]

0000b972 <.L0>:
    b972:	b0 07 9f    	mov.w     w0, [w15-250]
    b974:	c1 07 9f    	mov.w     w1, [w15-248]

0000b976 <.L0>:
  rtb_Add[1] = (rtb_RhhcosphisinlambYe * AUAV_V3_TestSensors_B.g_hat[0] -
    b976:	7f a9 97    	mov.w     [w15-34], w2
    b978:	8f b1 97    	mov.w     [w15-32], w3
    b97a:	5f 88 97    	mov.w     [w15-102], w0
    b97c:	ef 88 97    	mov.w     [w15-100], w1
    b97e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b980:	00 00 00 
    b982:	00 04 be    	mov.d     w0, w8

0000b984 <.L0>:
                rtb_Deg2R1 * AUAV_V3_TestSensors_B.g_hat[2]) + 30.0F * tmp_0[1];
    b984:	1f a1 97    	mov.w     [w15-62], w2
    b986:	af a1 97    	mov.w     [w15-60], w3
    b988:	3f 90 97    	mov.w     [w15-90], w0
    b98a:	cf 90 97    	mov.w     [w15-88], w1
    b98c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b98e:	00 00 00 
    b990:	00 01 be    	mov.d     w0, w2

0000b992 <.L0>:
    b992:	08 00 be    	mov.d     w8, w0
    b994:	90 14 02    	call      0x1490 <___subsf3>
    b996:	00 00 00 
    b998:	00 04 be    	mov.d     w0, w8

0000b99a <.L0>:
    b99a:	02 00 20    	mov.w     #0x0, w2
    b99c:	03 1f 24    	mov.w     #0x41f0, w3
    b99e:	3f 30 97    	mov.w     [w15-154], w0
    b9a0:	cf 30 97    	mov.w     [w15-152], w1
    b9a2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b9a4:	00 00 00 
    b9a6:	00 01 be    	mov.d     w0, w2
    b9a8:	08 00 be    	mov.d     w8, w0
    b9aa:	92 14 02    	call      0x1492 <___addsf3>
    b9ac:	00 00 00 
    b9ae:	90 a7 9f    	mov.w     w0, [w15-62]
    b9b0:	a1 a7 9f    	mov.w     w1, [w15-60]

0000b9b2 <.L0>:
    b9b2:	d0 07 9f    	mov.w     w0, [w15-246]
    b9b4:	e1 07 9f    	mov.w     w1, [w15-244]

0000b9b6 <.L0>:
  rtb_Add[2] = (rtb_RhhcosphicoslambXe * AUAV_V3_TestSensors_B.g_hat[1] -
    b9b6:	3f a9 97    	mov.w     [w15-42], w2
    b9b8:	cf a9 97    	mov.w     [w15-40], w3
    b9ba:	3f 90 97    	mov.w     [w15-90], w0
    b9bc:	cf 90 97    	mov.w     [w15-88], w1
    b9be:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b9c0:	00 00 00 
    b9c2:	00 04 be    	mov.d     w0, w8

0000b9c4 <.L0>:
                rtb_ixk * AUAV_V3_TestSensors_B.g_hat[0]) + 30.0F * tmp_0[2];
    b9c4:	7f a9 97    	mov.w     [w15-34], w2
    b9c6:	8f b1 97    	mov.w     [w15-32], w3
    b9c8:	7f 88 97    	mov.w     [w15-98], w0
    b9ca:	8f 90 97    	mov.w     [w15-96], w1
    b9cc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b9ce:	00 00 00 
    b9d0:	00 01 be    	mov.d     w0, w2

0000b9d2 <.L0>:
    b9d2:	08 00 be    	mov.d     w8, w0
    b9d4:	90 14 02    	call      0x1490 <___subsf3>
    b9d6:	00 00 00 
    b9d8:	00 04 be    	mov.d     w0, w8

0000b9da <.L0>:
    b9da:	02 00 20    	mov.w     #0x0, w2
    b9dc:	03 1f 24    	mov.w     #0x41f0, w3
    b9de:	5f 30 97    	mov.w     [w15-150], w0
    b9e0:	ef 30 97    	mov.w     [w15-148], w1
    b9e2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    b9e4:	00 00 00 
    b9e6:	00 01 be    	mov.d     w0, w2
    b9e8:	08 00 be    	mov.d     w8, w0
    b9ea:	92 14 02    	call      0x1492 <___addsf3>
    b9ec:	00 00 00 
    b9ee:	f0 af 9f    	mov.w     w0, [w15-34]
    b9f0:	81 b7 9f    	mov.w     w1, [w15-32]

0000b9f2 <.L0>:
    b9f2:	f0 07 9f    	mov.w     w0, [w15-242]
    b9f4:	81 0f 9f    	mov.w     w1, [w15-240]

0000b9f6 <.L0>:

  /* DataTypeConversion: '<S485>/Data Type Conversion2' */
  rtb_DataTypeConversion2_e2[0] = rtb_Add[0];
  rtb_DataTypeConversion2_e2[1] = rtb_Add[1];
  rtb_DataTypeConversion2_e2[2] = rtb_Add[2];

  /* DiscreteZeroPole: '<S498>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_k = 0.005*rtb_DataTypeConversion2_e2[0];
    b9f6:	a2 70 2d    	mov.w     #0xd70a, w2
    b9f8:	33 ba 23    	mov.w     #0x3ba3, w3
    b9fa:	7f 98 97    	mov.w     [w15-66], w0
    b9fc:	8f a0 97    	mov.w     [w15-64], w1
    b9fe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba00:	00 00 00 
    ba02:	00 06 be    	mov.d     w0, w12

0000ba04 <.L0>:
    rtb_DiscreteZeroPole_k += 0.01*
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_c;
  }

  /* DiscreteZeroPole: '<S499>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_o = 0.005*rtb_DataTypeConversion2_e2[1];
    ba04:	a2 70 2d    	mov.w     #0xd70a, w2
    ba06:	33 ba 23    	mov.w     #0x3ba3, w3
    ba08:	1f a0 97    	mov.w     [w15-62], w0
    ba0a:	af a0 97    	mov.w     [w15-60], w1
    ba0c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba0e:	00 00 00 
    ba10:	00 05 be    	mov.d     w0, w10

0000ba12 <.L0>:
    rtb_DiscreteZeroPole_o += 0.01*
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_n;
  }

  /* DiscreteZeroPole: '<S500>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_g = 0.005*rtb_DataTypeConversion2_e2[2];
    ba12:	a2 70 2d    	mov.w     #0xd70a, w2
    ba14:	33 ba 23    	mov.w     #0x3ba3, w3
    ba16:	7f a8 97    	mov.w     [w15-34], w0
    ba18:	8f b0 97    	mov.w     [w15-32], w1
    ba1a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba1c:	00 00 00 
    ba1e:	00 04 be    	mov.d     w0, w8

0000ba20 <.L0>:
    rtb_DiscreteZeroPole_g += 0.01*
    ba20:	a2 70 2d    	mov.w     #0xd70a, w2
    ba22:	33 c2 23    	mov.w     #0x3c23, w3
    ba24:	a0 eb 80    	mov.w     0x1d74, w0
    ba26:	b1 eb 80    	mov.w     0x1d76, w1
    ba28:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba2a:	00 00 00 
    ba2c:	08 01 be    	mov.d     w8, w2
    ba2e:	92 14 02    	call      0x1492 <___addsf3>
    ba30:	00 00 00 
    ba32:	d0 b7 9f    	mov.w     w0, [w15-22]
    ba34:	e1 b7 9f    	mov.w     w1, [w15-20]

0000ba36 <.L0>:
    ba36:	a2 70 2d    	mov.w     #0xd70a, w2
    ba38:	33 c2 23    	mov.w     #0x3c23, w3
    ba3a:	80 eb 80    	mov.w     0x1d70, w0
    ba3c:	91 eb 80    	mov.w     0x1d72, w1
    ba3e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba40:	00 00 00 
    ba42:	0a 01 be    	mov.d     w10, w2
    ba44:	92 14 02    	call      0x1492 <___addsf3>
    ba46:	00 00 00 
    ba48:	00 04 be    	mov.d     w0, w8

0000ba4a <.L0>:
    ba4a:	a2 70 2d    	mov.w     #0xd70a, w2
    ba4c:	33 c2 23    	mov.w     #0x3c23, w3
    ba4e:	60 eb 80    	mov.w     0x1d6c, w0
    ba50:	71 eb 80    	mov.w     0x1d6e, w1
    ba52:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ba54:	00 00 00 
    ba56:	0c 01 be    	mov.d     w12, w2
    ba58:	92 14 02    	call      0x1492 <___addsf3>
    ba5a:	00 00 00 

0000ba5c <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_e;
  }

  /* MATLAB Function: '<S485>/myMux Fun1' */
  AUAV_V3_TestSens_myMuxFun1(rtb_DiscreteZeroPole_k, rtb_DiscreteZeroPole_o,
    ba5c:	06 c2 21    	mov.w     #0x1c20, w6
    ba5e:	5f b2 97    	mov.w     [w15-22], w4
    ba60:	ef b2 97    	mov.w     [w15-20], w5
    ba62:	08 01 be    	mov.d     w8, w2
    ba64:	ff f7 07    	rcall     0xaa64 <_AUAV_V3_TestSens_myMuxFun1> <L0> <.L0> <.LFB1465> <.LFE1467> <.Letext0> <.Ltext0>

0000ba66 <.L0>:
    rtb_DiscreteZeroPole_g, &AUAV_V3_TestSensors_B.sf_myMuxFun1_n);

  /* RateLimiter: '<S478>/Bias Rate Limiter' incorporates:
   *  DataTypeConversion: '<S485>/Data Type Conversion1'
   */
  AUAV_V3_TestSensors_B.BiasRateLimiter[0] = (real32_T)
    AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[0] -
    ba66:	0c e1 80    	mov.w     0x1c20, w12
    ba68:	1d e1 80    	mov.w     0x1c22, w13
    AUAV_V3_TestSensors_DWork.PrevY_n[0];
    ba6a:	4a fe 80    	mov.w     0x1fc8, w10
    ba6c:	5b fe 80    	mov.w     0x1fca, w11

0000ba6e <.L0>:
    ba6e:	0a 01 be    	mov.d     w10, w2
    ba70:	0c 00 be    	mov.d     w12, w0
    ba72:	90 14 02    	call      0x1490 <___subsf3>
    ba74:	00 00 00 
    ba76:	00 04 be    	mov.d     w0, w8

0000ba78 <.L0>:
  AUAV_V3_TestSensors_B.BiasRateLimiter[1] = (real32_T)
    AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[1] -
    ba78:	62 fe 80    	mov.w     0x1fcc, w2
    ba7a:	73 fe 80    	mov.w     0x1fce, w3
    ba7c:	20 e1 80    	mov.w     0x1c24, w0
    ba7e:	31 e1 80    	mov.w     0x1c26, w1
    ba80:	90 14 02    	call      0x1490 <___subsf3>
    ba82:	00 00 00 

0000ba84 <.L0>:
    ba84:	90 ba 88    	mov.w     w0, 0x1752
    ba86:	a1 ba 88    	mov.w     w1, 0x1754

0000ba88 <.L0>:
    AUAV_V3_TestSensors_DWork.PrevY_n[1];
  AUAV_V3_TestSensors_B.BiasRateLimiter[2] = (real32_T)
    AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[2] -
    ba88:	82 fe 80    	mov.w     0x1fd0, w2
    ba8a:	93 fe 80    	mov.w     0x1fd2, w3
    ba8c:	40 e1 80    	mov.w     0x1c28, w0
    ba8e:	51 e1 80    	mov.w     0x1c2a, w1
    ba90:	90 14 02    	call      0x1490 <___subsf3>
    ba92:	00 00 00 

0000ba94 <.L0>:
    ba94:	b0 ba 88    	mov.w     w0, 0x1756
    ba96:	c1 ba 88    	mov.w     w1, 0x1758

0000ba98 <.L0>:
    AUAV_V3_TestSensors_DWork.PrevY_n[2];
  if (AUAV_V3_TestSensors_B.BiasRateLimiter[0] > 2.5572E-9F) {
    ba98:	d2 ab 2b    	mov.w     #0xbabd, w2
    ba9a:	f3 12 23    	mov.w     #0x312f, w3
    ba9c:	08 00 be    	mov.d     w8, w0
    ba9e:	90 18 02    	call      0x1890 <___gesf2>
    baa0:	00 00 00 
    baa2:	00 00 e0    	cp0.w     w0
    baa4:	08 00 34    	bra       LE, 0xbab6 <.L0> <.L144>

0000baa6 <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[0] =
      AUAV_V3_TestSensors_DWork.PrevY_n[0] + 2.5572E-9F;
    baa6:	d2 ab 2b    	mov.w     #0xbabd, w2
    baa8:	f3 12 23    	mov.w     #0x312f, w3
    baaa:	0a 00 be    	mov.d     w10, w0
    baac:	92 14 02    	call      0x1492 <___addsf3>
    baae:	00 00 00 

0000bab0 <.L0>:
    bab0:	70 ba 88    	mov.w     w0, 0x174e
    bab2:	81 ba 88    	mov.w     w1, 0x1750
    bab4:	11 00 37    	bra       0xbad8 <.L0> <.L56>

0000bab6 <.L0>:
  } else if (AUAV_V3_TestSensors_B.BiasRateLimiter[0] < -2.5572E-9F) {
    bab6:	d2 ab 2b    	mov.w     #0xbabd, w2
    bab8:	f3 12 2b    	mov.w     #0xb12f, w3
    baba:	08 00 be    	mov.d     w8, w0
    babc:	8c 18 02    	call      0x188c <___eqsf2>
    babe:	00 00 00 
    bac0:	00 00 e0    	cp0.w     w0
    bac2:	08 00 3d    	bra       GE, 0xbad4 <.L145>

0000bac4 <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[0] =
      AUAV_V3_TestSensors_DWork.PrevY_n[0] + -2.5572E-9F;
    bac4:	d2 ab 2b    	mov.w     #0xbabd, w2
    bac6:	f3 12 23    	mov.w     #0x312f, w3
    bac8:	0a 00 be    	mov.d     w10, w0
    baca:	90 14 02    	call      0x1490 <___subsf3>
    bacc:	00 00 00 

0000bace <.L0>:
    bace:	70 ba 88    	mov.w     w0, 0x174e
    bad0:	81 ba 88    	mov.w     w1, 0x1750
    bad2:	02 00 37    	bra       0xbad8 <.L0> <.L56>

0000bad4 <.L145>:
  } else {
    AUAV_V3_TestSensors_B.BiasRateLimiter[0] = (real32_T)
    bad4:	7c ba 88    	mov.w     w12, 0x174e
    bad6:	8d ba 88    	mov.w     w13, 0x1750

0000bad8 <.L0>:
      AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[0];
  }

  if (AUAV_V3_TestSensors_B.BiasRateLimiter[1] > 2.5572E-9F) {
    bad8:	98 ba 80    	mov.w     0x1752, w8
    bada:	a9 ba 80    	mov.w     0x1754, w9
    badc:	d2 ab 2b    	mov.w     #0xbabd, w2
    bade:	f3 12 23    	mov.w     #0x312f, w3
    bae0:	08 00 be    	mov.d     w8, w0
    bae2:	90 18 02    	call      0x1890 <___gesf2>
    bae4:	00 00 00 
    bae6:	00 00 e0    	cp0.w     w0
    bae8:	09 00 34    	bra       LE, 0xbafc <.L0> <.L146>

0000baea <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[1] =
      AUAV_V3_TestSensors_DWork.PrevY_n[1] + 2.5572E-9F;
    baea:	d2 ab 2b    	mov.w     #0xbabd, w2
    baec:	f3 12 23    	mov.w     #0x312f, w3
    baee:	60 fe 80    	mov.w     0x1fcc, w0
    baf0:	71 fe 80    	mov.w     0x1fce, w1
    baf2:	92 14 02    	call      0x1492 <___addsf3>
    baf4:	00 00 00 

0000baf6 <.L0>:
    baf6:	90 ba 88    	mov.w     w0, 0x1752
    baf8:	a1 ba 88    	mov.w     w1, 0x1754
    bafa:	14 00 37    	bra       0xbb24 <.L0> <.L61>

0000bafc <.L0>:
  } else if (AUAV_V3_TestSensors_B.BiasRateLimiter[1] < -2.5572E-9F) {
    bafc:	d2 ab 2b    	mov.w     #0xbabd, w2
    bafe:	f3 12 2b    	mov.w     #0xb12f, w3
    bb00:	08 00 be    	mov.d     w8, w0
    bb02:	8c 18 02    	call      0x188c <___eqsf2>
    bb04:	00 00 00 
    bb06:	00 00 e0    	cp0.w     w0
    bb08:	09 00 3d    	bra       GE, 0xbb1c <.L147>

0000bb0a <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[1] =
      AUAV_V3_TestSensors_DWork.PrevY_n[1] + -2.5572E-9F;
    bb0a:	d2 ab 2b    	mov.w     #0xbabd, w2
    bb0c:	f3 12 23    	mov.w     #0x312f, w3
    bb0e:	60 fe 80    	mov.w     0x1fcc, w0
    bb10:	71 fe 80    	mov.w     0x1fce, w1
    bb12:	90 14 02    	call      0x1490 <___subsf3>
    bb14:	00 00 00 

0000bb16 <.L0>:
    bb16:	90 ba 88    	mov.w     w0, 0x1752
    bb18:	a1 ba 88    	mov.w     w1, 0x1754
    bb1a:	04 00 37    	bra       0xbb24 <.L0> <.L61>

0000bb1c <.L147>:
  } else {
    AUAV_V3_TestSensors_B.BiasRateLimiter[1] = (real32_T)
    bb1c:	24 e1 80    	mov.w     0x1c24, w4
    bb1e:	35 e1 80    	mov.w     0x1c26, w5
    bb20:	94 ba 88    	mov.w     w4, 0x1752
    bb22:	a5 ba 88    	mov.w     w5, 0x1754

0000bb24 <.L0>:
      AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[1];
  }

  if (AUAV_V3_TestSensors_B.BiasRateLimiter[2] > 2.5572E-9F) {
    bb24:	b8 ba 80    	mov.w     0x1756, w8
    bb26:	c9 ba 80    	mov.w     0x1758, w9
    bb28:	d2 ab 2b    	mov.w     #0xbabd, w2
    bb2a:	f3 12 23    	mov.w     #0x312f, w3
    bb2c:	08 00 be    	mov.d     w8, w0
    bb2e:	90 18 02    	call      0x1890 <___gesf2>
    bb30:	00 00 00 
    bb32:	00 00 e0    	cp0.w     w0
    bb34:	09 00 34    	bra       LE, 0xbb48 <.L0> <.L148>

0000bb36 <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[2] =
      AUAV_V3_TestSensors_DWork.PrevY_n[2] + 2.5572E-9F;
    bb36:	d2 ab 2b    	mov.w     #0xbabd, w2
    bb38:	f3 12 23    	mov.w     #0x312f, w3
    bb3a:	80 fe 80    	mov.w     0x1fd0, w0
    bb3c:	91 fe 80    	mov.w     0x1fd2, w1
    bb3e:	92 14 02    	call      0x1492 <___addsf3>
    bb40:	00 00 00 

0000bb42 <.L0>:
    bb42:	b0 ba 88    	mov.w     w0, 0x1756
    bb44:	c1 ba 88    	mov.w     w1, 0x1758
    bb46:	14 00 37    	bra       0xbb70 <.L66>

0000bb48 <.L0>:
  } else if (AUAV_V3_TestSensors_B.BiasRateLimiter[2] < -2.5572E-9F) {
    bb48:	d2 ab 2b    	mov.w     #0xbabd, w2
    bb4a:	f3 12 2b    	mov.w     #0xb12f, w3
    bb4c:	08 00 be    	mov.d     w8, w0
    bb4e:	8c 18 02    	call      0x188c <___eqsf2>
    bb50:	00 00 00 
    bb52:	00 00 e0    	cp0.w     w0
    bb54:	09 00 3d    	bra       GE, 0xbb68 <.L149>

0000bb56 <.L0>:
    AUAV_V3_TestSensors_B.BiasRateLimiter[2] =
      AUAV_V3_TestSensors_DWork.PrevY_n[2] + -2.5572E-9F;
    bb56:	d2 ab 2b    	mov.w     #0xbabd, w2
    bb58:	f3 12 23    	mov.w     #0x312f, w3
    bb5a:	80 fe 80    	mov.w     0x1fd0, w0
    bb5c:	91 fe 80    	mov.w     0x1fd2, w1
    bb5e:	90 14 02    	call      0x1490 <___subsf3>
    bb60:	00 00 00 

0000bb62 <.L0>:
    bb62:	b0 ba 88    	mov.w     w0, 0x1756
    bb64:	c1 ba 88    	mov.w     w1, 0x1758
    bb66:	04 00 37    	bra       0xbb70 <.L66>

0000bb68 <.L149>:
  } else {
    AUAV_V3_TestSensors_B.BiasRateLimiter[2] = (real32_T)
    bb68:	40 e1 80    	mov.w     0x1c28, w0
    bb6a:	51 e1 80    	mov.w     0x1c2a, w1
    bb6c:	b0 ba 88    	mov.w     w0, 0x1756
    bb6e:	c1 ba 88    	mov.w     w1, 0x1758

0000bb70 <.L66>:
      AUAV_V3_TestSensors_B.sf_myMuxFun1_n.y[2];
  }

  AUAV_V3_TestSensors_DWork.PrevY_n[0] = AUAV_V3_TestSensors_B.BiasRateLimiter[0];
    bb70:	72 ba 80    	mov.w     0x174e, w2
    bb72:	83 ba 80    	mov.w     0x1750, w3
    bb74:	42 fe 88    	mov.w     w2, 0x1fc8
    bb76:	53 fe 88    	mov.w     w3, 0x1fca
  AUAV_V3_TestSensors_DWork.PrevY_n[1] = AUAV_V3_TestSensors_B.BiasRateLimiter[1];
    bb78:	94 ba 80    	mov.w     0x1752, w4
    bb7a:	a5 ba 80    	mov.w     0x1754, w5
    bb7c:	64 fe 88    	mov.w     w4, 0x1fcc
    bb7e:	75 fe 88    	mov.w     w5, 0x1fce
  AUAV_V3_TestSensors_DWork.PrevY_n[2] = AUAV_V3_TestSensors_B.BiasRateLimiter[2];
    bb80:	b0 ba 80    	mov.w     0x1756, w0
    bb82:	c1 ba 80    	mov.w     0x1758, w1
    bb84:	80 fe 88    	mov.w     w0, 0x1fd0
    bb86:	91 fe 88    	mov.w     w1, 0x1fd2

  /* End of RateLimiter: '<S478>/Bias Rate Limiter' */

  /* Gain: '<S510>/Gain1' incorporates:
   *  Selector: '<S510>/Selector1'
   */
  rtb_VectorConcatenate[0] = AUAV_V3_TestSensors_B.VectorConcatenate[3];
    bb88:	92 b7 80    	mov.w     0x16f2, w2
    bb8a:	a3 b7 80    	mov.w     0x16f4, w3
    bb8c:	92 0f 9f    	mov.w     w2, [w15-238]
    bb8e:	a3 0f 9f    	mov.w     w3, [w15-236]
  rtb_VectorConcatenate[1] = AUAV_V3_TestSensors_B.VectorConcatenate[0];
    bb90:	34 b7 80    	mov.w     0x16e6, w4
    bb92:	45 b7 80    	mov.w     0x16e8, w5
    bb94:	b4 0f 9f    	mov.w     w4, [w15-234]
    bb96:	c5 0f 9f    	mov.w     w5, [w15-232]
  rtb_VectorConcatenate[2] = -AUAV_V3_TestSensors_B.VectorConcatenate[6];
    bb98:	f8 b7 80    	mov.w     0x16fe, w8
    bb9a:	09 b8 80    	mov.w     0x1700, w9
    bb9c:	08 00 be    	mov.d     w8, w0
    bb9e:	01 f0 a2    	btg.w     w1, #0xf
    bba0:	d0 0f 9f    	mov.w     w0, [w15-230]
    bba2:	e1 0f 9f    	mov.w     w1, [w15-228]

  /* Gain: '<S510>/Gain2' incorporates:
   *  Selector: '<S510>/Selector2'
   */
  rtb_VectorConcatenate[3] = AUAV_V3_TestSensors_B.VectorConcatenate[7];
    bba4:	10 b8 80    	mov.w     0x1702, w0
    bba6:	21 b8 80    	mov.w     0x1704, w1
    bba8:	f0 0f 9f    	mov.w     w0, [w15-226]
    bbaa:	81 17 9f    	mov.w     w1, [w15-224]
  rtb_VectorConcatenate[4] = AUAV_V3_TestSensors_B.VectorConcatenate[8];
    bbac:	32 b8 80    	mov.w     0x1706, w2
    bbae:	43 b8 80    	mov.w     0x1708, w3
    bbb0:	92 17 9f    	mov.w     w2, [w15-222]
    bbb2:	a3 17 9f    	mov.w     w3, [w15-220]

  /* Gain: '<S510>/Gain3' incorporates:
   *  Selector: '<S510>/Selector3'
   */
  rtb_VectorConcatenate[5] = -AUAV_V3_TestSensors_B.VectorConcatenate[1];
    bbb4:	50 b7 80    	mov.w     0x16ea, w0
    bbb6:	61 b7 80    	mov.w     0x16ec, w1
    bbb8:	01 f0 a2    	btg.w     w1, #0xf
    bbba:	b0 17 9f    	mov.w     w0, [w15-218]
    bbbc:	c1 17 9f    	mov.w     w1, [w15-216]
  rtb_VectorConcatenate[6] = AUAV_V3_TestSensors_B.VectorConcatenate[4];
    bbbe:	b4 b7 80    	mov.w     0x16f6, w4
    bbc0:	c5 b7 80    	mov.w     0x16f8, w5
    bbc2:	d4 17 9f    	mov.w     w4, [w15-214]
    bbc4:	e5 17 9f    	mov.w     w5, [w15-212]

0000bbc6 <.L0>:

  /* If: '<S490>/If' incorporates:
   *  Gain: '<S510>/Gain1'
   *  Selector: '<S510>/Selector1'
   */
  if ((-AUAV_V3_TestSensors_B.VectorConcatenate[6] >= 1.0F) ||
    bbc6:	02 00 20    	mov.w     #0x0, w2
    bbc8:	03 f8 2b    	mov.w     #0xbf80, w3
    bbca:	08 00 be    	mov.d     w8, w0
    bbcc:	8c 18 02    	call      0x188c <___eqsf2>
    bbce:	00 00 00 
    bbd0:	00 00 e0    	cp0.w     w0
    bbd2:	07 00 34    	bra       LE, 0xbbe2 <.L0> <.L0> <.L69>
    bbd4:	02 00 20    	mov.w     #0x0, w2
    bbd6:	03 f8 23    	mov.w     #0x3f80, w3
    bbd8:	08 00 be    	mov.d     w8, w0
    bbda:	90 18 02    	call      0x1890 <___gesf2>
    bbdc:	00 00 00 
    bbde:	00 00 e0    	cp0.w     w0
    bbe0:	08 00 35    	bra       LT, 0xbbf2 <.L0> <.L0> <.L150>

0000bbe2 <.L0>:
      (-AUAV_V3_TestSensors_B.VectorConcatenate[6] <= -1.0F)) {
    /* Outputs for IfAction SubSystem: '<S490>/AxisRotZeroR3' incorporates:
     *  ActionPort: '<S509>/Action Port'
     */
    AUAV_V3_Test_AxisRotZeroR3(rtb_VectorConcatenate,
    bbe2:	23 76 21    	mov.w     #0x1762, w3
    bbe4:	64 81 51    	sub.w     w3, #0x4, w2
    bbe6:	e4 00 51    	sub.w     w2, #0x4, w1
    bbe8:	20 f1 2f    	mov.w     #0xff12, w0
    bbea:	0f 00 40    	add.w     w0, w15, w0
    bbec:	4e 0c 02    	call      0x10c4e <_AUAV_V3_Test_AxisRotZeroR3>
    bbee:	01 00 00 
    bbf0:	07 00 37    	bra       0xbc00 <.L0> <.L0> <.L72>

0000bbf2 <.L0>:
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[0],
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[1],
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[2]);

    /* End of Outputs for SubSystem: '<S490>/AxisRotZeroR3' */
  } else {
    /* Outputs for IfAction SubSystem: '<S490>/AxisRotDefault' incorporates:
     *  ActionPort: '<S508>/Action Port'
     */
    AUAV_V3_Tes_AxisRotDefault(rtb_VectorConcatenate,
    bbf2:	23 76 21    	mov.w     #0x1762, w3
    bbf4:	64 81 51    	sub.w     w3, #0x4, w2
    bbf6:	e4 00 51    	sub.w     w2, #0x4, w1
    bbf8:	20 f1 2f    	mov.w     #0xff12, w0
    bbfa:	0f 00 40    	add.w     w0, w15, w0
    bbfc:	e0 10 02    	call      0x110e0 <_AUAV_V3_Tes_AxisRotDefault>
    bbfe:	01 00 00 

0000bc00 <.L0>:
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[0],
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[1],
      &AUAV_V3_TestSensors_B.DataTypeConversion_m[2]);

    /* End of Outputs for SubSystem: '<S490>/AxisRotDefault' */
  }

  /* End of If: '<S490>/If' */

  /* MATLAB Function: '<S478>/Embedded MATLAB Function' */
  A_EmbeddedMATLABFunction_l(AUAV_V3_TestSensors_B.DataTypeConversion_m[0],
    bc00:	c2 c1 21    	mov.w     #0x1c1c, w2
    bc02:	d0 ba 80    	mov.w     0x175a, w0
    bc04:	e1 ba 80    	mov.w     0x175c, w1
    bc06:	ec 11 02    	call      0x111ec <_A_EmbeddedMATLABFunction_l>
    bc08:	01 00 00 

0000bc0a <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_lt);

  /* Sum: '<S478>/Sum3' */
  AUAV_V3_TestSensors_B.GyroErr[0] = AUAV_V3_TestSensors_B.DataTypeConversion7[0]
    + AUAV_V3_TestSensors_B.BiasRateLimiter[0];
    bc0a:	72 ba 80    	mov.w     0x174e, w2
    bc0c:	83 ba 80    	mov.w     0x1750, w3
    bc0e:	50 b3 80    	mov.w     0x166a, w0
    bc10:	61 b3 80    	mov.w     0x166c, w1
    bc12:	92 14 02    	call      0x1492 <___addsf3>
    bc14:	00 00 00 
    bc16:	00 04 be    	mov.d     w0, w8

0000bc18 <.L0>:
    bc18:	30 bb 88    	mov.w     w0, 0x1766
    bc1a:	41 bb 88    	mov.w     w1, 0x1768

0000bc1c <.L0>:
  AUAV_V3_TestSensors_B.GyroErr[1] = AUAV_V3_TestSensors_B.DataTypeConversion7[1]
    + AUAV_V3_TestSensors_B.BiasRateLimiter[1];
    bc1c:	92 ba 80    	mov.w     0x1752, w2
    bc1e:	a3 ba 80    	mov.w     0x1754, w3
    bc20:	70 b3 80    	mov.w     0x166e, w0
    bc22:	81 b3 80    	mov.w     0x1670, w1
    bc24:	92 14 02    	call      0x1492 <___addsf3>
    bc26:	00 00 00 
    bc28:	00 06 be    	mov.d     w0, w12

0000bc2a <.L0>:
    bc2a:	50 bb 88    	mov.w     w0, 0x176a
    bc2c:	61 bb 88    	mov.w     w1, 0x176c

0000bc2e <.L0>:
  AUAV_V3_TestSensors_B.GyroErr[2] = AUAV_V3_TestSensors_B.DataTypeConversion7[2]
    + AUAV_V3_TestSensors_B.BiasRateLimiter[2];
    bc2e:	b2 ba 80    	mov.w     0x1756, w2
    bc30:	c3 ba 80    	mov.w     0x1758, w3
    bc32:	90 b3 80    	mov.w     0x1672, w0
    bc34:	a1 b3 80    	mov.w     0x1674, w1
    bc36:	92 14 02    	call      0x1492 <___addsf3>
    bc38:	00 00 00 
    bc3a:	d0 b7 9f    	mov.w     w0, [w15-22]
    bc3c:	e1 b7 9f    	mov.w     w1, [w15-20]

0000bc3e <.L0>:
    bc3e:	70 bb 88    	mov.w     w0, 0x176e
    bc40:	81 bb 88    	mov.w     w1, 0x1770

0000bc42 <.L0>:

  /* Sum: '<S478>/Sum1' incorporates:
   *  Gain: '<S478>/Gain'
   */
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[0] = 0.1F * rtb_Add[0] +
    bc42:	d2 cc 2c    	mov.w     #0xcccd, w2
    bc44:	c3 dc 23    	mov.w     #0x3dcc, w3
    bc46:	3f 00 97    	mov.w     [w15-250], w0
    bc48:	cf 00 97    	mov.w     [w15-248], w1
    bc4a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bc4c:	00 00 00 
    bc4e:	00 01 be    	mov.d     w0, w2
    bc50:	08 00 be    	mov.d     w8, w0
    bc52:	92 14 02    	call      0x1492 <___addsf3>
    bc54:	00 00 00 
    bc56:	00 05 be    	mov.d     w0, w10
    bc58:	a0 ed 88    	mov.w     w0, 0x1db4
    bc5a:	b1 ed 88    	mov.w     w1, 0x1db6

0000bc5c <.L0>:
    AUAV_V3_TestSensors_B.GyroErr[0];
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[1] = 0.1F * rtb_Add[1] +
    bc5c:	d2 cc 2c    	mov.w     #0xcccd, w2
    bc5e:	c3 dc 23    	mov.w     #0x3dcc, w3
    bc60:	5f 00 97    	mov.w     [w15-246], w0
    bc62:	ef 00 97    	mov.w     [w15-244], w1
    bc64:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bc66:	00 00 00 
    bc68:	00 01 be    	mov.d     w0, w2
    bc6a:	0c 00 be    	mov.d     w12, w0
    bc6c:	92 14 02    	call      0x1492 <___addsf3>
    bc6e:	00 00 00 
    bc70:	b0 b7 9f    	mov.w     w0, [w15-26]
    bc72:	c1 b7 9f    	mov.w     w1, [w15-24]
    bc74:	c0 ed 88    	mov.w     w0, 0x1db8
    bc76:	d1 ed 88    	mov.w     w1, 0x1dba

0000bc78 <.L0>:
    AUAV_V3_TestSensors_B.GyroErr[1];
  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[2] = 0.1F * rtb_Add[2] +
    bc78:	d2 cc 2c    	mov.w     #0xcccd, w2
    bc7a:	c3 dc 23    	mov.w     #0x3dcc, w3
    bc7c:	7f 00 97    	mov.w     [w15-242], w0
    bc7e:	8f 08 97    	mov.w     [w15-240], w1
    bc80:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bc82:	00 00 00 
    bc84:	00 01 be    	mov.d     w0, w2
    bc86:	5f b0 97    	mov.w     [w15-22], w0
    bc88:	ef b0 97    	mov.w     [w15-20], w1
    bc8a:	92 14 02    	call      0x1492 <___addsf3>
    bc8c:	00 00 00 
    bc8e:	00 06 be    	mov.d     w0, w12
    bc90:	e0 ed 88    	mov.w     w0, 0x1dbc
    bc92:	f1 ed 88    	mov.w     w1, 0x1dbe

0000bc94 <.L0>:
    AUAV_V3_TestSensors_B.GyroErr[2];

  /* MATLAB Function: '<S478>/q dot calc' incorporates:
   *  SignalConversion: '<S497>/TmpSignal ConversionAt SFunction Inport1'
   */
  /* MATLAB Function 'Position_and_Attitude_Filter/Attitude Complimentary Filter COG/q dot calc': '<S497>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S497>:1:5' */
  /* '<S497>:1:6' */
  /* '<S497>:1:7' */
  rtb_q_dot[1] = 0.0F;
    bc94:	60 00 b8    	mul.uu    w0, #0x0, w0
    bc96:	90 1f 9f    	mov.w     w0, [w15-206]
    bc98:	a1 1f 9f    	mov.w     w1, [w15-204]
  rtb_q_dot[2] = 0.0F;
    bc9a:	b0 1f 9f    	mov.w     w0, [w15-202]
    bc9c:	c1 1f 9f    	mov.w     w1, [w15-200]
  rtb_q_dot[3] = 0.0F;
    bc9e:	d0 1f 9f    	mov.w     w0, [w15-198]
    bca0:	e1 1f 9f    	mov.w     w1, [w15-196]

0000bca2 <.L0>:

  /* '<S497>:1:8' */
  rtb_q_dot[0] = (-0.5F * rtb_Product1_gz *
    bca2:	02 00 20    	mov.w     #0x0, w2
    bca4:	03 f0 2b    	mov.w     #0xbf00, w3
    bca6:	1f 98 97    	mov.w     [w15-78], w0
    bca8:	af 98 97    	mov.w     [w15-76], w1
    bcaa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bcac:	00 00 00 
    bcae:	00 01 be    	mov.d     w0, w2
    bcb0:	0a 00 be    	mov.d     w10, w0
    bcb2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bcb4:	00 00 00 
    bcb6:	00 04 be    	mov.d     w0, w8

0000bcb8 <.L0>:
                  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[0] + -0.5F *
    bcb8:	02 00 20    	mov.w     #0x0, w2
    bcba:	03 f0 2b    	mov.w     #0xbf00, w3
    bcbc:	7f 90 97    	mov.w     [w15-82], w0
    bcbe:	8f 98 97    	mov.w     [w15-80], w1
    bcc0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bcc2:	00 00 00 
    bcc4:	00 01 be    	mov.d     w0, w2

0000bcc6 <.L0>:
                  rtb_Product2_noi *
    bcc6:	3f b0 97    	mov.w     [w15-26], w0
    bcc8:	cf b0 97    	mov.w     [w15-24], w1
    bcca:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bccc:	00 00 00 
    bcce:	00 01 be    	mov.d     w0, w2

0000bcd0 <.L0>:
    bcd0:	08 00 be    	mov.d     w8, w0
    bcd2:	92 14 02    	call      0x1492 <___addsf3>
    bcd4:	00 00 00 
    bcd6:	00 04 be    	mov.d     w0, w8

0000bcd8 <.L0>:
                  AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[1]) + -0.5F *
    bcd8:	02 00 20    	mov.w     #0x0, w2
    bcda:	03 f0 2b    	mov.w     #0xbf00, w3
    bcdc:	5f 90 97    	mov.w     [w15-86], w0
    bcde:	ef 90 97    	mov.w     [w15-84], w1
    bce0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bce2:	00 00 00 
    bce4:	00 01 be    	mov.d     w0, w2

0000bce6 <.L0>:
    rtb_Product3_ap * AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[2];
    bce6:	0c 00 be    	mov.d     w12, w0
    bce8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bcea:	00 00 00 
    bcec:	00 01 be    	mov.d     w0, w2

0000bcee <.L0>:
    bcee:	08 00 be    	mov.d     w8, w0
    bcf0:	92 14 02    	call      0x1492 <___addsf3>
    bcf2:	00 00 00 

0000bcf4 <.L0>:
    bcf4:	f0 17 9f    	mov.w     w0, [w15-210]
    bcf6:	81 1f 9f    	mov.w     w1, [w15-208]

  /* '<S497>:1:9' */
  rtb_TmpSignalConversionAtSFun_0[0] = rtb_Product_pc;
    bcf8:	3f a0 97    	mov.w     [w15-58], w0
    bcfa:	cf a0 97    	mov.w     [w15-56], w1
    bcfc:	f0 37 9f    	mov.w     w0, [w15-146]
    bcfe:	81 3f 9f    	mov.w     w1, [w15-144]
  rtb_TmpSignalConversionAtSFun_0[3] = -rtb_Product3_ap;
    bd00:	5f 90 97    	mov.w     [w15-86], w0
    bd02:	ef 90 97    	mov.w     [w15-84], w1
    bd04:	01 f0 a2    	btg.w     w1, #0xf
    bd06:	d0 3f 9f    	mov.w     w0, [w15-134]
    bd08:	e1 3f 9f    	mov.w     w1, [w15-132]
  rtb_TmpSignalConversionAtSFun_0[6] = rtb_Product2_noi;
    bd0a:	7f 91 97    	mov.w     [w15-82], w2
    bd0c:	8f 99 97    	mov.w     [w15-80], w3
    bd0e:	b2 87 9f    	mov.w     w2, [w15-122]
    bd10:	c3 87 9f    	mov.w     w3, [w15-120]
  rtb_TmpSignalConversionAtSFun_0[1] = rtb_Product3_ap;
    bd12:	5f 92 97    	mov.w     [w15-86], w4
    bd14:	ef 92 97    	mov.w     [w15-84], w5
    bd16:	94 3f 9f    	mov.w     w4, [w15-142]
    bd18:	a5 3f 9f    	mov.w     w5, [w15-140]
  rtb_TmpSignalConversionAtSFun_0[4] = rtb_Product_pc;
    bd1a:	3f a0 97    	mov.w     [w15-58], w0
    bd1c:	cf a0 97    	mov.w     [w15-56], w1
    bd1e:	f0 3f 9f    	mov.w     w0, [w15-130]
    bd20:	81 87 9f    	mov.w     w1, [w15-128]
  rtb_TmpSignalConversionAtSFun_0[7] = -rtb_Product1_gz;
    bd22:	1f 98 97    	mov.w     [w15-78], w0
    bd24:	af 98 97    	mov.w     [w15-76], w1
    bd26:	01 f0 a2    	btg.w     w1, #0xf
    bd28:	d0 87 9f    	mov.w     w0, [w15-118]
    bd2a:	e1 87 9f    	mov.w     w1, [w15-116]
  rtb_TmpSignalConversionAtSFun_0[2] = -rtb_Product2_noi;
    bd2c:	02 00 be    	mov.d     w2, w0
    bd2e:	01 f0 a2    	btg.w     w1, #0xf
    bd30:	b0 3f 9f    	mov.w     w0, [w15-138]
    bd32:	c1 3f 9f    	mov.w     w1, [w15-136]
  rtb_TmpSignalConversionAtSFun_0[5] = rtb_Product1_gz;
    bd34:	1f 99 97    	mov.w     [w15-78], w2
    bd36:	af 99 97    	mov.w     [w15-76], w3
    bd38:	92 87 9f    	mov.w     w2, [w15-126]
    bd3a:	a3 87 9f    	mov.w     w3, [w15-124]
  rtb_TmpSignalConversionAtSFun_0[8] = rtb_Product_pc;
    bd3c:	3f a2 97    	mov.w     [w15-58], w4
    bd3e:	cf a2 97    	mov.w     [w15-56], w5
    bd40:	f4 87 9f    	mov.w     w4, [w15-114]
    bd42:	85 8f 9f    	mov.w     w5, [w15-112]
    bd44:	ee f6 2f    	mov.w     #0xff6e, w14
    bd46:	0f 07 47    	add.w     w14, w15, w14
    bd48:	e5 f3 2f    	mov.w     #0xff3e, w5
    bd4a:	85 82 47    	add.w     w15, w5, w5
    bd4c:	d5 b7 9f    	mov.w     w5, [w15-22]
    bd4e:	20 f9 2f    	mov.w     #0xff92, w0
    bd50:	00 80 47    	add.w     w15, w0, w0
    bd52:	b0 af 9f    	mov.w     w0, [w15-42]

0000bd54 <.L0>:
  for (colIdx = 0; colIdx < 3; colIdx++) {
    tmp[3 * colIdx] = rtb_TmpSignalConversionAtSFun_0[3 * colIdx] * 0.5F;
    bd54:	08 00 20    	mov.w     #0x0, w8
    bd56:	09 f0 23    	mov.w     #0x3f00, w9
    bd58:	9a b7 9f    	mov.w     w10, [w15-30]
    bd5a:	ab b7 9f    	mov.w     w11, [w15-28]
    bd5c:	05 05 78    	mov.w     w5, w10

0000bd5e <.L73>:
    bd5e:	08 01 be    	mov.d     w8, w2
    bd60:	1e 00 be    	mov.d     [w14], w0
    bd62:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bd64:	00 00 00 
    bd66:	00 8d be    	mov.d     w0, [w10]

0000bd68 <.L0>:
    tmp[1 + 3 * colIdx] = rtb_TmpSignalConversionAtSFun_0[3 * colIdx + 1] * 0.5F;
    bd68:	08 01 be    	mov.d     w8, w2
    bd6a:	2e 00 90    	mov.w     [w14+4], w0
    bd6c:	be 00 90    	mov.w     [w14+6], w1
    bd6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bd70:	00 00 00 
    bd72:	20 05 98    	mov.w     w0, [w10+4]
    bd74:	31 05 98    	mov.w     w1, [w10+6]

0000bd76 <.L0>:
    tmp[2 + 3 * colIdx] = rtb_TmpSignalConversionAtSFun_0[3 * colIdx + 2] * 0.5F;
    bd76:	08 01 be    	mov.d     w8, w2
    bd78:	4e 00 90    	mov.w     [w14+8], w0
    bd7a:	de 00 90    	mov.w     [w14+10], w1
    bd7c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bd7e:	00 00 00 
    bd80:	40 05 98    	mov.w     w0, [w10+8]
    bd82:	51 05 98    	mov.w     w1, [w10+10]
    bd84:	6c 07 47    	add.w     w14, #0xc, w14
    bd86:	6c 05 45    	add.w     w10, #0xc, w10

0000bd88 <.L0>:
    bd88:	bf a9 97    	mov.w     [w15-42], w3
    bd8a:	83 0f 57    	sub.w     w14, w3, [w15]
    bd8c:	e8 ff 3a    	bra       NZ, 0xbd5e <.L73>
    bd8e:	1f b5 97    	mov.w     [w15-30], w10
    bd90:	af b5 97    	mov.w     [w15-28], w11
    bd92:	e4 f3 2f    	mov.w     #0xff3e, w4
    bd94:	0f 02 42    	add.w     w4, w15, w4
    bd96:	64 02 52    	sub.w     w4, #0x4, w4
    bd98:	94 b7 9f    	mov.w     w4, [w15-30]
    bd9a:	e5 f3 2f    	mov.w     #0xff3e, w5
    bd9c:	8f 82 42    	add.w     w5, w15, w5
    bd9e:	e8 82 42    	add.w     w5, #0x8, w5
    bda0:	d5 b7 9f    	mov.w     w5, [w15-22]
    bda2:	e0 f3 2f    	mov.w     #0xff3e, w0
    bda4:	0f 00 40    	add.w     w0, w15, w0
    bda6:	74 00 40    	add.w     w0, #0x14, w0
    bda8:	f0 a7 9f    	mov.w     w0, [w15-50]
    bdaa:	e1 f2 2f    	mov.w     #0xff2e, w1
    bdac:	81 80 47    	add.w     w15, w1, w1
    bdae:	b1 a7 9f    	mov.w     w1, [w15-58]
    bdb0:	00 07 eb    	clr.w     w14

0000bdb2 <.L74>:
  }

  for (colIdx = 0; colIdx < 3; colIdx++) {
    rtb_q_dot[1 + colIdx] = 0.0F;
    bdb2:	0e 07 e8    	inc.w     w14, w14

0000bdb4 <.L0>:
    rtb_q_dot[1 + colIdx] += tmp[colIdx] *
    bdb4:	1f b2 97    	mov.w     [w15-30], w4
    bdb6:	54 01 be    	mov.d     [++w4], w2
    bdb8:	94 b7 9f    	mov.w     w4, [w15-30]
    bdba:	0a 00 be    	mov.d     w10, w0
    bdbc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bdbe:	00 00 00 
    bdc0:	60 11 b8    	mul.uu    w2, #0x0, w2
    bdc2:	92 14 02    	call      0x1492 <___addsf3>
    bdc4:	00 00 00 
    bdc6:	00 04 be    	mov.d     w0, w8

0000bdc8 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[0];
    rtb_q_dot[1 + colIdx] += tmp[colIdx + 3] *
    bdc8:	df b2 97    	mov.w     [w15-22], w5
    bdca:	55 01 be    	mov.d     [++w5], w2
    bdcc:	d5 b7 9f    	mov.w     w5, [w15-22]
    bdce:	3f b0 97    	mov.w     [w15-26], w0
    bdd0:	cf b0 97    	mov.w     [w15-24], w1
    bdd2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bdd4:	00 00 00 
    bdd6:	00 01 be    	mov.d     w0, w2
    bdd8:	08 00 be    	mov.d     w8, w0
    bdda:	92 14 02    	call      0x1492 <___addsf3>
    bddc:	00 00 00 
    bdde:	00 04 be    	mov.d     w0, w8

0000bde0 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[1];
    rtb_q_dot[1 + colIdx] += tmp[colIdx + 6] *
    bde0:	7f a0 97    	mov.w     [w15-50], w0
    bde2:	50 01 be    	mov.d     [++w0], w2
    bde4:	f0 a7 9f    	mov.w     w0, [w15-50]
    bde6:	0c 00 be    	mov.d     w12, w0
    bde8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bdea:	00 00 00 
    bdec:	00 01 be    	mov.d     w0, w2
    bdee:	08 00 be    	mov.d     w8, w0
    bdf0:	92 14 02    	call      0x1492 <___addsf3>
    bdf2:	00 00 00 
    bdf4:	3f a1 97    	mov.w     [w15-58], w2
    bdf6:	00 a9 be    	mov.d     w0, [++w2]
    bdf8:	b2 a7 9f    	mov.w     w2, [w15-58]

0000bdfa <.L0>:
    bdfa:	e3 0f 57    	sub.w     w14, #0x3, [w15]
    bdfc:	da ff 3a    	bra       NZ, 0xbdb2 <.L74>
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_j[2];
  }

  /* End of MATLAB Function: '<S478>/q dot calc' */

  /* DataTypeConversion: '<S570>/Data Type Conversion2' incorporates:
   *  Gain: '<S14>/[1 1 -1]'
   *  Gain: '<S555>/Gain'
   *  Sum: '<S555>/Sum'
   *  Sum: '<S555>/Sum1'
   *  UnitDelay: '<S555>/Unit Delay'
   */
  rtb_DataTypeConversion2_b = (AUAV_V3_TestSensors_B.In1[0] -
    AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_n) * 10.0F + rtb_Deg2R_idx_0;
    bdfe:	8a e4 21    	mov.w     #0x1e48, w10

0000be00 <.L0>:
    be00:	1a 01 be    	mov.d     [w10], w2
    be02:	90 bb 80    	mov.w     0x1772, w0
    be04:	a1 bb 80    	mov.w     0x1774, w1
    be06:	90 14 02    	call      0x1490 <___subsf3>
    be08:	00 00 00 

0000be0a <.L0>:
    be0a:	02 00 20    	mov.w     #0x0, w2
    be0c:	03 12 24    	mov.w     #0x4120, w3
    be0e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be10:	00 00 00 

0000be12 <.L0>:
    be12:	3f 89 97    	mov.w     [w15-106], w2
    be14:	cf 89 97    	mov.w     [w15-104], w3
    be16:	92 14 02    	call      0x1492 <___addsf3>
    be18:	00 00 00 
    be1a:	00 06 be    	mov.d     w0, w12

0000be1c <.L0>:

  /* DiscreteZeroPole: '<S571>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_ki = 0.005*rtb_DataTypeConversion2_b;
    be1c:	a2 70 2d    	mov.w     #0xd70a, w2
    be1e:	33 ba 23    	mov.w     #0x3ba3, w3
    be20:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be22:	00 00 00 
    be24:	00 04 be    	mov.d     w0, w8

0000be26 <.L0>:
    rtb_DiscreteZeroPole_ki += 0.01*
    be26:	a2 70 2d    	mov.w     #0xd70a, w2
    be28:	33 c2 23    	mov.w     #0x3c23, w3
    be2a:	c0 eb 80    	mov.w     0x1d78, w0
    be2c:	d1 eb 80    	mov.w     0x1d7a, w1
    be2e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be30:	00 00 00 
    be32:	08 01 be    	mov.d     w8, w2
    be34:	92 14 02    	call      0x1492 <___addsf3>
    be36:	00 00 00 
    be38:	00 04 be    	mov.d     w0, w8

0000be3a <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_jl;
  }

  /* DataTypeConversion: '<S570>/Data Type Conversion1' */
  AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_n = (real32_T)
    be3a:	00 8d be    	mov.d     w0, [w10]
    rtb_DiscreteZeroPole_ki;

  /* DataTypeConversion: '<S572>/Data Type Conversion2' incorporates:
   *  Gain: '<S14>/[1 1 -1]'
   *  Gain: '<S556>/Gain'
   *  Sum: '<S556>/Sum'
   *  Sum: '<S556>/Sum1'
   *  UnitDelay: '<S556>/Unit Delay'
   */
  rtb_DataTypeConversion2_j = (AUAV_V3_TestSensors_B.In1[1] -
    AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_j) * 10.0F + rtb_Deg2R_idx_1;
    be3c:	64 07 45    	add.w     w10, #0x4, w14

0000be3e <.L0>:
    be3e:	1e 01 be    	mov.d     [w14], w2
    be40:	b0 bb 80    	mov.w     0x1776, w0
    be42:	c1 bb 80    	mov.w     0x1778, w1
    be44:	90 14 02    	call      0x1490 <___subsf3>
    be46:	00 00 00 

0000be48 <.L0>:
    be48:	02 00 20    	mov.w     #0x0, w2
    be4a:	03 12 24    	mov.w     #0x4120, w3
    be4c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be4e:	00 00 00 

0000be50 <.L0>:
    be50:	1f 89 97    	mov.w     [w15-110], w2
    be52:	af 89 97    	mov.w     [w15-108], w3
    be54:	92 14 02    	call      0x1492 <___addsf3>
    be56:	00 00 00 
    be58:	00 05 be    	mov.d     w0, w10

0000be5a <.L0>:

  /* DiscreteZeroPole: '<S573>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_ki = 0.005*rtb_DataTypeConversion2_j;
    be5a:	a2 70 2d    	mov.w     #0xd70a, w2
    be5c:	33 ba 23    	mov.w     #0x3ba3, w3
    be5e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be60:	00 00 00 
    be62:	d0 b7 9f    	mov.w     w0, [w15-22]
    be64:	e1 b7 9f    	mov.w     w1, [w15-20]

0000be66 <.L0>:
    rtb_DiscreteZeroPole_ki += 0.01*
    be66:	a2 70 2d    	mov.w     #0xd70a, w2
    be68:	33 c2 23    	mov.w     #0x3c23, w3
    be6a:	e0 eb 80    	mov.w     0x1d7c, w0
    be6c:	f1 eb 80    	mov.w     0x1d7e, w1
    be6e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be70:	00 00 00 
    be72:	5f b1 97    	mov.w     [w15-22], w2
    be74:	ef b1 97    	mov.w     [w15-20], w3
    be76:	92 14 02    	call      0x1492 <___addsf3>
    be78:	00 00 00 
    be7a:	d0 b7 9f    	mov.w     w0, [w15-22]
    be7c:	e1 b7 9f    	mov.w     w1, [w15-20]

0000be7e <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_a;
  }

  /* DataTypeConversion: '<S572>/Data Type Conversion1' */
  AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_j = (real32_T)
    be7e:	00 8f be    	mov.d     w0, [w14]

0000be80 <.L0>:
    rtb_DiscreteZeroPole_ki;

  /* DataTypeConversion: '<S574>/Data Type Conversion2' */
  rtb_DataTypeConversion2_gb = rtb_jxi;

  /* DiscreteZeroPole: '<S575>/Discrete Zero-Pole' */
  {
    rtb_DiscreteZeroPole_ki = 0.005*rtb_DataTypeConversion2_gb;
    be80:	a2 70 2d    	mov.w     #0xd70a, w2
    be82:	33 ba 23    	mov.w     #0x3ba3, w3
    be84:	5f 98 97    	mov.w     [w15-70], w0
    be86:	ef 98 97    	mov.w     [w15-68], w1
    be88:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be8a:	00 00 00 
    be8c:	90 b7 9f    	mov.w     w0, [w15-30]
    be8e:	a1 b7 9f    	mov.w     w1, [w15-28]

0000be90 <.L0>:
    rtb_DiscreteZeroPole_ki += 0.01*
    be90:	a2 70 2d    	mov.w     #0xd70a, w2
    be92:	33 c2 23    	mov.w     #0x3c23, w3
    be94:	00 ec 80    	mov.w     0x1d80, w0
    be96:	11 ec 80    	mov.w     0x1d82, w1
    be98:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    be9a:	00 00 00 
    be9c:	1f b1 97    	mov.w     [w15-30], w2
    be9e:	af b1 97    	mov.w     [w15-28], w3
    bea0:	92 14 02    	call      0x1492 <___addsf3>
    bea2:	00 00 00 

0000bea4 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_b;
  }

  /* DataTypeConversion: '<S574>/Data Type Conversion1' */
  AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE = (real32_T)rtb_DiscreteZeroPole_ki;
    bea4:	60 ee 88    	mov.w     w0, 0x1dcc
    bea6:	71 ee 88    	mov.w     w1, 0x1dce

0000bea8 <.L0>:

  /* MATLAB Function: '<S552>/myMux Fun1' incorporates:
   *  Gain: '<S552>/Gain1'
   */
  AUAV_V3_TestSe_myMuxFun1_e(AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_n,
    bea8:	86 be 21    	mov.w     #0x1be8, w6
    beaa:	44 e0 80    	mov.w     0x1c08, w4
    beac:	55 e0 80    	mov.w     0x1c0a, w5
    beae:	05 f0 a2    	btg.w     w5, #0xf
    beb0:	5f b1 97    	mov.w     [w15-22], w2
    beb2:	ef b1 97    	mov.w     [w15-20], w3
    beb4:	08 00 be    	mov.d     w8, w0
    beb6:	68 12 02    	call      0x11268 <_AUAV_V3_TestSe_myMuxFun1_e>
    beb8:	01 00 00 

0000beba <.L0>:
    AUAV_V3_TestSensors_DWork.UnitDelay_DSTATE_j,
    -AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ph.y,
    &AUAV_V3_TestSensors_B.sf_myMuxFun1_e);

  /* Update for DiscreteIntegrator: '<S478>/Discrete-Time Integrator1' */
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] += 0.01F *
    beba:	8e 0a b1    	sub.w     #0xa8, w14
    bebc:	a2 70 2d    	mov.w     #0xd70a, w2
    bebe:	33 c2 23    	mov.w     #0x3c23, w3
    bec0:	7f 10 97    	mov.w     [w15-210], w0
    bec2:	8f 18 97    	mov.w     [w15-208], w1
    bec4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bec6:	00 00 00 
    bec8:	1e 01 be    	mov.d     [w14], w2
    beca:	92 14 02    	call      0x1492 <___addsf3>
    becc:	00 00 00 
    bece:	00 04 be    	mov.d     w0, w8
    bed0:	00 8f be    	mov.d     w0, [w14]

0000bed2 <.L0>:
    rtb_q_dot[0];
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] += 0.01F *
    bed2:	64 07 47    	add.w     w14, #0x4, w14
    bed4:	a2 70 2d    	mov.w     #0xd70a, w2
    bed6:	33 c2 23    	mov.w     #0x3c23, w3
    bed8:	1f 18 97    	mov.w     [w15-206], w0
    beda:	af 18 97    	mov.w     [w15-204], w1
    bedc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bede:	00 00 00 
    bee0:	00 01 be    	mov.d     w0, w2
    bee2:	1e 00 be    	mov.d     [w14], w0
    bee4:	92 14 02    	call      0x1492 <___addsf3>
    bee6:	00 00 00 
    bee8:	00 8f be    	mov.d     w0, [w14]

0000beea <.L0>:
    rtb_q_dot[1];
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] += 0.01F *
    beea:	64 07 47    	add.w     w14, #0x4, w14
    beec:	a2 70 2d    	mov.w     #0xd70a, w2
    beee:	33 c2 23    	mov.w     #0x3c23, w3
    bef0:	3f 18 97    	mov.w     [w15-202], w0
    bef2:	cf 18 97    	mov.w     [w15-200], w1
    bef4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bef6:	00 00 00 
    bef8:	00 01 be    	mov.d     w0, w2
    befa:	1e 00 be    	mov.d     [w14], w0
    befc:	92 14 02    	call      0x1492 <___addsf3>
    befe:	00 00 00 
    bf00:	00 8f be    	mov.d     w0, [w14]

0000bf02 <.L0>:
    rtb_q_dot[2];
  AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] += 0.01F *
    bf02:	64 07 47    	add.w     w14, #0x4, w14
    bf04:	a2 70 2d    	mov.w     #0xd70a, w2
    bf06:	33 c2 23    	mov.w     #0x3c23, w3
    bf08:	5f 18 97    	mov.w     [w15-198], w0
    bf0a:	ef 18 97    	mov.w     [w15-196], w1
    bf0c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    bf0e:	00 00 00 
    bf10:	00 01 be    	mov.d     w0, w2
    bf12:	1e 00 be    	mov.d     [w14], w0
    bf14:	92 14 02    	call      0x1492 <___addsf3>
    bf16:	00 00 00 
    bf18:	00 8f be    	mov.d     w0, [w14]

0000bf1a <.L0>:
    rtb_q_dot[3];
  if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] >= 1.0F) {
    bf1a:	02 00 20    	mov.w     #0x0, w2
    bf1c:	03 f8 23    	mov.w     #0x3f80, w3
    bf1e:	08 00 be    	mov.d     w8, w0
    bf20:	90 18 02    	call      0x1890 <___gesf2>
    bf22:	00 00 00 
    bf24:	00 00 e0    	cp0.w     w0
    bf26:	05 00 35    	bra       LT, 0xbf32 <.L0> <.L151>

0000bf28 <.L0>:
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] = 1.0F;
    bf28:	00 00 20    	mov.w     #0x0, w0
    bf2a:	01 f8 23    	mov.w     #0x3f80, w1
    bf2c:	20 ed 88    	mov.w     w0, 0x1da4
    bf2e:	31 ed 88    	mov.w     w1, 0x1da6
    bf30:	0b 00 37    	bra       0xbf48 <.L0> <.L77>

0000bf32 <.L0>:
  } else {
    if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] <= -1.0F) {
    bf32:	02 00 20    	mov.w     #0x0, w2
    bf34:	03 f8 2b    	mov.w     #0xbf80, w3
    bf36:	08 00 be    	mov.d     w8, w0
    bf38:	8c 18 02    	call      0x188c <___eqsf2>
    bf3a:	00 00 00 
    bf3c:	00 00 e0    	cp0.w     w0
    bf3e:	04 00 3c    	bra       GT, 0xbf48 <.L0> <.L77>

0000bf40 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[0] = -1.0F;
    bf40:	00 00 20    	mov.w     #0x0, w0
    bf42:	01 f8 2b    	mov.w     #0xbf80, w1
    bf44:	20 ed 88    	mov.w     w0, 0x1da4
    bf46:	31 ed 88    	mov.w     w1, 0x1da6

0000bf48 <.L0>:
    }
  }

  if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] >= 1.0F) {
    bf48:	48 ed 80    	mov.w     0x1da8, w8
    bf4a:	59 ed 80    	mov.w     0x1daa, w9
    bf4c:	02 00 20    	mov.w     #0x0, w2
    bf4e:	03 f8 23    	mov.w     #0x3f80, w3
    bf50:	08 00 be    	mov.d     w8, w0
    bf52:	90 18 02    	call      0x1890 <___gesf2>
    bf54:	00 00 00 
    bf56:	00 00 e0    	cp0.w     w0
    bf58:	05 00 35    	bra       LT, 0xbf64 <.L0> <.L152>

0000bf5a <.L0>:
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] = 1.0F;
    bf5a:	00 00 20    	mov.w     #0x0, w0
    bf5c:	01 f8 23    	mov.w     #0x3f80, w1
    bf5e:	40 ed 88    	mov.w     w0, 0x1da8
    bf60:	51 ed 88    	mov.w     w1, 0x1daa
    bf62:	0b 00 37    	bra       0xbf7a <.L0> <.L81>

0000bf64 <.L0>:
  } else {
    if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] <= -1.0F) {
    bf64:	02 00 20    	mov.w     #0x0, w2
    bf66:	03 f8 2b    	mov.w     #0xbf80, w3
    bf68:	08 00 be    	mov.d     w8, w0
    bf6a:	8c 18 02    	call      0x188c <___eqsf2>
    bf6c:	00 00 00 
    bf6e:	00 00 e0    	cp0.w     w0
    bf70:	04 00 3c    	bra       GT, 0xbf7a <.L0> <.L81>

0000bf72 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[1] = -1.0F;
    bf72:	00 00 20    	mov.w     #0x0, w0
    bf74:	01 f8 2b    	mov.w     #0xbf80, w1
    bf76:	40 ed 88    	mov.w     w0, 0x1da8
    bf78:	51 ed 88    	mov.w     w1, 0x1daa

0000bf7a <.L0>:
    }
  }

  if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] >= 1.0F) {
    bf7a:	68 ed 80    	mov.w     0x1dac, w8
    bf7c:	79 ed 80    	mov.w     0x1dae, w9
    bf7e:	02 00 20    	mov.w     #0x0, w2
    bf80:	03 f8 23    	mov.w     #0x3f80, w3
    bf82:	08 00 be    	mov.d     w8, w0
    bf84:	90 18 02    	call      0x1890 <___gesf2>
    bf86:	00 00 00 
    bf88:	00 00 e0    	cp0.w     w0
    bf8a:	05 00 35    	bra       LT, 0xbf96 <.L0> <.L153>

0000bf8c <.L0>:
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] = 1.0F;
    bf8c:	00 00 20    	mov.w     #0x0, w0
    bf8e:	01 f8 23    	mov.w     #0x3f80, w1
    bf90:	60 ed 88    	mov.w     w0, 0x1dac
    bf92:	71 ed 88    	mov.w     w1, 0x1dae
    bf94:	0b 00 37    	bra       0xbfac <.L0> <.L85>

0000bf96 <.L0>:
  } else {
    if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] <= -1.0F) {
    bf96:	02 00 20    	mov.w     #0x0, w2
    bf98:	03 f8 2b    	mov.w     #0xbf80, w3
    bf9a:	08 00 be    	mov.d     w8, w0
    bf9c:	8c 18 02    	call      0x188c <___eqsf2>
    bf9e:	00 00 00 
    bfa0:	00 00 e0    	cp0.w     w0
    bfa2:	04 00 3c    	bra       GT, 0xbfac <.L0> <.L85>

0000bfa4 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[2] = -1.0F;
    bfa4:	00 00 20    	mov.w     #0x0, w0
    bfa6:	01 f8 2b    	mov.w     #0xbf80, w1
    bfa8:	60 ed 88    	mov.w     w0, 0x1dac
    bfaa:	71 ed 88    	mov.w     w1, 0x1dae

0000bfac <.L0>:
    }
  }

  if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] >= 1.0F) {
    bfac:	88 ed 80    	mov.w     0x1db0, w8
    bfae:	99 ed 80    	mov.w     0x1db2, w9
    bfb0:	02 00 20    	mov.w     #0x0, w2
    bfb2:	03 f8 23    	mov.w     #0x3f80, w3
    bfb4:	08 00 be    	mov.d     w8, w0
    bfb6:	90 18 02    	call      0x1890 <___gesf2>
    bfb8:	00 00 00 
    bfba:	00 00 e0    	cp0.w     w0
    bfbc:	05 00 35    	bra       LT, 0xbfc8 <.L0> <.L154>

0000bfbe <.L0>:
    AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] = 1.0F;
    bfbe:	00 00 20    	mov.w     #0x0, w0
    bfc0:	01 f8 23    	mov.w     #0x3f80, w1
    bfc2:	80 ed 88    	mov.w     w0, 0x1db0
    bfc4:	91 ed 88    	mov.w     w1, 0x1db2
    bfc6:	0b 00 37    	bra       0xbfde <.L89>

0000bfc8 <.L0>:
  } else {
    if (AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] <= -1.0F) {
    bfc8:	02 00 20    	mov.w     #0x0, w2
    bfca:	03 f8 2b    	mov.w     #0xbf80, w3
    bfcc:	08 00 be    	mov.d     w8, w0
    bfce:	8c 18 02    	call      0x188c <___eqsf2>
    bfd0:	00 00 00 
    bfd2:	00 00 e0    	cp0.w     w0
    bfd4:	04 00 3c    	bra       GT, 0xbfde <.L89>

0000bfd6 <.L0>:
      AUAV_V3_TestSensors_DWork.DiscreteTimeIntegrator1_DSTATE[3] = -1.0F;
    bfd6:	00 00 20    	mov.w     #0x0, w0
    bfd8:	01 f8 2b    	mov.w     #0xbf80, w1
    bfda:	80 ed 88    	mov.w     w0, 0x1db0
    bfdc:	91 ed 88    	mov.w     w1, 0x1db2

0000bfde <.L89>:
    }
  }

  /* End of Update for DiscreteIntegrator: '<S478>/Discrete-Time Integrator1' */

  /* Update for UnitDelay: '<S544>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE = AUAV_V3_TestSensors_B.In1[0];
    bfde:	90 bb 80    	mov.w     0x1772, w0
    bfe0:	a1 bb 80    	mov.w     0x1774, w1
    bfe2:	00 ee 88    	mov.w     w0, 0x1dc0
    bfe4:	11 ee 88    	mov.w     w1, 0x1dc2

  /* Update for UnitDelay: '<S545>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE_o = AUAV_V3_TestSensors_B.In1[1];
    bfe6:	b2 bb 80    	mov.w     0x1776, w2
    bfe8:	c3 bb 80    	mov.w     0x1778, w3
    bfea:	22 ee 88    	mov.w     w2, 0x1dc4
    bfec:	33 ee 88    	mov.w     w3, 0x1dc6

  /* Update for UnitDelay: '<S546>/UD' */
  AUAV_V3_TestSensors_DWork.UD_DSTATE_o2 = AUAV_V3_TestSensors_B.In1[2];
    bfee:	d4 bb 80    	mov.w     0x177a, w4
    bff0:	e5 bb 80    	mov.w     0x177c, w5
    bff2:	44 ee 88    	mov.w     w4, 0x1dc8
    bff4:	55 ee 88    	mov.w     w5, 0x1dca

  /* Update for Delay: '<S489>/Integer Delay1' */
  for (colIdx = 0; colIdx < 4; colIdx++) {
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[colIdx * 3] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[(colIdx + 1) * 3];
    bff6:	c0 dd 21    	mov.w     #0x1ddc, w0
    bff8:	10 01 be    	mov.d     [w0], w2
    bffa:	82 ee 88    	mov.w     w2, 0x1dd0
    bffc:	93 ee 88    	mov.w     w3, 0x1dd2
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[colIdx * 3 + 1] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[(colIdx + 1) * 3 + 1];
    bffe:	e4 00 40    	add.w     w0, #0x4, w1
    c000:	11 02 be    	mov.d     [w1], w4
    c002:	a4 ee 88    	mov.w     w4, 0x1dd4
    c004:	b5 ee 88    	mov.w     w5, 0x1dd6
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[colIdx * 3 + 2] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[(colIdx + 1) * 3 + 2];
    c006:	68 01 40    	add.w     w0, #0x8, w2
    c008:	12 02 be    	mov.d     [w2], w4
    c00a:	c4 ee 88    	mov.w     w4, 0x1dd8
    c00c:	d5 ee 88    	mov.w     w5, 0x1dda
    c00e:	ec 01 40    	add.w     w0, #0xc, w3
    c010:	33 18 78    	mov.w     [w3++], [w0++]
    c012:	23 10 78    	mov.w     [w3--], [w0--]
    c014:	70 02 40    	add.w     w0, #0x10, w4
    c016:	b4 18 78    	mov.w     [w4++], [w1++]
    c018:	a4 10 78    	mov.w     [w4--], [w1--]
    c01a:	74 00 40    	add.w     w0, #0x14, w0
    c01c:	30 19 78    	mov.w     [w0++], [w2++]
    c01e:	20 11 78    	mov.w     [w0--], [w2--]
    c020:	f4 80 40    	add.w     w1, #0x14, w1
    c022:	b1 19 78    	mov.w     [w1++], [w3++]
    c024:	a1 11 78    	mov.w     [w1--], [w3--]
    c026:	74 01 41    	add.w     w2, #0x14, w2
    c028:	32 1a 78    	mov.w     [w2++], [w4++]
    c02a:	22 12 78    	mov.w     [w2--], [w4--]
    c02c:	70 02 42    	add.w     w4, #0x10, w4
    c02e:	34 18 78    	mov.w     [w4++], [w0++]
    c030:	24 10 78    	mov.w     [w4--], [w0--]
    c032:	f8 81 41    	add.w     w3, #0x18, w3
    c034:	b3 18 78    	mov.w     [w3++], [w1++]
    c036:	a3 10 78    	mov.w     [w3--], [w1--]
    c038:	f0 80 40    	add.w     w1, #0x10, w1
    c03a:	31 19 78    	mov.w     [w1++], [w2++]
    c03c:	21 11 78    	mov.w     [w1--], [w2--]
    c03e:	78 00 40    	add.w     w0, #0x18, w0
    c040:	30 1a 78    	mov.w     [w0++], [w4++]
    c042:	20 12 78    	mov.w     [w0--], [w4--]
  }

  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[12] = rtb_Product1_e[0];
    c044:	7f b2 96    	mov.w     [w15-274], w4
    c046:	8f ba 96    	mov.w     [w15-272], w5
    c048:	84 89 be    	mov.d     w4, [w3]
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[13] = rtb_Product1_e[1];
    c04a:	1f b9 96    	mov.w     [w15-270], w2
    c04c:	af b9 96    	mov.w     [w15-268], w3
    c04e:	82 88 be    	mov.d     w2, [w1]
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE[14] = rtb_Product1_e[2];
    c050:	3f ba 96    	mov.w     [w15-266], w4
    c052:	cf ba 96    	mov.w     [w15-264], w5
    c054:	04 88 be    	mov.d     w4, [w0]

  /* End of Update for Delay: '<S489>/Integer Delay1' */

  /* Update for Delay: '<S559>/Integer Delay1' */
  for (colIdx = 0; colIdx < 4; colIdx++) {
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[colIdx * 3] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[(colIdx + 1) * 3];
    c056:	70 00 40    	add.w     w0, #0x10, w0
    c058:	10 01 be    	mov.d     [w0], w2
    c05a:	62 f0 88    	mov.w     w2, 0x1e0c
    c05c:	73 f0 88    	mov.w     w3, 0x1e0e
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[colIdx * 3 + 1] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[(colIdx + 1) * 3 + 1];
    c05e:	f8 80 40    	add.w     w1, #0x18, w1
    c060:	11 02 be    	mov.d     [w1], w4
    c062:	84 f0 88    	mov.w     w4, 0x1e10
    c064:	95 f0 88    	mov.w     w5, 0x1e12
    AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[colIdx * 3 + 2] =
      AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[(colIdx + 1) * 3 + 2];
    c066:	68 01 40    	add.w     w0, #0x8, w2
    c068:	12 02 be    	mov.d     [w2], w4
    c06a:	a4 f0 88    	mov.w     w4, 0x1e14
    c06c:	b5 f0 88    	mov.w     w5, 0x1e16
    c06e:	ec 01 40    	add.w     w0, #0xc, w3
    c070:	33 18 78    	mov.w     [w3++], [w0++]
    c072:	23 10 78    	mov.w     [w3--], [w0--]
    c074:	70 02 40    	add.w     w0, #0x10, w4
    c076:	b4 18 78    	mov.w     [w4++], [w1++]
    c078:	a4 10 78    	mov.w     [w4--], [w1--]
    c07a:	74 00 40    	add.w     w0, #0x14, w0
    c07c:	30 19 78    	mov.w     [w0++], [w2++]
    c07e:	20 11 78    	mov.w     [w0--], [w2--]
    c080:	f4 80 40    	add.w     w1, #0x14, w1
    c082:	b1 19 78    	mov.w     [w1++], [w3++]
    c084:	a1 11 78    	mov.w     [w1--], [w3--]
    c086:	74 01 41    	add.w     w2, #0x14, w2
    c088:	32 1a 78    	mov.w     [w2++], [w4++]
    c08a:	22 12 78    	mov.w     [w2--], [w4--]
    c08c:	70 02 42    	add.w     w4, #0x10, w4
    c08e:	34 18 78    	mov.w     [w4++], [w0++]
    c090:	24 10 78    	mov.w     [w4--], [w0--]
    c092:	f8 81 41    	add.w     w3, #0x18, w3
    c094:	b3 18 78    	mov.w     [w3++], [w1++]
    c096:	a3 10 78    	mov.w     [w3--], [w1--]
    c098:	f0 80 40    	add.w     w1, #0x10, w1
    c09a:	31 19 78    	mov.w     [w1++], [w2++]
    c09c:	21 11 78    	mov.w     [w1--], [w2--]
    c09e:	78 00 40    	add.w     w0, #0x18, w0
    c0a0:	30 1a 78    	mov.w     [w0++], [w4++]
    c0a2:	20 12 78    	mov.w     [w0--], [w4--]
  }

  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[12] = rtb_Product1_kx[0];
    c0a4:	5f ba 96    	mov.w     [w15-262], w4
    c0a6:	ef ba 96    	mov.w     [w15-260], w5
    c0a8:	84 89 be    	mov.d     w4, [w3]
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[13] = rtb_Product1_kx[1];
    c0aa:	7f b9 96    	mov.w     [w15-258], w2
    c0ac:	8f 01 97    	mov.w     [w15-256], w3
    c0ae:	82 88 be    	mov.d     w2, [w1]
  AUAV_V3_TestSensors_DWork.IntegerDelay1_DSTATE_g[14] = rtb_Product1_kx[2];
    c0b0:	1f 02 97    	mov.w     [w15-254], w4
    c0b2:	af 02 97    	mov.w     [w15-252], w5
    c0b4:	04 88 be    	mov.d     w4, [w0]

  /* End of Update for Delay: '<S559>/Integer Delay1' */
  /* Update for DiscreteZeroPole: '<S566>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_o =
    c0b6:	c8 f1 2f    	mov.w     #0xff1c, w8
    c0b8:	00 04 44    	add.w     w8, w0, w8

0000c0ba <.L0>:
      rtb_DataTypeConversion2_g[0] + (-0.99960423832914991)*
    c0ba:	02 61 2e    	mov.w     #0xe610, w2
    c0bc:	f3 f7 2b    	mov.w     #0xbf7f, w3
    c0be:	18 00 be    	mov.d     [w8], w0
    c0c0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    c0c2:	00 00 00 
    c0c4:	00 01 be    	mov.d     w0, w2
    c0c6:	5f a0 97    	mov.w     [w15-54], w0
    c0c8:	ef a0 97    	mov.w     [w15-52], w1
    c0ca:	92 14 02    	call      0x1492 <___addsf3>
    c0cc:	00 00 00 

0000c0ce <.L0>:
    c0ce:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_o;
  }

  /* Update for DiscreteZeroPole: '<S567>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_j =
    c0d0:	64 04 44    	add.w     w8, #0x4, w8

0000c0d2 <.L0>:
      rtb_DataTypeConversion2_g[1] + (-0.99960423832914991)*
    c0d2:	02 61 2e    	mov.w     #0xe610, w2
    c0d4:	f3 f7 2b    	mov.w     #0xbf7f, w3
    c0d6:	18 00 be    	mov.d     [w8], w0
    c0d8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    c0da:	00 00 00 
    c0dc:	00 01 be    	mov.d     w0, w2
    c0de:	5f a8 97    	mov.w     [w15-38], w0
    c0e0:	ef a8 97    	mov.w     [w15-36], w1
    c0e2:	92 14 02    	call      0x1492 <___addsf3>
    c0e4:	00 00 00 

0000c0e6 <.L0>:
    c0e6:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_j;
  }

  /* Update for DiscreteZeroPole: '<S568>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_k =
    c0e8:	64 04 44    	add.w     w8, #0x4, w8

0000c0ea <.L0>:
      rtb_DataTypeConversion2_g[2] + (-0.99960423832914991)*
    c0ea:	02 61 2e    	mov.w     #0xe610, w2
    c0ec:	f3 f7 2b    	mov.w     #0xbf7f, w3
    c0ee:	18 00 be    	mov.d     [w8], w0
    c0f0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    c0f2:	00 00 00 
    c0f4:	00 01 be    	mov.d     w0, w2
    c0f6:	1f a8 97    	mov.w     [w15-46], w0
    c0f8:	af a8 97    	mov.w     [w15-44], w1
    c0fa:	92 14 02    	call      0x1492 <___addsf3>
    c0fc:	00 00 00 

0000c0fe <.L0>:
    c0fe:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_k;
  }

  /* Update for DiscreteZeroPole: '<S498>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_c =
    c100:	64 04 44    	add.w     w8, #0x4, w8

0000c102 <.L0>:
      rtb_DataTypeConversion2_e2[0] + 1.0*
    c102:	18 01 be    	mov.d     [w8], w2
    c104:	7f 98 97    	mov.w     [w15-66], w0
    c106:	8f a0 97    	mov.w     [w15-64], w1
    c108:	92 14 02    	call      0x1492 <___addsf3>
    c10a:	00 00 00 

0000c10c <.L0>:
    c10c:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_c;
  }

  /* Update for DiscreteZeroPole: '<S499>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_n =
    c10e:	64 04 44    	add.w     w8, #0x4, w8

0000c110 <.L0>:
      rtb_DataTypeConversion2_e2[1] + 1.0*
    c110:	18 01 be    	mov.d     [w8], w2
    c112:	1f a0 97    	mov.w     [w15-62], w0
    c114:	af a0 97    	mov.w     [w15-60], w1
    c116:	92 14 02    	call      0x1492 <___addsf3>
    c118:	00 00 00 

0000c11a <.L0>:
    c11a:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_n;
  }

  /* Update for DiscreteZeroPole: '<S500>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_e =
    c11c:	64 04 44    	add.w     w8, #0x4, w8

0000c11e <.L0>:
      rtb_DataTypeConversion2_e2[2] + 1.0*
    c11e:	18 01 be    	mov.d     [w8], w2
    c120:	7f a8 97    	mov.w     [w15-34], w0
    c122:	8f b0 97    	mov.w     [w15-32], w1
    c124:	92 14 02    	call      0x1492 <___addsf3>
    c126:	00 00 00 

0000c128 <.L0>:
    c128:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_e;
  }

  /* Update for DiscreteZeroPole: '<S571>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_jl =
    c12a:	64 04 44    	add.w     w8, #0x4, w8

0000c12c <.L0>:
      rtb_DataTypeConversion2_b + 1.0*
    c12c:	0c 01 be    	mov.d     w12, w2
    c12e:	18 00 be    	mov.d     [w8], w0
    c130:	92 14 02    	call      0x1492 <___addsf3>
    c132:	00 00 00 

0000c134 <.L0>:
    c134:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_jl;
  }

  /* Update for DiscreteZeroPole: '<S573>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_a =
    c136:	64 04 44    	add.w     w8, #0x4, w8

0000c138 <.L0>:
      rtb_DataTypeConversion2_j + 1.0*
    c138:	0a 01 be    	mov.d     w10, w2
    c13a:	18 00 be    	mov.d     [w8], w0
    c13c:	92 14 02    	call      0x1492 <___addsf3>
    c13e:	00 00 00 

0000c140 <.L0>:
    c140:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_a;
  }

  /* Update for DiscreteZeroPole: '<S575>/Discrete Zero-Pole' */
  {
    AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_b =
    c142:	64 04 44    	add.w     w8, #0x4, w8

0000c144 <.L0>:
      rtb_DataTypeConversion2_gb + 1.0*
    c144:	18 01 be    	mov.d     [w8], w2
    c146:	5f 98 97    	mov.w     [w15-70], w0
    c148:	ef 98 97    	mov.w     [w15-68], w1
    c14a:	92 14 02    	call      0x1492 <___addsf3>
    c14c:	00 00 00 

0000c14e <.L0>:
    c14e:	00 8c be    	mov.d     w0, [w8]
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_b;
  }
}
    c150:	4f 07 78    	mov.w     [--w15], w14
    c152:	4f 06 be    	mov.d     [--w15], w12
    c154:	4f 05 be    	mov.d     [--w15], w10
    c156:	4f 04 be    	mov.d     [--w15], w8
    c158:	2f 11 b1    	sub.w     #0x112, w15
    c15a:	00 00 06    	return    

0000c15c <_crc_accumulate>:
    c15c:	11 01 78    	mov.w     [w1], w2
    c15e:	02 40 68    	xor.b     w0, w2, w0
    c160:	80 81 fb    	ze        w0, w3
    c162:	c4 19 dd    	sl.w      w3, #0x4, w3
    c164:	03 40 68    	xor.b     w0, w3, w0
    c166:	00 80 fb    	ze        w0, w0
    c168:	c4 01 de    	lsr.w     w0, #0x4, w3
        uint8_t tmp;

        tmp = data ^ (uint8_t)(*crcAccum &0xff);
        tmp ^= (tmp<<4);
        *crcAccum = (*crcAccum>>8) ^ (tmp<<8) ^ (tmp <<3) ^ (tmp>>4);
    c16a:	48 11 de    	lsr.w     w2, #0x8, w2
    c16c:	02 81 69    	xor.w     w3, w2, w2
    c16e:	c8 01 dd    	sl.w      w0, #0x8, w3
    c170:	03 01 69    	xor.w     w2, w3, w2
    c172:	43 00 dd    	sl.w      w0, #0x3, w0
    c174:	80 08 69    	xor.w     w2, w0, [w1]
}
    c176:	00 00 06    	return    

0000c178 <_crc_init>:
#endif

/**
 * @brief Initiliaze the buffer for the X.25 CRC
 *
 * @param crcAccum the 16 bit X.25 CRC
 */
static inline void crc_init(uint16_t* crcAccum)
{
        *crcAccum = X25_INIT_CRC;
    c178:	00 88 eb    	setm.w    [w0]
}
    c17a:	00 00 06    	return    

0000c17c <_crc_calculate>:


/**
 * @brief Calculates the X.25 checksum on a byte buffer
 *
 * @param  pBuffer buffer containing the byte array to hash
 * @param  length  length of the byte array
 * @return the checksum over the buffer bytes
 **/
static inline uint16_t crc_calculate(const uint8_t* pBuffer, uint16_t length)
{
    c17c:	02 00 fa    	lnk       #0x2
    c17e:	88 9f be    	mov.d     w8, [w15++]
    c180:	80 04 78    	mov.w     w0, w9
    c182:	01 04 78    	mov.w     w1, w8

0000c184 <.L0>:
        uint16_t crcTmp;
        crc_init(&crcTmp);
    c184:	66 80 57    	sub.w     w15, #0x6, w0
    c186:	f8 ff 07    	rcall     0xc178 <_crc_init> <L0> <.LFB1> <.LFE0>

0000c188 <.L0>:
	while (length--) {
    c188:	08 00 e0    	cp0.w     w8
    c18a:	05 00 32    	bra       Z, 0xc196 <.L4>

0000c18c <.L0>:
                crc_accumulate(*pBuffer++, &crcTmp);
    c18c:	39 40 78    	mov.b     [w9++], w0
    c18e:	e6 80 57    	sub.w     w15, #0x6, w1
    c190:	e5 ff 07    	rcall     0xc15c <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1471> <.Letext0> <.Ltext0>
    c192:	08 04 e9    	dec.w     w8, w8

0000c194 <.L0>:
    c194:	fb ff 3a    	bra       NZ, 0xc18c <.L0> <.L6>

0000c196 <.L4>:
        }
        return crcTmp;
}
    c196:	5f b8 97    	mov.w     [w15-6], w0
    c198:	4f 04 be    	mov.d     [--w15], w8
    c19a:	00 80 fa    	ulnk      
    c19c:	00 00 06    	return    

0000c19e <_mavlink_get_channel_status>:
	// has to be defined externally
#else
	static mavlink_status_t m_mavlink_status[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_status[chan];
    c19e:	e2 c0 b3    	mov.b     #0xe, w2
    c1a0:	04 40 bc    	mul.b     0x4
    c1a2:	61 80 22    	mov.w     #0x2806, w1
    c1a4:	01 00 41    	add.w     w2, w1, w0
}
    c1a6:	00 00 06    	return    

0000c1a8 <_mavlink_get_channel_buffer>:
#endif

/*
 * Internal function to give access to the channel buffer for each channel
 */
#ifndef MAVLINK_GET_CHANNEL_BUFFER
MAVLINK_HELPER mavlink_message_t* mavlink_get_channel_buffer(uint8_t chan)
{
	
#if MAVLINK_EXTERNAL_RX_BUFFER
	// No m_mavlink_buffer array defined in function,
	// has to be defined externally
#else
	static mavlink_message_t m_mavlink_buffer[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_buffer[chan];
    c1a8:	00 80 fb    	ze        w0, w0
    c1aa:	01 11 20    	mov.w     #0x110, w1
    c1ac:	81 80 b9    	.pword 0xb98081
    c1ae:	e1 83 22    	mov.w     #0x283e, w1
    c1b0:	01 00 40    	add.w     w0, w1, w0
}
    c1b2:	00 00 06    	return    

0000c1b4 <_mavlink_finalize_message_chan>:
#endif

/**
 * @brief Reset the status of a channel.
 */
MAVLINK_HELPER void mavlink_reset_channel_status(uint8_t chan)
{
	mavlink_status_t *status = mavlink_get_channel_status(chan);
	status->parse_state = MAVLINK_PARSE_STATE_IDLE;
}

/**
 * @brief Finalize a MAVLink message with channel assignment
 *
 * This function calculates the checksum and sets length and aircraft id correctly.
 * It assumes that the message id and the payload are already correctly set. This function
 * can also be used if the message header has already been written before (as in mavlink_msg_xxx_pack
 * instead of mavlink_msg_xxx_pack_headerless), it just introduces little extra overhead.
 *
 * @param msg Message to finalize
 * @param system_id Id of the sending (this) system, 1-127
 * @param length Message length
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length, uint8_t crc_extra)
#else
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length)
#endif
{
    c1b4:	02 00 fa    	lnk       #0x2
    c1b6:	88 9f be    	mov.d     w8, [w15++]
    c1b8:	8a 1f 78    	mov.w     w10, [w15++]
    c1ba:	00 04 78    	mov.w     w0, w8
    c1bc:	03 40 78    	mov.b     w3, w0
    c1be:	84 44 78    	mov.b     w4, w9
    c1c0:	05 45 78    	mov.b     w5, w10
	// This code part is the same for all messages;
	uint16_t checksum;
	msg->magic = MAVLINK_STX;
    c1c2:	e3 cf b3    	mov.b     #0xfe, w3
    c1c4:	23 44 98    	mov.b     w3, [w8+2]
	msg->len = length;
    c1c6:	39 44 98    	mov.b     w9, [w8+3]
	msg->sysid = system_id;
    c1c8:	51 44 98    	mov.b     w1, [w8+5]

0000c1ca <.L0>:
	msg->compid = component_id;
	// One sequence number per component
	msg->seq = mavlink_get_channel_status(chan)->current_tx_seq;
    c1ca:	62 44 98    	mov.b     w2, [w8+6]
    c1cc:	e8 ff 07    	rcall     0xc19e <_mavlink_get_channel_status> <L0> <.LFB9> <.LFE2>
    c1ce:	80 48 90    	mov.b     [w0+8], w1
    c1d0:	41 44 98    	mov.b     w1, [w8+4]
	mavlink_get_channel_status(chan)->current_tx_seq = mavlink_get_channel_status(chan)->current_tx_seq+1;
    c1d2:	80 48 90    	mov.b     [w0+8], w1
    c1d4:	81 40 e8    	inc.b     w1, w1
    c1d6:	01 48 98    	mov.b     w1, [w0+8]

0000c1d8 <.L0>:
	checksum = crc_calculate((uint8_t*)&msg->len, length + MAVLINK_CORE_HEADER_LEN);
    c1d8:	89 84 fb    	ze        w9, w9
    c1da:	e5 80 44    	add.w     w9, #0x5, w1
    c1dc:	63 00 44    	add.w     w8, #0x3, w0
    c1de:	ce ff 07    	rcall     0xc17c <_crc_calculate> <L0> <.LFB2> <.LFE1>
    c1e0:	c0 bf 9f    	mov.w     w0, [w15-8]

0000c1e2 <.L0>:
#if MAVLINK_CRC_EXTRA
	crc_accumulate(crc_extra, &checksum);
    c1e2:	e8 80 57    	sub.w     w15, #0x8, w1
    c1e4:	0a 40 78    	mov.b     w10, w0
    c1e6:	ba ff 07    	rcall     0xc15c <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1471> <.Letext0> <.Ltext0>

0000c1e8 <.L0>:
#endif
	mavlink_ck_a(msg) = (uint8_t)(checksum & 0xFF);
    c1e8:	e8 00 44    	add.w     w8, #0x8, w1
    c1ea:	4f b8 97    	mov.w     [w15-8], w0
    c1ec:	38 41 90    	mov.b     [w8+3], w2
    c1ee:	02 81 fb    	ze        w2, w2
    c1f0:	02 81 40    	add.w     w1, w2, w2
    c1f2:	00 49 78    	mov.b     w0, [w2]
	mavlink_ck_b(msg) = (uint8_t)(checksum >> 8);
    c1f4:	38 41 90    	mov.b     [w8+3], w2
    c1f6:	02 81 fb    	ze        w2, w2
    c1f8:	82 80 40    	add.w     w1, w2, w1
    c1fa:	48 00 de    	lsr.w     w0, #0x8, w0
    c1fc:	90 40 98    	mov.b     w0, [w1+1]

	return length + MAVLINK_NUM_NON_PAYLOAD_BYTES;
    c1fe:	68 80 44    	add.w     w9, #0x8, w0
}
    c200:	4f 05 78    	mov.w     [--w15], w10
    c202:	4f 04 be    	mov.d     [--w15], w8
    c204:	00 80 fa    	ulnk      
    c206:	00 00 06    	return    

0000c208 <_mavlink_finalize_message>:


/**
 * @brief Finalize a MAVLink message with MAVLINK_COMM_0 as default channel
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						 uint8_t length, uint8_t crc_extra)
{
	return mavlink_finalize_message_chan(msg, system_id, component_id, MAVLINK_COMM_0, length, crc_extra);
    c208:	84 42 78    	mov.b     w4, w5
    c20a:	03 42 78    	mov.b     w3, w4
    c20c:	80 41 eb    	clr.b     w3
    c20e:	d2 ff 07    	rcall     0xc1b4 <_mavlink_finalize_message_chan> <L0> <.LFB12> <.LFE10>

0000c210 <.L0>:
}
#else
MAVLINK_HELPER uint16_t mavlink_finalize_message(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						 uint8_t length)
{
	return mavlink_finalize_message_chan(msg, system_id, component_id, MAVLINK_COMM_0, length);
}
#endif

#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
MAVLINK_HELPER void _mavlink_send_uart(mavlink_channel_t chan, const char *buf, uint16_t len);

/**
 * @brief Finalize a MAVLink message with channel assignment and send
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER void _mav_finalize_message_chan_send(mavlink_channel_t chan, uint8_t msgid, const char *packet, 
						    uint8_t length, uint8_t crc_extra)
#else
MAVLINK_HELPER void _mav_finalize_message_chan_send(mavlink_channel_t chan, uint8_t msgid, const char *packet, uint8_t length)
#endif
{
	uint16_t checksum;
	uint8_t buf[MAVLINK_NUM_HEADER_BYTES];
	uint8_t ck[2];
	mavlink_status_t *status = mavlink_get_channel_status(chan);
	buf[0] = MAVLINK_STX;
	buf[1] = length;
	buf[2] = status->current_tx_seq;
	buf[3] = mavlink_system.sysid;
	buf[4] = mavlink_system.compid;
	buf[5] = msgid;
	status->current_tx_seq++;
	checksum = crc_calculate((uint8_t*)&buf[1], MAVLINK_CORE_HEADER_LEN);
	crc_accumulate_buffer(&checksum, packet, length);
#if MAVLINK_CRC_EXTRA
	crc_accumulate(crc_extra, &checksum);
#endif
	ck[0] = (uint8_t)(checksum & 0xFF);
	ck[1] = (uint8_t)(checksum >> 8);

	MAVLINK_START_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)length);
	_mavlink_send_uart(chan, (const char *)buf, MAVLINK_NUM_HEADER_BYTES);
	_mavlink_send_uart(chan, packet, length);
	_mavlink_send_uart(chan, (const char *)ck, 2);
	MAVLINK_END_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)length);
}

/**
 * @brief re-send a message over a uart channel
 * this is more stack efficient than re-marshalling the message
 */
MAVLINK_HELPER void _mavlink_resend_uart(mavlink_channel_t chan, const mavlink_message_t *msg)
{
	uint8_t ck[2];

	ck[0] = (uint8_t)(msg->checksum & 0xFF);
	ck[1] = (uint8_t)(msg->checksum >> 8);

	MAVLINK_START_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + msg->len);
	_mavlink_send_uart(chan, (const char *)&msg->magic, MAVLINK_NUM_HEADER_BYTES);
	_mavlink_send_uart(chan, _MAV_PAYLOAD(msg), msg->len);
	_mavlink_send_uart(chan, (const char *)ck, 2);
	MAVLINK_END_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + msg->len);
}
#endif // MAVLINK_USE_CONVENIENCE_FUNCTIONS

/**
 * @brief Pack a message to send it over a serial byte stream
 */
MAVLINK_HELPER uint16_t mavlink_msg_to_send_buffer(uint8_t *buffer, const mavlink_message_t *msg)
{
	memcpy(buffer, (const uint8_t *)&msg->magic, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len);
	return MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len;
}

union __mavlink_bitfield {
	uint8_t uint8;
	int8_t int8;
	uint16_t uint16;
	int16_t int16;
	uint32_t uint32;
	int32_t int32;
};


MAVLINK_HELPER void mavlink_start_checksum(mavlink_message_t* msg)
{
	crc_init(&msg->checksum);
    c210:	00 00 06    	return    

0000c212 <_mavlink_start_checksum>:
}
    c212:	b2 ff 07    	rcall     0xc178 <_crc_init> <L0> <.LFB1> <.LFE0>
    c214:	00 00 06    	return    

0000c216 <_mavlink_update_checksum>:

MAVLINK_HELPER void mavlink_update_checksum(mavlink_message_t* msg, uint8_t c)
{
    c216:	00 01 78    	mov.w     w0, w2
    c218:	01 40 78    	mov.b     w1, w0

0000c21a <.L0>:
	crc_accumulate(c, &msg->checksum);
    c21a:	82 00 78    	mov.w     w2, w1
    c21c:	9f ff 07    	rcall     0xc15c <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1471> <.Letext0> <.Ltext0>

0000c21e <.L0>:
}
    c21e:	00 00 06    	return    

0000c220 <__MAV_RETURN_int16_t>:
static inline TYPE _MAV_RETURN_## TYPE(const mavlink_message_t *msg, uint8_t ofs) \
{ return *(const TYPE *)(&_MAV_PAYLOAD(msg)[ofs]);}

_MAV_MSG_RETURN_TYPE(uint16_t)
_MAV_MSG_RETURN_TYPE(int16_t)
    c220:	81 80 fb    	ze        w1, w1
    c222:	01 00 40    	add.w     w0, w1, w0
    c224:	40 00 90    	mov.w     [w0+8], w0
    c226:	00 00 06    	return    

0000c228 <_mavlink_msg_param_request_read_get_param_index>:
 * @return Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
 */
static inline int16_t mavlink_msg_param_request_read_get_param_index(const mavlink_message_t* msg)
{
	return _MAV_RETURN_int16_t(msg,  0);
    c228:	80 40 eb    	clr.b     w1
    c22a:	fa ff 07    	rcall     0xc220 <__MAV_RETURN_int16_t> <L0> <.LFB33> <.LFE16>

0000c22c <.L0>:
}
    c22c:	00 00 06    	return    

0000c22e <_mavlink_msg_gps_raw_int_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_gps_raw_int_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, uint8_t fix_type, int32_t lat, int32_t lon, int32_t alt, uint16_t eph, uint16_t epv, uint16_t vel, uint16_t cog, uint8_t satellites_visible)
{
    c22e:	1e 00 fa    	lnk       #0x1e
    c230:	88 1f 78    	mov.w     w8, [w15++]
    c232:	00 44 78    	mov.b     w0, w8
    c234:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_GPS_RAW_INT_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int32_t(buf, 8, lat);
	_mav_put_int32_t(buf, 12, lon);
	_mav_put_int32_t(buf, 16, alt);
	_mav_put_uint16_t(buf, 20, eph);
	_mav_put_uint16_t(buf, 22, epv);
	_mav_put_uint16_t(buf, 24, vel);
	_mav_put_uint16_t(buf, 26, cog);
	_mav_put_uint8_t(buf, 28, fix_type);
	_mav_put_uint8_t(buf, 29, satellites_visible);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
#else
	mavlink_gps_raw_int_t packet;
	packet.time_usec = time_usec;
    c236:	84 b7 9f    	mov.w     w4, [w15-32]
    c238:	95 b7 9f    	mov.w     w5, [w15-30]
    c23a:	a6 b7 9f    	mov.w     w6, [w15-28]
    c23c:	b7 b7 9f    	mov.w     w7, [w15-26]
	packet.lat = lat;
    c23e:	3f aa 97    	mov.w     [w15-42], w4
    c240:	cf aa 97    	mov.w     [w15-40], w5
    c242:	c4 b7 9f    	mov.w     w4, [w15-24]
    c244:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.lon = lon;
    c246:	1f aa 97    	mov.w     [w15-46], w4
    c248:	af aa 97    	mov.w     [w15-44], w5
    c24a:	e4 b7 9f    	mov.w     w4, [w15-20]
    c24c:	f5 b7 9f    	mov.w     w5, [w15-18]
	packet.alt = alt;
    c24e:	7f a2 97    	mov.w     [w15-50], w4
    c250:	8f aa 97    	mov.w     [w15-48], w5
    c252:	84 bf 9f    	mov.w     w4, [w15-16]
    c254:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.eph = eph;
    c256:	ef a2 97    	mov.w     [w15-52], w5
    c258:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.epv = epv;
    c25a:	5f a1 97    	mov.w     [w15-54], w2
    c25c:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.vel = vel;
    c25e:	4f a2 97    	mov.w     [w15-56], w4
    c260:	c4 bf 9f    	mov.w     w4, [w15-8]
	packet.cog = cog;
    c262:	bf a2 97    	mov.w     [w15-58], w5
    c264:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.fix_type = fix_type;
    c266:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.satellites_visible = satellites_visible;
    c268:	4f c1 97    	mov.b     [w15-60], w2
    c26a:	d2 ff 9f    	mov.b     w2, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
    c26c:	e8 01 40    	add.w     w0, #0x8, w3
    c26e:	04 fe 2f    	mov.w     #0xffe0, w4
    c270:	04 82 47    	add.w     w15, w4, w4
    c272:	0e 00 09    	.pword 0x09000e
    c274:	b4 19 78    	mov.w     [w4++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_GPS_RAW_INT;
    c276:	84 c1 b3    	mov.b     #0x18, w4
    c278:	74 40 98    	mov.b     w4, [w0+7]

0000c27a <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN, MAVLINK_MSG_ID_GPS_RAW_INT_CRC);
    c27a:	e3 c1 b3    	mov.b     #0x1e, w3
    c27c:	01 41 78    	mov.b     w1, w2
    c27e:	88 40 78    	mov.b     w8, w1
    c280:	c3 ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c282 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
#endif
}
    c282:	4f 04 78    	mov.w     [--w15], w8
    c284:	00 80 fa    	ulnk      
    c286:	00 00 06    	return    

0000c288 <_mavlink_msg_raw_imu_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_raw_imu_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint64_t time_usec, int16_t xacc, int16_t yacc, int16_t zacc, int16_t xgyro, int16_t ygyro, int16_t zgyro, int16_t xmag, int16_t ymag, int16_t zmag)
{
    c288:	1a 00 fa    	lnk       #0x1a
    c28a:	88 1f 78    	mov.w     w8, [w15++]
    c28c:	00 44 78    	mov.b     w0, w8
    c28e:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RAW_IMU_LEN];
	_mav_put_uint64_t(buf, 0, time_usec);
	_mav_put_int16_t(buf, 8, xacc);
	_mav_put_int16_t(buf, 10, yacc);
	_mav_put_int16_t(buf, 12, zacc);
	_mav_put_int16_t(buf, 14, xgyro);
	_mav_put_int16_t(buf, 16, ygyro);
	_mav_put_int16_t(buf, 18, zgyro);
	_mav_put_int16_t(buf, 20, xmag);
	_mav_put_int16_t(buf, 22, ymag);
	_mav_put_int16_t(buf, 24, zmag);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RAW_IMU_LEN);
#else
	mavlink_raw_imu_t packet;
	packet.time_usec = time_usec;
    c290:	a4 b7 9f    	mov.w     w4, [w15-28]
    c292:	b5 b7 9f    	mov.w     w5, [w15-26]
    c294:	c6 b7 9f    	mov.w     w6, [w15-24]
    c296:	d7 b7 9f    	mov.w     w7, [w15-22]
	packet.xacc = xacc;
    c298:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.yacc = yacc;
    c29a:	6f a9 97    	mov.w     [w15-36], w2
    c29c:	f2 b7 9f    	mov.w     w2, [w15-18]
	packet.zacc = zacc;
    c29e:	df a9 97    	mov.w     [w15-38], w3
    c2a0:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.xgyro = xgyro;
    c2a2:	4f a9 97    	mov.w     [w15-40], w2
    c2a4:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.ygyro = ygyro;
    c2a6:	bf a9 97    	mov.w     [w15-42], w3
    c2a8:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.zgyro = zgyro;
    c2aa:	2f a9 97    	mov.w     [w15-44], w2
    c2ac:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.xmag = xmag;
    c2ae:	9f a9 97    	mov.w     [w15-46], w3
    c2b0:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.ymag = ymag;
    c2b2:	0f a9 97    	mov.w     [w15-48], w2
    c2b4:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.zmag = zmag;
    c2b6:	ff a1 97    	mov.w     [w15-50], w3
    c2b8:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RAW_IMU_LEN);
    c2ba:	68 01 40    	add.w     w0, #0x8, w2
    c2bc:	fc 81 57    	sub.w     w15, #0x1c, w3
    c2be:	0c 00 09    	.pword 0x09000c
    c2c0:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_RAW_IMU;
    c2c2:	b2 c1 b3    	mov.b     #0x1b, w2
    c2c4:	72 40 98    	mov.b     w2, [w0+7]

0000c2c6 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN, MAVLINK_MSG_ID_RAW_IMU_CRC);
    c2c6:	04 c9 b3    	mov.b     #0x90, w4
    c2c8:	a3 c1 b3    	mov.b     #0x1a, w3
    c2ca:	01 41 78    	mov.b     w1, w2
    c2cc:	88 40 78    	mov.b     w8, w1
    c2ce:	9c ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c2d0 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RAW_IMU_LEN);
#endif
}
    c2d0:	4f 04 78    	mov.w     [--w15], w8
    c2d2:	00 80 fa    	ulnk      
    c2d4:	00 00 06    	return    

0000c2d6 <_mavlink_msg_scaled_pressure_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_scaled_pressure_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float press_abs, float press_diff, int16_t temperature)
{
    c2d6:	0e 00 fa    	lnk       #0xe
    c2d8:	88 1f 78    	mov.w     w8, [w15++]
    c2da:	00 44 78    	mov.b     w0, w8
    c2dc:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SCALED_PRESSURE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, press_abs);
	_mav_put_float(buf, 8, press_diff);
	_mav_put_int16_t(buf, 12, temperature);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#else
	mavlink_scaled_pressure_t packet;
	packet.time_boot_ms = time_boot_ms;
    c2de:	84 bf 9f    	mov.w     w4, [w15-16]
    c2e0:	95 bf 9f    	mov.w     w5, [w15-14]
	packet.press_abs = press_abs;
    c2e2:	a6 bf 9f    	mov.w     w6, [w15-12]
    c2e4:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.press_diff = press_diff;
    c2e6:	3f b2 97    	mov.w     [w15-26], w4
    c2e8:	cf b2 97    	mov.w     [w15-24], w5
    c2ea:	c4 bf 9f    	mov.w     w4, [w15-8]
    c2ec:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.temperature = temperature;
    c2ee:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
    c2f0:	e8 02 40    	add.w     w0, #0x8, w5
    c2f2:	70 81 57    	sub.w     w15, #0x10, w2
    c2f4:	06 00 09    	.pword 0x090006
    c2f6:	b2 1a 78    	mov.w     [w2++], [w5++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SCALED_PRESSURE;
    c2f8:	d2 c1 b3    	mov.b     #0x1d, w2
    c2fa:	72 40 98    	mov.b     w2, [w0+7]

0000c2fc <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN, MAVLINK_MSG_ID_SCALED_PRESSURE_CRC);
    c2fc:	34 c7 b3    	mov.b     #0x73, w4
    c2fe:	e3 c0 b3    	mov.b     #0xe, w3
    c300:	01 41 78    	mov.b     w1, w2
    c302:	88 40 78    	mov.b     w8, w1
    c304:	81 ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c306 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
#endif
}
    c306:	4f 04 78    	mov.w     [--w15], w8
    c308:	00 80 fa    	ulnk      
    c30a:	00 00 06    	return    

0000c30c <_mavlink_msg_attitude_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_attitude_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float roll, float pitch, float yaw, float rollspeed, float pitchspeed, float yawspeed)
{
    c30c:	1c 00 fa    	lnk       #0x1c
    c30e:	88 1f 78    	mov.w     w8, [w15++]
    c310:	00 44 78    	mov.b     w0, w8
    c312:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_ATTITUDE_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, roll);
	_mav_put_float(buf, 8, pitch);
	_mav_put_float(buf, 12, yaw);
	_mav_put_float(buf, 16, rollspeed);
	_mav_put_float(buf, 20, pitchspeed);
	_mav_put_float(buf, 24, yawspeed);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_ATTITUDE_LEN);
#else
	mavlink_attitude_t packet;
	packet.time_boot_ms = time_boot_ms;
    c314:	94 b7 9f    	mov.w     w4, [w15-30]
    c316:	a5 b7 9f    	mov.w     w5, [w15-28]
	packet.roll = roll;
    c318:	b6 b7 9f    	mov.w     w6, [w15-26]
    c31a:	c7 b7 9f    	mov.w     w7, [w15-24]
	packet.pitch = pitch;
    c31c:	4f a9 97    	mov.w     [w15-40], w2
    c31e:	df a9 97    	mov.w     [w15-38], w3
    c320:	d2 b7 9f    	mov.w     w2, [w15-22]
    c322:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.yaw = yaw;
    c324:	2f a9 97    	mov.w     [w15-44], w2
    c326:	bf a9 97    	mov.w     [w15-42], w3
    c328:	f2 b7 9f    	mov.w     w2, [w15-18]
    c32a:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.rollspeed = rollspeed;
    c32c:	0f a9 97    	mov.w     [w15-48], w2
    c32e:	9f a9 97    	mov.w     [w15-46], w3
    c330:	92 bf 9f    	mov.w     w2, [w15-14]
    c332:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.pitchspeed = pitchspeed;
    c334:	6f a1 97    	mov.w     [w15-52], w2
    c336:	ff a1 97    	mov.w     [w15-50], w3
    c338:	b2 bf 9f    	mov.w     w2, [w15-10]
    c33a:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.yawspeed = yawspeed;
    c33c:	4f a1 97    	mov.w     [w15-56], w2
    c33e:	df a1 97    	mov.w     [w15-54], w3
    c340:	d2 bf 9f    	mov.w     w2, [w15-6]
    c342:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_ATTITUDE_LEN);
    c344:	e8 01 40    	add.w     w0, #0x8, w3
    c346:	7e 81 57    	sub.w     w15, #0x1e, w2
    c348:	0d 00 09    	.pword 0x09000d
    c34a:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_ATTITUDE;
    c34c:	e2 c1 b3    	mov.b     #0x1e, w2
    c34e:	72 40 98    	mov.b     w2, [w0+7]

0000c350 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN, MAVLINK_MSG_ID_ATTITUDE_CRC);
    c350:	74 c2 b3    	mov.b     #0x27, w4
    c352:	c3 c1 b3    	mov.b     #0x1c, w3
    c354:	01 41 78    	mov.b     w1, w2
    c356:	88 40 78    	mov.b     w8, w1
    c358:	57 ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c35a <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_ATTITUDE_LEN);
#endif
}
    c35a:	4f 04 78    	mov.w     [--w15], w8
    c35c:	00 80 fa    	ulnk      
    c35e:	00 00 06    	return    

0000c360 <_mavlink_msg_local_position_ned_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_local_position_ned_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, float x, float y, float z, float vx, float vy, float vz)
{
    c360:	1c 00 fa    	lnk       #0x1c
    c362:	88 1f 78    	mov.w     w8, [w15++]
    c364:	00 44 78    	mov.b     w0, w8
    c366:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_float(buf, 4, x);
	_mav_put_float(buf, 8, y);
	_mav_put_float(buf, 12, z);
	_mav_put_float(buf, 16, vx);
	_mav_put_float(buf, 20, vy);
	_mav_put_float(buf, 24, vz);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#else
	mavlink_local_position_ned_t packet;
	packet.time_boot_ms = time_boot_ms;
    c368:	94 b7 9f    	mov.w     w4, [w15-30]
    c36a:	a5 b7 9f    	mov.w     w5, [w15-28]
	packet.x = x;
    c36c:	b6 b7 9f    	mov.w     w6, [w15-26]
    c36e:	c7 b7 9f    	mov.w     w7, [w15-24]
	packet.y = y;
    c370:	4f a9 97    	mov.w     [w15-40], w2
    c372:	df a9 97    	mov.w     [w15-38], w3
    c374:	d2 b7 9f    	mov.w     w2, [w15-22]
    c376:	e3 b7 9f    	mov.w     w3, [w15-20]
	packet.z = z;
    c378:	2f a9 97    	mov.w     [w15-44], w2
    c37a:	bf a9 97    	mov.w     [w15-42], w3
    c37c:	f2 b7 9f    	mov.w     w2, [w15-18]
    c37e:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.vx = vx;
    c380:	0f a9 97    	mov.w     [w15-48], w2
    c382:	9f a9 97    	mov.w     [w15-46], w3
    c384:	92 bf 9f    	mov.w     w2, [w15-14]
    c386:	a3 bf 9f    	mov.w     w3, [w15-12]
	packet.vy = vy;
    c388:	6f a1 97    	mov.w     [w15-52], w2
    c38a:	ff a1 97    	mov.w     [w15-50], w3
    c38c:	b2 bf 9f    	mov.w     w2, [w15-10]
    c38e:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.vz = vz;
    c390:	4f a1 97    	mov.w     [w15-56], w2
    c392:	df a1 97    	mov.w     [w15-54], w3
    c394:	d2 bf 9f    	mov.w     w2, [w15-6]
    c396:	e3 bf 9f    	mov.w     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
    c398:	e8 01 40    	add.w     w0, #0x8, w3
    c39a:	7e 81 57    	sub.w     w15, #0x1e, w2
    c39c:	0d 00 09    	.pword 0x09000d
    c39e:	b2 19 78    	mov.w     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;
    c3a0:	02 c2 b3    	mov.b     #0x20, w2
    c3a2:	72 40 98    	mov.b     w2, [w0+7]

0000c3a4 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN, MAVLINK_MSG_ID_LOCAL_POSITION_NED_CRC);
    c3a4:	94 cb b3    	mov.b     #0xb9, w4
    c3a6:	c3 c1 b3    	mov.b     #0x1c, w3
    c3a8:	01 41 78    	mov.b     w1, w2
    c3aa:	88 40 78    	mov.b     w8, w1
    c3ac:	2d ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c3ae <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
#endif
}
    c3ae:	4f 04 78    	mov.w     [--w15], w8
    c3b0:	00 80 fa    	ulnk      
    c3b2:	00 00 06    	return    

0000c3b4 <_mavlink_msg_rc_channels_raw_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_rc_channels_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_boot_ms, uint8_t port, uint16_t chan1_raw, uint16_t chan2_raw, uint16_t chan3_raw, uint16_t chan4_raw, uint16_t chan5_raw, uint16_t chan6_raw, uint16_t chan7_raw, uint16_t chan8_raw, uint8_t rssi)
{
    c3b4:	16 00 fa    	lnk       #0x16
    c3b6:	88 1f 78    	mov.w     w8, [w15++]
    c3b8:	00 44 78    	mov.b     w0, w8
    c3ba:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_boot_ms);
	_mav_put_uint16_t(buf, 4, chan1_raw);
	_mav_put_uint16_t(buf, 6, chan2_raw);
	_mav_put_uint16_t(buf, 8, chan3_raw);
	_mav_put_uint16_t(buf, 10, chan4_raw);
	_mav_put_uint16_t(buf, 12, chan5_raw);
	_mav_put_uint16_t(buf, 14, chan6_raw);
	_mav_put_uint16_t(buf, 16, chan7_raw);
	_mav_put_uint16_t(buf, 18, chan8_raw);
	_mav_put_uint8_t(buf, 20, port);
	_mav_put_uint8_t(buf, 21, rssi);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#else
	mavlink_rc_channels_raw_t packet;
	packet.time_boot_ms = time_boot_ms;
    c3bc:	c4 b7 9f    	mov.w     w4, [w15-24]
    c3be:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.chan1_raw = chan1_raw;
    c3c0:	e6 b7 9f    	mov.w     w6, [w15-20]
	packet.chan2_raw = chan2_raw;
    c3c2:	f7 b7 9f    	mov.w     w7, [w15-18]
	packet.chan3_raw = chan3_raw;
    c3c4:	0f b1 97    	mov.w     [w15-32], w2
    c3c6:	82 bf 9f    	mov.w     w2, [w15-16]
	packet.chan4_raw = chan4_raw;
    c3c8:	7f a9 97    	mov.w     [w15-34], w2
    c3ca:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.chan5_raw = chan5_raw;
    c3cc:	6f a9 97    	mov.w     [w15-36], w2
    c3ce:	a2 bf 9f    	mov.w     w2, [w15-12]
	packet.chan6_raw = chan6_raw;
    c3d0:	5f a9 97    	mov.w     [w15-38], w2
    c3d2:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.chan7_raw = chan7_raw;
    c3d4:	4f a9 97    	mov.w     [w15-40], w2
    c3d6:	c2 bf 9f    	mov.w     w2, [w15-8]
	packet.chan8_raw = chan8_raw;
    c3d8:	3f a9 97    	mov.w     [w15-42], w2
    c3da:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.port = port;
    c3dc:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.rssi = rssi;
    c3de:	cf d1 97    	mov.b     [w15-44], w3
    c3e0:	d3 ff 9f    	mov.b     w3, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
    c3e2:	68 01 40    	add.w     w0, #0x8, w2
    c3e4:	f8 81 57    	sub.w     w15, #0x18, w3
    c3e6:	0a 00 09    	.pword 0x09000a
    c3e8:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_RC_CHANNELS_RAW;
    c3ea:	32 c2 b3    	mov.b     #0x23, w2
    c3ec:	72 40 98    	mov.b     w2, [w0+7]

0000c3ee <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN, MAVLINK_MSG_ID_RC_CHANNELS_RAW_CRC);
    c3ee:	44 cf b3    	mov.b     #0xf4, w4
    c3f0:	63 c1 b3    	mov.b     #0x16, w3
    c3f2:	01 41 78    	mov.b     w1, w2
    c3f4:	88 40 78    	mov.b     w8, w1
    c3f6:	08 ff 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c3f8 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_RC_CHANNELS_RAW_LEN);
#endif
}
    c3f8:	4f 04 78    	mov.w     [--w15], w8
    c3fa:	00 80 fa    	ulnk      
    c3fc:	00 00 06    	return    

0000c3fe <_mavlink_msg_mission_request_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_request_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t seq)
{
    c3fe:	88 9f be    	mov.d     w8, [w15++]
    c400:	00 43 78    	mov.b     w0, w6
    c402:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_REQUEST_LEN];
	_mav_put_uint16_t(buf, 0, seq);
	_mav_put_uint8_t(buf, 2, target_system);
	_mav_put_uint8_t(buf, 3, target_component);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
#else
	mavlink_mission_request_t packet;
	packet.seq = seq;
    c404:	60 44 b8    	mul.uu    w8, #0x0, w8
    c406:	05 04 78    	mov.w     w5, w8
	packet.target_system = target_system;
    c408:	83 81 fb    	ze        w3, w3
    c40a:	02 f0 2f    	mov.w     #0xff00, w2
    c40c:	09 01 61    	and.w     w2, w9, w2
    c40e:	82 81 71    	ior.w     w3, w2, w3
	packet.target_component = target_component;
    c410:	48 22 dd    	sl.w      w4, #0x8, w4
    c412:	83 81 fb    	ze        w3, w3
    c414:	83 04 72    	ior.w     w4, w3, w9

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
    c416:	48 00 98    	mov.w     w8, [w0+8]
    c418:	59 00 98    	mov.w     w9, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_REQUEST;
    c41a:	82 c2 b3    	mov.b     #0x28, w2
    c41c:	72 40 98    	mov.b     w2, [w0+7]

0000c41e <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN, MAVLINK_MSG_ID_MISSION_REQUEST_CRC);
    c41e:	64 ce b3    	mov.b     #0xe6, w4
    c420:	43 c0 b3    	mov.b     #0x4, w3
    c422:	01 41 78    	mov.b     w1, w2
    c424:	86 40 78    	mov.b     w6, w1
    c426:	f0 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c428 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
#endif
}
    c428:	4f 04 be    	mov.d     [--w15], w8
    c42a:	00 00 06    	return    

0000c42c <_mavlink_msg_mission_current_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_current_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint16_t seq)
{
    c42c:	80 42 78    	mov.b     w0, w5
    c42e:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_CURRENT_LEN];
	_mav_put_uint16_t(buf, 0, seq);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
#else
	mavlink_mission_current_t packet;
	packet.seq = seq;

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
    c430:	43 00 98    	mov.w     w3, [w0+8]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_CURRENT;
    c432:	a2 c2 b3    	mov.b     #0x2a, w2
    c434:	72 40 98    	mov.b     w2, [w0+7]

0000c436 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN, MAVLINK_MSG_ID_MISSION_CURRENT_CRC);
    c436:	c4 c1 b3    	mov.b     #0x1c, w4
    c438:	23 c0 b3    	mov.b     #0x2, w3
    c43a:	01 41 78    	mov.b     w1, w2
    c43c:	85 40 78    	mov.b     w5, w1
    c43e:	e4 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c440 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_CURRENT_LEN);
#endif
}
    c440:	00 00 06    	return    

0000c442 <_mavlink_msg_mission_count_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_count_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t count)
{
    c442:	88 9f be    	mov.d     w8, [w15++]
    c444:	00 43 78    	mov.b     w0, w6
    c446:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_COUNT_LEN];
	_mav_put_uint16_t(buf, 0, count);
	_mav_put_uint8_t(buf, 2, target_system);
	_mav_put_uint8_t(buf, 3, target_component);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
#else
	mavlink_mission_count_t packet;
	packet.count = count;
    c448:	60 44 b8    	mul.uu    w8, #0x0, w8
    c44a:	05 04 78    	mov.w     w5, w8
	packet.target_system = target_system;
    c44c:	83 81 fb    	ze        w3, w3
    c44e:	02 f0 2f    	mov.w     #0xff00, w2
    c450:	09 01 61    	and.w     w2, w9, w2
    c452:	82 81 71    	ior.w     w3, w2, w3
	packet.target_component = target_component;
    c454:	48 22 dd    	sl.w      w4, #0x8, w4
    c456:	83 81 fb    	ze        w3, w3
    c458:	83 04 72    	ior.w     w4, w3, w9

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
    c45a:	48 00 98    	mov.w     w8, [w0+8]
    c45c:	59 00 98    	mov.w     w9, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_COUNT;
    c45e:	c2 c2 b3    	mov.b     #0x2c, w2
    c460:	72 40 98    	mov.b     w2, [w0+7]

0000c462 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN, MAVLINK_MSG_ID_MISSION_COUNT_CRC);
    c462:	d4 cd b3    	mov.b     #0xdd, w4
    c464:	43 c0 b3    	mov.b     #0x4, w3
    c466:	01 41 78    	mov.b     w1, w2
    c468:	86 40 78    	mov.b     w6, w1
    c46a:	ce fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c46c <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_COUNT_LEN);
#endif
}
    c46c:	4f 04 be    	mov.d     [--w15], w8
    c46e:	00 00 06    	return    

0000c470 <_mavlink_msg_mission_ack_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_ack_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint8_t type)
{
    c470:	04 00 fa    	lnk       #0x4
    c472:	00 43 78    	mov.b     w0, w6
    c474:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_ACK_LEN];
	_mav_put_uint8_t(buf, 0, target_system);
	_mav_put_uint8_t(buf, 1, target_component);
	_mav_put_uint8_t(buf, 2, type);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ACK_LEN);
#else
	mavlink_mission_ack_t packet;
	packet.target_system = target_system;
    c476:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.target_component = target_component;
    c478:	d4 ff 9f    	mov.b     w4, [w15-3]
	packet.type = type;
    c47a:	e5 ff 9f    	mov.b     w5, [w15-2]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ACK_LEN);
    c47c:	03 48 98    	mov.b     w3, [w0+8]
    c47e:	63 81 57    	sub.w     w15, #0x3, w2
    c480:	b2 41 78    	mov.b     [w2++], w3
    c482:	13 48 98    	mov.b     w3, [w0+9]
    c484:	12 41 78    	mov.b     [w2], w2
    c486:	22 48 98    	mov.b     w2, [w0+10]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_ACK;
    c488:	f2 c2 b3    	mov.b     #0x2f, w2
    c48a:	72 40 98    	mov.b     w2, [w0+7]

0000c48c <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN, MAVLINK_MSG_ID_MISSION_ACK_CRC);
    c48c:	94 c9 b3    	mov.b     #0x99, w4
    c48e:	33 c0 b3    	mov.b     #0x3, w3
    c490:	01 41 78    	mov.b     w1, w2
    c492:	86 40 78    	mov.b     w6, w1
    c494:	b9 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c496 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ACK_LEN);
#endif
}
    c496:	00 80 fa    	ulnk      
    c498:	00 00 06    	return    

0000c49a <_mavlink_msg_vfr_hud_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_vfr_hud_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float airspeed, float groundspeed, int16_t heading, uint16_t throttle, float alt, float climb)
{
    c49a:	14 00 fa    	lnk       #0x14
    c49c:	88 1f 78    	mov.w     w8, [w15++]
    c49e:	00 44 78    	mov.b     w0, w8
    c4a0:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_VFR_HUD_LEN];
	_mav_put_float(buf, 0, airspeed);
	_mav_put_float(buf, 4, groundspeed);
	_mav_put_float(buf, 8, alt);
	_mav_put_float(buf, 12, climb);
	_mav_put_int16_t(buf, 16, heading);
	_mav_put_uint16_t(buf, 18, throttle);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_VFR_HUD_LEN);
#else
	mavlink_vfr_hud_t packet;
	packet.airspeed = airspeed;
    c4a2:	d4 b7 9f    	mov.w     w4, [w15-22]
    c4a4:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.groundspeed = groundspeed;
    c4a6:	f6 b7 9f    	mov.w     w6, [w15-18]
    c4a8:	87 bf 9f    	mov.w     w7, [w15-16]
	packet.alt = alt;
    c4aa:	7f aa 97    	mov.w     [w15-34], w4
    c4ac:	8f b2 97    	mov.w     [w15-32], w5
    c4ae:	94 bf 9f    	mov.w     w4, [w15-14]
    c4b0:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.climb = climb;
    c4b2:	5f aa 97    	mov.w     [w15-38], w4
    c4b4:	ef aa 97    	mov.w     [w15-36], w5
    c4b6:	b4 bf 9f    	mov.w     w4, [w15-10]
    c4b8:	c5 bf 9f    	mov.w     w5, [w15-8]
	packet.heading = heading;
    c4ba:	d3 bf 9f    	mov.w     w3, [w15-6]
	packet.throttle = throttle;
    c4bc:	9f b2 97    	mov.w     [w15-30], w5
    c4be:	e5 bf 9f    	mov.w     w5, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_VFR_HUD_LEN);
    c4c0:	68 01 40    	add.w     w0, #0x8, w2
    c4c2:	f6 81 57    	sub.w     w15, #0x16, w3
    c4c4:	09 00 09    	.pword 0x090009
    c4c6:	33 19 78    	mov.w     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_VFR_HUD;
    c4c8:	a2 c4 b3    	mov.b     #0x4a, w2
    c4ca:	72 40 98    	mov.b     w2, [w0+7]

0000c4cc <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN, MAVLINK_MSG_ID_VFR_HUD_CRC);
    c4cc:	44 c1 b3    	mov.b     #0x14, w4
    c4ce:	84 41 78    	mov.b     w4, w3
    c4d0:	01 41 78    	mov.b     w1, w2
    c4d2:	88 40 78    	mov.b     w8, w1
    c4d4:	99 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c4d6 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_VFR_HUD_LEN);
#endif
}
    c4d6:	4f 04 78    	mov.w     [--w15], w8
    c4d8:	00 80 fa    	ulnk      
    c4da:	00 00 06    	return    

0000c4dc <_mavlink_msg_slugs_navigation_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_slugs_navigation_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       float u_m, float phi_c, float theta_c, float psiDot_c, float ay_body, float totalDist, float dist2Go, uint8_t fromWP, uint8_t toWP, uint16_t h_c)
{
    c4dc:	20 00 fa    	lnk       #0x20
    c4de:	88 1f 78    	mov.w     w8, [w15++]
    c4e0:	00 44 78    	mov.b     w0, w8
    c4e2:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN];
	_mav_put_float(buf, 0, u_m);
	_mav_put_float(buf, 4, phi_c);
	_mav_put_float(buf, 8, theta_c);
	_mav_put_float(buf, 12, psiDot_c);
	_mav_put_float(buf, 16, ay_body);
	_mav_put_float(buf, 20, totalDist);
	_mav_put_float(buf, 24, dist2Go);
	_mav_put_uint16_t(buf, 28, h_c);
	_mav_put_uint8_t(buf, 30, fromWP);
	_mav_put_uint8_t(buf, 31, toWP);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#else
	mavlink_slugs_navigation_t packet;
	packet.u_m = u_m;
    c4e4:	f4 af 9f    	mov.w     w4, [w15-34]
    c4e6:	85 b7 9f    	mov.w     w5, [w15-32]
	packet.phi_c = phi_c;
    c4e8:	96 b7 9f    	mov.w     w6, [w15-30]
    c4ea:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.theta_c = theta_c;
    c4ec:	2f aa 97    	mov.w     [w15-44], w4
    c4ee:	bf aa 97    	mov.w     [w15-42], w5
    c4f0:	b4 b7 9f    	mov.w     w4, [w15-26]
    c4f2:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.psiDot_c = psiDot_c;
    c4f4:	0f aa 97    	mov.w     [w15-48], w4
    c4f6:	9f aa 97    	mov.w     [w15-46], w5
    c4f8:	d4 b7 9f    	mov.w     w4, [w15-22]
    c4fa:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.ay_body = ay_body;
    c4fc:	6f a2 97    	mov.w     [w15-52], w4
    c4fe:	ff a2 97    	mov.w     [w15-50], w5
    c500:	f4 b7 9f    	mov.w     w4, [w15-18]
    c502:	85 bf 9f    	mov.w     w5, [w15-16]
	packet.totalDist = totalDist;
    c504:	4f a2 97    	mov.w     [w15-56], w4
    c506:	df a2 97    	mov.w     [w15-54], w5
    c508:	94 bf 9f    	mov.w     w4, [w15-14]
    c50a:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.dist2Go = dist2Go;
    c50c:	2f a2 97    	mov.w     [w15-60], w4
    c50e:	bf a2 97    	mov.w     [w15-58], w5
    c510:	b4 bf 9f    	mov.w     w4, [w15-10]
    c512:	c5 bf 9f    	mov.w     w5, [w15-8]
	packet.h_c = h_c;
    c514:	8f a2 97    	mov.w     [w15-64], w5
    c516:	d5 bf 9f    	mov.w     w5, [w15-6]
	packet.fromWP = fromWP;
    c518:	c3 ff 9f    	mov.b     w3, [w15-4]
	packet.toWP = toWP;
    c51a:	2f c1 97    	mov.b     [w15-62], w2
    c51c:	d2 ff 9f    	mov.b     w2, [w15-3]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
    c51e:	e8 01 40    	add.w     w0, #0x8, w3
    c520:	e4 fd 2f    	mov.w     #0xffde, w4
    c522:	04 82 47    	add.w     w15, w4, w4
    c524:	0f 00 09    	.pword 0x09000f
    c526:	b4 19 78    	mov.w     [w4++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SLUGS_NAVIGATION;
    c528:	02 cb b3    	mov.b     #0xb0, w2
    c52a:	72 40 98    	mov.b     w2, [w0+7]

0000c52c <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN, MAVLINK_MSG_ID_SLUGS_NAVIGATION_CRC);
    c52c:	44 ce b3    	mov.b     #0xe4, w4
    c52e:	03 c2 b3    	mov.b     #0x20, w3
    c530:	01 41 78    	mov.b     w1, w2
    c532:	88 40 78    	mov.b     w8, w1
    c534:	69 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c536 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SLUGS_NAVIGATION_LEN);
#endif
}
    c536:	4f 04 78    	mov.w     [--w15], w8
    c538:	00 80 fa    	ulnk      
    c53a:	00 00 06    	return    

0000c53c <_mav_array_memcpy>:
  like memcpy(), but if src is NULL, do a memset to zero
*/
static inline void mav_array_memcpy(void *dest, const void *src, size_t n)
{
	if (src == NULL) {
    c53c:	01 00 e0    	cp0.w     w1
    c53e:	03 00 3a    	bra       NZ, 0xc546 <.L0> <.L29>

0000c540 <.L0>:
		memset(dest, 0, n);
    c540:	d6 23 02    	call      0x23d6 <_memset>
    c542:	00 00 00 
    c544:	02 00 37    	bra       0xc54a <.L28>

0000c546 <.L0>:
	} else {
		memcpy(dest, src, n);
    c546:	c8 23 02    	call      0x23c8 <_memcpy>
    c548:	00 00 00 

0000c54a <.L28>:
	}
}
    c54a:	00 00 06    	return    

0000c54c <_mavlink_msg_statustext_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_statustext_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t severity, const char *text)
{
    c54c:	34 00 fa    	lnk       #0x34
    c54e:	88 9f be    	mov.d     w8, [w15++]
    c550:	8a 1f 78    	mov.w     w10, [w15++]
    c552:	00 45 78    	mov.b     w0, w10
    c554:	81 44 78    	mov.b     w1, w9
    c556:	02 04 78    	mov.w     w2, w8
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_STATUSTEXT_LEN];
	_mav_put_uint8_t(buf, 0, severity);
	_mav_put_char_array(buf, 1, text, 50);
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_STATUSTEXT_LEN);
#else
	mavlink_statustext_t packet;
	packet.severity = severity;
    c558:	60 fc 2f    	mov.w     #0xffc6, w0
    c55a:	0f 00 40    	add.w     w0, w15, w0
    c55c:	03 58 78    	mov.b     w3, [w0++]

0000c55e <.L0>:
	mav_array_memcpy(packet.text, text, sizeof(char)*50);
    c55e:	22 03 20    	mov.w     #0x32, w2
    c560:	84 00 78    	mov.w     w4, w1
    c562:	ec ff 07    	rcall     0xc53c <_mav_array_memcpy> <L0> <.L0> <.LFB20> <.LFE1291>

0000c564 <.L0>:
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_STATUSTEXT_LEN);
    c564:	68 00 44    	add.w     w8, #0x8, w0
    c566:	61 fc 2f    	mov.w     #0xffc6, w1
    c568:	81 80 47    	add.w     w15, w1, w1
    c56a:	32 00 09    	.pword 0x090032
    c56c:	31 58 78    	mov.b     [w1++], [w0++]
#endif

	msg->msgid = MAVLINK_MSG_ID_STATUSTEXT;
    c56e:	d0 cf b3    	mov.b     #0xfd, w0
    c570:	70 44 98    	mov.b     w0, [w8+7]

0000c572 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN, MAVLINK_MSG_ID_STATUSTEXT_CRC);
    c572:	34 c5 b3    	mov.b     #0x53, w4
    c574:	33 c3 b3    	mov.b     #0x33, w3
    c576:	09 41 78    	mov.b     w9, w2
    c578:	8a 40 78    	mov.b     w10, w1
    c57a:	08 00 78    	mov.w     w8, w0
    c57c:	45 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c57e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_STATUSTEXT_LEN);
#endif
}
    c57e:	4f 05 78    	mov.w     [--w15], w10
    c580:	4f 04 be    	mov.d     [--w15], w8
    c582:	00 80 fa    	ulnk      
    c584:	00 00 06    	return    

0000c586 <_mavlink_msg_to_send_buffer>:
/**
 * @brief Pack a message to send it over a serial byte stream
 */
MAVLINK_HELPER uint16_t mavlink_msg_to_send_buffer(uint8_t *buffer, const mavlink_message_t *msg)
{
    c586:	88 1f 78    	mov.w     w8, [w15++]
    c588:	01 04 78    	mov.w     w1, w8

0000c58a <.L0>:
	memcpy(buffer, (const uint8_t *)&msg->magic, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len);
    c58a:	38 41 90    	mov.b     [w8+3], w2
    c58c:	02 81 fb    	ze        w2, w2
    c58e:	68 01 41    	add.w     w2, #0x8, w2
    c590:	88 80 e8    	inc2.w    w8, w1
    c592:	c8 23 02    	call      0x23c8 <_memcpy>
    c594:	00 00 00 

0000c596 <.L0>:
	return MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len;
    c596:	38 40 90    	mov.b     [w8+3], w0
    c598:	00 80 fb    	ze        w0, w0
    c59a:	68 00 40    	add.w     w0, #0x8, w0
}
    c59c:	4f 04 78    	mov.w     [--w15], w8
    c59e:	00 00 06    	return    

0000c5a0 <_mavlink_msg_servo_output_raw_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_servo_output_raw_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t time_usec, uint8_t port, uint16_t servo1_raw, uint16_t servo2_raw, uint16_t servo3_raw, uint16_t servo4_raw, uint16_t servo5_raw, uint16_t servo6_raw, uint16_t servo7_raw, uint16_t servo8_raw)
{
    c5a0:	16 00 fa    	lnk       #0x16
    c5a2:	88 1f 78    	mov.w     w8, [w15++]
    c5a4:	00 44 78    	mov.b     w0, w8
    c5a6:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN];
	_mav_put_uint32_t(buf, 0, time_usec);
	_mav_put_uint16_t(buf, 4, servo1_raw);
	_mav_put_uint16_t(buf, 6, servo2_raw);
	_mav_put_uint16_t(buf, 8, servo3_raw);
	_mav_put_uint16_t(buf, 10, servo4_raw);
	_mav_put_uint16_t(buf, 12, servo5_raw);
	_mav_put_uint16_t(buf, 14, servo6_raw);
	_mav_put_uint16_t(buf, 16, servo7_raw);
	_mav_put_uint16_t(buf, 18, servo8_raw);
	_mav_put_uint8_t(buf, 20, port);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#else
	mavlink_servo_output_raw_t packet;
	packet.time_usec = time_usec;
    c5a8:	c4 b7 9f    	mov.w     w4, [w15-24]
    c5aa:	d5 b7 9f    	mov.w     w5, [w15-22]
	packet.servo1_raw = servo1_raw;
    c5ac:	e6 b7 9f    	mov.w     w6, [w15-20]
	packet.servo2_raw = servo2_raw;
    c5ae:	f7 b7 9f    	mov.w     w7, [w15-18]
	packet.servo3_raw = servo3_raw;
    c5b0:	0f b1 97    	mov.w     [w15-32], w2
    c5b2:	82 bf 9f    	mov.w     w2, [w15-16]
	packet.servo4_raw = servo4_raw;
    c5b4:	7f a9 97    	mov.w     [w15-34], w2
    c5b6:	92 bf 9f    	mov.w     w2, [w15-14]
	packet.servo5_raw = servo5_raw;
    c5b8:	6f a9 97    	mov.w     [w15-36], w2
    c5ba:	a2 bf 9f    	mov.w     w2, [w15-12]

0000c5bc <.L0>:
	packet.servo6_raw = servo6_raw;
    c5bc:	5f a9 97    	mov.w     [w15-38], w2
    c5be:	b2 bf 9f    	mov.w     w2, [w15-10]

0000c5c0 <.L0>:
	packet.servo7_raw = servo7_raw;
    c5c0:	4f a9 97    	mov.w     [w15-40], w2
    c5c2:	c2 bf 9f    	mov.w     w2, [w15-8]
	packet.servo8_raw = servo8_raw;
    c5c4:	3f a9 97    	mov.w     [w15-42], w2
    c5c6:	d2 bf 9f    	mov.w     w2, [w15-6]
	packet.port = port;
    c5c8:	c3 ff 9f    	mov.b     w3, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
    c5ca:	e8 01 40    	add.w     w0, #0x8, w3
    c5cc:	78 81 57    	sub.w     w15, #0x18, w2
    c5ce:	09 00 09    	.pword 0x090009
    c5d0:	b2 19 78    	mov.w     [w2++], [w3++]
    c5d2:	b2 59 78    	mov.b     [w2++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;
    c5d4:	42 c2 b3    	mov.b     #0x24, w2
    c5d6:	72 40 98    	mov.b     w2, [w0+7]

0000c5d8 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_CRC);
    c5d8:	e4 cd b3    	mov.b     #0xde, w4
    c5da:	53 c1 b3    	mov.b     #0x15, w3
    c5dc:	01 41 78    	mov.b     w1, w2
    c5de:	88 40 78    	mov.b     w8, w1
    c5e0:	13 fe 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c5e2 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SERVO_OUTPUT_RAW_LEN);
#endif
}
    c5e2:	4f 04 78    	mov.w     [--w15], w8
    c5e4:	00 80 fa    	ulnk      
    c5e6:	00 00 06    	return    

0000c5e8 <_mavlink_msg_sys_status_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_sys_status_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint32_t onboard_control_sensors_present, uint32_t onboard_control_sensors_enabled, uint32_t onboard_control_sensors_health, uint16_t load, uint16_t voltage_battery, int16_t current_battery, int8_t battery_remaining, uint16_t drop_rate_comm, uint16_t errors_comm, uint16_t errors_count1, uint16_t errors_count2, uint16_t errors_count3, uint16_t errors_count4)
{
    c5e8:	20 00 fa    	lnk       #0x20
    c5ea:	88 1f 78    	mov.w     w8, [w15++]
    c5ec:	00 44 78    	mov.b     w0, w8
    c5ee:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_SYS_STATUS_LEN];
	_mav_put_uint32_t(buf, 0, onboard_control_sensors_present);
	_mav_put_uint32_t(buf, 4, onboard_control_sensors_enabled);
	_mav_put_uint32_t(buf, 8, onboard_control_sensors_health);
	_mav_put_uint16_t(buf, 12, load);
	_mav_put_uint16_t(buf, 14, voltage_battery);
	_mav_put_int16_t(buf, 16, current_battery);
	_mav_put_uint16_t(buf, 18, drop_rate_comm);
	_mav_put_uint16_t(buf, 20, errors_comm);
	_mav_put_uint16_t(buf, 22, errors_count1);
	_mav_put_uint16_t(buf, 24, errors_count2);
	_mav_put_uint16_t(buf, 26, errors_count3);
	_mav_put_uint16_t(buf, 28, errors_count4);
	_mav_put_int8_t(buf, 30, battery_remaining);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#else
	mavlink_sys_status_t packet;
	packet.onboard_control_sensors_present = onboard_control_sensors_present;
    c5f0:	f4 af 9f    	mov.w     w4, [w15-34]
    c5f2:	85 b7 9f    	mov.w     w5, [w15-32]
	packet.onboard_control_sensors_enabled = onboard_control_sensors_enabled;
    c5f4:	96 b7 9f    	mov.w     w6, [w15-30]
    c5f6:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.onboard_control_sensors_health = onboard_control_sensors_health;
    c5f8:	2f aa 97    	mov.w     [w15-44], w4
    c5fa:	bf aa 97    	mov.w     [w15-42], w5
    c5fc:	b4 b7 9f    	mov.w     w4, [w15-26]
    c5fe:	c5 b7 9f    	mov.w     w5, [w15-24]
	packet.load = load;
    c600:	d3 b7 9f    	mov.w     w3, [w15-22]
	packet.voltage_battery = voltage_battery;
    c602:	9f aa 97    	mov.w     [w15-46], w5
    c604:	e5 b7 9f    	mov.w     w5, [w15-20]
	packet.current_battery = current_battery;
    c606:	0f a9 97    	mov.w     [w15-48], w2
    c608:	f2 b7 9f    	mov.w     w2, [w15-18]
	packet.drop_rate_comm = drop_rate_comm;
    c60a:	ef a1 97    	mov.w     [w15-52], w3
    c60c:	83 bf 9f    	mov.w     w3, [w15-16]
	packet.errors_comm = errors_comm;
    c60e:	5f a2 97    	mov.w     [w15-54], w4
    c610:	94 bf 9f    	mov.w     w4, [w15-14]
	packet.errors_count1 = errors_count1;
    c612:	cf a2 97    	mov.w     [w15-56], w5
    c614:	a5 bf 9f    	mov.w     w5, [w15-12]
	packet.errors_count2 = errors_count2;
    c616:	3f a1 97    	mov.w     [w15-58], w2
    c618:	b2 bf 9f    	mov.w     w2, [w15-10]
	packet.errors_count3 = errors_count3;
    c61a:	af a1 97    	mov.w     [w15-60], w3
    c61c:	c3 bf 9f    	mov.w     w3, [w15-8]
	packet.errors_count4 = errors_count4;
    c61e:	1f a2 97    	mov.w     [w15-62], w4
    c620:	d4 bf 9f    	mov.w     w4, [w15-6]
	packet.battery_remaining = battery_remaining;
    c622:	ef ca 97    	mov.b     [w15-50], w5
    c624:	c5 ff 9f    	mov.b     w5, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_SYS_STATUS_LEN);
    c626:	68 01 40    	add.w     w0, #0x8, w2
    c628:	e3 fd 2f    	mov.w     #0xffde, w3
    c62a:	83 81 47    	add.w     w15, w3, w3
    c62c:	0e 00 09    	.pword 0x09000e
    c62e:	33 19 78    	mov.w     [w3++], [w2++]
    c630:	33 59 78    	mov.b     [w3++], [w2++]
#endif

	msg->msgid = MAVLINK_MSG_ID_SYS_STATUS;
    c632:	12 c0 b3    	mov.b     #0x1, w2
    c634:	72 40 98    	mov.b     w2, [w0+7]

0000c636 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN, MAVLINK_MSG_ID_SYS_STATUS_CRC);
    c636:	c4 c7 b3    	mov.b     #0x7c, w4
    c638:	f3 c1 b3    	mov.b     #0x1f, w3
    c63a:	01 41 78    	mov.b     w1, w2
    c63c:	88 40 78    	mov.b     w8, w1
    c63e:	e4 fd 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c640 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_SYS_STATUS_LEN);
#endif
}
    c640:	4f 04 78    	mov.w     [--w15], w8
    c642:	00 80 fa    	ulnk      
    c644:	00 00 06    	return    

0000c646 <_mavlink_msg_heartbeat_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_heartbeat_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status)
{
    c646:	0a 00 fa    	lnk       #0xa
    c648:	88 1f 78    	mov.w     w8, [w15++]
    c64a:	00 44 78    	mov.b     w0, w8
    c64c:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_HEARTBEAT_LEN];
	_mav_put_uint32_t(buf, 0, custom_mode);
	_mav_put_uint8_t(buf, 4, type);
	_mav_put_uint8_t(buf, 5, autopilot);
	_mav_put_uint8_t(buf, 6, base_mode);
	_mav_put_uint8_t(buf, 7, system_status);
	_mav_put_uint8_t(buf, 8, 3);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_HEARTBEAT_LEN);
#else
	mavlink_heartbeat_t packet;
	packet.custom_mode = custom_mode;
    c64e:	a6 bf 9f    	mov.w     w6, [w15-12]
    c650:	b7 bf 9f    	mov.w     w7, [w15-10]
	packet.type = type;
    c652:	83 ff 9f    	mov.b     w3, [w15-8]
	packet.autopilot = autopilot;
    c654:	94 ff 9f    	mov.b     w4, [w15-7]
	packet.base_mode = base_mode;
    c656:	a5 ff 9f    	mov.b     w5, [w15-6]
	packet.system_status = system_status;
    c658:	4f e9 97    	mov.b     [w15-20], w2
    c65a:	b2 ff 9f    	mov.b     w2, [w15-5]
	packet.mavlink_version = 3;
    c65c:	32 c0 b3    	mov.b     #0x3, w2
    c65e:	c2 ff 9f    	mov.b     w2, [w15-4]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_HEARTBEAT_LEN);
    c660:	46 00 98    	mov.w     w6, [w0+8]
    c662:	57 00 98    	mov.w     w7, [w0+10]
    c664:	68 81 57    	sub.w     w15, #0x8, w2
    c666:	32 02 be    	mov.d     [w2++], w4
    c668:	64 00 98    	mov.w     w4, [w0+12]
    c66a:	75 00 98    	mov.w     w5, [w0+14]
    c66c:	12 41 78    	mov.b     [w2], w2
    c66e:	02 50 98    	mov.b     w2, [w0+16]
#endif

	msg->msgid = MAVLINK_MSG_ID_HEARTBEAT;
    c670:	00 41 eb    	clr.b     w2
    c672:	72 40 98    	mov.b     w2, [w0+7]

0000c674 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC);
    c674:	24 c3 b3    	mov.b     #0x32, w4
    c676:	93 c0 b3    	mov.b     #0x9, w3
    c678:	01 41 78    	mov.b     w1, w2
    c67a:	88 40 78    	mov.b     w8, w1
    c67c:	c5 fd 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c67e <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_HEARTBEAT_LEN);
#endif
}
    c67e:	4f 04 78    	mov.w     [--w15], w8
    c680:	00 80 fa    	ulnk      
    c682:	00 00 06    	return    

0000c684 <_mavlink_msg_param_value_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_param_value_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       const char *param_id, float param_value, uint8_t param_type, uint16_t param_count, uint16_t param_index)
{
    c684:	1a 00 fa    	lnk       #0x1a
    c686:	88 9f be    	mov.d     w8, [w15++]
    c688:	8a 1f 78    	mov.w     w10, [w15++]
    c68a:	00 45 78    	mov.b     w0, w10
    c68c:	81 44 78    	mov.b     w1, w9
    c68e:	02 04 78    	mov.w     w2, w8
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_PARAM_VALUE_LEN];
	_mav_put_float(buf, 0, param_value);
	_mav_put_uint16_t(buf, 4, param_count);
	_mav_put_uint16_t(buf, 6, param_index);
	_mav_put_uint8_t(buf, 24, param_type);
	_mav_put_char_array(buf, 8, param_id, 16);
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
#else
	mavlink_param_value_t packet;
	packet.param_value = param_value;
    c690:	84 b7 9f    	mov.w     w4, [w15-32]
    c692:	95 b7 9f    	mov.w     w5, [w15-30]
	packet.param_count = param_count;
    c694:	a7 b7 9f    	mov.w     w7, [w15-28]
	packet.param_index = param_index;
    c696:	4f a8 97    	mov.w     [w15-40], w0
    c698:	b0 b7 9f    	mov.w     w0, [w15-26]
	packet.param_type = param_type;
    c69a:	86 ff 9f    	mov.b     w6, [w15-8]

0000c69c <.L0>:
	mav_array_memcpy(packet.param_id, param_id, sizeof(char)*16);
    c69c:	02 01 20    	mov.w     #0x10, w2
    c69e:	83 00 78    	mov.w     w3, w1
    c6a0:	78 80 57    	sub.w     w15, #0x18, w0
    c6a2:	4c ff 07    	rcall     0xc53c <_mav_array_memcpy> <L0> <.L0> <.LFB20> <.LFE1291>

0000c6a4 <.L0>:
        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
    c6a4:	e8 00 44    	add.w     w8, #0x8, w1
    c6a6:	00 fe 2f    	mov.w     #0xffe0, w0
    c6a8:	00 80 47    	add.w     w15, w0, w0
    c6aa:	0b 00 09    	.pword 0x09000b
    c6ac:	b0 18 78    	mov.w     [w0++], [w1++]
    c6ae:	b0 58 78    	mov.b     [w0++], [w1++]
#endif

	msg->msgid = MAVLINK_MSG_ID_PARAM_VALUE;
    c6b0:	60 c1 b3    	mov.b     #0x16, w0
    c6b2:	70 44 98    	mov.b     w0, [w8+7]

0000c6b4 <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN, MAVLINK_MSG_ID_PARAM_VALUE_CRC);
    c6b4:	c4 cd b3    	mov.b     #0xdc, w4
    c6b6:	93 c1 b3    	mov.b     #0x19, w3
    c6b8:	09 41 78    	mov.b     w9, w2
    c6ba:	8a 40 78    	mov.b     w10, w1
    c6bc:	08 00 78    	mov.w     w8, w0
    c6be:	a4 fd 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c6c0 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_PARAM_VALUE_LEN);
#endif
}
    c6c0:	4f 05 78    	mov.w     [--w15], w10
    c6c2:	4f 04 be    	mov.d     [--w15], w8
    c6c4:	00 80 fa    	ulnk      
    c6c6:	00 00 06    	return    

0000c6c8 <_mavlink_msg_mission_item_pack>:
 * @return length of the message in bytes (excluding serial stream start sign)
 */
static inline uint16_t mavlink_msg_mission_item_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg,
						       uint8_t target_system, uint8_t target_component, uint16_t seq, uint8_t frame, uint16_t command, uint8_t current, uint8_t autocontinue, float param1, float param2, float param3, float param4, float x, float y, float z)
{
    c6c8:	26 00 fa    	lnk       #0x26
    c6ca:	88 1f 78    	mov.w     w8, [w15++]
    c6cc:	8a 9f be    	mov.d     w10, [w15++]
    c6ce:	00 44 78    	mov.b     w0, w8
    c6d0:	02 00 78    	mov.w     w2, w0
#if MAVLINK_NEED_BYTE_SWAP || !MAVLINK_ALIGNED_FIELDS
	char buf[MAVLINK_MSG_ID_MISSION_ITEM_LEN];
	_mav_put_float(buf, 0, param1);
	_mav_put_float(buf, 4, param2);
	_mav_put_float(buf, 8, param3);
	_mav_put_float(buf, 12, param4);
	_mav_put_float(buf, 16, x);
	_mav_put_float(buf, 20, y);
	_mav_put_float(buf, 24, z);
	_mav_put_uint16_t(buf, 28, seq);
	_mav_put_uint16_t(buf, 30, command);
	_mav_put_uint8_t(buf, 32, target_system);
	_mav_put_uint8_t(buf, 33, target_component);
	_mav_put_uint8_t(buf, 34, frame);
	_mav_put_uint8_t(buf, 35, current);
	_mav_put_uint8_t(buf, 36, autocontinue);

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), buf, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
#else
	mavlink_mission_item_t packet;
	packet.param1 = param1;
    c6d2:	3f a5 97    	mov.w     [w15-58], w10
    c6d4:	cf a5 97    	mov.w     [w15-56], w11
    c6d6:	aa af 9f    	mov.w     w10, [w15-44]
    c6d8:	bb af 9f    	mov.w     w11, [w15-42]
	packet.param2 = param2;
    c6da:	1f a5 97    	mov.w     [w15-62], w10
    c6dc:	af a5 97    	mov.w     [w15-60], w11
    c6de:	ca af 9f    	mov.w     w10, [w15-40]
    c6e0:	db af 9f    	mov.w     w11, [w15-38]
	packet.param3 = param3;
    c6e2:	7f 9d 97    	mov.w     [w15-66], w10
    c6e4:	8f a5 97    	mov.w     [w15-64], w11
    c6e6:	ea af 9f    	mov.w     w10, [w15-36]
    c6e8:	fb af 9f    	mov.w     w11, [w15-34]
	packet.param4 = param4;
    c6ea:	5f 9d 97    	mov.w     [w15-70], w10
    c6ec:	ef 9d 97    	mov.w     [w15-68], w11
    c6ee:	8a b7 9f    	mov.w     w10, [w15-32]
    c6f0:	9b b7 9f    	mov.w     w11, [w15-30]
	packet.x = x;
    c6f2:	3f 9d 97    	mov.w     [w15-74], w10
    c6f4:	cf 9d 97    	mov.w     [w15-72], w11
    c6f6:	aa b7 9f    	mov.w     w10, [w15-28]
    c6f8:	bb b7 9f    	mov.w     w11, [w15-26]
	packet.y = y;
    c6fa:	1f 9d 97    	mov.w     [w15-78], w10
    c6fc:	af 9d 97    	mov.w     [w15-76], w11
    c6fe:	ca b7 9f    	mov.w     w10, [w15-24]
    c700:	db b7 9f    	mov.w     w11, [w15-22]
	packet.z = z;
    c702:	7f 95 97    	mov.w     [w15-82], w10
    c704:	8f 9d 97    	mov.w     [w15-80], w11
    c706:	ea b7 9f    	mov.w     w10, [w15-20]
    c708:	fb b7 9f    	mov.w     w11, [w15-18]
	packet.seq = seq;
    c70a:	85 bf 9f    	mov.w     w5, [w15-16]
	packet.command = command;
    c70c:	97 bf 9f    	mov.w     w7, [w15-14]
	packet.target_system = target_system;
    c70e:	c3 f7 9f    	mov.b     w3, [w15-12]
	packet.target_component = target_component;
    c710:	d4 f7 9f    	mov.b     w4, [w15-11]
	packet.frame = frame;
    c712:	e6 f7 9f    	mov.b     w6, [w15-10]
	packet.current = current;
    c714:	cf cd 97    	mov.b     [w15-52], w11
    c716:	fb f7 9f    	mov.b     w11, [w15-9]
	packet.autocontinue = autocontinue;
    c718:	2f c9 97    	mov.b     [w15-54], w2
    c71a:	82 ff 9f    	mov.b     w2, [w15-8]

        memcpy(_MAV_PAYLOAD_NON_CONST(msg), &packet, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
    c71c:	e8 01 40    	add.w     w0, #0x8, w3
    c71e:	4a fd 2f    	mov.w     #0xffd4, w10
    c720:	0a 85 47    	add.w     w15, w10, w10
    c722:	11 00 09    	.pword 0x090011
    c724:	ba 19 78    	mov.w     [w10++], [w3++]
    c726:	ba 59 78    	mov.b     [w10++], [w3++]
#endif

	msg->msgid = MAVLINK_MSG_ID_MISSION_ITEM;
    c728:	72 c2 b3    	mov.b     #0x27, w2
    c72a:	72 40 98    	mov.b     w2, [w0+7]

0000c72c <.L0>:
#if MAVLINK_CRC_EXTRA
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN, MAVLINK_MSG_ID_MISSION_ITEM_CRC);
    c72c:	e4 cf b3    	mov.b     #0xfe, w4
    c72e:	53 c2 b3    	mov.b     #0x25, w3
    c730:	01 41 78    	mov.b     w1, w2
    c732:	88 40 78    	mov.b     w8, w1
    c734:	69 fd 07    	rcall     0xc208 <_mavlink_finalize_message> <L0> <.L0> <.LFB13> <.LFE12>

0000c736 <.L0>:
#else
    return mavlink_finalize_message(msg, system_id, component_id, MAVLINK_MSG_ID_MISSION_ITEM_LEN);
#endif
}
    c736:	4f 05 be    	mov.d     [--w15], w10
    c738:	4f 04 78    	mov.w     [--w15], w8
    c73a:	00 80 fa    	ulnk      
    c73c:	00 00 06    	return    

0000c73e <_mavlink_parse_char>:
 *
 * @endcode
 */
MAVLINK_HELPER uint8_t mavlink_parse_char(uint8_t chan, uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status)
{
    c73e:	88 9f be    	mov.d     w8, [w15++]
    c740:	8a 9f be    	mov.d     w10, [w15++]
    c742:	8c 1f 78    	mov.w     w12, [w15++]
    c744:	00 44 78    	mov.b     w0, w8
    c746:	81 45 78    	mov.b     w1, w11
    c748:	02 06 78    	mov.w     w2, w12
    c74a:	83 04 78    	mov.w     w3, w9

0000c74c <.L0>:
        /*
	  default message crc function. You can override this per-system to
	  put this data in a different memory segment
	*/
#if MAVLINK_CRC_EXTRA
#ifndef MAVLINK_MESSAGE_CRC
	static const uint8_t mavlink_message_crcs[256] = MAVLINK_MESSAGE_CRCS;
#define MAVLINK_MESSAGE_CRC(msgid) mavlink_message_crcs[msgid]
#endif
#endif

/* Enable this option to check the length of each message.
 This allows invalid messages to be caught much sooner. Use if the transmission
 medium is prone to missing (or extra) characters (e.g. a radio that fades in
 and out). Only use if the channel will only contain messages types listed in
 the headers.
*/
#if MAVLINK_CHECK_MESSAGE_LENGTH
#ifndef MAVLINK_MESSAGE_LENGTH
	static const uint8_t mavlink_message_lengths[256] = MAVLINK_MESSAGE_LENGTHS;
#define MAVLINK_MESSAGE_LENGTH(msgid) mavlink_message_lengths[msgid]
#endif
#endif

	mavlink_message_t* rxmsg = mavlink_get_channel_buffer(chan); ///< The currently decoded message
    c74c:	08 40 78    	mov.b     w8, w0
    c74e:	2c fd 07    	rcall     0xc1a8 <_mavlink_get_channel_buffer> <L0> <.LFB10> <.LFE9>
    c750:	00 05 78    	mov.w     w0, w10

0000c752 <.L0>:
	mavlink_status_t* status = mavlink_get_channel_status(chan); ///< The current decode status
    c752:	08 40 78    	mov.b     w8, w0
    c754:	24 fd 07    	rcall     0xc19e <_mavlink_get_channel_status> <L0> <.LFB9> <.LFE2>
    c756:	00 04 78    	mov.w     w0, w8

0000c758 <.L0>:
	int bufferIndex = 0;

	status->msg_received = 0;
    c758:	00 4c eb    	clr.b     [w8]

	switch (status->parse_state)
    c75a:	28 00 90    	mov.w     [w8+4], w0
    c75c:	80 00 eb    	clr.w     w1
    c75e:	e9 0f 50    	sub.w     w0, #0x9, [w15]
    c760:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    c762:	91 00 3e    	bra       GTU, 0xc886 <.L39>
    c764:	00 06 01    	.pword 0x010600
    c766:	09 00 37    	bra       0xc77a <.L40>
    c768:	08 00 37    	bra       0xc77a <.L40>
    c76a:	12 00 37    	bra       0xc790 <.L0> <.L41>
    c76c:	21 00 37    	bra       0xc7b0 <.L42>
    c76e:	19 00 37    	bra       0xc7a2 <.L43>
    c770:	26 00 37    	bra       0xc7be <.L44>
    c772:	2c 00 37    	bra       0xc7cc <.L45>
    c774:	38 00 37    	bra       0xc7e6 <.L46>
    c776:	47 00 37    	bra       0xc806 <.L0> <.L47>
    c778:	67 00 37    	bra       0xc848 <.L48>

0000c77a <.L40>:
	{
	case MAVLINK_PARSE_STATE_UNINIT:
	case MAVLINK_PARSE_STATE_IDLE:
		if (c == MAVLINK_STX)
    c77a:	e2 cf 45    	add.b     w11, #0x2, [w15]
    c77c:	90 00 3a    	bra       NZ, 0xc89e <.L50>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
    c77e:	20 00 20    	mov.w     #0x2, w0
    c780:	20 04 98    	mov.w     w0, [w8+4]
			rxmsg->len = 0;
    c782:	00 40 eb    	clr.b     w0
    c784:	30 45 98    	mov.b     w0, [w10+3]
			rxmsg->magic = c;
    c786:	e0 cf b3    	mov.b     #0xfe, w0
    c788:	20 45 98    	mov.b     w0, [w10+2]

0000c78a <.L0>:
			mavlink_start_checksum(rxmsg);
    c78a:	0a 00 78    	mov.w     w10, w0
    c78c:	42 fd 07    	rcall     0xc212 <_mavlink_start_checksum> <L0> <.LFB15> <.LFE13>
    c78e:	7b 00 37    	bra       0xc886 <.L39>

0000c790 <.L0>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_STX:
			if (status->msg_received 
/* Support shorter buffers than the
   default maximum packet size */
#if (MAVLINK_MAX_PAYLOAD_LEN < 255)
				|| c > MAVLINK_MAX_PAYLOAD_LEN
#endif
				)
		{
			status->buffer_overrun++;
			status->parse_error++;
			status->msg_received = 0;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
		}
		else
		{
			// NOT counting STX, LENGTH, SEQ, SYSID, COMPID, MSGID, CRC1 and CRC2
			rxmsg->len = c;
    c790:	3b 45 98    	mov.b     w11, [w10+3]
			status->packet_idx = 0;
    c792:	00 40 eb    	clr.b     w0
    c794:	60 44 98    	mov.b     w0, [w8+6]

0000c796 <.L0>:
			mavlink_update_checksum(rxmsg, c);
    c796:	8b 40 78    	mov.b     w11, w1
    c798:	0a 00 78    	mov.w     w10, w0
    c79a:	3d fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c79c <.L0>:
			status->parse_state = MAVLINK_PARSE_STATE_GOT_LENGTH;
    c79c:	40 00 20    	mov.w     #0x4, w0
    c79e:	20 04 98    	mov.w     w0, [w8+4]
    c7a0:	72 00 37    	bra       0xc886 <.L39>

0000c7a2 <.L43>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_LENGTH:
		rxmsg->seq = c;
    c7a2:	4b 45 98    	mov.b     w11, [w10+4]

0000c7a4 <.L0>:
		mavlink_update_checksum(rxmsg, c);
    c7a4:	8b 40 78    	mov.b     w11, w1
    c7a6:	0a 00 78    	mov.w     w10, w0
    c7a8:	36 fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c7aa <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_SEQ;
    c7aa:	30 00 20    	mov.w     #0x3, w0
    c7ac:	20 04 98    	mov.w     w0, [w8+4]
		break;
    c7ae:	6b 00 37    	bra       0xc886 <.L39>

0000c7b0 <.L42>:

	case MAVLINK_PARSE_STATE_GOT_SEQ:
		rxmsg->sysid = c;
    c7b0:	5b 45 98    	mov.b     w11, [w10+5]

0000c7b2 <.L0>:
		mavlink_update_checksum(rxmsg, c);
    c7b2:	8b 40 78    	mov.b     w11, w1
    c7b4:	0a 00 78    	mov.w     w10, w0
    c7b6:	2f fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c7b8 <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_SYSID;
    c7b8:	50 00 20    	mov.w     #0x5, w0
    c7ba:	20 04 98    	mov.w     w0, [w8+4]
		break;
    c7bc:	64 00 37    	bra       0xc886 <.L39>

0000c7be <.L44>:

	case MAVLINK_PARSE_STATE_GOT_SYSID:
		rxmsg->compid = c;
    c7be:	6b 45 98    	mov.b     w11, [w10+6]

0000c7c0 <.L0>:
		mavlink_update_checksum(rxmsg, c);
    c7c0:	8b 40 78    	mov.b     w11, w1
    c7c2:	0a 00 78    	mov.w     w10, w0
    c7c4:	28 fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c7c6 <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_COMPID;
    c7c6:	60 00 20    	mov.w     #0x6, w0
    c7c8:	20 04 98    	mov.w     w0, [w8+4]
		break;
    c7ca:	5d 00 37    	bra       0xc886 <.L39>

0000c7cc <.L45>:

	case MAVLINK_PARSE_STATE_GOT_COMPID:
#if MAVLINK_CHECK_MESSAGE_LENGTH
	        if (rxmsg->len != MAVLINK_MESSAGE_LENGTH(c))
		{
			status->parse_error++;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
			break;
			if (c == MAVLINK_STX)
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
				mavlink_start_checksum(rxmsg);
			}
	        }
#endif
		rxmsg->msgid = c;
    c7cc:	7b 45 98    	mov.b     w11, [w10+7]

0000c7ce <.L0>:
		mavlink_update_checksum(rxmsg, c);
    c7ce:	8b 40 78    	mov.b     w11, w1
    c7d0:	0a 00 78    	mov.w     w10, w0
    c7d2:	21 fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c7d4 <.L0>:
		if (rxmsg->len == 0)
    c7d4:	3a 40 90    	mov.b     [w10+3], w0
    c7d6:	00 04 e0    	cp0.b     w0
    c7d8:	03 00 3a    	bra       NZ, 0xc7e0 <.L51>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
    c7da:	80 00 20    	mov.w     #0x8, w0
    c7dc:	20 04 98    	mov.w     w0, [w8+4]
    c7de:	53 00 37    	bra       0xc886 <.L39>

0000c7e0 <.L51>:
		}
		else
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_MSGID;
    c7e0:	70 00 20    	mov.w     #0x7, w0
    c7e2:	20 04 98    	mov.w     w0, [w8+4]
    c7e4:	50 00 37    	bra       0xc886 <.L39>

0000c7e6 <.L46>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_MSGID:
		_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx++] = (char)c;
    c7e6:	68 40 90    	mov.b     [w8+6], w0
    c7e8:	80 80 fb    	ze        w0, w1
    c7ea:	81 00 45    	add.w     w10, w1, w1
    c7ec:	8b 48 98    	mov.b     w11, [w1+8]
    c7ee:	00 40 e8    	inc.b     w0, w0
    c7f0:	60 44 98    	mov.b     w0, [w8+6]

0000c7f2 <.L0>:
		mavlink_update_checksum(rxmsg, c);
    c7f2:	8b 40 78    	mov.b     w11, w1
    c7f4:	0a 00 78    	mov.w     w10, w0
    c7f6:	0f fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c7f8 <.L0>:
		if (status->packet_idx == rxmsg->len)
    c7f8:	e8 40 90    	mov.b     [w8+6], w1
    c7fa:	3a 40 90    	mov.b     [w10+3], w0
    c7fc:	80 cf 50    	sub.b     w1, w0, [w15]
    c7fe:	43 00 3a    	bra       NZ, 0xc886 <.L39>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
    c800:	80 00 20    	mov.w     #0x8, w0
    c802:	20 04 98    	mov.w     w0, [w8+4]
    c804:	40 00 37    	bra       0xc886 <.L39>

0000c806 <.L0>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_PAYLOAD:
#if MAVLINK_CRC_EXTRA
		mavlink_update_checksum(rxmsg, MAVLINK_MESSAGE_CRC(rxmsg->msgid));
    c806:	7a 40 90    	mov.b     [w10+7], w0
    c808:	00 80 fb    	ze        w0, w0
    c80a:	21 2e 2c    	mov.w     #0xc2e2, w1
    c80c:	00 80 40    	add.w     w1, w0, w0
    c80e:	90 40 78    	mov.b     [w0], w1
    c810:	0a 00 78    	mov.w     w10, w0
    c812:	01 fd 07    	rcall     0xc216 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15> <.LC16>

0000c814 <.L0>:
#endif
		if (c != (rxmsg->checksum & 0xFF)) {
    c814:	8b 80 fb    	ze        w11, w1
    c816:	1a 80 fb    	ze        [w10], w0
    c818:	80 8f 50    	sub.w     w1, w0, [w15]
    c81a:	0f 00 32    	bra       Z, 0xc83a <.L0> <.L52>
			// Check first checksum byte
			status->parse_error++;
    c81c:	28 40 90    	mov.b     [w8+2], w0
    c81e:	00 40 e8    	inc.b     w0, w0
    c820:	20 44 98    	mov.b     w0, [w8+2]
			status->msg_received = 0;
    c822:	00 4c eb    	clr.b     [w8]
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
    c824:	10 00 20    	mov.w     #0x1, w0
    c826:	20 04 98    	mov.w     w0, [w8+4]
			if (c == MAVLINK_STX)
    c828:	e2 cf 45    	add.b     w11, #0x2, [w15]
    c82a:	2d 00 3a    	bra       NZ, 0xc886 <.L39>
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
    c82c:	20 00 20    	mov.w     #0x2, w0
    c82e:	20 04 98    	mov.w     w0, [w8+4]
				rxmsg->len = 0;
    c830:	00 40 eb    	clr.b     w0
    c832:	30 45 98    	mov.b     w0, [w10+3]

0000c834 <.L0>:
				mavlink_start_checksum(rxmsg);
    c834:	0a 00 78    	mov.w     w10, w0
    c836:	ed fc 07    	rcall     0xc212 <_mavlink_start_checksum> <L0> <.LFB15> <.LFE13>
    c838:	26 00 37    	bra       0xc886 <.L39>

0000c83a <.L0>:
			}
		}
		else
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_CRC1;
    c83a:	90 00 20    	mov.w     #0x9, w0
    c83c:	20 04 98    	mov.w     w0, [w8+4]
			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx] = (char)c;
    c83e:	68 40 90    	mov.b     [w8+6], w0
    c840:	00 80 fb    	ze        w0, w0
    c842:	00 00 45    	add.w     w10, w0, w0
    c844:	0b 48 98    	mov.b     w11, [w0+8]
    c846:	1f 00 37    	bra       0xc886 <.L39>

0000c848 <.L48>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_CRC1:
		if (c != (rxmsg->checksum >> 8)) {
    c848:	8b 80 fb    	ze        w11, w1
    c84a:	1a 00 78    	mov.w     [w10], w0
    c84c:	48 00 de    	lsr.w     w0, #0x8, w0
    c84e:	80 8f 50    	sub.w     w1, w0, [w15]
    c850:	0e 00 32    	bra       Z, 0xc86e <.L0> <.L53>
			// Check second checksum byte
			status->parse_error++;
    c852:	28 40 90    	mov.b     [w8+2], w0
    c854:	00 40 e8    	inc.b     w0, w0
    c856:	20 44 98    	mov.b     w0, [w8+2]
			status->msg_received = 0;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
    c858:	10 00 20    	mov.w     #0x1, w0
    c85a:	20 04 98    	mov.w     w0, [w8+4]
			if (c == MAVLINK_STX)
    c85c:	e2 cf 45    	add.b     w11, #0x2, [w15]
    c85e:	13 00 3a    	bra       NZ, 0xc886 <.L39>
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
    c860:	20 00 20    	mov.w     #0x2, w0
    c862:	20 04 98    	mov.w     w0, [w8+4]
				rxmsg->len = 0;
    c864:	00 40 eb    	clr.b     w0
    c866:	30 45 98    	mov.b     w0, [w10+3]

0000c868 <.L0>:
				mavlink_start_checksum(rxmsg);
    c868:	0a 00 78    	mov.w     w10, w0
    c86a:	d3 fc 07    	rcall     0xc212 <_mavlink_start_checksum> <L0> <.LFB15> <.LFE13>
    c86c:	0c 00 37    	bra       0xc886 <.L39>

0000c86e <.L0>:
			}
		}
		else
		{
			// Successfully got message
			status->msg_received = 1;
    c86e:	10 c0 b3    	mov.b     #0x1, w0
    c870:	00 4c 78    	mov.b     w0, [w8]
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
    c872:	10 00 20    	mov.w     #0x1, w0
    c874:	20 04 98    	mov.w     w0, [w8+4]
			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx+1] = (char)c;
    c876:	68 40 90    	mov.b     [w8+6], w0
    c878:	00 80 fb    	ze        w0, w0
    c87a:	00 00 45    	add.w     w10, w0, w0
    c87c:	1b 48 98    	mov.b     w11, [w0+9]
			memcpy(r_message, rxmsg, sizeof(mavlink_message_t));
    c87e:	87 00 09    	.pword 0x090087
    c880:	3a 1e 78    	mov.w     [w10++], [w12++]
    c882:	0c 11 b1    	sub.w     #0x110, w12
    c884:	0a 11 b1    	sub.w     #0x110, w10

0000c886 <.L39>:
		}
		break;
	}

	bufferIndex++;
	// If a message has been sucessfully decoded, check index
	if (status->msg_received == 1)
    c886:	10 c0 b3    	mov.b     #0x1, w0
    c888:	98 4f 10    	subr.b    w0, [w8], [w15]
    c88a:	09 00 3a    	bra       NZ, 0xc89e <.L50>
	{
		//while(status->current_seq != rxmsg->seq)
		//{
		//	status->packet_rx_drop_count++;
		//               status->current_seq++;
		//}
		status->current_rx_seq = rxmsg->seq;
    c88c:	4a 45 90    	mov.b     [w10+4], w10
    c88e:	7a 44 98    	mov.b     w10, [w8+7]
		// Initial condition: If no packet has been received so far, drop count is undefined
		if (status->packet_rx_success_count == 0) status->packet_rx_drop_count = 0;
    c890:	58 00 90    	mov.w     [w8+10], w0
    c892:	00 00 e0    	cp0.w     w0
    c894:	02 00 3a    	bra       NZ, 0xc89a <.L54>
    c896:	80 00 eb    	clr.w     w1
    c898:	61 04 98    	mov.w     w1, [w8+12]

0000c89a <.L54>:
		// Count this packet as received
		status->packet_rx_success_count++;
    c89a:	00 00 e8    	inc.w     w0, w0
    c89c:	50 04 98    	mov.w     w0, [w8+10]

0000c89e <.L50>:
	}

	r_mavlink_status->current_rx_seq = status->current_rx_seq+1;
    c89e:	78 40 90    	mov.b     [w8+7], w0
    c8a0:	00 40 e8    	inc.b     w0, w0
    c8a2:	f0 44 98    	mov.b     w0, [w9+7]
	r_mavlink_status->packet_rx_success_count = status->packet_rx_success_count;
    c8a4:	58 00 90    	mov.w     [w8+10], w0
    c8a6:	d0 04 98    	mov.w     w0, [w9+10]
	r_mavlink_status->packet_rx_drop_count = status->parse_error;
    c8a8:	28 40 90    	mov.b     [w8+2], w0
    c8aa:	00 80 fb    	ze        w0, w0
    c8ac:	e0 04 98    	mov.w     w0, [w9+12]
	status->parse_error = 0;
    c8ae:	00 40 eb    	clr.b     w0
    c8b0:	20 44 98    	mov.b     w0, [w8+2]
    c8b2:	18 40 78    	mov.b     [w8], w0
	return status->msg_received;
}
    c8b4:	4f 06 78    	mov.w     [--w15], w12
    c8b6:	4f 05 be    	mov.d     [--w15], w10
    c8b8:	4f 04 be    	mov.d     [--w15], w8
    c8ba:	00 00 06    	return    

0000c8bc <_mavlink_msg_heartbeat_decode>:
	heartbeat->base_mode = mavlink_msg_heartbeat_get_base_mode(msg);
	heartbeat->system_status = mavlink_msg_heartbeat_get_system_status(msg);
	heartbeat->mavlink_version = mavlink_msg_heartbeat_get_mavlink_version(msg);
#else
	memcpy(heartbeat, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_HEARTBEAT_LEN);
    c8bc:	68 01 40    	add.w     w0, #0x8, w2
    c8be:	12 02 be    	mov.d     [w2], w4
    c8c0:	84 98 be    	mov.d     w4, [w1++]
    c8c2:	60 01 90    	mov.w     [w0+12], w2
    c8c4:	f0 01 90    	mov.w     [w0+14], w3
    c8c6:	82 98 be    	mov.d     w2, [w1++]
    c8c8:	00 50 90    	mov.b     [w0+16], w0
    c8ca:	80 48 78    	mov.b     w0, [w1]
#endif
}
    c8cc:	00 00 06    	return    

0000c8ce <_mavlink_msg_mission_count_decode>:
	mission_count->count = mavlink_msg_mission_count_get_count(msg);
	mission_count->target_system = mavlink_msg_mission_count_get_target_system(msg);
	mission_count->target_component = mavlink_msg_mission_count_get_target_component(msg);
#else
	memcpy(mission_count, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_COUNT_LEN);
    c8ce:	40 01 90    	mov.w     [w0+8], w2
    c8d0:	d0 01 90    	mov.w     [w0+10], w3
    c8d2:	82 88 be    	mov.d     w2, [w1]
#endif
}
    c8d4:	00 00 06    	return    

0000c8d6 <_mavlink_msg_mission_request_decode>:
	mission_request->seq = mavlink_msg_mission_request_get_seq(msg);
	mission_request->target_system = mavlink_msg_mission_request_get_target_system(msg);
	mission_request->target_component = mavlink_msg_mission_request_get_target_component(msg);
#else
	memcpy(mission_request, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_REQUEST_LEN);
    c8d6:	40 01 90    	mov.w     [w0+8], w2
    c8d8:	d0 01 90    	mov.w     [w0+10], w3
    c8da:	82 88 be    	mov.d     w2, [w1]
#endif
}
    c8dc:	00 00 06    	return    

0000c8de <_mavlink_msg_mission_ack_decode>:
	mission_ack->target_system = mavlink_msg_mission_ack_get_target_system(msg);
	mission_ack->target_component = mavlink_msg_mission_ack_get_target_component(msg);
	mission_ack->type = mavlink_msg_mission_ack_get_type(msg);
#else
	memcpy(mission_ack, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ACK_LEN);
    c8de:	68 01 40    	add.w     w0, #0x8, w2
    c8e0:	92 58 78    	mov.b     [w2], [w1++]
    c8e2:	10 49 90    	mov.b     [w0+9], w2
    c8e4:	82 58 78    	mov.b     w2, [w1++]
    c8e6:	20 48 90    	mov.b     [w0+10], w0
    c8e8:	80 48 78    	mov.b     w0, [w1]
#endif
}
    c8ea:	00 00 06    	return    

0000c8ec <_mavlink_msg_mission_item_decode>:
	mission_item->frame = mavlink_msg_mission_item_get_frame(msg);
	mission_item->current = mavlink_msg_mission_item_get_current(msg);
	mission_item->autocontinue = mavlink_msg_mission_item_get_autocontinue(msg);
#else
	memcpy(mission_item, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_MISSION_ITEM_LEN);
    c8ec:	68 01 40    	add.w     w0, #0x8, w2
    c8ee:	11 00 09    	.pword 0x090011
    c8f0:	b2 18 78    	mov.w     [w2++], [w1++]
    c8f2:	b2 58 78    	mov.b     [w2++], [w1++]
    c8f4:	51 02 b1    	sub.w     #0x25, w1
#endif
}
    c8f6:	00 00 06    	return    

0000c8f8 <_mavlink_msg_set_gps_global_origin_decode>:
	set_gps_global_origin->longitude = mavlink_msg_set_gps_global_origin_get_longitude(msg);
	set_gps_global_origin->altitude = mavlink_msg_set_gps_global_origin_get_altitude(msg);
	set_gps_global_origin->target_system = mavlink_msg_set_gps_global_origin_get_target_system(msg);
#else
	memcpy(set_gps_global_origin, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN_LEN);
    c8f8:	68 01 40    	add.w     w0, #0x8, w2
    c8fa:	05 00 09    	.pword 0x090005
    c8fc:	b2 18 78    	mov.w     [w2++], [w1++]
    c8fe:	b2 58 78    	mov.b     [w2++], [w1++]
    c900:	d1 00 b1    	sub.w     #0xd, w1
#endif
}
    c902:	00 00 06    	return    

0000c904 <_mavlink_msg_param_set_decode>:
	param_set->target_component = mavlink_msg_param_set_get_target_component(msg);
	mavlink_msg_param_set_get_param_id(msg, param_set->param_id);
	param_set->param_type = mavlink_msg_param_set_get_param_type(msg);
#else
	memcpy(param_set, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_PARAM_SET_LEN);
    c904:	68 01 40    	add.w     w0, #0x8, w2
    c906:	0a 00 09    	.pword 0x09000a
    c908:	b2 18 78    	mov.w     [w2++], [w1++]
    c90a:	b2 58 78    	mov.b     [w2++], [w1++]
    c90c:	71 01 b1    	sub.w     #0x17, w1
#endif
}
    c90e:	00 00 06    	return    

0000c910 <_uartMavlinkBufferInit>:
//pi_struct mlParamInterface;

void uartMavlinkBufferInit (void){
#if (WIN != 1)
  _U1RXIP = 5;                         /* Rx Interrupt priority set to 1 */
    c910:	20 42 80    	mov.w     0x844, w0
    c912:	00 c0 a0    	bset.w    w0, #0xc
    c914:	00 d0 a1    	bclr.w    w0, #0xd
    c916:	00 e0 a0    	bset.w    w0, #0xe
    c918:	20 42 88    	mov.w     w0, 0x844
  _U1RXIF = 0;
    c91a:	01 68 a9    	bclr.b    0x801, #0x3
  _U1RXIE = 1;                         /* Enable Interrupt */
    c91c:	21 68 a8    	bset.b    0x821, #0x3
  /* Configure Remappables Pins */
   RPINR18 = 0x62;
    c91e:	20 06 20    	mov.w     #0x62, w0
    c920:	20 36 88    	mov.w     w0, 0x6c4

0000c922 <.L0>:
#endif
  uartMavlinkInBuffer = (struct CircBuffer*) &comMavlinkBuffer;
    c922:	00 25 22    	mov.w     #0x2250, w0
    c924:	70 12 89    	mov.w     w0, 0x224e

0000c926 <.L0>:
  newCircBuffer(uartMavlinkInBuffer);
    c926:	94 0a 02    	call      0x10a94 <_newCircBuffer>
    c928:	01 00 00 
}
    c92a:	00 00 06    	return    

0000c92c <__U1RXInterrupt>:
#if (WIN != 1)
void __attribute__((__interrupt__,__auto_psv__)) _U1RXInterrupt(void)
{
    c92c:	36 00 f8    	push      0x36
    c92e:	80 9f be    	mov.d     w0, [w15++]
    c930:	82 9f be    	mov.d     w2, [w15++]
    c932:	84 9f be    	mov.d     w4, [w15++]
    c934:	86 9f be    	mov.d     w6, [w15++]
    c936:	32 00 f8    	push      0x32
    c938:	34 00 f8    	push      0x34
    c93a:	10 00 20    	mov.w     #0x1, w0
    c93c:	a0 01 88    	mov.w     w0, 0x34
    c93e:	00 20 20    	mov.w     #0x200, w0
    c940:	90 01 88    	mov.w     w0, 0x32
    c942:	00 00 00    	nop       
  //
        _U1RXIF = 0;
    c944:	01 68 a9    	bclr.b    0x801, #0x3
    // Read the buffer while it has data
    // and add it to the circular buffer
    while (U1STAbits.URXDA == 1) {
    c946:	22 02 ab    	btst.b    0x222, #0x0
    c948:	06 00 32    	bra       Z, 0xc956 <.L64>

0000c94a <.L0>:
        writeBack(uartMavlinkInBuffer, (unsigned char) U1RXREG);
    c94a:	31 11 80    	mov.w     0x226, w1
    c94c:	70 12 81    	mov.w     0x224e, w0
    c94e:	42 0b 02    	call      0x10b42 <_writeBack>
    c950:	01 00 00 

0000c952 <.L0>:
    c952:	22 02 ab    	btst.b    0x222, #0x0
    c954:	fa ff 3a    	bra       NZ, 0xc94a <.L0> <.L67>

0000c956 <.L64>:
    }

    // If there was an overun error clear it and continue
    if (U1STAbits.OERR == 1) {
    c956:	22 22 ab    	btst.b    0x222, #0x1
    c958:	02 00 32    	bra       Z, 0xc95e <.L66>
        _U1RXIF = 0;
    c95a:	01 68 a9    	bclr.b    0x801, #0x3
        U1STAbits.OERR = 0;
    c95c:	22 22 a9    	bclr.b    0x222, #0x1

0000c95e <.L66>:
    }

    // clear the interrupt
    IFS0bits.U1RXIF = 0;
    c95e:	01 68 a9    	bclr.b    0x801, #0x3

}
    c960:	34 00 f9    	pop       0x34
    c962:	32 00 f9    	pop       0x32
    c964:	4f 03 be    	mov.d     [--w15], w6
    c966:	4f 02 be    	mov.d     [--w15], w4
    c968:	4f 01 be    	mov.d     [--w15], w2
    c96a:	4f 00 be    	mov.d     [--w15], w0
    c96c:	36 00 f9    	pop       0x36
    c96e:	00 40 06    	retfie    

0000c970 <_isFinite>:
#endif
uint8_t isFinite(float s) {
    c970:	88 9f be    	mov.d     w8, [w15++]
    c972:	8a 1f 78    	mov.w     w10, [w15++]
    c974:	00 04 be    	mov.d     w0, w8

0000c976 <.L0>:
  // By IEEE 754 rule, 2*Inf equals Inf
  return ((s == s) && ((s == 0) || (s != 2*s)));
    c976:	00 01 be    	mov.d     w0, w2
    c978:	8c 18 02    	call      0x188c <___eqsf2>
    c97a:	00 00 00 
    c97c:	00 00 e0    	cp0.w     w0
    c97e:	16 00 3a    	bra       NZ, 0xc9ac <.L76>
    c980:	60 11 b8    	mul.uu    w2, #0x0, w2
    c982:	08 00 be    	mov.d     w8, w0
    c984:	8c 18 02    	call      0x188c <___eqsf2>
    c986:	00 00 00 
    c988:	80 00 78    	mov.w     w0, w1
    c98a:	10 00 20    	mov.w     #0x1, w0
    c98c:	01 00 e0    	cp0.w     w1
    c98e:	0f 00 32    	bra       Z, 0xc9ae <.L70>
    c990:	08 01 be    	mov.d     w8, w2
    c992:	08 00 be    	mov.d     w8, w0
    c994:	92 14 02    	call      0x1492 <___addsf3>
    c996:	00 00 00 
    c998:	00 01 be    	mov.d     w0, w2

0000c99a <.L0>:
    c99a:	1a 00 20    	mov.w     #0x1, w10
    c99c:	08 00 be    	mov.d     w8, w0
    c99e:	c8 19 02    	call      0x19c8 <___nesf2>
    c9a0:	00 00 00 
    c9a2:	00 00 e0    	cp0.w     w0
    c9a4:	01 00 3a    	bra       NZ, 0xc9a8 <.L0> <.L72>
    c9a6:	00 05 eb    	clr.w     w10

0000c9a8 <.L0>:
    c9a8:	0a 00 78    	mov.w     w10, w0
    c9aa:	01 00 37    	bra       0xc9ae <.L70>

0000c9ac <.L76>:
    c9ac:	00 00 eb    	clr.w     w0

0000c9ae <.L70>:
}
    c9ae:	4f 05 78    	mov.w     [--w15], w10
    c9b0:	4f 04 be    	mov.d     [--w15], w8
    c9b2:	00 00 06    	return    

0000c9b4 <_InitParameterInterface>:

void InitParameterInterface(void)
{
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_P], "PID_AIRSPD_P");
    c9b4:	00 14 2c    	mov.w     #0xc140, w0
    c9b6:	61 2d 21    	mov.w     #0x12d6, w1
    c9b8:	0c 00 09    	.pword 0x09000c
    c9ba:	b0 58 78    	mov.b     [w0++], [w1++]
    c9bc:	d0 00 b1    	sub.w     #0xd, w0
    mlParamInterface.param[PAR_PID_AIRSPEED_P] = 0.949999988079;
    c9be:	30 33 23    	mov.w     #0x3333, w0
    c9c0:	31 f7 23    	mov.w     #0x3f73, w1
    c9c2:	d0 92 88    	mov.w     w0, 0x125a
    c9c4:	e1 92 88    	mov.w     w1, 0x125c
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_I], "PID_AIRSPD_I");
    c9c6:	d0 14 2c    	mov.w     #0xc14d, w0
    c9c8:	63 2e 21    	mov.w     #0x12e6, w3
    c9ca:	0c 00 09    	.pword 0x09000c
    c9cc:	b0 59 78    	mov.b     [w0++], [w3++]
    c9ce:	d0 00 b1    	sub.w     #0xd, w0
    //mlParamInterface.param[PAR_PID_AIRSPEED_I] = 0.00700000021607;
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_D], "PID_AIRSPD_D");
    c9d0:	a0 15 2c    	mov.w     #0xc15a, w0
    c9d2:	65 2f 21    	mov.w     #0x12f6, w5
    c9d4:	0c 00 09    	.pword 0x09000c
    c9d6:	b0 5a 78    	mov.b     [w0++], [w5++]
    c9d8:	d0 00 b1    	sub.w     #0xd, w0
    //mlParamInterface.param[PAR_PID_AIRSPEED_D] = 0.20000000298;

    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_P], "PID_PIT_FO_P");
    c9da:	70 16 2c    	mov.w     #0xc167, w0
    c9dc:	61 30 21    	mov.w     #0x1306, w1
    c9de:	0c 00 09    	.pword 0x09000c
    c9e0:	b0 58 78    	mov.b     [w0++], [w1++]
    c9e2:	d0 00 b1    	sub.w     #0xd, w0
        mlParamInterface.param[PAR_PID_PITCH_FO_P] = -0.20000000298;
    c9e4:	d0 cc 2c    	mov.w     #0xcccd, w0
    c9e6:	c1 e4 2b    	mov.w     #0xbe4c, w1
    c9e8:	30 93 88    	mov.w     w0, 0x1266
    c9ea:	41 93 88    	mov.w     w1, 0x1268
    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_I], "PID_PIT_FO_I");
    c9ec:	40 17 2c    	mov.w     #0xc174, w0
    c9ee:	63 31 21    	mov.w     #0x1316, w3
    c9f0:	0c 00 09    	.pword 0x09000c
    c9f2:	b0 59 78    	mov.b     [w0++], [w3++]
    c9f4:	d0 00 b1    	sub.w     #0xd, w0
        //mlParamInterface.param[PAR_PID_PITCH_FO_I] = -0.00499999988824;   
    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_D], "PID_PIT_FO_D");
    c9f6:	10 18 2c    	mov.w     #0xc181, w0
    c9f8:	65 32 21    	mov.w     #0x1326, w5
    c9fa:	0c 00 09    	.pword 0x09000c
    c9fc:	b0 5a 78    	mov.b     [w0++], [w5++]
    c9fe:	d0 00 b1    	sub.w     #0xd, w0
        //mlParamInterface.param[PAR_PID_PITCH_FO_D] = -0.0599999986589;

    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_P], "PID_ROLL_CO_P");
    ca00:	e0 18 2c    	mov.w     #0xc18e, w0
    ca02:	61 33 21    	mov.w     #0x1336, w1
    ca04:	0d 00 09    	.pword 0x09000d
    ca06:	b0 58 78    	mov.b     [w0++], [w1++]
    ca08:	e0 00 b1    	sub.w     #0xe, w0
	mlParamInterface.param[PAR_PID_ROLL_CON_P] = 0.099;// 0.649999976158;
    ca0a:	30 08 2c    	mov.w     #0xc083, w0
    ca0c:	a1 dc 23    	mov.w     #0x3dca, w1
    ca0e:	90 93 88    	mov.w     w0, 0x1272
    ca10:	a1 93 88    	mov.w     w1, 0x1274
    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_I], "PID_ROLL_CO_I");
    ca12:	c0 19 2c    	mov.w     #0xc19c, w0
    ca14:	63 34 21    	mov.w     #0x1346, w3
    ca16:	0d 00 09    	.pword 0x09000d
    ca18:	b0 59 78    	mov.b     [w0++], [w3++]
    ca1a:	e0 00 b1    	sub.w     #0xe, w0
            mlParamInterface.param[PAR_PID_ROLL_CON_I] = 0.001;//0.00999999977648;
    ca1c:	f0 26 21    	mov.w     #0x126f, w0
    ca1e:	31 a8 23    	mov.w     #0x3a83, w1
    ca20:	b0 93 88    	mov.w     w0, 0x1276
    ca22:	c1 93 88    	mov.w     w1, 0x1278
    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_D], "PID_ROLL_CO_D");
    ca24:	a0 1a 2c    	mov.w     #0xc1aa, w0
    ca26:	65 35 21    	mov.w     #0x1356, w5
    ca28:	0d 00 09    	.pword 0x09000d
    ca2a:	b0 5a 78    	mov.b     [w0++], [w5++]
    ca2c:	e0 00 b1    	sub.w     #0xe, w0
           mlParamInterface.param[PAR_PID_ROLL_CON_D] = 0.01;//0.0599999986589;
    ca2e:	a0 70 2d    	mov.w     #0xd70a, w0
    ca30:	31 c2 23    	mov.w     #0x3c23, w1
    ca32:	d0 93 88    	mov.w     w0, 0x127a
    ca34:	e1 93 88    	mov.w     w1, 0x127c


    strcpy(mlParamInterface.param_name[PAR_PID_HE_TO_PI_P], "PID_HE2PITC_P");
    ca36:	80 1b 2c    	mov.w     #0xc1b8, w0
    ca38:	61 36 21    	mov.w     #0x1366, w1
    ca3a:	0d 00 09    	.pword 0x09000d
    ca3c:	b0 58 78    	mov.b     [w0++], [w1++]
    ca3e:	e0 00 b1    	sub.w     #0xe, w0

0000ca40 <.L0>:
                //mlParamInterface.param[PAR_PID_HE_TO_PI_P] = 0.0450000017881;

    strcpy(mlParamInterface.param_name[PAR_PID_HE_TO_PI_I], "PID_HE2PITC_I");
    ca40:	60 1c 2c    	mov.w     #0xc1c6, w0
    ca42:	63 37 21    	mov.w     #0x1376, w3
    ca44:	0d 00 09    	.pword 0x09000d
    ca46:	b0 59 78    	mov.b     [w0++], [w3++]
    ca48:	e0 00 b1    	sub.w     #0xe, w0

0000ca4a <.L0>:
                mlParamInterface.param[PAR_PID_HE_TO_PI_I] = 0;
    ca4a:	60 00 b8    	mul.uu    w0, #0x0, w0
    ca4c:	10 94 88    	mov.w     w0, 0x1282
    ca4e:	21 94 88    	mov.w     w1, 0x1284

    strcpy(mlParamInterface.param_name[PAR_PID_HEI_ERR_FF], "PID_HERR_FF");
    ca50:	42 1d 2c    	mov.w     #0xc1d4, w2
    ca52:	65 38 21    	mov.w     #0x1386, w5
    ca54:	0b 00 09    	.pword 0x09000b
    ca56:	b2 5a 78    	mov.b     [w2++], [w5++]
    ca58:	c2 00 b1    	sub.w     #0xc, w2
                //mlParamInterface.param[PAR_PID_HEI_ERR_FF] = -0.10000000149;
    strcpy(mlParamInterface.param_name[PAR_PID_PITC_DT_FF], "PID_PITC_DT_FF");
    ca5a:	02 1e 2c    	mov.w     #0xc1e0, w2
    ca5c:	63 3c 21    	mov.w     #0x13c6, w3
    ca5e:	0e 00 09    	.pword 0x09000e
    ca60:	b2 59 78    	mov.b     [w2++], [w3++]
    ca62:	f2 00 b1    	sub.w     #0xf, w2
                //mlParamInterface.param[PAR_PID_PITC_DT_FF] = 0.34999999404;

    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_P], "PID_YAW_DA_P");
    ca64:	f2 1e 2c    	mov.w     #0xc1ef, w2
    ca66:	65 39 21    	mov.w     #0x1396, w5
    ca68:	0c 00 09    	.pword 0x09000c
    ca6a:	b2 5a 78    	mov.b     [w2++], [w5++]
    ca6c:	d2 00 b1    	sub.w     #0xd, w2
	mlParamInterface.param[PAR_PID_YAW_DAMP_P] = 0.0099;// 0.00999999977648;
    ca6e:	c2 39 23    	mov.w     #0x339c, w2
    ca70:	23 c2 23    	mov.w     #0x3c22, w3
    ca72:	52 94 88    	mov.w     w2, 0x128a
    ca74:	63 94 88    	mov.w     w3, 0x128c

    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_I], "PID_YAW_DA_I");
    ca76:	c2 1f 2c    	mov.w     #0xc1fc, w2
    ca78:	63 3a 21    	mov.w     #0x13a6, w3
    ca7a:	0c 00 09    	.pword 0x09000c
    ca7c:	b2 59 78    	mov.b     [w2++], [w3++]
    ca7e:	d2 00 b1    	sub.w     #0xd, w2
                    mlParamInterface.param[PAR_PID_YAW_DAMP_I] = 0;
    ca80:	70 94 88    	mov.w     w0, 0x128e
    ca82:	81 94 88    	mov.w     w1, 0x1290

    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_D], "PID_YAW_DA_D");
    ca84:	92 20 2c    	mov.w     #0xc209, w2
    ca86:	65 3b 21    	mov.w     #0x13b6, w5
    ca88:	0c 00 09    	.pword 0x09000c
    ca8a:	b2 5a 78    	mov.b     [w2++], [w5++]
    ca8c:	d2 00 b1    	sub.w     #0xd, w2
                    mlParamInterface.param[PAR_PID_YAW_DAMP_D] = 0;
    ca8e:	90 94 88    	mov.w     w0, 0x1292
    ca90:	a1 94 88    	mov.w     w1, 0x1294

 strcpy(mlParamInterface.param_name[PAR_NAV_L2_BASE], "NAV_L2_BASE");
    ca92:	62 21 2c    	mov.w     #0xc216, w2
    ca94:	63 40 21    	mov.w     #0x1406, w3
    ca96:	0b 00 09    	.pword 0x09000b
    ca98:	b2 59 78    	mov.b     [w2++], [w3++]
    ca9a:	c2 00 b1    	sub.w     #0xc, w2
                    mlParamInterface.param[PAR_NAV_L2_BASE] =  5;
    ca9c:	02 00 20    	mov.w     #0x0, w2
    ca9e:	03 0a 24    	mov.w     #0x40a0, w3
    caa0:	32 95 88    	mov.w     w2, 0x12a6
    caa2:	43 95 88    	mov.w     w3, 0x12a8
strcpy(mlParamInterface.param_name[PAR_NAV_PRETURN_K], "NAV_PRETURN_K");
    caa4:	24 22 2c    	mov.w     #0xc222, w4
    caa6:	65 41 21    	mov.w     #0x1416, w5
    caa8:	0d 00 09    	.pword 0x09000d
    caaa:	b4 5a 78    	mov.b     [w4++], [w5++]
    caac:	e4 00 b1    	sub.w     #0xe, w4
                    mlParamInterface.param[PAR_NAV_PRETURN_K] = 5;	
    caae:	52 95 88    	mov.w     w2, 0x12aa
    cab0:	63 95 88    	mov.w     w3, 0x12ac
strcpy(mlParamInterface.param_name[PAR_NAV_SSCOMP_ON], "NAV_SSCOMP_ON");
    cab2:	04 23 2c    	mov.w     #0xc230, w4
    cab4:	65 42 21    	mov.w     #0x1426, w5
    cab6:	0d 00 09    	.pword 0x09000d
    cab8:	b4 5a 78    	mov.b     [w4++], [w5++]
    caba:	e4 00 b1    	sub.w     #0xe, w4
                    mlParamInterface.param[PAR_NAV_SSCOMP_ON] = 0;
    cabc:	70 95 88    	mov.w     w0, 0x12ae
    cabe:	81 95 88    	mov.w     w1, 0x12b0

 strcpy(mlParamInterface.param_name[PAR_L1_OMEGA], "L1_OMEGA");
    cac0:	e4 23 2c    	mov.w     #0xc23e, w4
    cac2:	65 43 21    	mov.w     #0x1436, w5
    cac4:	08 00 09    	.pword 0x090008
    cac6:	b4 5a 78    	mov.b     [w4++], [w5++]
    cac8:	94 00 b1    	sub.w     #0x9, w4
                    mlParamInterface.param[PAR_L1_OMEGA] = 0;                   
    caca:	90 95 88    	mov.w     w0, 0x12b2
    cacc:	a1 95 88    	mov.w     w1, 0x12b4
strcpy(mlParamInterface.param_name[PAR_L1_M], "L1_M");
    cace:	74 24 2c    	mov.w     #0xc247, w4
    cad0:	65 44 21    	mov.w     #0x1446, w5
    cad2:	04 00 09    	.pword 0x090004
    cad4:	b4 5a 78    	mov.b     [w4++], [w5++]
    cad6:	54 00 b1    	sub.w     #0x5, w4
                    mlParamInterface.param[PAR_L1_M] = 0; 
    cad8:	b0 95 88    	mov.w     w0, 0x12b6
    cada:	c1 95 88    	mov.w     w1, 0x12b8
strcpy(mlParamInterface.param_name[PAR_L1_GAMMA], "L1_GAMMA");
    cadc:	c4 24 2c    	mov.w     #0xc24c, w4
    cade:	65 45 21    	mov.w     #0x1456, w5
    cae0:	08 00 09    	.pword 0x090008
    cae2:	b4 5a 78    	mov.b     [w4++], [w5++]
    cae4:	94 00 b1    	sub.w     #0x9, w4
                    mlParamInterface.param[PAR_L1_GAMMA] = 0;
    cae6:	d0 95 88    	mov.w     w0, 0x12ba
    cae8:	e1 95 88    	mov.w     w1, 0x12bc
strcpy(mlParamInterface.param_name[PAR_L1_ON_OFF], "L1_ON_OFF");
    caea:	54 25 2c    	mov.w     #0xc255, w4
    caec:	65 46 21    	mov.w     #0x1466, w5
    caee:	09 00 09    	.pword 0x090009
    caf0:	b4 5a 78    	mov.b     [w4++], [w5++]
    caf2:	a4 00 b1    	sub.w     #0xa, w4
                    mlParamInterface.param[PAR_L1_ON_OFF] = 0;
    caf4:	f0 95 88    	mov.w     w0, 0x12be
    caf6:	01 96 88    	mov.w     w1, 0x12c0
strcpy(mlParamInterface.param_name[PAR_NAV_ISR_FAC], "NAV_ISR_FAC");
    caf8:	f4 25 2c    	mov.w     #0xc25f, w4
    cafa:	65 47 21    	mov.w     #0x1476, w5
    cafc:	0b 00 09    	.pword 0x09000b
    cafe:	b4 5a 78    	mov.b     [w4++], [w5++]
    cb00:	c4 00 b1    	sub.w     #0xc, w4
                    mlParamInterface.param[PAR_NAV_ISR_FAC] = 5;
    cb02:	12 96 88    	mov.w     w2, 0x12c2
    cb04:	23 96 88    	mov.w     w3, 0x12c4
strcpy(mlParamInterface.param_name[PAR_PID_RMIX_ON], "PID_RMIX_ON");
    cb06:	b2 26 2c    	mov.w     #0xc26b, w2
    cb08:	63 48 21    	mov.w     #0x1486, w3
    cb0a:	0b 00 09    	.pword 0x09000b
    cb0c:	b2 59 78    	mov.b     [w2++], [w3++]
    cb0e:	c2 00 b1    	sub.w     #0xc, w2
                    mlParamInterface.param[PAR_PID_RMIX_ON] = 1;
    cb10:	02 00 20    	mov.w     #0x0, w2
    cb12:	03 f8 23    	mov.w     #0x3f80, w3
    cb14:	32 96 88    	mov.w     w2, 0x12c6
    cb16:	43 96 88    	mov.w     w3, 0x12c8
strcpy(mlParamInterface.param_name[PAR_PID_RMIX_P], "PID_RMIX_P");
    cb18:	72 27 2c    	mov.w     #0xc277, w2
    cb1a:	65 49 21    	mov.w     #0x1496, w5
    cb1c:	0a 00 09    	.pword 0x09000a
    cb1e:	b2 5a 78    	mov.b     [w2++], [w5++]
    cb20:	b2 00 b1    	sub.w     #0xb, w2
                    mlParamInterface.param[PAR_PID_RMIX_P] = 0.4; 
    cb22:	d2 cc 2c    	mov.w     #0xcccd, w2
    cb24:	c3 ec 23    	mov.w     #0x3ecc, w3
    cb26:	52 96 88    	mov.w     w2, 0x12ca
    cb28:	63 96 88    	mov.w     w3, 0x12cc
                    
strcpy(mlParamInterface.param_name[PAR_CONFIG_ROLL_R], "CONFIG_ROLL_R");
    cb2a:	22 28 2c    	mov.w     #0xc282, w2
    cb2c:	63 3d 21    	mov.w     #0x13d6, w3
    cb2e:	0d 00 09    	.pword 0x09000d
    cb30:	b2 59 78    	mov.b     [w2++], [w3++]
    cb32:	e2 00 b1    	sub.w     #0xe, w2
    mlParamInterface.param[PAR_CONFIG_ROLL_R] = 0;
    cb34:	d0 94 88    	mov.w     w0, 0x129a
    cb36:	e1 94 88    	mov.w     w1, 0x129c
    strcpy(mlParamInterface.param_name[PAR_CONFIG_PITCH_R], "CONFIG_PITCH_R");
    cb38:	02 29 2c    	mov.w     #0xc290, w2
    cb3a:	65 3e 21    	mov.w     #0x13e6, w5
    cb3c:	0e 00 09    	.pword 0x09000e
    cb3e:	b2 5a 78    	mov.b     [w2++], [w5++]
    cb40:	f2 00 b1    	sub.w     #0xf, w2
    mlParamInterface.param[PAR_CONFIG_PITCH_R] = 0;
    cb42:	f0 94 88    	mov.w     w0, 0x129e
    cb44:	01 95 88    	mov.w     w1, 0x12a0
    strcpy(mlParamInterface.param_name[PAR_CONFIG_YAW_R], "CONFIG_YAW_R");
    cb46:	f2 29 2c    	mov.w     #0xc29f, w2
    cb48:	63 3f 21    	mov.w     #0x13f6, w3
    cb4a:	0c 00 09    	.pword 0x09000c
    cb4c:	b2 59 78    	mov.b     [w2++], [w3++]
    cb4e:	d2 00 b1    	sub.w     #0xd, w2
    mlParamInterface.param[PAR_CONFIG_YAW_R] = 0;                    
    cb50:	10 95 88    	mov.w     w0, 0x12a2
    cb52:	21 95 88    	mov.w     w1, 0x12a4
    // Populate default mid-level commands
    mlMidLevelCommands.hCommand = 120.0f; // altitude (m)
    cb54:	00 00 20    	mov.w     #0x0, w0
    cb56:	01 2f 24    	mov.w     #0x42f0, w1
    cb58:	50 89 88    	mov.w     w0, 0x112a
    cb5a:	61 89 88    	mov.w     w1, 0x112c
    mlMidLevelCommands.uCommand = 16.0f; // airspeed (m/s)
    cb5c:	00 00 20    	mov.w     #0x0, w0
    cb5e:	01 18 24    	mov.w     #0x4180, w1
    cb60:	70 89 88    	mov.w     w0, 0x112e
    cb62:	81 89 88    	mov.w     w1, 0x1130
    mlMidLevelCommands.rCommand = 0.2f; // turn rate (radians/s)
    cb64:	d0 cc 2c    	mov.w     #0xcccd, w0
    cb66:	c1 e4 23    	mov.w     #0x3e4c, w1
    cb68:	90 89 88    	mov.w     w0, 0x1132
    cb6a:	a1 89 88    	mov.w     w1, 0x1134

	 // Initialize the system Status
	 mlHeartbeatLocal.base_mode = MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
    cb6c:	01 c4 b3    	mov.b     #0x40, w1
    cb6e:	60 12 21    	mov.w     #0x1126, w0
    cb70:	01 48 78    	mov.b     w1, [w0]
	 mlHeartbeatLocal.custom_mode = SLUGS_MODE_WAYPOINT;
    cb72:	30 00 20    	mov.w     #0x3, w0
    cb74:	01 00 20    	mov.w     #0x0, w1
    cb76:	00 89 88    	mov.w     w0, 0x1120
    cb78:	11 89 88    	mov.w     w1, 0x1122
	 mlHeartbeatLocal.system_status = MAV_STATE_ACTIVE;
    cb7a:	41 c0 b3    	mov.b     #0x4, w1
    cb7c:	70 12 21    	mov.w     #0x1127, w0
    cb7e:	01 48 78    	mov.b     w1, [w0]
	/* lastNavigationMode = mlHeartbeatLocal.custom_mode;
	 mlSystemStatus.mode = MAV_MODE_MANUAL;
	 mlSystemStatus.nav_mode = MAV_NAV_WAYPOINT;
	 mlSystemStatus.status = MAV_STATE_ACTIVE;*/
	 mlSystemStatus.load = 500;
    cb80:	40 1f 20    	mov.w     #0x1f4, w0
    cb82:	10 14 8a    	mov.w     w0, 0x4282
	 mlSystemStatus.voltage_battery = 0;
    cb84:	40 28 24    	mov.w     #0x4284, w0
    cb86:	00 08 eb    	clr.w     [w0]
	 mlCameraOrder.zoom = 1;
    cb88:	11 c0 b3    	mov.b     #0x1, w1
    cb8a:	90 29 24    	mov.w     #0x4299, w0
    cb8c:	01 48 78    	mov.b     w1, [w0]

	 mlBoot.version = 1;
    cb8e:	10 00 20    	mov.w     #0x1, w0
    cb90:	01 00 20    	mov.w     #0x0, w1
    cb92:	00 0d 8a    	mov.w     w0, 0x41a0
    cb94:	11 0d 8a    	mov.w     w1, 0x41a2
	 mlMobileLocation.latitude = 36.988506f ;
    cb96:	b0 43 2f    	mov.w     #0xf43b, w0
    cb98:	31 21 24    	mov.w     #0x4213, w1
    cb9a:	30 a6 88    	mov.w     w0, 0x14c6
    cb9c:	41 a6 88    	mov.w     w1, 0x14c8
	 mlMobileLocation.longitude = -122.055308f;
    cb9e:	10 c5 21    	mov.w     #0x1c51, w0
    cba0:	41 2f 2c    	mov.w     #0xc2f4, w1
    cba2:	50 a6 88    	mov.w     w0, 0x14ca
    cba4:	61 a6 88    	mov.w     w1, 0x14cc
	 mlWpValues.lat[0] = 36.9958344;
    cba6:	c0 bb 2f    	mov.w     #0xfbbc, w0
    cba8:	31 21 24    	mov.w     #0x4213, w1
    cbaa:	c0 89 88    	mov.w     w0, 0x1138
    cbac:	d1 89 88    	mov.w     w1, 0x113a
	 mlWpValues.lat[1] = 36.9870605;
    cbae:	00 2c 2f    	mov.w     #0xf2c0, w0
    cbb0:	31 21 24    	mov.w     #0x4213, w1
    cbb2:	e0 89 88    	mov.w     w0, 0x113c
    cbb4:	f1 89 88    	mov.w     w1, 0x113e

	 mlWpValues.lon[0] = -122.065491;
    cbb6:	80 18 22    	mov.w     #0x2188, w0
    cbb8:	41 2f 2c    	mov.w     #0xc2f4, w1
    cbba:	e0 8b 88    	mov.w     w0, 0x117c
    cbbc:	f1 8b 88    	mov.w     w1, 0x117e
	 mlWpValues.lon[1] = -122.044891;
    cbbe:	c0 6f 21    	mov.w     #0x16fc, w0
    cbc0:	41 2f 2c    	mov.w     #0xc2f4, w1
    cbc2:	00 8c 88    	mov.w     w0, 0x1180
    cbc4:	11 8c 88    	mov.w     w1, 0x1182

	 mlWpValues.alt[0] = 30.0;
    cbc6:	00 00 20    	mov.w     #0x0, w0
    cbc8:	01 1f 24    	mov.w     #0x41f0, w1
    cbca:	00 8e 88    	mov.w     w0, 0x11c0
    cbcc:	11 8e 88    	mov.w     w1, 0x11c2
	 mlWpValues.alt[1] = 30.0;
    cbce:	20 8e 88    	mov.w     w0, 0x11c4
    cbd0:	31 8e 88    	mov.w     w1, 0x11c6

	 mlWpValues.type[0] = 16;
    cbd2:	00 c1 b3    	mov.b     #0x10, w0
    cbd4:	41 20 21    	mov.w     #0x1204, w1
    cbd6:	80 48 78    	mov.b     w0, [w1]
	 mlWpValues.type[1] = 16;
    cbd8:	81 00 e8    	inc.w     w1, w1
    cbda:	80 48 78    	mov.b     w0, [w1]
	 mlWpValues.wpCount = 2;
    cbdc:	21 c0 b3    	mov.b     #0x2, w1
    cbde:	80 23 21    	mov.w     #0x1238, w0
    cbe0:	01 48 78    	mov.b     w1, [w0]

}
    cbe2:	00 00 06    	return    

0000cbe4 <_protDecodeMavlink>:

void protDecodeMavlink(void) {
    cbe4:	2f 14 b0    	add.w     #0x142, w15
    cbe6:	88 9f be    	mov.d     w8, [w15++]
    cbe8:	8a 9f be    	mov.d     w10, [w15++]
    cbea:	8c 9f be    	mov.d     w12, [w15++]
    cbec:	8e 1f 78    	mov.w     w14, [w15++]

0000cbee <.L0>:

    uint8_t indx, writeSuccess, commChannel = 1;
    mavlink_param_set_t set;
    mavlink_message_t msg;
    mavlink_status_t status;
   // uint8_t* dataIn;
    // fix the data length so if the interrupt adds data
    // during execution of this block, it will be read
    // until the next gsRead
    unsigned int tmpLen = getLength(uartMavlinkInBuffer), i = 0;
    cbee:	70 12 81    	mov.w     0x224e, w0
    cbf0:	c0 0a 02    	call      0x10ac0 <_getLength>
    cbf2:	01 00 00 
    cbf4:	00 07 78    	mov.w     w0, w14

0000cbf6 <.L0>:

    // if the buffer has more data than the max size, set it to max,
    // otherwise set it to the length
    //DatafromGSmavlink[0] = (tmpLen > MAXINLEN) ? MAXINLEN : tmpLen;

    // read the data
    //for (i = 1; i <= DatafromGSmavlink[0]; i += 1) {
      //mavlink_parse_char(commChannel, readFront(uartBufferInMavlink), &msg, &status);
      //DatafromGSmavlink[i] = readFront(uartMavlinkInBuffer);
    //}
    //dataIn = DatafromGSmavlink;
    // increment the age of heartbeat
    mlPending.heartbeatAge++;
    cbf6:	00 52 22    	mov.w     #0x2520, w0
    cbf8:	10 08 e8    	inc.w     [w0], [w0]

    for (i = 0; i <= tmpLen; i++) {
    cbfa:	80 06 eb    	clr.w     w13

0000cbfc <.LBB2>:
    cbfc:	7c ec 2f    	mov.w     #0xfec7, w12
    cbfe:	0f 06 46    	add.w     w12, w15, w12

0000cc00 <.L0>:
        // Try to get a new message
       if (mavlink_parse_char(commChannel, readFront(uartMavlinkInBuffer), &msg, &status)) {
    cc00:	70 12 81    	mov.w     0x224e, w0
    cc02:	14 0b 02    	call      0x10b14 <_readFront>
    cc04:	01 00 00 
    cc06:	a3 fd 2f    	mov.w     #0xffda, w3
    cc08:	8f 81 41    	add.w     w3, w15, w3
    cc0a:	a2 ec 2f    	mov.w     #0xfeca, w2
    cc0c:	0f 01 41    	add.w     w2, w15, w2
    cc0e:	80 40 78    	mov.b     w0, w1
    cc10:	10 c0 b3    	mov.b     #0x1, w0
    cc12:	95 fd 07    	rcall     0xc73e <_mavlink_parse_char> <L0> <.LFB17> <.LFE354>
    cc14:	00 04 e0    	cp0.b     w0
    cc16:	8c 01 32    	bra       Z, 0xcf30 <.L79>

0000cc18 <.L0>:
                    // Handle message
            switch (msg.msgid) {
    cc18:	1f d0 95    	mov.b     [w15-303], w0
    cc1a:	00 80 fb    	ze        w0, w0
    cc1c:	80 00 eb    	clr.w     w1
    cc1e:	02 03 20    	mov.w     #0x30, w2
    cc20:	82 0f 50    	sub.w     w0, w2, [w15]
    cc22:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    cc24:	85 01 3e    	bra       GTU, 0xcf30 <.L79>
    cc26:	00 06 01    	.pword 0x010600
    cc28:	30 00 37    	bra       0xcc8a <.L0> <.L80>
    cc2a:	82 01 37    	bra       0xcf30 <.L79>
    cc2c:	81 01 37    	bra       0xcf30 <.L79>
    cc2e:	80 01 37    	bra       0xcf30 <.L79>
    cc30:	7f 01 37    	bra       0xcf30 <.L79>
    cc32:	7e 01 37    	bra       0xcf30 <.L79>
    cc34:	7d 01 37    	bra       0xcf30 <.L79>
    cc36:	7c 01 37    	bra       0xcf30 <.L79>
    cc38:	7b 01 37    	bra       0xcf30 <.L79>
    cc3a:	7a 01 37    	bra       0xcf30 <.L79>
    cc3c:	79 01 37    	bra       0xcf30 <.L79>
    cc3e:	78 01 37    	bra       0xcf30 <.L79>
    cc40:	77 01 37    	bra       0xcf30 <.L79>
    cc42:	76 01 37    	bra       0xcf30 <.L79>
    cc44:	75 01 37    	bra       0xcf30 <.L79>
    cc46:	74 01 37    	bra       0xcf30 <.L79>
    cc48:	73 01 37    	bra       0xcf30 <.L79>
    cc4a:	72 01 37    	bra       0xcf30 <.L79>
    cc4c:	71 01 37    	bra       0xcf30 <.L79>
    cc4e:	70 01 37    	bra       0xcf30 <.L79>
    cc50:	dd 00 37    	bra       0xce0c <.L81>
    cc52:	d4 00 37    	bra       0xcdfc <.L82>
    cc54:	6d 01 37    	bra       0xcf30 <.L79>
    cc56:	14 01 37    	bra       0xce80 <.L0> <.L83>
    cc58:	6b 01 37    	bra       0xcf30 <.L79>
    cc5a:	6a 01 37    	bra       0xcf30 <.L79>
    cc5c:	69 01 37    	bra       0xcf30 <.L79>
    cc5e:	68 01 37    	bra       0xcf30 <.L79>
    cc60:	67 01 37    	bra       0xcf30 <.L79>
    cc62:	66 01 37    	bra       0xcf30 <.L79>
    cc64:	65 01 37    	bra       0xcf30 <.L79>
    cc66:	64 01 37    	bra       0xcf30 <.L79>
    cc68:	63 01 37    	bra       0xcf30 <.L79>
    cc6a:	62 01 37    	bra       0xcf30 <.L79>
    cc6c:	61 01 37    	bra       0xcf30 <.L79>
    cc6e:	60 01 37    	bra       0xcf30 <.L79>
    cc70:	5f 01 37    	bra       0xcf30 <.L79>
    cc72:	5e 01 37    	bra       0xcf30 <.L79>
    cc74:	5d 01 37    	bra       0xcf30 <.L79>
    cc76:	5c 00 37    	bra       0xcd30 <.L0> <.L84>
    cc78:	33 00 37    	bra       0xcce0 <.L0> <.L85>
    cc7a:	5a 01 37    	bra       0xcf30 <.L79>
    cc7c:	59 01 37    	bra       0xcf30 <.L79>
    cc7e:	22 00 37    	bra       0xccc4 <.L86>
    cc80:	0b 00 37    	bra       0xcc98 <.L87>
    cc82:	86 00 37    	bra       0xcd90 <.L88>
    cc84:	55 01 37    	bra       0xcf30 <.L79>
    cc86:	40 00 37    	bra       0xcd08 <.L0> <.L89>
    cc88:	92 00 37    	bra       0xcdae <.L90>

0000cc8a <.L0>:
                case MAVLINK_MSG_ID_HEARTBEAT:
                    mavlink_msg_heartbeat_decode(&msg, &mlHeartbeat);
    cc8a:	61 46 22    	mov.w     #0x2466, w1
    cc8c:	a0 ec 2f    	mov.w     #0xfeca, w0
    cc8e:	0f 00 40    	add.w     w0, w15, w0
    cc90:	15 fe 07    	rcall     0xc8bc <_mavlink_msg_heartbeat_decode> <L0> <.LFB61> <.LFE17>

0000cc92 <.L0>:
                    // Reset the heartbeat
                    mlPending.heartbeatAge = 0;
    cc92:	00 52 22    	mov.w     #0x2520, w0
    cc94:	00 08 eb    	clr.w     [w0]
                    break;
    cc96:	4c 01 37    	bra       0xcf30 <.L79>

0000cc98 <.L87>:
//AM DBG
                case MAVLINK_MSG_ID_MISSION_COUNT:

                    if (!mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_IDLE)) {
    cc98:	f0 24 81    	mov.w     0x249e, w0
    cc9a:	00 00 e0    	cp0.w     w0
    cc9c:	49 01 3a    	bra       NZ, 0xcf30 <.L79>

0000cc9e <.L0>:


                        mavlink_msg_mission_count_decode(&msg, &mlWpCount);
    cc9e:	a1 52 22    	mov.w     #0x252a, w1
    cca0:	a0 ec 2f    	mov.w     #0xfeca, w0
    cca2:	0f 00 40    	add.w     w0, w15, w0
    cca4:	14 fe 07    	rcall     0xc8ce <_mavlink_msg_mission_count_decode> <L0> <.LFB409> <.LFE61>

0000cca6 <.L0>:

                        // Start the transaction
                        mlPending.wpTransaction = 1;
    cca6:	11 c0 b3    	mov.b     #0x1, w1
    cca8:	e0 49 22    	mov.w     #0x249e, w0
    ccaa:	01 48 78    	mov.b     w1, [w0]

                        // change the state
                        mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;
    ccac:	61 c0 b3    	mov.b     #0x6, w1
    ccae:	00 00 e8    	inc.w     w0, w0
    ccb0:	01 48 78    	mov.b     w1, [w0]

                        // reset the rest of the state machine
                        mlPending.wpTotalWps = mlWpCount.count;
    ccb2:	51 29 81    	mov.w     0x252a, w1
    ccb4:	63 00 40    	add.w     w0, #0x3, w0
    ccb6:	01 48 78    	mov.b     w1, [w0]
                        mlPending.wpCurrentWpInTransaction = 0;
    ccb8:	00 40 eb    	clr.b     w0
    ccba:	01 4a 22    	mov.w     #0x24a0, w1
    ccbc:	80 48 78    	mov.b     w0, [w1]
                        mlPending.wpTimeOut = 0;
    ccbe:	81 00 e8    	inc.w     w1, w1
    ccc0:	80 48 78    	mov.b     w0, [w1]
    ccc2:	36 01 37    	bra       0xcf30 <.L79>

0000ccc4 <.L86>:
                    }

                    break;

                case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:

                    // if there is no transaction going on
                    if (!mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_IDLE)) {
    ccc4:	f0 24 81    	mov.w     0x249e, w0
    ccc6:	00 00 e0    	cp0.w     w0
    ccc8:	33 01 3a    	bra       NZ, 0xcf30 <.L79>
                        // Start the transaction
                        mlPending.wpTransaction = 1;
    ccca:	10 c0 b3    	mov.b     #0x1, w0
    cccc:	e1 49 22    	mov.w     #0x249e, w1
    ccce:	80 48 78    	mov.b     w0, [w1]

                        // change the state
                        mlPending.wpProtState = WP_PROT_LIST_REQUESTED;
    ccd0:	81 00 e8    	inc.w     w1, w1
    ccd2:	80 48 78    	mov.b     w0, [w1]



                        // reset the rest of the state machine
                        mlPending.wpCurrentWpInTransaction = 0;
    ccd4:	00 40 eb    	clr.b     w0
    ccd6:	81 00 e8    	inc.w     w1, w1
    ccd8:	80 48 78    	mov.b     w0, [w1]
                        mlPending.wpTimeOut = 0;
    ccda:	81 00 e8    	inc.w     w1, w1
    ccdc:	80 48 78    	mov.b     w0, [w1]
    ccde:	28 01 37    	bra       0xcf30 <.L79>

0000cce0 <.L0>:
                    }
                    break;

                case MAVLINK_MSG_ID_MISSION_REQUEST:
                    mavlink_msg_mission_request_decode(&msg, &mlWpRequest);
    cce0:	21 52 22    	mov.w     #0x2522, w1
    cce2:	a0 ec 2f    	mov.w     #0xfeca, w0
    cce4:	0f 00 40    	add.w     w0, w15, w0
    cce6:	f7 fd 07    	rcall     0xc8d6 <_mavlink_msg_mission_request_decode> <L0> <.LFB380> <.LFE409>

0000cce8 <.L0>:

                    if (mlPending.wpTransaction && (mlWpRequest.seq < mlWpValues.wpCount)) {
    cce8:	e0 49 22    	mov.w     #0x249e, w0
    ccea:	10 04 e0    	cp0.b     [w0]
    ccec:	21 01 32    	bra       Z, 0xcf30 <.L79>
    ccee:	10 29 81    	mov.w     0x2522, w0
    ccf0:	81 23 21    	mov.w     #0x1238, w1
    ccf2:	91 80 fb    	ze        [w1], w1
    ccf4:	81 0f 50    	sub.w     w0, w1, [w15]
    ccf6:	1c 01 31    	bra       C, 0xcf30 <.L79>
                        // change the state
                        mlPending.wpProtState = WP_PROT_TX_WP;
    ccf8:	32 c0 b3    	mov.b     #0x3, w2
    ccfa:	f1 49 22    	mov.w     #0x249f, w1
    ccfc:	82 48 78    	mov.b     w2, [w1]

                        // reset the rest of the state machine
                        mlPending.wpCurrentWpInTransaction = mlWpRequest.seq;
    ccfe:	81 00 e8    	inc.w     w1, w1
    cd00:	80 48 78    	mov.b     w0, [w1]
                        mlPending.wpTimeOut = 0;
    cd02:	01 00 e8    	inc.w     w1, w0
    cd04:	00 48 eb    	clr.b     [w0]
    cd06:	14 01 37    	bra       0xcf30 <.L79>

0000cd08 <.L0>:
                    } else {
                        // TODO: put here a report for a single WP, i.e. not inside a transaction
                    }
                    break;

                case MAVLINK_MSG_ID_MISSION_ACK:
                    mavlink_msg_mission_ack_decode(&msg, &mlWpAck);
    cd08:	61 52 22    	mov.w     #0x2526, w1
    cd0a:	a0 ec 2f    	mov.w     #0xfeca, w0
    cd0c:	0f 00 40    	add.w     w0, w15, w0
    cd0e:	e7 fd 07    	rcall     0xc8de <_mavlink_msg_mission_ack_decode> <L0> <.LFB430> <.LFE380>

0000cd10 <.L0>:

                    if (mlPending.wpTransaction) {
    cd10:	e0 49 22    	mov.w     #0x249e, w0
    cd12:	10 04 e0    	cp0.b     [w0]
    cd14:	0d 01 32    	bra       Z, 0xcf30 <.L79>
                        // End the transaction
                        mlPending.wpTransaction = 0;
    cd16:	00 40 eb    	clr.b     w0
    cd18:	e1 49 22    	mov.w     #0x249e, w1
    cd1a:	80 48 78    	mov.b     w0, [w1]

                        // change the state
                        mlPending.wpProtState = WP_PROT_IDLE;
    cd1c:	81 00 e8    	inc.w     w1, w1
    cd1e:	80 48 78    	mov.b     w0, [w1]

                        // reset the rest of the state machine
                        mlPending.wpCurrentWpInTransaction = 0;
    cd20:	81 00 e8    	inc.w     w1, w1
    cd22:	80 48 78    	mov.b     w0, [w1]
                        mlPending.wpTimeOut = 0;
    cd24:	81 00 e8    	inc.w     w1, w1
    cd26:	80 48 78    	mov.b     w0, [w1]

                        // send current waypoint index
                        mlPending.wpSendCurrent = TRUE;
    cd28:	11 c0 b3    	mov.b     #0x1, w1
    cd2a:	30 4a 22    	mov.w     #0x24a3, w0
    cd2c:	01 48 78    	mov.b     w1, [w0]
    cd2e:	00 01 37    	bra       0xcf30 <.L79>

0000cd30 <.L0>:
                    }

                    break;

                case MAVLINK_MSG_ID_MISSION_ITEM:
                    writeSuccess = SUCCESS;
                    mavlink_msg_mission_item_decode(&msg, &mlSingleWp);
    cd30:	01 47 22    	mov.w     #0x2470, w1
    cd32:	a0 ec 2f    	mov.w     #0xfeca, w0
    cd34:	0f 00 40    	add.w     w0, w15, w0
    cd36:	da fd 07    	rcall     0xc8ec <_mavlink_msg_mission_item_decode> <L0> <.LFB372> <.LFE430>

0000cd38 <.L0>:

                    if (mlPending.wpTransaction && (mlPending.wpProtState == WP_PROT_RX_WP)) {
    cd38:	e0 49 22    	mov.w     #0x249e, w0
    cd3a:	10 04 e0    	cp0.b     [w0]
    cd3c:	06 00 32    	bra       Z, 0xcd4a <.L92>
    cd3e:	00 00 e8    	inc.w     w0, w0
    cd40:	44 c0 b3    	mov.b     #0x4, w4
    cd42:	90 4f 12    	subr.b    w4, [w0], [w15]
    cd44:	02 00 3a    	bra       NZ, 0xcd4a <.L92>
                        mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;
    cd46:	61 c0 b3    	mov.b     #0x6, w1
    cd48:	01 48 78    	mov.b     w1, [w0]

0000cd4a <.L92>:

                    }

                    indx = (uint8_t) mlSingleWp.seq;
    cd4a:	60 24 81    	mov.w     0x248c, w0

                    mlWpValues.lat[indx] = mlSingleWp.x;
    cd4c:	00 80 fb    	ze        w0, w0
    cd4e:	81 13 21    	mov.w     #0x1138, w1
    cd50:	42 01 dd    	sl.w      w0, #0x2, w2
    cd52:	02 81 40    	add.w     w1, w2, w2
    cd54:	04 24 81    	mov.w     0x2480, w4
    cd56:	15 24 81    	mov.w     0x2482, w5
    cd58:	04 89 be    	mov.d     w4, [w2]
                    mlWpValues.lon[indx] = mlSingleWp.y;
    cd5a:	71 01 40    	add.w     w0, #0x11, w2
    cd5c:	42 11 dd    	sl.w      w2, #0x2, w2
    cd5e:	02 81 40    	add.w     w1, w2, w2
    cd60:	24 24 81    	mov.w     0x2484, w4
    cd62:	35 24 81    	mov.w     0x2486, w5
    cd64:	04 89 be    	mov.d     w4, [w2]
                    mlWpValues.alt[indx] = mlSingleWp.z;
    cd66:	22 02 20    	mov.w     #0x22, w2
    cd68:	00 01 41    	add.w     w2, w0, w2
    cd6a:	42 11 dd    	sl.w      w2, #0x2, w2
    cd6c:	02 81 40    	add.w     w1, w2, w2
    cd6e:	44 24 81    	mov.w     0x2488, w4
    cd70:	55 24 81    	mov.w     0x248a, w5
    cd72:	04 89 be    	mov.d     w4, [w2]

                    mlWpValues.type[indx] = mlSingleWp.command;
    cd74:	c2 0c 20    	mov.w     #0xcc, w2
    cd76:	01 01 41    	add.w     w2, w1, w2
    cd78:	00 01 41    	add.w     w2, w0, w2
    cd7a:	73 24 81    	mov.w     0x248e, w3
    cd7c:	03 49 78    	mov.b     w3, [w2]

0000cd7e <.L0>:

                    mlWpValues.orbit[indx] = (uint16_t) mlSingleWp.param3;
    cd7e:	f0 06 b0    	add.w     #0x6f, w0
    cd80:	00 00 40    	add.w     w0, w0, w0
    cd82:	00 84 40    	add.w     w1, w0, w8
    cd84:	c0 23 81    	mov.w     0x2478, w0
    cd86:	d1 23 81    	mov.w     0x247a, w1
    cd88:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    cd8a:	00 00 00 
    cd8c:	00 0c 78    	mov.w     w0, [w8]

0000cd8e <.L0>:
/*
                    // Record the data in EEPROM
                    writeSuccess = storeWaypointInEeprom(&mlSingleWp);

                    // Set the flag of Aknowledge for the AKN Message
                    // if the write was not successful
                    if (writeSuccess != SUCCESS) {
                        mlPending.wpAck++;

                        mlWpAck.target_component = MAV_COMP_ID_MISSIONPLANNER;
                        mlWpAck.type = MAV_MISSION_ERROR;

                    }
*/
                    break;
    cd8e:	d0 00 37    	bra       0xcf30 <.L79>

0000cd90 <.L88>:

                case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:

                    writeSuccess = SUCCESS;

                    // clear the WP values in memory;
                    memset(&mlWpValues, 0, sizeof (mavlink_mission_item_values_t));
    cd90:	85 13 21    	mov.w     #0x1138, w5
    cd92:	80 00 09    	.pword 0x090080
    cd94:	80 1a eb    	clr.w     [w5++]
/*
                    writeSuccess = clearWaypointsFrom(0);

                    // Set the flag of Aknowledge fail
                    // if the write was unsuccessful
                    if (writeSuccess != SUCCESS) {
                        mlPending.statustext++;

                        mlStatustext.severity = MAV_SEVERITY_ERROR;
                        strncpy(mlStatustext.text, "Failed to clear waypoints from EEPROM.", 49);

                    }
  */

                    // Update the waypoint count
                    mlWpValues.wpCount = 0;

                    // Set the state machine ready to send the WP akn
                    mlPending.wpCurrentWpInTransaction = 0;
    cd96:	00 40 eb    	clr.b     w0
    cd98:	01 4a 22    	mov.w     #0x24a0, w1
    cd9a:	80 48 78    	mov.b     w0, [w1]
                    mlPending.wpTotalWps = 0;
    cd9c:	81 80 e8    	inc2.w    w1, w1
    cd9e:	80 48 78    	mov.b     w0, [w1]
                    mlPending.wpTransaction = 1;
    cda0:	11 c0 b3    	mov.b     #0x1, w1
    cda2:	e0 49 22    	mov.w     #0x249e, w0
    cda4:	01 48 78    	mov.b     w1, [w0]
                    mlPending.wpProtState = WP_PROT_GETTING_WP_IDLE;
    cda6:	61 c0 b3    	mov.b     #0x6, w1
    cda8:	00 00 e8    	inc.w     w0, w0
    cdaa:	01 48 78    	mov.b     w1, [w0]

                    break;
    cdac:	c1 00 37    	bra       0xcf30 <.L79>

0000cdae <.L90>:

                case MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN:
                    writeSuccess = SUCCESS;

                    memset(&mlSingleWp, 0, sizeof (mavlink_mission_item_t));
    cdae:	00 47 22    	mov.w     #0x2470, w0
    cdb0:	12 00 09    	.pword 0x090012
    cdb2:	00 18 eb    	clr.w     [w0++]

0000cdb4 <.L0>:

                    mavlink_msg_set_gps_global_origin_decode(&msg, &mlGSLocation);
    cdb4:	81 45 22    	mov.w     #0x2458, w1
    cdb6:	a0 ec 2f    	mov.w     #0xfeca, w0
    cdb8:	0f 00 40    	add.w     w0, w15, w0
    cdba:	9e fd 07    	rcall     0xc8f8 <_mavlink_msg_set_gps_global_origin_decode> <L0> <.LFB439> <.LFE372>

0000cdbc <.L0>:

                    mlSingleWp.x = (float) (mlGSLocation.latitude);
    cdbc:	c0 22 81    	mov.w     0x2458, w0
    cdbe:	d1 22 81    	mov.w     0x245a, w1
    cdc0:	0c 19 02    	call      0x190c <___floatsisf>
    cdc2:	00 00 00 
    cdc4:	00 04 be    	mov.d     w0, w8
    cdc6:	00 24 89    	mov.w     w0, 0x2480
    cdc8:	11 24 89    	mov.w     w1, 0x2482

0000cdca <.L0>:
                    mlSingleWp.y = (float) (mlGSLocation.longitude);
    cdca:	e0 22 81    	mov.w     0x245c, w0
    cdcc:	f1 22 81    	mov.w     0x245e, w1
    cdce:	0c 19 02    	call      0x190c <___floatsisf>
    cdd0:	00 00 00 
    cdd2:	00 05 be    	mov.d     w0, w10
    cdd4:	20 24 89    	mov.w     w0, 0x2484
    cdd6:	31 24 89    	mov.w     w1, 0x2486

0000cdd8 <.L0>:
                    mlSingleWp.z = (float) (mlGSLocation.altitude);
    cdd8:	00 23 81    	mov.w     0x2460, w0
    cdda:	11 23 81    	mov.w     0x2462, w1
    cddc:	0c 19 02    	call      0x190c <___floatsisf>
    cdde:	00 00 00 
    cde0:	40 24 89    	mov.w     w0, 0x2488
    cde2:	51 24 89    	mov.w     w1, 0x248a

0000cde4 <.L0>:

                    indx = (uint8_t) MAX_NUM_WPS - 1;

                    mlWpValues.lat[indx] = mlSingleWp.x;
    cde4:	c8 8b 88    	mov.w     w8, 0x1178
    cde6:	d9 8b 88    	mov.w     w9, 0x117a
                    mlWpValues.lon[indx] = mlSingleWp.y;
    cde8:	ea 8d 88    	mov.w     w10, 0x11bc
    cdea:	fb 8d 88    	mov.w     w11, 0x11be
                    mlWpValues.alt[indx] = mlSingleWp.z;
    cdec:	00 90 88    	mov.w     w0, 0x1200
    cdee:	11 90 88    	mov.w     w1, 0x1202
                    mlWpValues.type[indx] = MAV_CMD_NAV_LAND;
    cdf0:	51 c1 b3    	mov.b     #0x15, w1
    cdf2:	40 21 21    	mov.w     #0x1214, w0
    cdf4:	01 48 78    	mov.b     w1, [w0]
                    mlWpValues.orbit[indx] = 0;
    cdf6:	20 02 b0    	add.w     #0x22, w0
    cdf8:	00 08 eb    	clr.w     [w0]

                    // Record the data in EEPROM
                    /*
                    writeSuccess = storeWaypointInEeprom(&mlSingleWp);

                    if (writeSuccess != SUCCESS) {
                        mlPending.statustext++;

                        mlStatustext.severity = MAV_SEVERITY_ERROR;
                        strncpy(mlStatustext.text, "Failed to write origin to EEPROM.", 49);
                    }
                    else {

                        mlPending.statustext++;

                        mlStatustext.severity = MAV_SEVERITY_INFO;
                        strncpy(mlStatustext.text, "Control DSC GPS origin set.", 49);
                    }
                     */
                    break;
    cdfa:	9a 00 37    	bra       0xcf30 <.L79>

0000cdfc <.L82>:

//AM DBG
                case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
                    mlPending.piTransaction = 1;
    cdfc:	10 c0 b3    	mov.b     #0x1, w0
    cdfe:	61 4a 22    	mov.w     #0x24a6, w1
    ce00:	80 48 78    	mov.b     w0, [w1]
                    mlPending.piProtState = PI_SEND_ALL_PARAM;
    ce02:	81 00 e8    	inc.w     w1, w1
    ce04:	80 48 78    	mov.b     w0, [w1]
                    mlPending.piCurrentParamInTransaction = 0;
    ce06:	01 00 e8    	inc.w     w1, w0
    ce08:	00 48 eb    	clr.b     [w0]
                    break;
    ce0a:	92 00 37    	bra       0xcf30 <.L79>

0000ce0c <.L81>:

                case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
                    // If it was in the middle of a list transmission or there is already a param enqueued
                    mlPending.piTransaction = 1;
    ce0c:	10 c0 b3    	mov.b     #0x1, w0
    ce0e:	62 4a 22    	mov.w     #0x24a6, w2
    ce10:	00 49 78    	mov.b     w0, [w2]
                    switch (mlPending.piProtState) {
    ce12:	02 00 e8    	inc.w     w2, w0
    ce14:	10 40 78    	mov.b     [w0], w0
    ce16:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    ce18:	11 00 32    	bra       Z, 0xce3c <.L94>
    ce1a:	03 00 39    	bra       NC, 0xce22 <.L93>
    ce1c:	e2 4f 50    	sub.b     w0, #0x2, [w15]
    ce1e:	88 00 3a    	bra       NZ, 0xcf30 <.L79>
    ce20:	1e 00 37    	bra       0xce5e <.L107>

0000ce22 <.L93>:
                        case PI_IDLE:
                            mlPending.piBackToList = 0; // no need to go back
    ce22:	90 4a 22    	mov.w     #0x24a9, w0
    ce24:	00 48 eb    	clr.b     [w0]
                            mlPending.piQIdx = -1; // no Index
    ce26:	66 00 40    	add.w     w0, #0x6, w0
    ce28:	00 c8 eb    	setm.b    [w0]

0000ce2a <.L0>:
                            mlPending.piCurrentParamInTransaction = mavlink_msg_param_request_read_get_param_index(&msg); // assign directly
    ce2a:	a0 ec 2f    	mov.w     #0xfeca, w0
    ce2c:	0f 00 40    	add.w     w0, w15, w0
    ce2e:	fc f9 07    	rcall     0xc228 <_mavlink_msg_param_request_read_get_param_index> <L0> <.L0> <.LFB134> <.LFE33>
    ce30:	81 4a 22    	mov.w     #0x24a8, w1
    ce32:	80 48 78    	mov.b     w0, [w1]

0000ce34 <.L0>:
                            mlPending.piProtState = PI_SEND_ONE_PARAM;
    ce34:	21 c0 b3    	mov.b     #0x2, w1
    ce36:	70 4a 22    	mov.w     #0x24a7, w0
    ce38:	01 48 78    	mov.b     w1, [w0]
                            break;
    ce3a:	7a 00 37    	bra       0xcf30 <.L79>

0000ce3c <.L94>:

                        case PI_SEND_ALL_PARAM:
                            mlPending.piBackToList = 1; // mark to go back
    ce3c:	11 c0 b3    	mov.b     #0x1, w1
    ce3e:	90 4a 22    	mov.w     #0x24a9, w0
    ce40:	01 48 78    	mov.b     w1, [w0]
                            mlPending.piQIdx++; // done like this because when empty index = -1
    ce42:	66 00 40    	add.w     w0, #0x6, w0
    ce44:	10 44 e8    	inc.b     [w0], w8
    ce46:	08 48 78    	mov.b     w8, [w0]

0000ce48 <.L0>:
                            mlPending.piQueue[mlPending.piQIdx] = mavlink_msg_param_request_read_get_param_index(&msg); // put in in queue
    ce48:	a0 ec 2f    	mov.w     #0xfeca, w0
    ce4a:	0f 00 40    	add.w     w0, w15, w0
    ce4c:	ed f9 07    	rcall     0xc228 <_mavlink_msg_param_request_read_get_param_index> <L0> <.L0> <.LFB134> <.LFE33>
    ce4e:	08 04 fb    	se        w8, w8
    ce50:	a1 4a 22    	mov.w     #0x24aa, w1
    ce52:	88 80 40    	add.w     w1, w8, w1
    ce54:	80 48 78    	mov.b     w0, [w1]

0000ce56 <.L0>:
                            mlPending.piProtState = PI_SEND_ONE_PARAM;
    ce56:	21 c0 b3    	mov.b     #0x2, w1
    ce58:	70 4a 22    	mov.w     #0x24a7, w0
    ce5a:	01 48 78    	mov.b     w1, [w0]
                            break;
    ce5c:	69 00 37    	bra       0xcf30 <.L79>

0000ce5e <.L107>:

                        case PI_SEND_ONE_PARAM:
                            if (mlPending.piBackToList) {
    ce5e:	90 4a 22    	mov.w     #0x24a9, w0
    ce60:	10 04 e0    	cp0.b     [w0]
    ce62:	0a 00 32    	bra       Z, 0xce78 <.L0> <.L96>
                                mlPending.piQIdx++; // done like this because when empty index = -1
    ce64:	66 00 40    	add.w     w0, #0x6, w0
    ce66:	10 44 e8    	inc.b     [w0], w8
    ce68:	08 48 78    	mov.b     w8, [w0]

0000ce6a <.L0>:
                                mlPending.piQueue[mlPending.piQIdx] = mavlink_msg_param_request_read_get_param_index(&msg); // put in in queue
    ce6a:	a0 ec 2f    	mov.w     #0xfeca, w0
    ce6c:	0f 00 40    	add.w     w0, w15, w0
    ce6e:	dc f9 07    	rcall     0xc228 <_mavlink_msg_param_request_read_get_param_index> <L0> <.L0> <.LFB134> <.LFE33>
    ce70:	08 04 fb    	se        w8, w8
    ce72:	a1 4a 22    	mov.w     #0x24aa, w1
    ce74:	88 80 40    	add.w     w1, w8, w1
    ce76:	80 48 78    	mov.b     w0, [w1]

0000ce78 <.L0>:
                            }
                            mlPending.piProtState = PI_SEND_ONE_PARAM;
    ce78:	21 c0 b3    	mov.b     #0x2, w1
    ce7a:	70 4a 22    	mov.w     #0x24a7, w0
    ce7c:	01 48 78    	mov.b     w1, [w0]
                            break;
    ce7e:	58 00 37    	bra       0xcf30 <.L79>

0000ce80 <.L0>:
                    }
                    break;

                case MAVLINK_MSG_ID_PARAM_SET:
                    mavlink_msg_param_set_decode(&msg, &set);
    ce80:	21 eb 2f    	mov.w     #0xfeb2, w1
    ce82:	8f 80 40    	add.w     w1, w15, w1
    ce84:	a0 ec 2f    	mov.w     #0xfeca, w0
    ce86:	0f 00 40    	add.w     w0, w15, w0
    ce88:	3d fd 07    	rcall     0xc904 <_mavlink_msg_param_set_decode> <L0> <.LFB162> <.LFE439>

0000ce8a <.L0>:

                    if ((uint8_t) set.target_system == (uint8_t) SYSTEMID &&
    ce8a:	50 16 20    	mov.w     #0x165, w0
    ce8c:	bf 98 96    	mov.w     [w15-330], w1
    ce8e:	80 8f 50    	sub.w     w1, w0, [w15]
    ce90:	4f 00 3a    	bra       NZ, 0xcf30 <.L79>
                        (uint8_t) set.target_component == (uint8_t) COMPID) {


                        char* key = (char*) set.param_id;
                        uint8_t i, j;
                        uint8_t match;
                        for (i = 0; i < PAR_PARAM_COUNT; i++) {
                            match = 1;
                            for (j = 0; j < PARAM_NAME_LENGTH; j++) {
                                // Compare
                                if (((char) (mlParamInterface.param_name[i][j]))
                                    != (char) (key[j])) {
                                    match = 0;
                                } // if

                                // End matching if null termination is reached
                                if (((char) mlParamInterface.param_name[i][j]) == '\0') {
                                    break;
                                } // if
                            }// for j

                            // Check if matched
                            if (match) {
                                //sw_debug = 1;
                                // Only write and emit changes if there is actually a difference
                                // AND only write if new value is NOT "not-a-number"
                                // AND is NOT infinity

                                if (isFinite(set.param_value)) {
    ce92:	1f 9c 96    	mov.w     [w15-334], w8
    ce94:	af 9c 96    	mov.w     [w15-332], w9
    ce96:	64 4a 22    	mov.w     #0x24a6, w4
    ce98:	14 42 78    	mov.b     [w4], w4
    ce9a:	d4 ef 9f    	mov.b     w4, [w15-19]
    ce9c:	70 4a 22    	mov.w     #0x24a7, w0
    ce9e:	10 40 78    	mov.b     [w0], w0
    cea0:	c0 ef 9f    	mov.b     w0, [w15-20]
    cea2:	80 4a 22    	mov.w     #0x24a8, w0
    cea4:	10 40 78    	mov.b     [w0], w0
    cea6:	e0 ef 9f    	mov.b     w0, [w15-18]
    cea8:	90 4a 22    	mov.w     #0x24a9, w0
    ceaa:	10 40 78    	mov.b     [w0], w0
    ceac:	f0 ef 9f    	mov.b     w0, [w15-17]
    ceae:	f0 4a 22    	mov.w     #0x24af, w0
    ceb0:	10 40 78    	mov.b     [w0], w0
    ceb2:	80 f7 9f    	mov.b     w0, [w15-16]
    ceb4:	80 05 eb    	clr.w     w11
    ceb6:	00 45 eb    	clr.b     w10
    ceb8:	8e 02 78    	mov.w     w14, w5
    ceba:	d5 b7 9f    	mov.w     w5, [w15-22]
    cebc:	cd b7 9f    	mov.w     w13, [w15-24]
    cebe:	4f ef 97    	mov.b     [w15-20], w14
    cec0:	1d 00 37    	bra       0xcefc <.L97>

0000cec2 <.L100>:
    cec2:	d2 40 78    	mov.b     [++w2], w1
    cec4:	d0 cf 50    	sub.b     w1, [++w0], [w15]
    cec6:	01 00 32    	bra       Z, 0xceca <.L98>
    cec8:	8a 41 78    	mov.b     w10, w3

0000ceca <.L98>:
    ceca:	01 04 e0    	cp0.b     w1
    cecc:	02 00 32    	bra       Z, 0xced2 <.L99>
    cece:	8c 0f 50    	sub.w     w0, w12, [w15]
    ced0:	f8 ff 3a    	bra       NZ, 0xcec2 <.L100>

0000ced2 <.L99>:
    ced2:	03 04 e0    	cp0.b     w3
    ced4:	10 00 32    	bra       Z, 0xcef6 <.L101>

0000ced6 <.L0>:
    ced6:	08 00 be    	mov.d     w8, w0
    ced8:	4b fd 07    	rcall     0xc970 <_isFinite> <L0> <.LFB1467> <.LFE1466>
    ceda:	00 04 e0    	cp0.b     w0
    cedc:	0c 00 32    	bra       Z, 0xcef6 <.L101>

0000cede <.L0>:

                                    mlParamInterface.param[i] = set.param_value;
    cede:	c2 6e dd    	sl.w      w13, #0x2, w13
    cee0:	a0 25 21    	mov.w     #0x125a, w0
    cee2:	8d 06 40    	add.w     w0, w13, w13
    cee4:	88 8e be    	mov.d     w8, [w13]
    cee6:	eb ef 9f    	mov.b     w11, [w15-18]

                                    // Report back new value
                                    mlPending.piBackToList = 0; // no need to go back
                                    mlPending.piQIdx = -1; // no Index
    cee8:	00 c1 eb    	setm.b    w2
    ceea:	82 f7 9f    	mov.b     w2, [w15-16]
    ceec:	00 42 eb    	clr.b     w4
    ceee:	f4 ef 9f    	mov.b     w4, [w15-17]
                                    mlPending.piCurrentParamInTransaction = i; // assign directly
                                    mlPending.piProtState = PI_SEND_ONE_PARAM;
    cef0:	2e c0 b3    	mov.b     #0x2, w14
                                    mlPending.piTransaction = 1;
    cef2:	15 c0 b3    	mov.b     #0x1, w5
    cef4:	d5 ef 9f    	mov.b     w5, [w15-19]

0000cef6 <.L101>:
    cef6:	8b 05 e8    	inc.w     w11, w11
    cef8:	ff 8f 55    	sub.w     w11, #0x1f, [w15]
    cefa:	09 00 32    	bra       Z, 0xcf0e <.L102>

0000cefc <.L97>:
    cefc:	8b 06 78    	mov.w     w11, w13
    cefe:	44 59 dd    	sl.w      w11, #0x4, w2
    cf00:	b2 07 b0    	add.w     #0x7b, w2
    cf02:	a0 25 21    	mov.w     #0x125a, w0
    cf04:	00 01 41    	add.w     w2, w0, w2
    cf06:	70 eb 2f    	mov.w     #0xfeb7, w0
    cf08:	0f 00 40    	add.w     w0, w15, w0
    cf0a:	13 c0 b3    	mov.b     #0x1, w3
    cf0c:	da ff 37    	bra       0xcec2 <.L100>

0000cf0e <.L102>:
    cf0e:	cf b6 97    	mov.w     [w15-24], w13
    cf10:	8e 40 78    	mov.b     w14, w1
    cf12:	5f b7 97    	mov.w     [w15-22], w14
    cf14:	5f ea 97    	mov.b     [w15-19], w4
    cf16:	62 4a 22    	mov.w     #0x24a6, w2
    cf18:	04 49 78    	mov.b     w4, [w2]
    cf1a:	02 00 e8    	inc.w     w2, w0
    cf1c:	01 48 78    	mov.b     w1, [w0]
    cf1e:	00 00 e8    	inc.w     w0, w0
    cf20:	ef ea 97    	mov.b     [w15-18], w5
    cf22:	05 48 78    	mov.b     w5, [w0]
    cf24:	00 00 e8    	inc.w     w0, w0
    cf26:	ff e8 97    	mov.b     [w15-17], w1
    cf28:	01 48 78    	mov.b     w1, [w0]
    cf2a:	66 00 40    	add.w     w0, #0x6, w0
    cf2c:	0f f1 97    	mov.b     [w15-16], w2
    cf2e:	02 48 78    	mov.b     w2, [w0]

0000cf30 <.L79>:
    cf30:	8d 06 e8    	inc.w     w13, w13
    cf32:	8d 0f 57    	sub.w     w14, w13, [w15]
    cf34:	65 fe 31    	bra       C, 0xcc00 <.L0> <.L103> <.LBE2>

                                } // if different and not nan and not inf
                            } // if match
                        }// for i
                    } // if addressed to this
                    break;
              default:
                break;
            }
       }
    }
}
    cf36:	4f 07 78    	mov.w     [--w15], w14
    cf38:	4f 06 be    	mov.d     [--w15], w12
    cf3a:	4f 05 be    	mov.d     [--w15], w10
    cf3c:	4f 04 be    	mov.d     [--w15], w8
    cf3e:	2f 14 b1    	sub.w     #0x142, w15
    cf40:	00 00 06    	return    

0000cf42 <_ParameterInterfaceResponse>:
uint16_t MissionInterfaceResponse(uint8_t system_id, uint8_t component_id){
  mavlink_message_t msg;
  uint16_t bytes2Send = 0;
  uint8_t CopyMsgToBuff = 0;
  char vr_message[50];
  if (mlPending.wpProtState == WP_PROT_TX_WP) { //SLUGS Nav DBG info
    memset(vr_message, 0, sizeof (vr_message));
    sprintf(vr_message, "%d: y =%2.2f x =%2.2f z =%2.2f o =%d  t =%d", mlPending.wpCurrentWpInTransaction, (double)mlWpValues.lat[mlPending.wpCurrentWpInTransaction],
        (double)mlWpValues.lon[mlPending.wpCurrentWpInTransaction],
        (double)mlWpValues.alt[mlPending.wpCurrentWpInTransaction],
        mlWpValues.orbit[mlPending.wpCurrentWpInTransaction],
        mlWpValues.type[mlPending.wpCurrentWpInTransaction]);
    bytes2Send += sendQGCDebugMessage(vr_message, 0, UartOutBuff, bytes2Send + 1);
  }
  //if (mlPending.wpProtState == WP_PROT_GETTING_WP_IDLE) { //SLUGS Nav DBG info
  //    memset(vr_message, 0, sizeof (vr_message));
  //    sprintf(vr_message, "com = %d, tb =%2.2f ta = %2.2f", sw_intTemp, (double)fl_temp1, (double)fl_temp2);
  //    bytes2Send += sendQGCDebugMessage(vr_message, 0, UartOutBuff, bytes2Send + 1);

  //}

  // Current mission item (1 off indexing issue in qgc vs et)
  if (mlPending.wpSendCurrent) { //--DBG TODO AM implement with nav implamntation
      memset(&msg, 0, sizeof (mavlink_message_t));
      mavlink_msg_mission_current_pack(system_id,
          component_id,
          &msg, ((uint16_t)mlNavigation.toWP) - 1);
      bytes2Send += mavlink_msg_to_send_buffer((UartOutBuff + 1 + bytes2Send), &msg);
      mlPending.wpSendCurrent = FALSE;
  }

  // clear the msg
  memset(&msg, 0, sizeof (mavlink_message_t));
  //if (mlPending.wpTransaction){ //DBG
    CopyMsgToBuff = 1; //Set send msg flag - if nothing to send the switch statement will reset this
    switch (mlPending.wpProtState) { 
        case WP_PROT_LIST_REQUESTED:

            //mlPending.statustext++;
            //mlStatustext.severity = MAV_SEVERITY_INFO;
            //strncpy(mlStatustext.text, "Got mission list request. Sending count...", 49);

            mavlink_msg_mission_count_pack(system_id,
                MAV_COMP_ID_MISSIONPLANNER,
                &msg,
                GS_SYSTEMID,
                GS_COMPID,
                mlWpValues.wpCount);

            // Change the state machine state
            mlPending.wpProtState = WP_PROT_NUM_SENT;

            // Reset the timeout
            mlPending.wpTimeOut = 0;
            bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
            break;

        case WP_PROT_GETTING_WP_IDLE:
            if (mlPending.wpCurrentWpInTransaction < mlPending.wpTotalWps) {

                mavlink_msg_mission_request_pack(system_id,
                    MAV_COMP_ID_MISSIONPLANNER,
                    &msg,
                    GS_SYSTEMID,
                    GS_COMPID,
                    mlPending.wpCurrentWpInTransaction++);

                // Change the state machine state
                mlPending.wpProtState = WP_PROT_RX_WP;

            } else {
                mavlink_msg_mission_ack_pack(system_id,
                    MAV_COMP_ID_MISSIONPLANNER,
                    &msg,
                    GS_SYSTEMID,
                    GS_COMPID,
                    MAV_MISSION_ACCEPTED); // 0 is success

                // Update the waypoint count
                mlWpValues.wpCount = mlPending.wpTotalWps;

                // End the transaction
                mlPending.wpTransaction = 0;
                mlPending.wpProtState = WP_PROT_IDLE;
                mlPending.wpCurrentWpInTransaction = 0;
                mlPending.wpTotalWps = 0;
                mlPending.wpSendCurrent = TRUE; // send current waypoint index

                // put zeros in the rest of the waypoints;
                //clearWaypointsFrom(mlWpValues.wpCount); //this clears the EEPROM WP storage

            }
            bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
            // Reset the timeout            
            mlPending.wpTimeOut = 0;
            break;

        case WP_PROT_TX_WP:
            //mlPending.statustext++;
            //mlStatustext.severity = MAV_SEVERITY_INFO;
            //strncpy(mlStatustext.text, "Sending waypoint.", 25);


            // Send WP
            mavlink_msg_mission_item_pack(system_id,
                MAV_COMP_ID_MISSIONPLANNER,
                &msg,
                GS_SYSTEMID,
                GS_COMPID,
                mlPending.wpCurrentWpInTransaction,
                MAV_FRAME_GLOBAL,
                mlWpValues.type[mlPending.wpCurrentWpInTransaction],
                0, // not current
                1, // autocontinue
                0.0, // Param 1 not used
                0.0, // Param 2 not used
                (float) mlWpValues.orbit[mlPending.wpCurrentWpInTransaction],
                0.0, // Param 4 not used
                mlWpValues.lat[mlPending.wpCurrentWpInTransaction],
                mlWpValues.lon[mlPending.wpCurrentWpInTransaction],
                mlWpValues.alt[mlPending.wpCurrentWpInTransaction]); // always autocontinue

            // Switch the state waiting for the next request
            // Change the state machine state
            mlPending.wpProtState = WP_PROT_SENDING_WP_IDLE;
            bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
            // Reset the timeout
            mlPending.wpTimeOut = 0;
            break;
      default:
         CopyMsgToBuff = 0;
         break;
    } // switch wpProtState
//    if (CopyMsgToBuff) // Copy the message to the send buffer
//      bytes2Send += mavlink_msg_to_send_buffer((UartOutBuff + 1 + bytes2Send), &msg);

  //}//if DBG
  mlPending.wpTimeOut++;

  // if Timed out reset the state machine and send an error
  if (mlPending.wpTimeOut > PROTOCOL_TIMEOUT_TICKS) {
      memset(&msg, 0, sizeof (mavlink_message_t));

      mavlink_msg_mission_ack_pack(system_id,
          MAV_COMP_ID_MISSIONPLANNER,
          &msg,
          GS_SYSTEMID,
          GS_COMPID,
          1); // 1 is failure

      // Copy the message to the send buffer
      bytes2Send += mavlink_msg_to_send_buffer((UartOutBuff + 1 + bytes2Send), &msg);

      // reset the state machine
      mlPending.wpTransaction = 0;
      mlPending.wpProtState = WP_PROT_IDLE;
      mlPending.wpCurrentWpInTransaction = 0;
      mlPending.wpTimeOut = 0;
      mlPending.wpTotalWps = 0;
  }
  return(bytes2Send);
}

uint16_t ParameterInterfaceResponse(uint8_t system_id, uint8_t component_id){
    cf42:	10 01 fa    	lnk       #0x110
    cf44:	88 1f 78    	mov.w     w8, [w15++]
  mavlink_message_t msg;
  uint16_t bytes2Send = 0;
    cf46:	00 01 eb    	clr.w     w2
  if (mlPending.piTransaction){
    cf48:	63 4a 22    	mov.w     #0x24a6, w3
    cf4a:	13 04 e0    	cp0.b     [w3]
    cf4c:	76 00 32    	bra       Z, 0xd03a <.L109>

    switch (mlPending.piProtState) {
    cf4e:	03 01 e8    	inc.w     w3, w2
    cf50:	12 41 78    	mov.b     [w2], w2
    cf52:	e1 4f 51    	sub.b     w2, #0x1, [w15]
    cf54:	03 00 32    	bra       Z, 0xcf5c <.L110>
    cf56:	e2 4f 51    	sub.b     w2, #0x2, [w15]
    cf58:	6f 00 3a    	bra       NZ, 0xd038 <.L117>
    cf5a:	29 00 37    	bra       0xcfae <.L118>

0000cf5c <.L110>:
      case PI_SEND_ALL_PARAM:
          if (mlPending.piCurrentParamInTransaction < PAR_PARAM_COUNT) {
    cf5c:	82 4a 22    	mov.w     #0x24a8, w2
    cf5e:	12 41 78    	mov.b     [w2], w2
    cf60:	fe 4f 51    	sub.b     w2, #0x1e, [w15]
    cf62:	17 00 3e    	bra       GTU, 0xcf92 <.L0> <.L112>

              mavlink_msg_param_value_pack(system_id,
    cf64:	02 82 fb    	ze        w2, w4
    cf66:	42 21 dd    	sl.w      w4, #0x2, w2
    cf68:	a3 25 21    	mov.w     #0x125a, w3
    cf6a:	82 81 41    	add.w     w3, w2, w3
                  component_id,
                  &msg,
                  mlParamInterface.param_name[mlPending.piCurrentParamInTransaction],
    cf6c:	44 21 dd    	sl.w      w4, #0x4, w2

0000cf6e <.L0>:
    cf6e:	84 1f 78    	mov.w     w4, [w15++]
    cf70:	f7 01 20    	mov.w     #0x1f, w7
    cf72:	96 c0 b3    	mov.b     #0x9, w6
    cf74:	13 02 be    	mov.d     [w3], w4
    cf76:	63 2d 21    	mov.w     #0x12d6, w3
    cf78:	82 81 41    	add.w     w3, w2, w3
    cf7a:	c2 ee 2f    	mov.w     #0xfeec, w2
    cf7c:	0f 01 41    	add.w     w2, w15, w2
    cf7e:	82 fb 07    	rcall     0xc684 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE51>

0000cf80 <.L0>:
                  mlParamInterface.param[mlPending.piCurrentParamInTransaction],
                  MAV_PARAM_TYPE_REAL32, // TODO: make sure this is correct later on
                  PAR_PARAM_COUNT,
                  mlPending.piCurrentParamInTransaction);

              mlPending.piCurrentParamInTransaction++;
    cf80:	80 4a 22    	mov.w     #0x24a8, w0
    cf82:	10 48 e8    	inc.b     [w0], [w0]

0000cf84 <.L0>:

              // Copy the message to the send buffer
              bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
    cf84:	c1 ee 2f    	mov.w     #0xfeec, w1
    cf86:	8f 80 40    	add.w     w1, w15, w1
    cf88:	e0 52 22    	mov.w     #0x252e, w0
    cf8a:	fd fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    cf8c:	00 01 78    	mov.w     w0, w2
    cf8e:	8f 87 e9    	dec2.w    w15, w15
    cf90:	54 00 37    	bra       0xd03a <.L109>

0000cf92 <.L0>:

          } else {
              mlPending.piProtState = PI_IDLE;
    cf92:	00 40 eb    	clr.b     w0
    cf94:	71 4a 22    	mov.w     #0x24a7, w1
    cf96:	80 48 78    	mov.b     w0, [w1]
              mlPending.piCurrentParamInTransaction = PAR_PARAM_COUNT;
    cf98:	f2 c1 b3    	mov.b     #0x1f, w2
    cf9a:	81 00 e8    	inc.w     w1, w1
    cf9c:	82 48 78    	mov.b     w2, [w1]
              mlPending.piTransaction = 0;
    cf9e:	81 80 e9    	dec2.w    w1, w1
    cfa0:	80 48 78    	mov.b     w0, [w1]
              mlPending.piBackToList = 0;
    cfa2:	e3 80 40    	add.w     w1, #0x3, w1
    cfa4:	80 48 78    	mov.b     w0, [w1]
              mlPending.piQIdx = -1;
    cfa6:	66 80 40    	add.w     w1, #0x6, w0
    cfa8:	00 c8 eb    	setm.b    [w0]
    cfaa:	00 01 eb    	clr.w     w2
    cfac:	46 00 37    	bra       0xd03a <.L109>

0000cfae <.L118>:
          }
          break;

      case PI_SEND_ONE_PARAM:


          if (!mlPending.piBackToList) { // if this is just a single pm read, i.e. not a retransmission
    cfae:	92 4a 22    	mov.w     #0x24a9, w2
    cfb0:	12 04 e0    	cp0.b     [w2]
    cfb2:	1d 00 3a    	bra       NZ, 0xcfee <.L113>
              mavlink_msg_param_value_pack(system_id,
                  component_id,
                  &msg,
                  mlParamInterface.param_name[mlPending.piCurrentParamInTransaction],
                  mlParamInterface.param[mlPending.piCurrentParamInTransaction],
                  MAV_PARAM_TYPE_REAL32,
                  PAR_PARAM_COUNT,
                  mlPending.piCurrentParamInTransaction);
    cfb4:	02 04 e9    	dec.w     w2, w8
    cfb6:	18 82 fb    	ze        [w8], w4
    cfb8:	42 21 dd    	sl.w      w4, #0x2, w2
    cfba:	a3 25 21    	mov.w     #0x125a, w3
    cfbc:	82 81 41    	add.w     w3, w2, w3
    cfbe:	44 21 dd    	sl.w      w4, #0x4, w2

0000cfc0 <.L0>:
    cfc0:	84 1f 78    	mov.w     w4, [w15++]
    cfc2:	f7 01 20    	mov.w     #0x1f, w7
    cfc4:	96 c0 b3    	mov.b     #0x9, w6
    cfc6:	13 02 be    	mov.d     [w3], w4
    cfc8:	63 2d 21    	mov.w     #0x12d6, w3
    cfca:	82 81 41    	add.w     w3, w2, w3
    cfcc:	c2 ee 2f    	mov.w     #0xfeec, w2
    cfce:	0f 01 41    	add.w     w2, w15, w2
    cfd0:	59 fb 07    	rcall     0xc684 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE51>

0000cfd2 <.L0>:

              // Copy the message to the send buffer
              bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
    cfd2:	c1 ee 2f    	mov.w     #0xfeec, w1
    cfd4:	8f 80 40    	add.w     w1, w15, w1
    cfd6:	e0 52 22    	mov.w     #0x252e, w0
    cfd8:	d6 fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    cfda:	00 01 78    	mov.w     w0, w2

0000cfdc <.L0>:


              mlPending.piCurrentParamInTransaction = PAR_PARAM_COUNT;
    cfdc:	f0 c1 b3    	mov.b     #0x1f, w0
    cfde:	00 4c 78    	mov.b     w0, [w8]
              mlPending.piProtState = PI_IDLE;
    cfe0:	00 40 eb    	clr.b     w0
    cfe2:	88 00 e9    	dec.w     w8, w1
    cfe4:	80 48 78    	mov.b     w0, [w1]
              mlPending.piTransaction = 0;
    cfe6:	81 00 e9    	dec.w     w1, w1
    cfe8:	80 48 78    	mov.b     w0, [w1]
    cfea:	8f 87 e9    	dec2.w    w15, w15
    cfec:	26 00 37    	bra       0xd03a <.L109>

0000cfee <.L113>:
          } else { // you will need to go back to send all

              if (mlPending.piQIdx < 0) { // if you've sent all the requests, then go back to list
    cfee:	f2 4a 22    	mov.w     #0x24af, w2
    cff0:	12 41 78    	mov.b     [w2], w2
    cff2:	02 04 e0    	cp0.b     w2
    cff4:	07 00 3d    	bra       GE, 0xd004 <.L114>
                  mlPending.piProtState = PI_SEND_ALL_PARAM;
    cff6:	11 c0 b3    	mov.b     #0x1, w1
    cff8:	70 4a 22    	mov.w     #0x24a7, w0
    cffa:	01 48 78    	mov.b     w1, [w0]
                  mlPending.piBackToList = 0;
    cffc:	00 80 e8    	inc2.w    w0, w0
    cffe:	00 48 eb    	clr.b     [w0]
    d000:	00 01 eb    	clr.w     w2
    d002:	1b 00 37    	bra       0xd03a <.L109>

0000d004 <.L114>:

              } else { // send the requests
                  mavlink_msg_param_value_pack(system_id,
                      component_id,
                      &msg,
                      mlParamInterface.param_name[mlPending.piQueue[mlPending.piQIdx]],
                      mlParamInterface.param[mlPending.piQueue[mlPending.piQIdx]],
                      MAV_PARAM_TYPE_REAL32,
                      PAR_PARAM_COUNT,
                      mlPending.piQueue[mlPending.piQIdx]);
    d004:	02 01 fb    	se        w2, w2
    d006:	a3 4a 22    	mov.w     #0x24aa, w3
    d008:	03 01 41    	add.w     w2, w3, w2
    d00a:	12 82 fb    	ze        [w2], w4
    d00c:	42 21 dd    	sl.w      w4, #0x2, w2
    d00e:	a3 25 21    	mov.w     #0x125a, w3
    d010:	82 81 41    	add.w     w3, w2, w3
    d012:	44 21 dd    	sl.w      w4, #0x4, w2

0000d014 <.L0>:
    d014:	84 1f 78    	mov.w     w4, [w15++]
    d016:	f7 01 20    	mov.w     #0x1f, w7
    d018:	96 c0 b3    	mov.b     #0x9, w6
    d01a:	13 02 be    	mov.d     [w3], w4
    d01c:	63 2d 21    	mov.w     #0x12d6, w3
    d01e:	82 81 41    	add.w     w3, w2, w3
    d020:	c2 ee 2f    	mov.w     #0xfeec, w2
    d022:	0f 01 41    	add.w     w2, w15, w2
    d024:	2f fb 07    	rcall     0xc684 <_mavlink_msg_param_value_pack> <L0> <.LFB143> <.LFE51>

0000d026 <.L0>:

                  // Copy the message to the send buffer
                  bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
    d026:	c1 ee 2f    	mov.w     #0xfeec, w1
    d028:	8f 80 40    	add.w     w1, w15, w1
    d02a:	e0 52 22    	mov.w     #0x252e, w0
    d02c:	ac fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d02e:	00 01 78    	mov.w     w0, w2

0000d030 <.L0>:

                  // decrement the queue index
                  mlPending.piQIdx--;
    d030:	f0 4a 22    	mov.w     #0x24af, w0
    d032:	10 48 e9    	dec.b     [w0], [w0]
    d034:	8f 87 e9    	dec2.w    w15, w15
    d036:	01 00 37    	bra       0xd03a <.L109>

0000d038 <.L117>:
    d038:	00 01 eb    	clr.w     w2

0000d03a <.L109>:
              } // QIdx < 0
          }// !backToList
    }//switch
  }//if (mlPending.piTransaction)
  return(bytes2Send);
}
    d03a:	02 00 78    	mov.w     w2, w0
    d03c:	4f 04 78    	mov.w     [--w15], w8
    d03e:	00 80 fa    	ulnk      
    d040:	00 00 06    	return    

0000d042 <_PackHeartBeat>:
uint16_t PackHeartBeat(uint8_t system_id, uint8_t component_id){
    d042:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  mavlink_system.type = MAV_TYPE_FIXED_WING;   ///< This system is an airplane / fixed wing

  // Define the system type, in this case an airplane
  uint8_t system_type = MAV_TYPE_FIXED_WING;
  uint8_t autopilot_type = MAV_AUTOPILOT_GENERIC;

  uint8_t system_mode = mlHeartbeatLocal.base_mode; ///< Booting up
    d044:	62 12 21    	mov.w     #0x1126, w2
    d046:	92 42 78    	mov.b     [w2], w5
  uint32_t custom_mode = mlHeartbeatLocal.custom_mode;                 ///< Custom mode, can be defined by user/adopter
  uint8_t system_state = mlHeartbeatLocal.system_status; ///< System ready for flight
    d048:	02 01 e8    	inc.w     w2, w2
    d04a:	12 41 78    	mov.b     [w2], w2
  mavlink_message_t msg;
  uint16_t bytes2Send = 0;
  //////////////////////////////////////////////////////////////////////////
  memset(&msg, 0, sizeof (mavlink_message_t));
    d04c:	8f 01 78    	mov.w     w15, w3
    d04e:	03 11 b1    	sub.w     #0x110, w3
    d050:	87 00 09    	.pword 0x090087
    d052:	80 19 eb    	clr.w     [w3++]

0000d054 <.L0>:
  // Pack the Heartbeat message
  mavlink_msg_heartbeat_pack(mavlink_system.sysid, mavlink_system.compid, &msg, system_type, autopilot_type, system_mode, custom_mode, system_state);
    d054:	82 1f 78    	mov.w     w2, [w15++]
    d056:	06 89 80    	mov.w     0x1120, w6
    d058:	17 89 80    	mov.w     0x1122, w7
    d05a:	00 42 eb    	clr.b     w4
    d05c:	13 c0 b3    	mov.b     #0x1, w3
    d05e:	e2 ee 2f    	mov.w     #0xfeee, w2
    d060:	0f 01 41    	add.w     w2, w15, w2
    d062:	f1 fa 07    	rcall     0xc646 <_mavlink_msg_heartbeat_pack> <L0> <.LFB51> <.LFE62>

0000d064 <.L0>:
  /*
  mavlink_msg_heartbeat_pack(system_id,
                  component_id,
                  &msg,
                  MAV_TYPE_FIXED_WING,//MAV_TYPE_GENERIC,
                  MAV_AUTOPILOT_SLUGS,//MAV_AUTOPILOT_GENERIC,
                  MAV_MODE_PREFLIGHT,//mlHeartbeatLocal.base_mode,
                  MAV_MODE_PREFLIGHT,//mlHeartbeatLocal.custom_mode,
                  MAV_STATE_UNINIT//mlHeartbeatLocal.system_status
                  );
*/
  // Copy the message to the send buffer
  bytes2Send += mavlink_msg_to_send_buffer(UartOutBuff, &msg);
    d064:	e1 ee 2f    	mov.w     #0xfeee, w1
    d066:	8f 80 40    	add.w     w1, w15, w1
    d068:	e0 52 22    	mov.w     #0x252e, w0
    d06a:	8d fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d06c:	8f 87 e9    	dec2.w    w15, w15

0000d06e <.L0>:
  return(bytes2Send);
}
    d06e:	00 80 fa    	ulnk      
    d070:	00 00 06    	return    

0000d072 <_PackTextMsg>:

uint16_t PackTextMsg(uint8_t system_id, uint8_t component_id, unsigned char buf){
    d072:	42 01 fa    	lnk       #0x142
    d074:	88 9f be    	mov.d     w8, [w15++]
    d076:	80 44 78    	mov.b     w0, w9
    d078:	01 44 78    	mov.b     w1, w8
  mavlink_message_t msg;
  mavlink_system_t mavlink_system;
  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  char vr_message[50];
  memset(vr_message, 0, sizeof (vr_message));
    d07a:	0f 00 78    	mov.w     w15, w0
    d07c:	60 03 b1    	sub.w     #0x36, w0
    d07e:	18 00 09    	.pword 0x090018
    d080:	00 18 eb    	clr.w     [w0++]

0000d082 <.L0>:
  sprintf(vr_message, "buffer %d",buf);
    d082:	02 81 fb    	ze        w2, w2
    d084:	82 1f 78    	mov.w     w2, [w15++]
    d086:	c0 2a 2c    	mov.w     #0xc2ac, w0
    d088:	80 1f 78    	mov.w     w0, [w15++]
    d08a:	60 fc 2f    	mov.w     #0xffc6, w0
    d08c:	0f 00 40    	add.w     w0, w15, w0
    d08e:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    d090:	00 00 00 

0000d092 <.L0>:
  mavlink_msg_statustext_pack(mavlink_system.sysid,
    d092:	64 fc 2f    	mov.w     #0xffc6, w4
    d094:	0f 02 42    	add.w     w4, w15, w4
    d096:	80 41 eb    	clr.b     w3
    d098:	62 eb 2f    	mov.w     #0xfeb6, w2
    d09a:	0f 01 41    	add.w     w2, w15, w2
    d09c:	88 40 78    	mov.b     w8, w1
    d09e:	09 40 78    	mov.b     w9, w0
    d0a0:	55 fa 07    	rcall     0xc54c <_mavlink_msg_statustext_pack> <L0> <.LFB1246> <.LFE20>

0000d0a2 <.L0>:
  mavlink_system.compid,
  &msg,
  0,
  vr_message);
  return(mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d0a2:	61 eb 2f    	mov.w     #0xfeb6, w1
    d0a4:	8f 80 40    	add.w     w1, w15, w1
    d0a6:	e0 52 22    	mov.w     #0x252e, w0
    d0a8:	6e fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d0aa:	e4 87 57    	sub.w     w15, #0x4, w15

0000d0ac <.L0>:
}
    d0ac:	4f 04 be    	mov.d     [--w15], w8
    d0ae:	00 80 fa    	ulnk      
    d0b0:	00 00 06    	return    

0000d0b2 <_PackRawIMU>:


uint16_t PackRawIMU(uint8_t system_id, uint8_t component_id, mavlink_raw_imu_t mlRawIMUData ,uint32_t time_usec){
    d0b2:	10 01 fa    	lnk       #0x110
    d0b4:	02 02 be    	mov.d     w2, w4
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d0b6:	0f 01 78    	mov.w     w15, w2
    d0b8:	02 11 b1    	sub.w     #0x110, w2
    d0ba:	87 00 09    	.pword 0x090087
    d0bc:	00 19 eb    	clr.w     [w2++]

0000d0be <.L0>:
  mavlink_msg_raw_imu_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec , mlRawIMUData.xacc , mlRawIMUData.yacc , mlRawIMUData.zacc , mlRawIMUData.xgyro , mlRawIMUData.ygyro , mlRawIMUData.zgyro , mlRawIMUData.xmag , mlRawIMUData.ymag , mlRawIMUData.zmag );
    d0be:	4f b1 96    	mov.w     [w15-280], w2
    d0c0:	82 1f 78    	mov.w     w2, [w15++]
    d0c2:	2f b1 96    	mov.w     [w15-284], w2
    d0c4:	82 1f 78    	mov.w     w2, [w15++]
    d0c6:	0f b1 96    	mov.w     [w15-288], w2
    d0c8:	82 1f 78    	mov.w     w2, [w15++]
    d0ca:	6f a9 96    	mov.w     [w15-292], w2
    d0cc:	82 1f 78    	mov.w     w2, [w15++]
    d0ce:	4f a9 96    	mov.w     [w15-296], w2
    d0d0:	82 1f 78    	mov.w     w2, [w15++]
    d0d2:	2f a9 96    	mov.w     [w15-300], w2
    d0d4:	82 1f 78    	mov.w     w2, [w15++]
    d0d6:	0f a9 96    	mov.w     [w15-304], w2
    d0d8:	82 1f 78    	mov.w     w2, [w15++]
    d0da:	6f a1 96    	mov.w     [w15-308], w2
    d0dc:	82 1f 78    	mov.w     w2, [w15++]
    d0de:	cf a1 96    	mov.w     [w15-312], w3
    d0e0:	60 33 b8    	mul.uu    w6, #0x0, w6
    d0e2:	02 ee 2f    	mov.w     #0xfee0, w2
    d0e4:	0f 01 41    	add.w     w2, w15, w2
    d0e6:	d0 f8 07    	rcall     0xc288 <_mavlink_msg_raw_imu_pack> <L0> <.LFB204> <.LFE163>

0000d0e8 <.L0>:
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d0e8:	01 ee 2f    	mov.w     #0xfee0, w1
    d0ea:	8f 80 40    	add.w     w1, w15, w1
    d0ec:	e0 52 22    	mov.w     #0x252e, w0
    d0ee:	4b fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d0f0:	f0 87 57    	sub.w     w15, #0x10, w15

0000d0f2 <.L0>:
}
    d0f2:	00 80 fa    	ulnk      
    d0f4:	00 00 06    	return    

0000d0f6 <_PackRawAttitude>:

uint16_t PackRawAttitude(uint8_t system_id, uint8_t component_id, mavlink_attitude_t mlAttitudeData ,uint32_t time_usec){
    d0f6:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d0f8:	0f 02 78    	mov.w     w15, w4
    d0fa:	04 11 b1    	sub.w     #0x110, w4
    d0fc:	87 00 09    	.pword 0x090087
    d0fe:	00 1a eb    	clr.w     [w4++]

0000d100 <.L0>:
  mavlink_msg_attitude_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec , mlAttitudeData.roll, mlAttitudeData.pitch, mlAttitudeData.yaw, mlAttitudeData.rollspeed, mlAttitudeData.pitchspeed, mlAttitudeData.yawspeed );
    d100:	3f b2 96    	mov.w     [w15-282], w4
    d102:	cf b2 96    	mov.w     [w15-280], w5
    d104:	84 9f be    	mov.d     w4, [w15++]
    d106:	7f aa 96    	mov.w     [w15-290], w4
    d108:	8f b2 96    	mov.w     [w15-288], w5
    d10a:	84 9f be    	mov.d     w4, [w15++]
    d10c:	3f aa 96    	mov.w     [w15-298], w4
    d10e:	cf aa 96    	mov.w     [w15-296], w5
    d110:	84 9f be    	mov.d     w4, [w15++]
    d112:	7f a2 96    	mov.w     [w15-306], w4
    d114:	8f aa 96    	mov.w     [w15-304], w5
    d116:	84 9f be    	mov.d     w4, [w15++]
    d118:	3f a2 96    	mov.w     [w15-314], w4
    d11a:	cf a2 96    	mov.w     [w15-312], w5
    d11c:	84 9f be    	mov.d     w4, [w15++]
    d11e:	7f 9b 96    	mov.w     [w15-322], w6
    d120:	8f a3 96    	mov.w     [w15-320], w7
    d122:	02 02 be    	mov.d     w2, w4
    d124:	c2 ed 2f    	mov.w     #0xfedc, w2
    d126:	0f 01 41    	add.w     w2, w15, w2
    d128:	f1 f8 07    	rcall     0xc30c <_mavlink_msg_attitude_pack> <L0> <.LFB238> <.LFE229>

0000d12a <.L0>:
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d12a:	c1 ed 2f    	mov.w     #0xfedc, w1
    d12c:	8f 80 40    	add.w     w1, w15, w1
    d12e:	e0 52 22    	mov.w     #0x252e, w0
    d130:	2a fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d132:	f4 87 57    	sub.w     w15, #0x14, w15

0000d134 <.L0>:
}
    d134:	00 80 fa    	ulnk      
    d136:	00 00 06    	return    

0000d138 <_PackRawNavigation>:

uint16_t PackRawNavigation(uint8_t system_id, uint8_t component_id, mavlink_slugs_navigation_t mlNavigation, uint32_t time_usec) {
    d138:	10 01 fa    	lnk       #0x110
	mavlink_system_t mavlink_system;

	mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
	mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
										 //////////////////////////////////////////////////////////////////////////
	mavlink_message_t msg;
	memset(&msg, 0, sizeof(mavlink_message_t));
    d13a:	0f 01 78    	mov.w     w15, w2
    d13c:	02 11 b1    	sub.w     #0x110, w2
    d13e:	87 00 09    	.pword 0x090087
    d140:	00 19 eb    	clr.w     [w2++]

0000d142 <.L0>:
	mavlink_msg_slugs_navigation_pack(mavlink_system.sysid, mavlink_system.compid, &msg,
    d142:	bf b1 96    	mov.w     [w15-282], w3
    d144:	83 1f 78    	mov.w     w3, [w15++]
    d146:	7f e1 95    	mov.b     [w15-281], w2
    d148:	82 1f 78    	mov.w     w2, [w15++]
    d14a:	7f a9 96    	mov.w     [w15-290], w2
    d14c:	8f b1 96    	mov.w     [w15-288], w3
    d14e:	82 9f be    	mov.d     w2, [w15++]
    d150:	3f a9 96    	mov.w     [w15-298], w2
    d152:	cf a9 96    	mov.w     [w15-296], w3
    d154:	82 9f be    	mov.d     w2, [w15++]
    d156:	7f a1 96    	mov.w     [w15-306], w2
    d158:	8f a9 96    	mov.w     [w15-304], w3
    d15a:	82 9f be    	mov.d     w2, [w15++]
    d15c:	3f a1 96    	mov.w     [w15-314], w2
    d15e:	cf a1 96    	mov.w     [w15-312], w3
    d160:	82 9f be    	mov.d     w2, [w15++]
    d162:	7f 99 96    	mov.w     [w15-322], w2
    d164:	8f a1 96    	mov.w     [w15-320], w3
    d166:	82 9f be    	mov.d     w2, [w15++]
    d168:	8f d1 95    	mov.b     [w15-304], w3
    d16a:	3f 9b 96    	mov.w     [w15-330], w6
    d16c:	cf 9b 96    	mov.w     [w15-328], w7
    d16e:	1f 9a 96    	mov.w     [w15-334], w4
    d170:	af 9a 96    	mov.w     [w15-332], w5
    d172:	82 ed 2f    	mov.w     #0xfed8, w2
    d174:	0f 01 41    	add.w     w2, w15, w2
    d176:	b2 f9 07    	rcall     0xc4dc <_mavlink_msg_slugs_navigation_pack> <L0> <.LFB1291> <.LFE690>

0000d178 <.L0>:
		mlNavigation.u_m, mlNavigation.phi_c, mlNavigation.theta_c, mlNavigation.psiDot_c, mlNavigation.ay_body, mlNavigation.totalDist, mlNavigation.dist2Go, mlNavigation.fromWP, mlNavigation.toWP, mlNavigation.h_c);
	//mavlink_msg_command_long_pack(mavlink_system.sysid, mavlink_system.compid, &msg, mlNavigation.fromWP, mlNavigation.toWP, mlNavigation.h_c,111,
	//	mlNavigation.u_m, mlNavigation.phi_c, mlNavigation.theta_c, mlNavigation.psiDot_c, mlNavigation.ay_body, mlNavigation.totalDist, mlNavigation.dist2Go);

	return(mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d178:	81 ed 2f    	mov.w     #0xfed8, w1
    d17a:	8f 80 40    	add.w     w1, w15, w1
    d17c:	e0 52 22    	mov.w     #0x252e, w0
    d17e:	03 fa 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d180:	f8 87 57    	sub.w     w15, #0x18, w15

0000d182 <.L0>:

}
    d182:	00 80 fa    	ulnk      
    d184:	00 00 06    	return    

0000d186 <_PackPosXYZ_Sol>:

uint16_t PackPosXYZ_Sol(uint8_t system_id, uint8_t component_id, mavlink_local_position_ned_t mlLocalPositionSol ,uint32_t time_usec){
    d186:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d188:	0f 02 78    	mov.w     w15, w4
    d18a:	04 11 b1    	sub.w     #0x110, w4
    d18c:	87 00 09    	.pword 0x090087
    d18e:	00 1a eb    	clr.w     [w4++]

0000d190 <.L0>:
  mavlink_msg_local_position_ned_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec, mlLocalPositionSol.x, mlLocalPositionSol.y, mlLocalPositionSol.z, mlLocalPositionSol.vx, mlLocalPositionSol.vy, mlLocalPositionSol.vz);
    d190:	3f b2 96    	mov.w     [w15-282], w4
    d192:	cf b2 96    	mov.w     [w15-280], w5
    d194:	84 9f be    	mov.d     w4, [w15++]
    d196:	7f aa 96    	mov.w     [w15-290], w4
    d198:	8f b2 96    	mov.w     [w15-288], w5
    d19a:	84 9f be    	mov.d     w4, [w15++]
    d19c:	3f aa 96    	mov.w     [w15-298], w4
    d19e:	cf aa 96    	mov.w     [w15-296], w5
    d1a0:	84 9f be    	mov.d     w4, [w15++]
    d1a2:	7f a2 96    	mov.w     [w15-306], w4
    d1a4:	8f aa 96    	mov.w     [w15-304], w5
    d1a6:	84 9f be    	mov.d     w4, [w15++]
    d1a8:	3f a2 96    	mov.w     [w15-314], w4
    d1aa:	cf a2 96    	mov.w     [w15-312], w5
    d1ac:	84 9f be    	mov.d     w4, [w15++]
    d1ae:	7f 9b 96    	mov.w     [w15-322], w6
    d1b0:	8f a3 96    	mov.w     [w15-320], w7
    d1b2:	02 02 be    	mov.d     w2, w4
    d1b4:	c2 ed 2f    	mov.w     #0xfedc, w2
    d1b6:	0f 01 41    	add.w     w2, w15, w2
    d1b8:	d3 f8 07    	rcall     0xc360 <_mavlink_msg_local_position_ned_pack> <L0> <.LFB263> <.LFE238>

0000d1ba <.L0>:
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d1ba:	c1 ed 2f    	mov.w     #0xfedc, w1
    d1bc:	8f 80 40    	add.w     w1, w15, w1
    d1be:	e0 52 22    	mov.w     #0x252e, w0
    d1c0:	e2 f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d1c2:	f4 87 57    	sub.w     w15, #0x14, w15

0000d1c4 <.L0>:
}
    d1c4:	00 80 fa    	ulnk      
    d1c6:	00 00 06    	return    

0000d1c8 <_PackGpsRawInt>:

uint16_t PackGpsRawInt(uint8_t system_id, uint8_t component_id, mavlink_gps_raw_int_t mlRawGpsDataInt ,uint32_t time_usec){
    d1c8:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d1ca:	0f 01 78    	mov.w     w15, w2
    d1cc:	02 11 b1    	sub.w     #0x110, w2
    d1ce:	87 00 09    	.pword 0x090087
    d1d0:	00 19 eb    	clr.w     [w2++]

0000d1d2 <.L0>:
  mavlink_msg_gps_raw_int_pack(mavlink_system.sysid, mavlink_system.compid, &msg , mlRawGpsDataInt.time_usec,mlRawGpsDataInt.fix_type, mlRawGpsDataInt.lat,
    d1d2:	9f e9 95    	mov.b     [w15-279], w3
    d1d4:	83 1f 78    	mov.w     w3, [w15++]
    d1d6:	2f b1 96    	mov.w     [w15-284], w2
    d1d8:	82 1f 78    	mov.w     w2, [w15++]
    d1da:	8f b1 96    	mov.w     [w15-288], w3
    d1dc:	83 1f 78    	mov.w     w3, [w15++]
    d1de:	6f a9 96    	mov.w     [w15-292], w2
    d1e0:	82 1f 78    	mov.w     w2, [w15++]
    d1e2:	cf a9 96    	mov.w     [w15-296], w3
    d1e4:	83 1f 78    	mov.w     w3, [w15++]
    d1e6:	1f a9 96    	mov.w     [w15-302], w2
    d1e8:	af a9 96    	mov.w     [w15-300], w3
    d1ea:	82 9f be    	mov.d     w2, [w15++]
    d1ec:	5f a1 96    	mov.w     [w15-310], w2
    d1ee:	ef a1 96    	mov.w     [w15-308], w3
    d1f0:	82 9f be    	mov.d     w2, [w15++]
    d1f2:	1f a1 96    	mov.w     [w15-318], w2
    d1f4:	af a1 96    	mov.w     [w15-316], w3
    d1f6:	82 9f be    	mov.d     w2, [w15++]
    d1f8:	af d1 95    	mov.b     [w15-302], w3
    d1fa:	3f 9a 96    	mov.w     [w15-330], w4
    d1fc:	cf 9a 96    	mov.w     [w15-328], w5
    d1fe:	5f 9b 96    	mov.w     [w15-326], w6
    d200:	ef 9b 96    	mov.w     [w15-324], w7
    d202:	a2 ed 2f    	mov.w     #0xfeda, w2
    d204:	0f 01 41    	add.w     w2, w15, w2
    d206:	13 f8 07    	rcall     0xc22e <_mavlink_msg_gps_raw_int_pack> <L0> <.LFB163> <.LFE134>

0000d208 <.L0>:
          mlRawGpsDataInt.lon, mlRawGpsDataInt.alt, mlRawGpsDataInt.eph, mlRawGpsDataInt.epv, mlRawGpsDataInt.vel,
          mlRawGpsDataInt.cog, mlRawGpsDataInt.satellites_visible);
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d208:	a1 ed 2f    	mov.w     #0xfeda, w1
    d20a:	8f 80 40    	add.w     w1, w15, w1
    d20c:	e0 52 22    	mov.w     #0x252e, w0
    d20e:	bb f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d210:	f6 87 57    	sub.w     w15, #0x16, w15

0000d212 <.L0>:
}
    d212:	00 80 fa    	ulnk      
    d214:	00 00 06    	return    

0000d216 <_PackScaledPressure>:


uint16_t PackScaledPressure(uint8_t system_id, uint8_t component_id, mavlink_scaled_pressure_t mlAirData ,uint32_t time_usec){
    d216:	10 01 fa    	lnk       #0x110
    d218:	88 9f be    	mov.d     w8, [w15++]
    d21a:	80 44 78    	mov.b     w0, w9
    d21c:	01 44 78    	mov.b     w1, w8
    d21e:	02 00 be    	mov.d     w2, w0
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d220:	0f 01 78    	mov.w     w15, w2
    d222:	42 11 b1    	sub.w     #0x114, w2
    d224:	87 00 09    	.pword 0x090087
    d226:	00 19 eb    	clr.w     [w2++]

0000d228 <.L0>:
  mavlink_msg_scaled_pressure_pack(system_id, component_id, &msg,
    d228:	82 3e 20    	mov.w     #0x3e8, w2
    d22a:	03 00 20    	mov.w     #0x0, w3
    d22c:	34 1f 02    	call      0x1f34 <___udivsi3>
    d22e:	00 00 00 
    d230:	0f b1 96    	mov.w     [w15-288], w2
    d232:	9f b1 96    	mov.w     [w15-286], w3
    d234:	82 9f be    	mov.d     w2, [w15++]
    d236:	8f b1 96    	mov.w     [w15-288], w3
    d238:	4f ab 96    	mov.w     [w15-296], w6
    d23a:	df ab 96    	mov.w     [w15-294], w7
    d23c:	00 02 be    	mov.d     w0, w4
    d23e:	82 ee 2f    	mov.w     #0xfee8, w2
    d240:	0f 01 41    	add.w     w2, w15, w2
    d242:	88 40 78    	mov.b     w8, w1
    d244:	09 40 78    	mov.b     w9, w0
    d246:	47 f8 07    	rcall     0xc2d6 <_mavlink_msg_scaled_pressure_pack> <L0> <.LFB229> <.LFE204>

0000d248 <.L0>:
						       time_usec/1000, mlAirData.press_abs, mlAirData.press_diff, mlAirData.temperature);
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d248:	81 ee 2f    	mov.w     #0xfee8, w1
    d24a:	8f 80 40    	add.w     w1, w15, w1
    d24c:	e0 52 22    	mov.w     #0x252e, w0
    d24e:	9b f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d250:	e4 87 57    	sub.w     w15, #0x4, w15

0000d252 <.L0>:
}
    d252:	4f 04 be    	mov.d     [--w15], w8
    d254:	00 80 fa    	ulnk      
    d256:	00 00 06    	return    

0000d258 <_PackSysStatus>:

uint16_t PackSysStatus(uint8_t system_id, uint8_t component_id, mavlink_sys_status_t mlSysStatus){
    d258:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d25a:	0f 01 78    	mov.w     w15, w2
    d25c:	02 11 b1    	sub.w     #0x110, w2
    d25e:	87 00 09    	.pword 0x090087
    d260:	00 19 eb    	clr.w     [w2++]

0000d262 <.L0>:
  mavlink_msg_sys_status_pack(system_id, component_id, &msg,
    d262:	bf b1 96    	mov.w     [w15-282], w3
    d264:	83 1f 78    	mov.w     w3, [w15++]
    d266:	1f b1 96    	mov.w     [w15-286], w2
    d268:	82 1f 78    	mov.w     w2, [w15++]
    d26a:	ff a9 96    	mov.w     [w15-290], w3
    d26c:	83 1f 78    	mov.w     w3, [w15++]
    d26e:	5f a9 96    	mov.w     [w15-294], w2
    d270:	82 1f 78    	mov.w     w2, [w15++]
    d272:	bf a9 96    	mov.w     [w15-298], w3
    d274:	83 1f 78    	mov.w     w3, [w15++]
    d276:	1f a9 96    	mov.w     [w15-302], w2
    d278:	82 1f 78    	mov.w     w2, [w15++]
    d27a:	cf d9 95    	mov.b     [w15-292], w3
    d27c:	83 1f 78    	mov.w     w3, [w15++]
    d27e:	6f a1 96    	mov.w     [w15-308], w2
    d280:	82 1f 78    	mov.w     w2, [w15++]
    d282:	cf a1 96    	mov.w     [w15-312], w3
    d284:	83 1f 78    	mov.w     w3, [w15++]
    d286:	0f a1 96    	mov.w     [w15-320], w2
    d288:	9f a1 96    	mov.w     [w15-318], w3
    d28a:	82 9f be    	mov.d     w2, [w15++]
    d28c:	8f a1 96    	mov.w     [w15-320], w3
    d28e:	4f 9b 96    	mov.w     [w15-328], w6
    d290:	df 9b 96    	mov.w     [w15-326], w7
    d292:	2f 9a 96    	mov.w     [w15-332], w4
    d294:	bf 9a 96    	mov.w     [w15-330], w5
    d296:	a2 ed 2f    	mov.w     #0xfeda, w2
    d298:	0f 01 41    	add.w     w2, w15, w2
    d29a:	a6 f9 07    	rcall     0xc5e8 <_mavlink_msg_sys_status_pack> <L0> <.LFB62> <.LFE321>

0000d29c <.L0>:
						       mlSysStatus.onboard_control_sensors_present,mlSysStatus.onboard_control_sensors_enabled, mlSysStatus.onboard_control_sensors_health,
                   mlSysStatus.load, mlSysStatus.voltage_battery, mlSysStatus.current_battery,
                   mlSysStatus.battery_remaining, mlSysStatus.drop_rate_comm, mlSysStatus.errors_comm,
                   mlSysStatus.errors_count1, mlSysStatus.errors_count2, mlSysStatus.errors_count3, mlSysStatus.errors_count4);
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d29c:	a1 ed 2f    	mov.w     #0xfeda, w1
    d29e:	8f 80 40    	add.w     w1, w15, w1
    d2a0:	e0 52 22    	mov.w     #0x252e, w0
    d2a2:	71 f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d2a4:	f6 87 57    	sub.w     w15, #0x16, w15

0000d2a6 <.L0>:
}
    d2a6:	00 80 fa    	ulnk      
    d2a8:	00 00 06    	return    

0000d2aa <_PackRawServo>:
uint16_t PackRawServo(uint8_t system_id, uint8_t component_id, mavlink_servo_output_raw_t mlPwmCommands ,uint32_t time_usec){
    d2aa:	10 01 fa    	lnk       #0x110
    d2ac:	02 02 be    	mov.d     w2, w4
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d2ae:	0f 01 78    	mov.w     w15, w2
    d2b0:	02 11 b1    	sub.w     #0x110, w2
    d2b2:	87 00 09    	.pword 0x090087
    d2b4:	00 19 eb    	clr.w     [w2++]

0000d2b6 <.L0>:
  mavlink_msg_servo_output_raw_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec , mlPwmCommands.port, mlPwmCommands.servo1_raw, mlPwmCommands.servo2_raw, mlPwmCommands.servo3_raw, mlPwmCommands.servo4_raw, mlPwmCommands.servo5_raw, mlPwmCommands.servo6_raw, mlPwmCommands.servo7_raw, mlPwmCommands.servo8_raw );
    d2b6:	3f b1 96    	mov.w     [w15-282], w2
    d2b8:	82 1f 78    	mov.w     w2, [w15++]
    d2ba:	1f b1 96    	mov.w     [w15-286], w2
    d2bc:	82 1f 78    	mov.w     w2, [w15++]
    d2be:	7f a9 96    	mov.w     [w15-290], w2
    d2c0:	82 1f 78    	mov.w     w2, [w15++]
    d2c2:	5f a9 96    	mov.w     [w15-294], w2
    d2c4:	82 1f 78    	mov.w     w2, [w15++]
    d2c6:	3f a9 96    	mov.w     [w15-298], w2
    d2c8:	82 1f 78    	mov.w     w2, [w15++]
    d2ca:	1f a9 96    	mov.w     [w15-302], w2
    d2cc:	82 1f 78    	mov.w     w2, [w15++]
    d2ce:	ff a3 96    	mov.w     [w15-306], w7
    d2d0:	6f a3 96    	mov.w     [w15-308], w6
    d2d2:	cf d9 95    	mov.b     [w15-292], w3
    d2d4:	42 ee 2f    	mov.w     #0xfee4, w2
    d2d6:	0f 01 41    	add.w     w2, w15, w2
    d2d8:	63 f9 07    	rcall     0xc5a0 <_mavlink_msg_servo_output_raw_pack> <L0> <.LFB321> <.LFE14>

0000d2da <.L0>:
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d2da:	41 ee 2f    	mov.w     #0xfee4, w1
    d2dc:	8f 80 40    	add.w     w1, w15, w1
    d2de:	e0 52 22    	mov.w     #0x252e, w0
    d2e0:	52 f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d2e2:	ec 87 57    	sub.w     w15, #0xc, w15

0000d2e4 <.L0>:
}
    d2e4:	00 80 fa    	ulnk      
    d2e6:	00 00 06    	return    

0000d2e8 <_HIL_PackRawServo>:

uint16_t HIL_PackRawServo(uint8_t system_id, uint8_t component_id, mavlink_servo_output_raw_t mlPwmCommands ,uint32_t time_usec){
    d2e8:	10 01 fa    	lnk       #0x110
    d2ea:	02 02 be    	mov.d     w2, w4
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d2ec:	0f 01 78    	mov.w     w15, w2
    d2ee:	02 11 b1    	sub.w     #0x110, w2
    d2f0:	87 00 09    	.pword 0x090087
    d2f2:	00 19 eb    	clr.w     [w2++]

0000d2f4 <.L0>:
  mavlink_msg_servo_output_raw_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec , mlPwmCommands.port, mlPwmCommands.servo1_raw, mlPwmCommands.servo2_raw, mlPwmCommands.servo3_raw, mlPwmCommands.servo4_raw, mlPwmCommands.servo5_raw, mlPwmCommands.servo6_raw, mlPwmCommands.servo7_raw, mlPwmCommands.servo8_raw );
    d2f4:	3f b1 96    	mov.w     [w15-282], w2
    d2f6:	82 1f 78    	mov.w     w2, [w15++]
    d2f8:	1f b1 96    	mov.w     [w15-286], w2
    d2fa:	82 1f 78    	mov.w     w2, [w15++]
    d2fc:	7f a9 96    	mov.w     [w15-290], w2
    d2fe:	82 1f 78    	mov.w     w2, [w15++]
    d300:	5f a9 96    	mov.w     [w15-294], w2
    d302:	82 1f 78    	mov.w     w2, [w15++]
    d304:	3f a9 96    	mov.w     [w15-298], w2
    d306:	82 1f 78    	mov.w     w2, [w15++]
    d308:	1f a9 96    	mov.w     [w15-302], w2
    d30a:	82 1f 78    	mov.w     w2, [w15++]
    d30c:	ff a3 96    	mov.w     [w15-306], w7
    d30e:	6f a3 96    	mov.w     [w15-308], w6
    d310:	cf d9 95    	mov.b     [w15-292], w3
    d312:	42 ee 2f    	mov.w     #0xfee4, w2
    d314:	0f 01 41    	add.w     w2, w15, w2
    d316:	44 f9 07    	rcall     0xc5a0 <_mavlink_msg_servo_output_raw_pack> <L0> <.LFB321> <.LFE14>

0000d318 <.L0>:
  return( mavlink_msg_to_send_buffer(Uart4OutBuff, &msg));
    d318:	41 ee 2f    	mov.w     #0xfee4, w1
    d31a:	8f 80 40    	add.w     w1, w15, w1
    d31c:	50 63 22    	mov.w     #0x2635, w0
    d31e:	33 f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d320:	ec 87 57    	sub.w     w15, #0xc, w15

0000d322 <.L0>:
}
    d322:	00 80 fa    	ulnk      
    d324:	00 00 06    	return    

0000d326 <_PackRawRC>:

uint16_t PackRawRC(uint8_t system_id, uint8_t component_id, mavlink_rc_channels_raw_t mlRC_Commands ,uint32_t time_usec){
    d326:	10 01 fa    	lnk       #0x110
    d328:	02 02 be    	mov.d     w2, w4
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d32a:	0f 01 78    	mov.w     w15, w2
    d32c:	02 11 b1    	sub.w     #0x110, w2
    d32e:	87 00 09    	.pword 0x090087
    d330:	00 19 eb    	clr.w     [w2++]

0000d332 <.L0>:
  mavlink_msg_rc_channels_raw_pack(mavlink_system.sysid, mavlink_system.compid, &msg , time_usec , mlRC_Commands.port, mlRC_Commands.chan1_raw, mlRC_Commands.chan2_raw, mlRC_Commands.chan3_raw, mlRC_Commands.chan4_raw, mlRC_Commands.chan5_raw, mlRC_Commands.chan6_raw, mlRC_Commands.chan7_raw, mlRC_Commands.chan8_raw,mlRC_Commands.rssi );
    d332:	1f e9 95    	mov.b     [w15-279], w2
    d334:	82 1f 78    	mov.w     w2, [w15++]
    d336:	2f b1 96    	mov.w     [w15-284], w2
    d338:	82 1f 78    	mov.w     w2, [w15++]
    d33a:	0f b1 96    	mov.w     [w15-288], w2
    d33c:	82 1f 78    	mov.w     w2, [w15++]
    d33e:	6f a9 96    	mov.w     [w15-292], w2
    d340:	82 1f 78    	mov.w     w2, [w15++]
    d342:	4f a9 96    	mov.w     [w15-296], w2
    d344:	82 1f 78    	mov.w     w2, [w15++]
    d346:	2f a9 96    	mov.w     [w15-300], w2
    d348:	82 1f 78    	mov.w     w2, [w15++]
    d34a:	0f a9 96    	mov.w     [w15-304], w2
    d34c:	82 1f 78    	mov.w     w2, [w15++]
    d34e:	ef a3 96    	mov.w     [w15-308], w7
    d350:	5f a3 96    	mov.w     [w15-310], w6
    d352:	af d9 95    	mov.b     [w15-294], w3
    d354:	22 ee 2f    	mov.w     #0xfee2, w2
    d356:	0f 01 41    	add.w     w2, w15, w2
    d358:	2d f8 07    	rcall     0xc3b4 <_mavlink_msg_rc_channels_raw_pack> <L0> <.LFB305> <.LFE263>

0000d35a <.L0>:
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d35a:	21 ee 2f    	mov.w     #0xfee2, w1
    d35c:	8f 80 40    	add.w     w1, w15, w1
    d35e:	e0 52 22    	mov.w     #0x252e, w0
    d360:	12 f9 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d362:	ee 87 57    	sub.w     w15, #0xe, w15

0000d364 <.L0>:
}
    d364:	00 80 fa    	ulnk      
    d366:	00 00 06    	return    

0000d368 <_PackVFR_HUD>:

uint16_t PackVFR_HUD(uint8_t system_id, uint8_t component_id, mavlink_vfr_hud_t mlVfr_hud ,uint32_t time_usec){
    d368:	10 01 fa    	lnk       #0x110
  mavlink_system_t mavlink_system;

  mavlink_system.sysid = system_id;                   ///< ID 20 for this airplane
  mavlink_system.compid = component_id;//MAV_COMP_ID_IMU;     ///< The component sending the message is the IMU, it could be also a Linux process
  //////////////////////////////////////////////////////////////////////////
  mavlink_message_t msg;
  memset(&msg, 0, sizeof (mavlink_message_t));
    d36a:	0f 01 78    	mov.w     w15, w2
    d36c:	02 11 b1    	sub.w     #0x110, w2
    d36e:	87 00 09    	.pword 0x090087
    d370:	00 19 eb    	clr.w     [w2++]

0000d372 <.L0>:
  mavlink_msg_vfr_hud_pack(mavlink_system.sysid, mavlink_system.compid, &msg , mlVfr_hud.airspeed, mlVfr_hud.groundspeed, mlVfr_hud.heading, mlVfr_hud.throttle, mlVfr_hud.alt, mlVfr_hud.climb );
    d372:	1f b1 96    	mov.w     [w15-286], w2
    d374:	af b1 96    	mov.w     [w15-284], w3
    d376:	82 9f be    	mov.d     w2, [w15++]
    d378:	5f a9 96    	mov.w     [w15-294], w2
    d37a:	ef a9 96    	mov.w     [w15-292], w3
    d37c:	82 9f be    	mov.d     w2, [w15++]
    d37e:	8f b1 96    	mov.w     [w15-288], w3
    d380:	83 1f 78    	mov.w     w3, [w15++]
    d382:	ef a9 96    	mov.w     [w15-292], w3
    d384:	0f ab 96    	mov.w     [w15-304], w6
    d386:	9f ab 96    	mov.w     [w15-302], w7
    d388:	6f a2 96    	mov.w     [w15-308], w4
    d38a:	ff a2 96    	mov.w     [w15-306], w5
    d38c:	62 ee 2f    	mov.w     #0xfee6, w2
    d38e:	0f 01 41    	add.w     w2, w15, w2
    d390:	84 f8 07    	rcall     0xc49a <_mavlink_msg_vfr_hud_pack> <L0> <.LFB690> <.LFE423>

0000d392 <.L0>:
                                                                                
  return( mavlink_msg_to_send_buffer(UartOutBuff, &msg));
    d392:	61 ee 2f    	mov.w     #0xfee6, w1
    d394:	8f 80 40    	add.w     w1, w15, w1
    d396:	e0 52 22    	mov.w     #0x252e, w0
    d398:	f6 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d39a:	ea 87 57    	sub.w     w15, #0xa, w15

0000d39c <.L0>:
}
    d39c:	00 80 fa    	ulnk      
    d39e:	00 00 06    	return    

0000d3a0 <_sendQGCDebugMessage>:

char sendQGCDebugMessage(const char * dbgMessage, char severity, unsigned char* bytesToAdd, char positionStart) {
    d3a0:	10 01 fa    	lnk       #0x110
    d3a2:	00 02 78    	mov.w     w0, w4

0000d3a4 <.L0>:
    mavlink_message_t msg;
    unsigned char bytes2Send = 0; // size in bytes of the mavlink packed message (return value)

    mavlink_msg_statustext_pack(101,
    d3a4:	81 41 78    	mov.b     w1, w3
    d3a6:	02 ef 2f    	mov.w     #0xfef0, w2
    d3a8:	0f 01 41    	add.w     w2, w15, w2
    d3aa:	11 c0 b3    	mov.b     #0x1, w1
    d3ac:	50 c6 b3    	mov.b     #0x65, w0
    d3ae:	ce f8 07    	rcall     0xc54c <_mavlink_msg_statustext_pack> <L0> <.LFB1246> <.LFE20>

0000d3b0 <.L0>:
        1,
        &msg,
        severity,
        dbgMessage);

    bytes2Send = mavlink_msg_to_send_buffer(UartOutBuff, &msg);
    d3b0:	01 ef 2f    	mov.w     #0xfef0, w1
    d3b2:	8f 80 40    	add.w     w1, w15, w1
    d3b4:	e0 52 22    	mov.w     #0x252e, w0
    d3b6:	e7 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>

0000d3b8 <.L0>:

    return bytes2Send;
}
    d3b8:	00 80 fa    	ulnk      
    d3ba:	00 00 06    	return    

0000d3bc <_MissionInterfaceResponse>:
    d3bc:	4f 14 b0    	add.w     #0x144, w15
    d3be:	88 9f be    	mov.d     w8, [w15++]
    d3c0:	8a 9f be    	mov.d     w10, [w15++]
    d3c2:	8c 9f be    	mov.d     w12, [w15++]
    d3c4:	8e 1f 78    	mov.w     w14, [w15++]
    d3c6:	80 44 78    	mov.b     w0, w9
    d3c8:	01 45 78    	mov.b     w1, w10
    d3ca:	00 04 eb    	clr.w     w8
    d3cc:	f0 49 22    	mov.w     #0x249f, w0
    d3ce:	31 c0 b3    	mov.b     #0x3, w1
    d3d0:	90 cf 10    	subr.b    w1, [w0], [w15]
    d3d2:	2f 00 3a    	bra       NZ, 0xd432 <.L0> <.L134>
    d3d4:	0f 01 78    	mov.w     w15, w2
    d3d6:	02 04 b1    	sub.w     #0x40, w2
    d3d8:	18 00 09    	.pword 0x090018
    d3da:	00 19 eb    	clr.w     [w2++]
    d3dc:	00 00 e8    	inc.w     w0, w0
    d3de:	10 80 fb    	ze        [w0], w0
    d3e0:	c2 0c 20    	mov.w     #0xcc, w2
    d3e2:	00 01 41    	add.w     w2, w0, w2
    d3e4:	81 13 21    	mov.w     #0x1138, w1
    d3e6:	02 81 40    	add.w     w1, w2, w2
    d3e8:	12 81 fb    	ze        [w2], w2
    d3ea:	82 1f 78    	mov.w     w2, [w15++]
    d3ec:	f2 06 20    	mov.w     #0x6f, w2
    d3ee:	00 01 41    	add.w     w2, w0, w2
    d3f0:	02 01 41    	add.w     w2, w2, w2
    d3f2:	02 81 40    	add.w     w1, w2, w2
    d3f4:	92 1f 78    	mov.w     [w2], [w15++]
    d3f6:	22 02 20    	mov.w     #0x22, w2
    d3f8:	00 01 41    	add.w     w2, w0, w2
    d3fa:	42 11 dd    	sl.w      w2, #0x2, w2
    d3fc:	02 81 40    	add.w     w1, w2, w2
    d3fe:	12 02 be    	mov.d     [w2], w4
    d400:	84 9f be    	mov.d     w4, [w15++]
    d402:	71 01 40    	add.w     w0, #0x11, w2
    d404:	42 11 dd    	sl.w      w2, #0x2, w2
    d406:	02 81 40    	add.w     w1, w2, w2

0000d408 <.L0>:
    d408:	12 02 be    	mov.d     [w2], w4
    d40a:	84 9f be    	mov.d     w4, [w15++]
    d40c:	42 01 dd    	sl.w      w0, #0x2, w2
    d40e:	82 80 40    	add.w     w1, w2, w1
    d410:	11 01 be    	mov.d     [w1], w2
    d412:	82 9f be    	mov.d     w2, [w15++]
    d414:	80 1f 78    	mov.w     w0, [w15++]
    d416:	60 2b 2c    	mov.w     #0xc2b6, w0
    d418:	80 1f 78    	mov.w     w0, [w15++]
    d41a:	c0 fa 2f    	mov.w     #0xffac, w0
    d41c:	0f 00 40    	add.w     w0, w15, w0
    d41e:	26 24 02    	call      0x2426 <__sprintf_cdfFnopsuxX>
    d420:	00 00 00 

0000d422 <.L0>:
    d422:	13 c0 b3    	mov.b     #0x1, w3
    d424:	e2 52 22    	mov.w     #0x252e, w2
    d426:	80 40 eb    	clr.b     w1
    d428:	c0 fa 2f    	mov.w     #0xffac, w0
    d42a:	0f 00 40    	add.w     w0, w15, w0
    d42c:	b9 ff 07    	rcall     0xd3a0 <_sendQGCDebugMessage> <L0> <.LFB1485> <.LFE1484>
    d42e:	00 04 fb    	se        w0, w8
    d430:	f4 87 57    	sub.w     w15, #0x14, w15

0000d432 <.L0>:
    d432:	30 4a 22    	mov.w     #0x24a3, w0
    d434:	10 04 e0    	cp0.b     [w0]
    d436:	14 00 32    	bra       Z, 0xd460 <.L135>
    d438:	8f 01 78    	mov.w     w15, w3
    d43a:	03 15 b1    	sub.w     #0x150, w3
    d43c:	87 00 09    	.pword 0x090087
    d43e:	80 19 eb    	clr.w     [w3++]
    d440:	90 25 21    	mov.w     #0x1259, w0
    d442:	90 81 fb    	ze        [w0], w3

0000d444 <.L0>:
    d444:	83 01 e9    	dec.w     w3, w3
    d446:	02 eb 2f    	mov.w     #0xfeb0, w2
    d448:	0f 01 41    	add.w     w2, w15, w2
    d44a:	8a 40 78    	mov.b     w10, w1
    d44c:	09 40 78    	mov.b     w9, w0
    d44e:	ee f7 07    	rcall     0xc42c <_mavlink_msg_mission_current_pack> <L0> <.LFB389> <.LFE373>

0000d450 <.L0>:
    d450:	f0 52 22    	mov.w     #0x252f, w0
    d452:	00 00 44    	add.w     w8, w0, w0
    d454:	01 eb 2f    	mov.w     #0xfeb0, w1
    d456:	8f 80 40    	add.w     w1, w15, w1
    d458:	96 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d45a:	00 04 44    	add.w     w8, w0, w8

0000d45c <.L0>:
    d45c:	30 4a 22    	mov.w     #0x24a3, w0
    d45e:	00 48 eb    	clr.b     [w0]

0000d460 <.L135>:
    d460:	0f 02 78    	mov.w     w15, w4
    d462:	04 15 b1    	sub.w     #0x150, w4
    d464:	87 00 09    	.pword 0x090087
    d466:	00 1a eb    	clr.w     [w4++]
    d468:	f0 49 22    	mov.w     #0x249f, w0
    d46a:	10 40 78    	mov.b     [w0], w0
    d46c:	e3 4f 50    	sub.b     w0, #0x3, [w15]
    d46e:	49 00 32    	bra       Z, 0xd502 <.L138>
    d470:	e6 4f 50    	sub.b     w0, #0x6, [w15]
    d472:	16 00 32    	bra       Z, 0xd4a0 <.L139>
    d474:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    d476:	82 00 3a    	bra       NZ, 0xd57c <.L136>

0000d478 <.L0>:
    d478:	80 23 21    	mov.w     #0x1238, w0
    d47a:	90 82 fb    	ze        [w0], w5
    d47c:	00 42 eb    	clr.b     w4
    d47e:	f3 c7 b3    	mov.b     #0x7f, w3
    d480:	02 eb 2f    	mov.w     #0xfeb0, w2
    d482:	0f 01 41    	add.w     w2, w15, w2
    d484:	e1 cb b3    	mov.b     #0xbe, w1
    d486:	09 40 78    	mov.b     w9, w0
    d488:	dc f7 07    	rcall     0xc442 <_mavlink_msg_mission_count_pack> <L0> <.LFB402> <.LFE389>

0000d48a <.L0>:
    d48a:	21 c0 b3    	mov.b     #0x2, w1
    d48c:	f0 49 22    	mov.w     #0x249f, w0
    d48e:	01 48 78    	mov.b     w1, [w0]
    d490:	00 80 e8    	inc2.w    w0, w0
    d492:	00 48 eb    	clr.b     [w0]

0000d494 <.L0>:
    d494:	01 eb 2f    	mov.w     #0xfeb0, w1
    d496:	8f 80 40    	add.w     w1, w15, w1
    d498:	e0 52 22    	mov.w     #0x252e, w0
    d49a:	75 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d49c:	00 04 44    	add.w     w8, w0, w8

0000d49e <.L0>:
    d49e:	6e 00 37    	bra       0xd57c <.L136>

0000d4a0 <.L139>:
    d4a0:	00 4a 22    	mov.w     #0x24a0, w0
    d4a2:	90 42 78    	mov.b     [w0], w5
    d4a4:	00 80 e8    	inc2.w    w0, w0
    d4a6:	90 cf 52    	sub.b     w5, [w0], [w15]
    d4a8:	0e 00 31    	bra       C, 0xd4c6 <.L0> <.L140>
    d4aa:	00 80 e9    	dec2.w    w0, w0
    d4ac:	05 48 e8    	inc.b     w5, [w0]

0000d4ae <.L0>:
    d4ae:	85 82 fb    	ze        w5, w5
    d4b0:	00 42 eb    	clr.b     w4
    d4b2:	f3 c7 b3    	mov.b     #0x7f, w3
    d4b4:	02 eb 2f    	mov.w     #0xfeb0, w2
    d4b6:	0f 01 41    	add.w     w2, w15, w2
    d4b8:	e1 cb b3    	mov.b     #0xbe, w1
    d4ba:	09 40 78    	mov.b     w9, w0
    d4bc:	a0 f7 07    	rcall     0xc3fe <_mavlink_msg_mission_request_pack> <L0> <.LFB373> <.LFE305>

0000d4be <.L0>:
    d4be:	41 c0 b3    	mov.b     #0x4, w1
    d4c0:	f0 49 22    	mov.w     #0x249f, w0
    d4c2:	01 48 78    	mov.b     w1, [w0]
    d4c4:	16 00 37    	bra       0xd4f2 <.L0> <.L141>

0000d4c6 <.L0>:
    d4c6:	80 42 eb    	clr.b     w5
    d4c8:	05 42 78    	mov.b     w5, w4
    d4ca:	f3 c7 b3    	mov.b     #0x7f, w3
    d4cc:	02 eb 2f    	mov.w     #0xfeb0, w2
    d4ce:	0f 01 41    	add.w     w2, w15, w2
    d4d0:	e1 cb b3    	mov.b     #0xbe, w1
    d4d2:	09 40 78    	mov.b     w9, w0
    d4d4:	cd f7 07    	rcall     0xc470 <_mavlink_msg_mission_ack_pack> <L0> <.LFB423> <.LFE402>

0000d4d6 <.L0>:
    d4d6:	21 4a 22    	mov.w     #0x24a2, w1
    d4d8:	80 23 21    	mov.w     #0x1238, w0
    d4da:	11 48 78    	mov.b     [w1], [w0]
    d4dc:	00 40 eb    	clr.b     w0
    d4de:	64 81 50    	sub.w     w1, #0x4, w2
    d4e0:	00 49 78    	mov.b     w0, [w2]
    d4e2:	02 01 e8    	inc.w     w2, w2
    d4e4:	00 49 78    	mov.b     w0, [w2]
    d4e6:	02 01 e8    	inc.w     w2, w2
    d4e8:	00 49 78    	mov.b     w0, [w2]
    d4ea:	80 48 78    	mov.b     w0, [w1]
    d4ec:	11 c0 b3    	mov.b     #0x1, w1
    d4ee:	63 00 41    	add.w     w2, #0x3, w0
    d4f0:	01 48 78    	mov.b     w1, [w0]

0000d4f2 <.L0>:
    d4f2:	01 eb 2f    	mov.w     #0xfeb0, w1
    d4f4:	8f 80 40    	add.w     w1, w15, w1
    d4f6:	e0 52 22    	mov.w     #0x252e, w0
    d4f8:	46 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d4fa:	00 04 44    	add.w     w8, w0, w8

0000d4fc <.L0>:
    d4fc:	10 4a 22    	mov.w     #0x24a1, w0
    d4fe:	00 48 eb    	clr.b     [w0]
    d500:	66 00 37    	bra       0xd5ce <.L142>

0000d502 <.L138>:
    d502:	00 4a 22    	mov.w     #0x24a0, w0
    d504:	10 85 fb    	ze        [w0], w10
    d506:	c1 0c 20    	mov.w     #0xcc, w1
    d508:	8a 80 40    	add.w     w1, w10, w1
    d50a:	80 13 21    	mov.w     #0x1138, w0
    d50c:	81 00 40    	add.w     w0, w1, w1
    d50e:	11 87 fb    	ze        [w1], w14
    d510:	21 02 20    	mov.w     #0x22, w1
    d512:	8a 80 40    	add.w     w1, w10, w1
    d514:	c2 08 dd    	sl.w      w1, #0x2, w1
    d516:	81 00 40    	add.w     w0, w1, w1
    d518:	11 01 be    	mov.d     [w1], w2
    d51a:	82 9f be    	mov.d     w2, [w15++]
    d51c:	f1 00 45    	add.w     w10, #0x11, w1
    d51e:	c2 08 dd    	sl.w      w1, #0x2, w1
    d520:	81 00 40    	add.w     w0, w1, w1
    d522:	11 02 be    	mov.d     [w1], w4
    d524:	84 9f be    	mov.d     w4, [w15++]
    d526:	c2 50 dd    	sl.w      w10, #0x2, w1
    d528:	81 00 40    	add.w     w0, w1, w1
    d52a:	11 01 be    	mov.d     [w1], w2
    d52c:	82 9f be    	mov.d     w2, [w15++]
    d52e:	60 66 b8    	mul.uu    w12, #0x0, w12
    d530:	8c 9f be    	mov.d     w12, [w15++]
    d532:	f1 06 20    	mov.w     #0x6f, w1
    d534:	8a 80 40    	add.w     w1, w10, w1
    d536:	81 80 40    	add.w     w1, w1, w1
    d538:	01 00 40    	add.w     w0, w1, w0

0000d53a <.L0>:
    d53a:	10 00 78    	mov.w     [w0], w0
    d53c:	80 00 eb    	clr.w     w1
    d53e:	12 19 02    	call      0x1912 <___floatunsisf>
    d540:	00 00 00 
    d542:	80 9f be    	mov.d     w0, [w15++]
    d544:	8c 9f be    	mov.d     w12, [w15++]
    d546:	8c 9f be    	mov.d     w12, [w15++]
    d548:	10 c0 b3    	mov.b     #0x1, w0
    d54a:	80 1f 78    	mov.w     w0, [w15++]
    d54c:	80 45 eb    	clr.b     w11
    d54e:	8b 1f 78    	mov.w     w11, [w15++]
    d550:	8e 03 78    	mov.w     w14, w7
    d552:	0b 43 78    	mov.b     w11, w6
    d554:	8a 02 78    	mov.w     w10, w5
    d556:	0b 42 78    	mov.b     w11, w4
    d558:	f3 c7 b3    	mov.b     #0x7f, w3
    d55a:	02 e9 2f    	mov.w     #0xfe90, w2
    d55c:	0f 01 41    	add.w     w2, w15, w2
    d55e:	e1 cb b3    	mov.b     #0xbe, w1
    d560:	09 40 78    	mov.b     w9, w0
    d562:	b2 f8 07    	rcall     0xc6c8 <_mavlink_msg_mission_item_pack> <L0> <.LFB354> <.LFE143>

0000d564 <.L0>:
    d564:	51 c0 b3    	mov.b     #0x5, w1
    d566:	f0 49 22    	mov.w     #0x249f, w0
    d568:	01 48 78    	mov.b     w1, [w0]

0000d56a <.L0>:
    d56a:	0f 02 b1    	sub.w     #0x20, w15
    d56c:	01 eb 2f    	mov.w     #0xfeb0, w1
    d56e:	8f 80 40    	add.w     w1, w15, w1
    d570:	e0 52 22    	mov.w     #0x252e, w0
    d572:	09 f8 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d574:	00 04 44    	add.w     w8, w0, w8

0000d576 <.L0>:
    d576:	10 4a 22    	mov.w     #0x24a1, w0
    d578:	0b 48 78    	mov.b     w11, [w0]
    d57a:	29 00 37    	bra       0xd5ce <.L142>

0000d57c <.L136>:
    d57c:	11 4a 22    	mov.w     #0x24a1, w1
    d57e:	11 40 e8    	inc.b     [w1], w0
    d580:	80 48 78    	mov.b     w0, [w1]
    d582:	f4 4f 50    	sub.b     w0, #0x14, [w15]
    d584:	1d 00 36    	bra       LEU, 0xd5c0 <.L143>
    d586:	8f 01 78    	mov.w     w15, w3
    d588:	03 15 b1    	sub.w     #0x150, w3
    d58a:	87 00 09    	.pword 0x090087
    d58c:	80 19 eb    	clr.w     [w3++]

0000d58e <.L0>:
    d58e:	15 c0 b3    	mov.b     #0x1, w5
    d590:	00 42 eb    	clr.b     w4
    d592:	f3 c7 b3    	mov.b     #0x7f, w3
    d594:	02 eb 2f    	mov.w     #0xfeb0, w2
    d596:	0f 01 41    	add.w     w2, w15, w2
    d598:	e1 cb b3    	mov.b     #0xbe, w1
    d59a:	09 40 78    	mov.b     w9, w0
    d59c:	69 f7 07    	rcall     0xc470 <_mavlink_msg_mission_ack_pack> <L0> <.LFB423> <.LFE402>

0000d59e <.L0>:
    d59e:	f0 52 22    	mov.w     #0x252f, w0
    d5a0:	00 00 44    	add.w     w8, w0, w0
    d5a2:	01 eb 2f    	mov.w     #0xfeb0, w1
    d5a4:	8f 80 40    	add.w     w1, w15, w1
    d5a6:	ef f7 07    	rcall     0xc586 <_mavlink_msg_to_send_buffer> <L0> <.LFB14> <.LFE1246>
    d5a8:	00 04 44    	add.w     w8, w0, w8

0000d5aa <.L0>:
    d5aa:	00 40 eb    	clr.b     w0
    d5ac:	e1 49 22    	mov.w     #0x249e, w1
    d5ae:	80 48 78    	mov.b     w0, [w1]
    d5b0:	81 00 e8    	inc.w     w1, w1
    d5b2:	80 48 78    	mov.b     w0, [w1]
    d5b4:	81 00 e8    	inc.w     w1, w1
    d5b6:	80 48 78    	mov.b     w0, [w1]
    d5b8:	81 00 e8    	inc.w     w1, w1
    d5ba:	80 48 78    	mov.b     w0, [w1]
    d5bc:	81 00 e8    	inc.w     w1, w1
    d5be:	80 48 78    	mov.b     w0, [w1]

0000d5c0 <.L143>:
    d5c0:	08 00 78    	mov.w     w8, w0
    d5c2:	4f 07 78    	mov.w     [--w15], w14
    d5c4:	4f 06 be    	mov.d     [--w15], w12
    d5c6:	4f 05 be    	mov.d     [--w15], w10
    d5c8:	4f 04 be    	mov.d     [--w15], w8
    d5ca:	4f 14 b1    	sub.w     #0x144, w15
    d5cc:	00 00 06    	return    

0000d5ce <.L142>:
    d5ce:	10 4a 22    	mov.w     #0x24a1, w0
    d5d0:	10 48 e8    	inc.b     [w0], [w0]
    d5d2:	f6 ff 37    	bra       0xd5c0 <.L143>

0000d5d4 <_TxN_Data_OverU1>:
  

//uint8_t GetCharAtBuffIdx(int32_t idx){
//    return(UartOutBuff[idx]);
//}
/* Declare UART1 Tx Circular Buffer Structure */

extern MCHP_UART1_TxStr MCHP_UART1_Tx;

void TxN_Data_OverU1(uint16_t N){
    d5d4:	88 1f 78    	mov.w     w8, [w15++]
#if (WIN != 1)//SLUGS2 SIL
  uint16_T i;
  for (i = 0U; i < N; i++) {
    d5d6:	00 00 e0    	cp0.w     w0
    d5d8:	14 00 32    	bra       Z, 0xd602 <.L146>
    d5da:	52 e3 81    	mov.w     0x3c6a, w2
    d5dc:	80 00 eb    	clr.w     w1

0000d5de <.LBB5>:
    uint16_T Tmp;
    Tmp = ~(MCHP_UART1_Tx.tail - MCHP_UART1_Tx.head);
    d5de:	c5 c6 23    	mov.w     #0x3c6c, w5
    Tmp = Tmp & (Tx_BUFF_SIZE_Uart1 - 1);/* Modulo Buffer Size */
    d5e0:	f4 1f 20    	mov.w     #0x1ff, w4
    d5e2:	e8 52 22    	mov.w     #0x252e, w8
    if (Tmp != 0) {
      MCHP_UART1_Tx.buffer[MCHP_UART1_Tx.tail] = UartOutBuff[i];
    d5e4:	e7 df 2f    	mov.w     #0xfdfe, w7
    d5e6:	85 83 43    	add.w     w7, w5, w7

0000d5e8 <.L148>:
    d5e8:	95 01 51    	sub.w     w2, [w5], w3
    d5ea:	83 81 ea    	com.w     w3, w3
    d5ec:	84 81 61    	and.w     w3, w4, w3
    d5ee:	05 00 32    	bra       Z, 0xd5fa <.L147> <.LBE5>
    d5f0:	08 83 40    	add.w     w1, w8, w6
    d5f2:	82 81 43    	add.w     w7, w2, w3
    d5f4:	96 49 78    	mov.b     [w6], [w3]
      MCHP_UART1_Tx.tail = (MCHP_UART1_Tx.tail + 1) & (Tx_BUFF_SIZE_Uart1 - 1);
    d5f6:	02 01 e8    	inc.w     w2, w2
    d5f8:	04 01 61    	and.w     w2, w4, w2

0000d5fa <.L147>:
    d5fa:	81 00 e8    	inc.w     w1, w1
    d5fc:	81 0f 50    	sub.w     w0, w1, [w15]
    d5fe:	f4 ff 3e    	bra       GTU, 0xd5e8 <.L148>
    d600:	52 e3 89    	mov.w     w2, 0x3c6a

0000d602 <.L146>:
      Tmp--;
    }
  }
  _U1TXIF = U1STAbits.TRMT;
    d602:	10 11 80    	mov.w     0x222, w0
    d604:	48 00 de    	lsr.w     w0, #0x8, w0
    d606:	61 00 60    	and.w     w0, #0x1, w0
    d608:	4c 00 dd    	sl.w      w0, #0xc, w0
    d60a:	f1 ff 2e    	mov.w     #0xefff, w1
    d60c:	02 40 80    	mov.w     0x800, w2
    d60e:	82 80 60    	and.w     w1, w2, w1
    d610:	81 00 70    	ior.w     w0, w1, w1
    d612:	01 40 88    	mov.w     w1, 0x800
#else
	mavlink_serial_send(MAVLINK_COMM_0, &UartOutBuff[0], (uint16_t)N);

#endif
}
    d614:	4f 04 78    	mov.w     [--w15], w8
    d616:	00 00 06    	return    

0000d618 <_TxN_Data_OverU4>:
extern MCHP_UART4_TxStr MCHP_UART4_Tx;

void TxN_Data_OverU4(uint16_t N){
    d618:	88 1f 78    	mov.w     w8, [w15++]
#if (WIN != 1)//SLUGS2 SIL
  uint16_T i;
  for (i = 0U; i < N; i++) {
    d61a:	00 00 e0    	cp0.w     w0
    d61c:	14 00 32    	bra       Z, 0xd646 <.L151>
    d61e:	72 f3 81    	mov.w     0x3e6e, w2
    d620:	80 00 eb    	clr.w     w1

0000d622 <.LBB6>:
    uint16_T Tmp;
    Tmp = ~(MCHP_UART4_Tx.tail - MCHP_UART4_Tx.head);
    d622:	05 e7 23    	mov.w     #0x3e70, w5
    Tmp = Tmp & (Tx_BUFF_SIZE_Uart4 - 1);/* Modulo Buffer Size */
    d624:	f4 1f 20    	mov.w     #0x1ff, w4
    d626:	58 63 22    	mov.w     #0x2635, w8
    if (Tmp != 0) {
      MCHP_UART4_Tx.buffer[MCHP_UART4_Tx.tail] = Uart4OutBuff[i];
    d628:	e7 df 2f    	mov.w     #0xfdfe, w7
    d62a:	85 83 43    	add.w     w7, w5, w7

0000d62c <.L153>:
    d62c:	95 01 51    	sub.w     w2, [w5], w3
    d62e:	83 81 ea    	com.w     w3, w3
    d630:	84 81 61    	and.w     w3, w4, w3
    d632:	05 00 32    	bra       Z, 0xd63e <.L152> <.LBE6>
    d634:	08 83 40    	add.w     w1, w8, w6
    d636:	82 81 43    	add.w     w7, w2, w3
    d638:	96 49 78    	mov.b     [w6], [w3]
      MCHP_UART4_Tx.tail = (MCHP_UART4_Tx.tail + 1) & (Tx_BUFF_SIZE_Uart4 - 1);
    d63a:	02 01 e8    	inc.w     w2, w2
    d63c:	04 01 61    	and.w     w2, w4, w2

0000d63e <.L152>:
    d63e:	81 00 e8    	inc.w     w1, w1
    d640:	81 0f 50    	sub.w     w0, w1, [w15]
    d642:	f4 ff 3e    	bra       GTU, 0xd62c <.L153>
    d644:	72 f3 89    	mov.w     w2, 0x3e6e

0000d646 <.L151>:
      Tmp--;
    }
  }
  _U4TXIF = U4STAbits.TRMT;
    d646:	b2 02 d4    	sl.w      0x2b2, WREG
    d648:	00 20 b2    	and.w     #0x200, w0
    d64a:	f1 df 2f    	mov.w     #0xfdff, w1
    d64c:	52 40 80    	mov.w     0x80a, w2
    d64e:	82 80 60    	and.w     w1, w2, w1
    d650:	81 00 70    	ior.w     w0, w1, w1
    d652:	51 40 88    	mov.w     w1, 0x80a
#else
	//mavlink_serial_send(MAVLINK_COMM_0, &Uart4OutBuff[0], (uint16_t)N);

#endif
}    d654:	4f 04 78    	mov.w     [--w15], w8
    d656:	00 00 06    	return    

0000d658 <_EmbeddedMATLABFunction1_m>:
 *    '<S591>/Embedded MATLAB Function2'
 */
void EmbeddedMATLABFunction1_m(const real_T rtu_u[5],
  rtB_EmbeddedMATLABFunction1_e_T *localB)
{
    d658:	88 9f be    	mov.d     w8, [w15++]
    d65a:	00 04 be    	mov.d     w0, w8

0000d65c <.L0>:
  /* MATLAB Function 'Sensor_Data_Adapter/Raw HIL  Readings/Enabled Subsystem1/Embedded MATLAB Function1': '<S585>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S585>:1:5' */
  localB->y = ((((rtu_u[0] + rtu_u[1]) + rtu_u[2]) + rtu_u[3]) + rtu_u[4]) * 0.2;
    d65c:	28 01 90    	mov.w     [w8+4], w2
    d65e:	b8 01 90    	mov.w     [w8+6], w3
    d660:	18 00 be    	mov.d     [w8], w0
    d662:	92 14 02    	call      0x1492 <___addsf3>
    d664:	00 00 00 
    d666:	48 01 90    	mov.w     [w8+8], w2
    d668:	d8 01 90    	mov.w     [w8+10], w3
    d66a:	92 14 02    	call      0x1492 <___addsf3>
    d66c:	00 00 00 
    d66e:	68 01 90    	mov.w     [w8+12], w2
    d670:	f8 01 90    	mov.w     [w8+14], w3
    d672:	92 14 02    	call      0x1492 <___addsf3>
    d674:	00 00 00 
    d676:	08 09 90    	mov.w     [w8+16], w2
    d678:	98 09 90    	mov.w     [w8+18], w3
    d67a:	92 14 02    	call      0x1492 <___addsf3>
    d67c:	00 00 00 
    d67e:	d2 cc 2c    	mov.w     #0xcccd, w2
    d680:	c3 e4 23    	mov.w     #0x3e4c, w3
    d682:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    d684:	00 00 00 
    d686:	80 8c be    	mov.d     w0, [w9]

0000d688 <.L0>:
}
    d688:	4f 04 be    	mov.d     [--w15], w8
    d68a:	00 00 06    	return    

0000d68c <_AUAV_V3_TestSenso_myMuxFun>:

/*
 * Output and update for atomic system:
 *    '<S583>/myMux Fun'
 *    '<S591>/myMux Fun'
 */
void AUAV_V3_TestSenso_myMuxFun(int16_T rtu_u1, int16_T rtu_u2, int16_T rtu_u3,
  int16_T rtu_u4, rtB_myMuxFun_AUAV_V3_TestSens_T *localB)
{
  /* MATLAB Function 'Sensor_Data_Adapter/Raw HIL  Readings/Enabled Subsystem1/myMux Fun': '<S587>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S587>:1:5' */
  localB->y[0] = rtu_u1;
    d68c:	00 0a 78    	mov.w     w0, [w4]
  localB->y[1] = rtu_u2;
    d68e:	11 02 98    	mov.w     w1, [w4+2]
  localB->y[2] = rtu_u3;
    d690:	22 02 98    	mov.w     w2, [w4+4]
  localB->y[3] = rtu_u4;
    d692:	33 02 98    	mov.w     w3, [w4+6]
}
    d694:	00 00 06    	return    

0000d696 <_EmbeddedMATLABFunct_m_Init>:

/*
 * Initial conditions for atomic system:
 *    '<S596>/Embedded MATLAB Function'
 *    '<S596>/Embedded MATLAB Function1'
 *    '<S596>/Embedded MATLAB Function2'
 *    '<S597>/Embedded MATLAB Function'
 *    '<S597>/Embedded MATLAB Function1'
 *    '<S597>/Embedded MATLAB Function2'
 *    '<S598>/Embedded MATLAB Function'
 *    '<S598>/Embedded MATLAB Function1'
 *    '<S598>/Embedded MATLAB Function2'
 *    '<S629>/Embedded MATLAB Function'
 *    ...
 */
void EmbeddedMATLABFunct_m_Init(rtDW_EmbeddedMATLABFunction_i_T *localDW)
{
  localDW->a_not_empty = false;
    d696:	80 40 eb    	clr.b     w1
    d698:	01 50 98    	mov.b     w1, [w0+16]
}
    d69a:	00 00 06    	return    

0000d69c <_A_EmbeddedMATLABFunction_f>:

/*
 * Output and update for atomic system:
 *    '<S596>/Embedded MATLAB Function'
 *    '<S596>/Embedded MATLAB Function1'
 *    '<S596>/Embedded MATLAB Function2'
 *    '<S597>/Embedded MATLAB Function'
 *    '<S597>/Embedded MATLAB Function1'
 *    '<S597>/Embedded MATLAB Function2'
 *    '<S598>/Embedded MATLAB Function'
 *    '<S598>/Embedded MATLAB Function1'
 *    '<S598>/Embedded MATLAB Function2'
 *    '<S629>/Embedded MATLAB Function'
 *    ...
 */
void A_EmbeddedMATLABFunction_f(real_T rtu_u, real_T rtu_T, real_T rtu_f,
  rtB_EmbeddedMATLABFunction_gp_T *localB, rtDW_EmbeddedMATLABFunction_i_T
  *localDW)
{
    d69c:	e4 87 47    	add.w     w15, #0x4, w15
    d69e:	88 9f be    	mov.d     w8, [w15++]
    d6a0:	8a 9f be    	mov.d     w10, [w15++]
    d6a2:	8c 9f be    	mov.d     w12, [w15++]
    d6a4:	8e 1f 78    	mov.w     w14, [w15++]
    d6a6:	00 05 be    	mov.d     w0, w10
    d6a8:	02 04 be    	mov.d     w2, w8
    d6aa:	04 00 be    	mov.d     w4, w0
    d6ac:	86 bf 9f    	mov.w     w6, [w15-16]
    d6ae:	07 07 78    	mov.w     w7, w14
  real_T omega;

  /* MATLAB Function 'Sensor_Data_Adapter/Sensor Suite/ADIS16405 Signal Cond /3D Tustin Lowpass, Auto Initial Condition/Embedded MATLAB Function': '<S602>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  if (!localDW->a_not_empty) {
    d6b0:	0e 51 90    	mov.b     [w14+16], w2
    d6b2:	02 04 e0    	cp0.b     w2
    d6b4:	24 00 3a    	bra       NZ, 0xd6fe <.L0> <.L5>

0000d6b6 <.L0>:
    /* '<S602>:1:9' */
    /* tf = [T*omega/(2+T*omega) T*omega/(2+T*omega)],[1 (T*omega-2)/(T*omega+2)] */
    /* tf = [a a],[1 -b] */
    /* '<S602>:1:12' */
    omega = 6.2831853071795862 * rtu_f;
    d6b6:	b2 fd 20    	mov.w     #0xfdb, w2
    d6b8:	93 0c 24    	mov.w     #0x40c9, w3
    d6ba:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    d6bc:	00 00 00 
    d6be:	00 01 be    	mov.d     w0, w2

0000d6c0 <.L0>:

    /* '<S602>:1:13' */
    localDW->a = rtu_T * omega / (rtu_T * omega + 2.0);
    d6c0:	08 00 be    	mov.d     w8, w0
    d6c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    d6c4:	00 00 00 
    d6c6:	00 04 be    	mov.d     w0, w8
    d6c8:	02 00 20    	mov.w     #0x0, w2
    d6ca:	03 00 24    	mov.w     #0x4000, w3
    d6cc:	92 14 02    	call      0x1492 <___addsf3>
    d6ce:	00 00 00 
    d6d0:	00 06 be    	mov.d     w0, w12
    d6d2:	00 01 be    	mov.d     w0, w2
    d6d4:	08 00 be    	mov.d     w8, w0
    d6d6:	26 17 02    	call      0x1726 <___divsf3>
    d6d8:	00 00 00 
    d6da:	00 8f be    	mov.d     w0, [w14]

0000d6dc <.L0>:
    localDW->a_not_empty = true;
    d6dc:	10 c0 b3    	mov.b     #0x1, w0
    d6de:	00 57 98    	mov.b     w0, [w14+16]

0000d6e0 <.L0>:

    /* '<S602>:1:14' */
    localDW->b = -(rtu_T * omega - 2.0) / (rtu_T * omega + 2.0);
    d6e0:	02 00 20    	mov.w     #0x0, w2
    d6e2:	03 00 24    	mov.w     #0x4000, w3
    d6e4:	08 00 be    	mov.d     w8, w0
    d6e6:	90 14 02    	call      0x1490 <___subsf3>
    d6e8:	00 00 00 
    d6ea:	01 f0 a2    	btg.w     w1, #0xf
    d6ec:	0c 01 be    	mov.d     w12, w2
    d6ee:	26 17 02    	call      0x1726 <___divsf3>
    d6f0:	00 00 00 
    d6f2:	20 07 98    	mov.w     w0, [w14+4]
    d6f4:	31 07 98    	mov.w     w1, [w14+6]

0000d6f6 <.L0>:

    /* '<S602>:1:15' */
    localDW->y_km1 = rtu_u;
    d6f6:	4a 07 98    	mov.w     w10, [w14+8]
    d6f8:	5b 07 98    	mov.w     w11, [w14+10]

    /* '<S602>:1:16' */
    localDW->u_km1 = rtu_u;
    d6fa:	6a 07 98    	mov.w     w10, [w14+12]
    d6fc:	7b 07 98    	mov.w     w11, [w14+14]

0000d6fe <.L0>:
  }

  /* '<S602>:1:19' */
  localB->y = (rtu_u + localDW->u_km1) * localDW->a + localDW->b *
    d6fe:	6e 01 90    	mov.w     [w14+12], w2
    d700:	fe 01 90    	mov.w     [w14+14], w3
    d702:	0a 00 be    	mov.d     w10, w0
    d704:	92 14 02    	call      0x1492 <___addsf3>
    d706:	00 00 00 
    d708:	1e 01 be    	mov.d     [w14], w2
    d70a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    d70c:	00 00 00 
    d70e:	00 04 be    	mov.d     w0, w8
    d710:	4e 01 90    	mov.w     [w14+8], w2
    d712:	de 01 90    	mov.w     [w14+10], w3
    d714:	2e 00 90    	mov.w     [w14+4], w0
    d716:	be 00 90    	mov.w     [w14+6], w1
    d718:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    d71a:	00 00 00 
    d71c:	00 01 be    	mov.d     w0, w2
    d71e:	08 00 be    	mov.d     w8, w0
    d720:	92 14 02    	call      0x1492 <___addsf3>
    d722:	00 00 00 
    d724:	0f b9 97    	mov.w     [w15-16], w2
    d726:	00 89 be    	mov.d     w0, [w2]

0000d728 <.L0>:
    localDW->y_km1;

  /* '<S602>:1:20' */
  localDW->y_km1 = localB->y;
    d728:	40 07 98    	mov.w     w0, [w14+8]
    d72a:	51 07 98    	mov.w     w1, [w14+10]

  /* '<S602>:1:21' */
  localDW->u_km1 = rtu_u;
    d72c:	6a 07 98    	mov.w     w10, [w14+12]
    d72e:	7b 07 98    	mov.w     w11, [w14+14]
}
    d730:	4f 07 78    	mov.w     [--w15], w14
    d732:	4f 06 be    	mov.d     [--w15], w12
    d734:	4f 05 be    	mov.d     [--w15], w10
    d736:	4f 04 be    	mov.d     [--w15], w8
    d738:	4f 00 b1    	sub.w     #0x4, w15
    d73a:	00 00 06    	return    

0000d73c <_AUAV_V3_TestSen_myMuxFun_i>:

/*
 * Output and update for atomic system:
 *    '<S596>/myMux Fun'
 *    '<S597>/myMux Fun'
 *    '<S598>/myMux Fun'
 */
void AUAV_V3_TestSen_myMuxFun_i(real_T rtu_u1, real_T rtu_u2, real_T rtu_u3,
  rtB_myMuxFun_AUAV_V3_TestSe_i_T *localB)
{
  /* MATLAB Function 'Sensor_Data_Adapter/Sensor Suite/ADIS16405 Signal Cond /3D Tustin Lowpass, Auto Initial Condition/myMux Fun': '<S605>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S605>:1:5' */
  localB->y[0] = rtu_u1;
    d73c:	00 8b be    	mov.d     w0, [w6]
  localB->y[1] = rtu_u2;
    d73e:	22 03 98    	mov.w     w2, [w6+4]
    d740:	33 03 98    	mov.w     w3, [w6+6]
  localB->y[2] = rtu_u3;
    d742:	44 03 98    	mov.w     w4, [w6+8]
    d744:	55 03 98    	mov.w     w5, [w6+10]
}
    d746:	00 00 06    	return    

0000d748 <_A_Sensor_Data_Adapter_Init>:

/* Initial conditions for atomic system: '<Root>/Sensor_Data_Adapter' */
void A_Sensor_Data_Adapter_Init(void)
{
  /* InitializeConditions for MATLAB Function: '<S629>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_g);
    d748:	e0 0a 22    	mov.w     #0x20ae, w0
    d74a:	a5 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d74c <.L0>:

  /* InitializeConditions for MATLAB Function: '<S631>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_lw);
    d74c:	a0 08 22    	mov.w     #0x208a, w0
    d74e:	a3 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d750 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S632>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_cn);
    d750:	80 07 22    	mov.w     #0x2078, w0
    d752:	a1 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d754 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S630>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_np);
    d754:	c0 09 22    	mov.w     #0x209c, w0
    d756:	9f ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d758 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S596>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_f);
    d758:	80 15 22    	mov.w     #0x2158, w0
    d75a:	9d ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d75c <.L0>:

  /* InitializeConditions for MATLAB Function: '<S596>/Embedded MATLAB Function1' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_i);
    d75c:	60 14 22    	mov.w     #0x2146, w0
    d75e:	9b ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d760 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S596>/Embedded MATLAB Function2' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_h);
    d760:	40 13 22    	mov.w     #0x2134, w0
    d762:	99 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d764 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S597>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_kq);
    d764:	20 12 22    	mov.w     #0x2122, w0
    d766:	97 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d768 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S597>/Embedded MATLAB Function1' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_f);
    d768:	00 11 22    	mov.w     #0x2110, w0
    d76a:	95 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d76c <.L0>:

  /* InitializeConditions for MATLAB Function: '<S597>/Embedded MATLAB Function2' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_f);
    d76c:	e0 0f 22    	mov.w     #0x20fe, w0
    d76e:	93 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d770 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S598>/Embedded MATLAB Function' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_ft);
    d770:	c0 0e 22    	mov.w     #0x20ec, w0
    d772:	91 ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d774 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S598>/Embedded MATLAB Function1' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_in);
    d774:	a0 0d 22    	mov.w     #0x20da, w0
    d776:	8f ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d778 <.L0>:

  /* InitializeConditions for MATLAB Function: '<S598>/Embedded MATLAB Function2' */
  EmbeddedMATLABFunct_m_Init
    (&AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_fu);
    d778:	80 0c 22    	mov.w     #0x20c8, w0
    d77a:	8d ff 07    	rcall     0xd696 <_EmbeddedMATLABFunct_m_Init> <L0> <.LFB1467> <.LFE1466>

0000d77c <.L0>:

  /* InitializeConditions for MATLAB Function: '<S622>/Enables//Disables the Computation of  initial Baro Bias' */
  EnablesDisablestheCom_Init
    (&AUAV_V3_TestSensors_DWork.sf_EnablesDisablestheComputat_b);
    d77c:	00 0c 22    	mov.w     #0x20c0, w0
    d77e:	42 11 02    	call      0x11142 <_EnablesDisablestheCom_Init>
    d780:	01 00 00 

0000d782 <.L0>:
}
    d782:	00 00 06    	return    

0000d784 <_Sensor_Data_Adapter_Start>:

/* Start for atomic system: '<Root>/Sensor_Data_Adapter' */
void Sensor_Data_Adapter_Start(void)
{
  /* Start for S-Function (MCHP_MCU_LOAD): '<S590>/Calculus Time Step1' */
  TMR3 = 0;                            /* Initialize Timer 3 Value to 0.  Timer 3 is enabled only when the mcu is not idle */
    d784:	0a 21 ef    	clr.w     0x10a
}
    d786:	00 00 06    	return    

0000d788 <_AUAV_V_Sensor_Data_Adapter>:

/* Output and update for atomic system: '<Root>/Sensor_Data_Adapter' */
void AUAV_V_Sensor_Data_Adapter(void)
{
    d788:	fe 87 47    	add.w     w15, #0x1e, w15
    d78a:	88 9f be    	mov.d     w8, [w15++]
    d78c:	8a 9f be    	mov.d     w10, [w15++]
    d78e:	8c 9f be    	mov.d     w12, [w15++]
    d790:	8e 1f 78    	mov.w     w14, [w15++]

0000d792 <.L0>:
  /* local block i/o variables */
  real_T rtb_DataTypeConversion_n;
  real_T rtb_DiscreteZeroPole_i;
  boolean_T rtb_LogicalOperator;
  int16_T rtb_Switch_d[13];
  real32_T rtb_Sum_o;
  uint8_T rtb_Compare_gl;
  real32_T rtb_u001maxDynPress;
  real32_T rtb_Sum_d;
  int16_T rtb_DataTypeConversion1_ax;
  int16_T rtb_DataTypeConversion2_c;
  int16_T i;
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S16>/Raw HIL  Readings' incorporates:
   *  EnablePort: '<S580>/Enable'
   */
  if (AUAV_V3_TestSensors_B.HILManualSwitch > 0.0) {
    d792:	60 11 b8    	mul.uu    w2, #0x0, w2
    d794:	f0 ae 80    	mov.w     0x15de, w0
    d796:	01 af 80    	mov.w     0x15e0, w1
    d798:	90 18 02    	call      0x1890 <___gesf2>
    d79a:	00 00 00 
    d79c:	00 00 e0    	cp0.w     w0
    d79e:	ae 00 34    	bra       LE, 0xd8fc <.L0> <.L10>

0000d7a0 <.L0>:
    /* Outputs for Enabled SubSystem: '<S580>/Enabled Subsystem' incorporates:
     *  EnablePort: '<S582>/Enable'
     */
    /* DataStoreRead: '<S580>/Data Store Read' */
    if (AUAV_V3_TestSensors_DWork.SIX_DOF_HIL_FLAG > 0.0) {
    d7a0:	60 11 b8    	mul.uu    w2, #0x0, w2
    d7a2:	60 ec 80    	mov.w     0x1d8c, w0
    d7a4:	71 ec 80    	mov.w     0x1d8e, w1
    d7a6:	90 18 02    	call      0x1890 <___gesf2>
    d7a8:	00 00 00 
    d7aa:	00 00 e0    	cp0.w     w0
    d7ac:	09 00 34    	bra       LE, 0xd7c0 <.L0> <.L0> <.L12>

0000d7ae <.L0>:
      /* S-Function (MCHP_C_function_Call): '<S582>/Data from HIL [hil.c]2' */
      hilRead(
    d7ae:	a0 a2 21    	mov.w     #0x1a2a, w0
    d7b0:	88 01 02    	call      0x10188 <_hilRead>
    d7b2:	01 00 00 

0000d7b4 <.L0>:
              &AUAV_V3_TestSensors_B.DatafromHILhilc2[0]
              );

      /* S-Function (MCHP_C_function_Call): '<S582>/HIL Messages  Parser//Decoder [hil.c]1' */
      protDecodeHil(
    d7b4:	a0 a2 21    	mov.w     #0x1a2a, w0
    d7b6:	52 02 02    	call      0x10252 <_protDecodeHil>
    d7b8:	01 00 00 

0000d7ba <.L0>:
                    &AUAV_V3_TestSensors_B.DatafromHILhilc2[0]
                    );

      /* S-Function (MCHP_C_function_Call): '<S582>/HIL Raw Readings [hil.c]1' */
      hil_getRawRead(
    d7ba:	40 99 21    	mov.w     #0x1994, w0
    d7bc:	b8 01 02    	call      0x101b8 <_hil_getRawRead>
    d7be:	01 00 00 

0000d7c0 <.L0>:
                     &AUAV_V3_TestSensors_B.HILRawReadingshilc1_k[0]
                     );
    }

    /* End of DataStoreRead: '<S580>/Data Store Read' */
    /* End of Outputs for SubSystem: '<S580>/Enabled Subsystem' */

    /* Outputs for Enabled SubSystem: '<S580>/Enabled Subsystem1' incorporates:
     *  EnablePort: '<S583>/Enable'
     */
    /* DataStoreRead: '<S580>/Data Store Read1' */
    if (AUAV_V3_TestSensors_DWork.X_PLANE_HIL_FLAG > 0.0) {
    d7c0:	60 11 b8    	mul.uu    w2, #0x0, w2
    d7c2:	80 ec 80    	mov.w     0x1d90, w0
    d7c4:	91 ec 80    	mov.w     0x1d92, w1
    d7c6:	90 18 02    	call      0x1890 <___gesf2>
    d7c8:	00 00 00 
    d7ca:	00 00 e0    	cp0.w     w0
    d7cc:	84 00 34    	bra       LE, 0xd8d6 <.L0> <.L14>

0000d7ce <.L0>:
      /* S-Function (MCHP_C_function_Call): '<S583>/Data from HIL X-Plane' */
      HILSIM_set_gplane(
    d7ce:	30 f0 02    	call      0xf030 <_HILSIM_set_gplane>
    d7d0:	00 00 00 

0000d7d2 <.L0>:
                        );

      /* S-Function (MCHP_C_function_Call): '<S583>/Data from HIL X-Plane2' */
      HILSIM_set_omegagyro(
    d7d2:	ce f0 02    	call      0xf0ce <_HILSIM_set_omegagyro>
    d7d4:	00 00 00 

0000d7d6 <.L0>:
                           );

      /* S-Function (MCHP_C_function_Call): '<S583>/HIL Raw Readings [hil.c]1' */
      hil_getRawRead(
    d7d6:	a0 97 21    	mov.w     #0x197a, w0
    d7d8:	b8 01 02    	call      0x101b8 <_hil_getRawRead>
    d7da:	01 00 00 

0000d7dc <.L0>:
                     &AUAV_V3_TestSensors_B.HILRawReadingshilc1[0]
                     );

      /* MATLAB Function: '<S583>/Embedded MATLAB Function1' incorporates:
       *  Constant: '<S583>/Constant1'
       */
      EmbeddedMATLABFunction1_m(AUAV_V3_TestSensors_ConstP.pooled16,
    d7dc:	81 bd 21    	mov.w     #0x1bd8, w1
    d7de:	c0 72 2c    	mov.w     #0xc72c, w0
    d7e0:	3b ff 07    	rcall     0xd658 <_EmbeddedMATLABFunction1_m> <L0> <.L0> <.LFB1465> <.LFE1487> <.Letext0> <.Ltext0>

0000d7e2 <.L0>:
        &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_m);

      /* DataTypeConversion: '<S583>/Data Type Conversion1' */
      tmp_0 = floor(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_m.y);
    d7e2:	c0 de 80    	mov.w     0x1bd8, w0
    d7e4:	d1 de 80    	mov.w     0x1bda, w1
    d7e6:	16 19 02    	call      0x1916 <_floorf>
    d7e8:	00 00 00 
    d7ea:	00 04 be    	mov.d     w0, w8

0000d7ec <.L0>:
      if (rtIsNaN(tmp_0) || rtIsInf(tmp_0)) {
    d7ec:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    d7ee:	01 00 00 
        tmp_0 = 0.0;
    d7f0:	60 66 b8    	mul.uu    w12, #0x0, w12

0000d7f2 <.L0>:
    d7f2:	00 04 e0    	cp0.b     w0
    d7f4:	0b 00 3a    	bra       NZ, 0xd80c <.L0> <.L0> <.L16>
    d7f6:	08 00 be    	mov.d     w8, w0
    d7f8:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    d7fa:	01 00 00 
    d7fc:	00 04 e0    	cp0.b     w0
    d7fe:	06 00 3a    	bra       NZ, 0xd80c <.L0> <.L0> <.L16>

0000d800 <.L0>:
      } else {
        tmp_0 = fmod(tmp_0, 65536.0);
    d800:	02 00 20    	mov.w     #0x0, w2
    d802:	03 78 24    	mov.w     #0x4780, w3
    d804:	08 00 be    	mov.d     w8, w0
    d806:	26 19 02    	call      0x1926 <_fmodf>
    d808:	00 00 00 
    d80a:	00 06 be    	mov.d     w0, w12

0000d80c <.L0>:
      }

      /* MATLAB Function: '<S583>/Embedded MATLAB Function2' incorporates:
       *  Constant: '<S583>/Constant2'
       */
      EmbeddedMATLABFunction1_m(AUAV_V3_TestSensors_ConstP.pooled16,
    d80c:	41 bd 21    	mov.w     #0x1bd4, w1
    d80e:	c0 72 2c    	mov.w     #0xc72c, w0
    d810:	23 ff 07    	rcall     0xd658 <_EmbeddedMATLABFunction1_m> <L0> <.L0> <.LFB1465> <.LFE1487> <.Letext0> <.Ltext0>

0000d812 <.L0>:
        &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_i);

      /* DataTypeConversion: '<S583>/Data Type Conversion' incorporates:
       *  DataStoreRead: '<S583>/Get mlAirData1'
       */
      rtb_Sum_o = (real32_T)floor(mlAirData.press_abs);
    d812:	e0 83 80    	mov.w     0x107c, w0
    d814:	f1 83 80    	mov.w     0x107e, w1
    d816:	16 19 02    	call      0x1916 <_floorf>
    d818:	00 00 00 
    d81a:	00 04 be    	mov.d     w0, w8

0000d81c <.L0>:
      if (rtIsNaNF(rtb_Sum_o) || rtIsInfF(rtb_Sum_o)) {
    d81c:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    d81e:	01 00 00 
        rtb_Sum_o = 0.0F;
    d820:	60 55 b8    	mul.uu    w10, #0x0, w10

0000d822 <.L0>:
    d822:	00 04 e0    	cp0.b     w0
    d824:	0b 00 3a    	bra       NZ, 0xd83c <.L0> <.L0> <.L17>
    d826:	08 00 be    	mov.d     w8, w0
    d828:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    d82a:	01 00 00 
    d82c:	00 04 e0    	cp0.b     w0
    d82e:	06 00 3a    	bra       NZ, 0xd83c <.L0> <.L0> <.L17>

0000d830 <.L0>:
      } else {
        rtb_Sum_o = (real32_T)fmod(rtb_Sum_o, 65536.0F);
    d830:	02 00 20    	mov.w     #0x0, w2
    d832:	03 78 24    	mov.w     #0x4780, w3
    d834:	08 00 be    	mov.d     w8, w0
    d836:	26 19 02    	call      0x1926 <_fmodf>
    d838:	00 00 00 
    d83a:	00 05 be    	mov.d     w0, w10

0000d83c <.L0>:
      }

      /* DataTypeConversion: '<S583>/Data Type Conversion2' */
      tmp = floor(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_i.y);
    d83c:	a0 de 80    	mov.w     0x1bd4, w0
    d83e:	b1 de 80    	mov.w     0x1bd6, w1
    d840:	16 19 02    	call      0x1916 <_floorf>
    d842:	00 00 00 
    d844:	00 04 be    	mov.d     w0, w8

0000d846 <.L0>:
      if (rtIsNaN(tmp) || rtIsInf(tmp)) {
    d846:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    d848:	01 00 00 
    d84a:	00 04 e0    	cp0.b     w0
    d84c:	fd 03 3a    	bra       NZ, 0xe048 <.L0> <.L18>
    d84e:	08 00 be    	mov.d     w8, w0
    d850:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    d852:	01 00 00 
    d854:	00 04 e0    	cp0.b     w0
    d856:	f8 03 3a    	bra       NZ, 0xe048 <.L0> <.L18>

0000d858 <.L0>:
        tmp = 0.0;
      } else {
        tmp = fmod(tmp, 65536.0);
    d858:	02 00 20    	mov.w     #0x0, w2
    d85a:	03 78 24    	mov.w     #0x4780, w3
    d85c:	08 00 be    	mov.d     w8, w0
    d85e:	26 19 02    	call      0x1926 <_fmodf>
    d860:	00 00 00 
    d862:	00 04 be    	mov.d     w0, w8

0000d864 <.L0>:
      }

      /* MATLAB Function: '<S583>/myMux Fun' incorporates:
       *  DataStoreRead: '<S583>/Get mlAirData2'
       *  DataTypeConversion: '<S583>/Data Type Conversion'
       *  DataTypeConversion: '<S583>/Data Type Conversion1'
       *  DataTypeConversion: '<S583>/Data Type Conversion2'
       */
      AUAV_V3_TestSenso_myMuxFun(rtb_Sum_o < 0.0F ? -(int16_T)(uint16_T)
    d864:	20 84 80    	mov.w     0x1084, w0
    d866:	80 bf 9f    	mov.w     w0, [w15-16]
    d868:	60 11 b8    	mul.uu    w2, #0x0, w2
    d86a:	08 00 be    	mov.d     w8, w0
    d86c:	8c 18 02    	call      0x188c <___eqsf2>
    d86e:	00 00 00 
    d870:	00 00 e0    	cp0.w     w0
    d872:	06 00 3d    	bra       GE, 0xd880 <.L0> <.L19>

0000d874 <.L0>:
        -rtb_Sum_o : (int16_T)(uint16_T)rtb_Sum_o, tmp_0 < 0.0 ? -(int16_T)
        (uint16_T)-tmp_0 : (int16_T)(uint16_T)tmp_0, tmp < 0.0 ? -(int16_T)
        (uint16_T)-tmp : (int16_T)(uint16_T)tmp, mlAirData.temperature,
    d874:	08 00 be    	mov.d     w8, w0
    d876:	01 f0 a2    	btg.w     w1, #0xf
    d878:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d87a:	00 00 00 

0000d87c <.L0>:
    d87c:	00 07 ea    	neg.w     w0, w14
    d87e:	04 00 37    	bra       0xd888 <.L0> <.L0> <.L21>

0000d880 <.L0>:
    d880:	08 00 be    	mov.d     w8, w0
    d882:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d884:	00 00 00 
    d886:	00 07 78    	mov.w     w0, w14

0000d888 <.L0>:
    d888:	60 11 b8    	mul.uu    w2, #0x0, w2
    d88a:	0c 00 be    	mov.d     w12, w0
    d88c:	8c 18 02    	call      0x188c <___eqsf2>
    d88e:	00 00 00 
    d890:	00 00 e0    	cp0.w     w0
    d892:	06 00 3d    	bra       GE, 0xd8a0 <.L0> <.L107>

0000d894 <.L0>:
    d894:	0c 00 be    	mov.d     w12, w0
    d896:	01 f0 a2    	btg.w     w1, #0xf
    d898:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d89a:	00 00 00 

0000d89c <.L0>:
    d89c:	00 04 ea    	neg.w     w0, w8
    d89e:	04 00 37    	bra       0xd8a8 <.L0> <.L0> <.L24>

0000d8a0 <.L0>:
    d8a0:	0c 00 be    	mov.d     w12, w0
    d8a2:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d8a4:	00 00 00 
    d8a6:	00 04 78    	mov.w     w0, w8

0000d8a8 <.L0>:
    d8a8:	60 11 b8    	mul.uu    w2, #0x0, w2
    d8aa:	0a 00 be    	mov.d     w10, w0
    d8ac:	8c 18 02    	call      0x188c <___eqsf2>
    d8ae:	00 00 00 
    d8b0:	00 00 e0    	cp0.w     w0
    d8b2:	06 00 3d    	bra       GE, 0xd8c0 <.L0> <.L108>

0000d8b4 <.L0>:
    d8b4:	0a 00 be    	mov.d     w10, w0
    d8b6:	01 f0 a2    	btg.w     w1, #0xf

0000d8b8 <.L0>:
    d8b8:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d8ba:	00 00 00 
    d8bc:	00 00 ea    	neg.w     w0, w0
    d8be:	03 00 37    	bra       0xd8c6 <.L0> <.L0> <.L27>

0000d8c0 <.L0>:
    d8c0:	0a 00 be    	mov.d     w10, w0
    d8c2:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d8c4:	00 00 00 

0000d8c6 <.L0>:
    d8c6:	c4 bc 21    	mov.w     #0x1bcc, w4
    d8c8:	8f b9 97    	mov.w     [w15-16], w3
    d8ca:	0e 01 78    	mov.w     w14, w2
    d8cc:	88 00 78    	mov.w     w8, w1
    d8ce:	de fe 07    	rcall     0xd68c <_AUAV_V3_TestSenso_myMuxFun> <L0> <.LFB1466> <.LFE1465>

0000d8d0 <.L0>:
        &AUAV_V3_TestSensors_B.sf_myMuxFun_h);

      /* S-Function (MCHP_C_function_Call): '<S583>/Update State AP ADC Data [updateSensorMcuState.c]1' */
      updateRawADCData(
    d8d0:	c0 bc 21    	mov.w     #0x1bcc, w0
    d8d2:	42 fb 02    	call      0xfb42 <_updateRawADCData>
    d8d4:	00 00 00 

0000d8d6 <.L0>:
                       &AUAV_V3_TestSensors_B.sf_myMuxFun_h.y[0]
                       );
    }

    /* End of Outputs for SubSystem: '<S580>/Enabled Subsystem1' */

    /* Switch: '<S580>/Switch' incorporates:
     *  DataStoreRead: '<S580>/Data Store Read1'
     */
    for (i = 0; i < 13; i++) {
      if (AUAV_V3_TestSensors_DWork.X_PLANE_HIL_FLAG != 0.0) {
    d8d6:	88 ec 80    	mov.w     0x1d90, w8
    d8d8:	99 ec 80    	mov.w     0x1d92, w9
    d8da:	0c 96 21    	mov.w     #0x1960, w12
    d8dc:	fa 06 46    	add.w     w12, #0x1a, w13

0000d8de <.L0>:
    d8de:	60 55 b8    	mul.uu    w10, #0x0, w10

0000d8e0 <.L31>:
    d8e0:	0a 01 be    	mov.d     w10, w2
    d8e2:	08 00 be    	mov.d     w8, w0
    d8e4:	c8 19 02    	call      0x19c8 <___nesf2>
    d8e6:	00 00 00 
    d8e8:	00 00 e0    	cp0.w     w0
    d8ea:	03 00 32    	bra       Z, 0xd8f2 <.L109>

0000d8ec <.L0>:
        AUAV_V3_TestSensors_B.Switch_i[i] =
    d8ec:	dc 08 90    	mov.w     [w12+26], w1
    d8ee:	01 0e 78    	mov.w     w1, [w12]
    d8f0:	02 00 37    	bra       0xd8f6 <.L30>

0000d8f2 <.L109>:
          AUAV_V3_TestSensors_B.HILRawReadingshilc1[i];
      } else {
        AUAV_V3_TestSensors_B.Switch_i[i] =
    d8f2:	2c 19 90    	mov.w     [w12+52], w2
    d8f4:	02 0e 78    	mov.w     w2, [w12]

0000d8f6 <.L30>:
    d8f6:	0c 86 e8    	inc2.w    w12, w12
    d8f8:	8d 0f 56    	sub.w     w12, w13, [w15]
    d8fa:	f2 ff 3a    	bra       NZ, 0xd8e0 <.L31>

0000d8fc <.L0>:
          AUAV_V3_TestSensors_B.HILRawReadingshilc1_k[i];
      }
    }

    /* End of Switch: '<S580>/Switch' */
  }

  /* End of Outputs for SubSystem: '<S16>/Raw HIL  Readings' */

  /* Logic: '<S581>/Logical Operator' */
  rtb_LogicalOperator = !(AUAV_V3_TestSensors_B.HILManualSwitch != 0.0);
    d8fc:	18 c0 b3    	mov.b     #0x1, w8
    d8fe:	60 11 b8    	mul.uu    w2, #0x0, w2
    d900:	f0 ae 80    	mov.w     0x15de, w0
    d902:	01 af 80    	mov.w     0x15e0, w1
    d904:	c8 19 02    	call      0x19c8 <___nesf2>
    d906:	00 00 00 
    d908:	00 00 e0    	cp0.w     w0
    d90a:	01 00 3a    	bra       NZ, 0xd90e <.L32>
    d90c:	00 44 eb    	clr.b     w8

0000d90e <.L32>:
    d90e:	08 04 a2    	btg.b     w8, #0x0
    d910:	88 f7 9f    	mov.b     w8, [w15-16]

0000d912 <.L0>:

  /* Outputs for Enabled SubSystem: '<S581>/If no HIL then Read all the Sensors' incorporates:
   *  EnablePort: '<S591>/Enable'
   */
  if (rtb_LogicalOperator) {
    d912:	88 41 78    	mov.b     w8, w3
    d914:	03 04 e0    	cp0.b     w3
    d916:	9d 00 32    	bra       Z, 0xda52 <.L0> <.L33>

0000d918 <.L0>:
    /* DataTypeConversion: '<S591>/Data Type Conversion' incorporates:
     *  DataStoreRead: '<S591>/Get mlAirData1'
     */
    rtb_Sum_o = (real32_T)floor(mlAirData.press_abs);
    d918:	e0 83 80    	mov.w     0x107c, w0
    d91a:	f1 83 80    	mov.w     0x107e, w1
    d91c:	16 19 02    	call      0x1916 <_floorf>
    d91e:	00 00 00 
    d920:	00 04 be    	mov.d     w0, w8

0000d922 <.L0>:
    if (rtIsNaNF(rtb_Sum_o) || rtIsInfF(rtb_Sum_o)) {
    d922:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    d924:	01 00 00 
    d926:	00 04 e0    	cp0.b     w0
    d928:	93 03 3a    	bra       NZ, 0xe050 <.L34>
    d92a:	08 00 be    	mov.d     w8, w0
    d92c:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    d92e:	01 00 00 
    d930:	00 04 e0    	cp0.b     w0
    d932:	8e 03 3a    	bra       NZ, 0xe050 <.L34>

0000d934 <.L0>:
      rtb_Sum_o = 0.0F;
    } else {
      rtb_Sum_o = (real32_T)fmod(rtb_Sum_o, 65536.0F);
    d934:	02 00 20    	mov.w     #0x0, w2
    d936:	03 78 24    	mov.w     #0x4780, w3
    d938:	08 00 be    	mov.d     w8, w0
    d93a:	26 19 02    	call      0x1926 <_fmodf>
    d93c:	00 00 00 
    d93e:	00 04 be    	mov.d     w0, w8

0000d940 <.L0>:
    }

    i = rtb_Sum_o < 0.0F ? -(int16_T)(uint16_T)-rtb_Sum_o : (int16_T)(uint16_T)
    d940:	60 11 b8    	mul.uu    w2, #0x0, w2
    d942:	8c 18 02    	call      0x188c <___eqsf2>
    d944:	00 00 00 
    d946:	00 00 e0    	cp0.w     w0
    d948:	06 00 3d    	bra       GE, 0xd956 <.L35>
    d94a:	08 00 be    	mov.d     w8, w0
    d94c:	01 f0 a2    	btg.w     w1, #0xf
    d94e:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d950:	00 00 00 
    d952:	80 06 ea    	neg.w     w0, w13
    d954:	04 00 37    	bra       0xd95e <.L0> <.L0> <.L37>

0000d956 <.L35>:
    d956:	08 00 be    	mov.d     w8, w0
    d958:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d95a:	00 00 00 
    d95c:	80 06 78    	mov.w     w0, w13

0000d95e <.L0>:
      rtb_Sum_o;

    /* End of DataTypeConversion: '<S591>/Data Type Conversion' */

    /* MATLAB Function: '<S591>/Embedded MATLAB Function1' incorporates:
     *  Constant: '<S591>/Constant1'
     */
    EmbeddedMATLABFunction1_m(AUAV_V3_TestSensors_ConstP.pooled16,
    d95e:	01 b8 21    	mov.w     #0x1b80, w1
    d960:	c0 72 2c    	mov.w     #0xc72c, w0
    d962:	7a fe 07    	rcall     0xd658 <_EmbeddedMATLABFunction1_m> <L0> <.L0> <.LFB1465> <.LFE1487> <.Letext0> <.Ltext0>

0000d964 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_ib);

    /* DataTypeConversion: '<S591>/Data Type Conversion1' */
    tmp_0 = floor(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_ib.y);
    d964:	00 dc 80    	mov.w     0x1b80, w0
    d966:	11 dc 80    	mov.w     0x1b82, w1
    d968:	16 19 02    	call      0x1916 <_floorf>
    d96a:	00 00 00 
    d96c:	00 04 be    	mov.d     w0, w8

0000d96e <.L0>:
    if (rtIsNaN(tmp_0) || rtIsInf(tmp_0)) {
    d96e:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    d970:	01 00 00 
    d972:	00 04 e0    	cp0.b     w0
    d974:	6f 03 3a    	bra       NZ, 0xe054 <.L38>
    d976:	08 00 be    	mov.d     w8, w0
    d978:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    d97a:	01 00 00 
    d97c:	00 04 e0    	cp0.b     w0
    d97e:	6a 03 3a    	bra       NZ, 0xe054 <.L38>

0000d980 <.L0>:
      tmp_0 = 0.0;
    } else {
      tmp_0 = fmod(tmp_0, 65536.0);
    d980:	02 00 20    	mov.w     #0x0, w2
    d982:	03 78 24    	mov.w     #0x4780, w3
    d984:	08 00 be    	mov.d     w8, w0
    d986:	26 19 02    	call      0x1926 <_fmodf>
    d988:	00 00 00 
    d98a:	00 04 be    	mov.d     w0, w8

0000d98c <.L0>:
    }

    rtb_DataTypeConversion1_ax = tmp_0 < 0.0 ? -(int16_T)(uint16_T)-tmp_0 :
    d98c:	60 11 b8    	mul.uu    w2, #0x0, w2
    d98e:	8c 18 02    	call      0x188c <___eqsf2>
    d990:	00 00 00 
    d992:	00 00 e0    	cp0.w     w0
    d994:	06 00 3d    	bra       GE, 0xd9a2 <.L0> <.L0> <.L39>
    d996:	08 00 be    	mov.d     w8, w0
    d998:	01 f0 a2    	btg.w     w1, #0xf
    d99a:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d99c:	00 00 00 
    d99e:	00 06 ea    	neg.w     w0, w12
    d9a0:	04 00 37    	bra       0xd9aa <.L0> <.L0> <.L41>

0000d9a2 <.L0>:
      (int16_T)(uint16_T)tmp_0;
    d9a2:	08 00 be    	mov.d     w8, w0
    d9a4:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d9a6:	00 00 00 
    d9a8:	00 06 78    	mov.w     w0, w12

0000d9aa <.L0>:

    /* End of DataTypeConversion: '<S591>/Data Type Conversion1' */

    /* MATLAB Function: '<S591>/Embedded MATLAB Function2' incorporates:
     *  Constant: '<S591>/Constant2'
     */
    EmbeddedMATLABFunction1_m(AUAV_V3_TestSensors_ConstP.pooled16,
    d9aa:	c1 b7 21    	mov.w     #0x1b7c, w1
    d9ac:	c0 72 2c    	mov.w     #0xc72c, w0
    d9ae:	54 fe 07    	rcall     0xd658 <_EmbeddedMATLABFunction1_m> <L0> <.L0> <.LFB1465> <.LFE1487> <.Letext0> <.Ltext0>

0000d9b0 <.L0>:
      &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_p);

    /* DataTypeConversion: '<S591>/Data Type Conversion2' */
    tmp_0 = floor(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_p.y);
    d9b0:	e0 db 80    	mov.w     0x1b7c, w0
    d9b2:	f1 db 80    	mov.w     0x1b7e, w1
    d9b4:	16 19 02    	call      0x1916 <_floorf>
    d9b6:	00 00 00 
    d9b8:	00 04 be    	mov.d     w0, w8

0000d9ba <.L0>:
    if (rtIsNaN(tmp_0) || rtIsInf(tmp_0)) {
    d9ba:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    d9bc:	01 00 00 
    d9be:	00 04 e0    	cp0.b     w0
    d9c0:	4b 03 3a    	bra       NZ, 0xe058 <.L42>
    d9c2:	08 00 be    	mov.d     w8, w0
    d9c4:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    d9c6:	01 00 00 
    d9c8:	00 04 e0    	cp0.b     w0
    d9ca:	46 03 3a    	bra       NZ, 0xe058 <.L42>

0000d9cc <.L0>:
      tmp_0 = 0.0;
    } else {
      tmp_0 = fmod(tmp_0, 65536.0);
    d9cc:	02 00 20    	mov.w     #0x0, w2
    d9ce:	03 78 24    	mov.w     #0x4780, w3
    d9d0:	08 00 be    	mov.d     w8, w0
    d9d2:	26 19 02    	call      0x1926 <_fmodf>
    d9d4:	00 00 00 
    d9d6:	00 04 be    	mov.d     w0, w8

0000d9d8 <.L0>:
    }

    rtb_DataTypeConversion2_c = tmp_0 < 0.0 ? -(int16_T)(uint16_T)-tmp_0 :
    d9d8:	60 11 b8    	mul.uu    w2, #0x0, w2
    d9da:	8c 18 02    	call      0x188c <___eqsf2>
    d9dc:	00 00 00 
    d9de:	00 00 e0    	cp0.w     w0
    d9e0:	06 00 3d    	bra       GE, 0xd9ee <.L0> <.L0> <.L43>
    d9e2:	08 00 be    	mov.d     w8, w0
    d9e4:	01 f0 a2    	btg.w     w1, #0xf
    d9e6:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d9e8:	00 00 00 
    d9ea:	00 05 ea    	neg.w     w0, w10
    d9ec:	04 00 37    	bra       0xd9f6 <.L0> <.L0> <.L45>

0000d9ee <.L0>:
      (int16_T)(uint16_T)tmp_0;
    d9ee:	08 00 be    	mov.d     w8, w0
    d9f0:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    d9f2:	00 00 00 
    d9f4:	00 05 78    	mov.w     w0, w10

0000d9f6 <.L0>:

    /* End of DataTypeConversion: '<S591>/Data Type Conversion2' */

    /* MATLAB Function: '<S591>/myMux Fun' incorporates:
     *  DataStoreRead: '<S591>/Get mlAirData2'
     */
    AUAV_V3_TestSenso_myMuxFun(i, rtb_DataTypeConversion1_ax,
    d9f6:	48 08 21    	mov.w     #0x1084, w8
    d9f8:	44 b7 21    	mov.w     #0x1b74, w4
    d9fa:	98 01 78    	mov.w     [w8], w3
    d9fc:	0a 01 78    	mov.w     w10, w2
    d9fe:	8c 00 78    	mov.w     w12, w1
    da00:	0d 00 78    	mov.w     w13, w0
    da02:	44 fe 07    	rcall     0xd68c <_AUAV_V3_TestSenso_myMuxFun> <L0> <.LFB1466> <.LFE1465>

0000da04 <.L0>:
      rtb_DataTypeConversion2_c, mlAirData.temperature,
      &AUAV_V3_TestSensors_B.sf_myMuxFun_n);

    /* S-Function (MCHP_C_function_Call): '<S591>/Update State AP ADC Data [updateSensorMcuState.c]1' */
    updateRawADCData(
    da04:	40 b7 21    	mov.w     #0x1b74, w0
    da06:	42 fb 02    	call      0xfb42 <_updateRawADCData>
    da08:	00 00 00 

0000da0a <.L0>:
                     &AUAV_V3_TestSensors_B.sf_myMuxFun_n.y[0]
                     );

    /* S-Function (MCHP_C_function_Call): '<S591>/Read the Cube Data [adisCube16405.c]1' */
    getCubeData(
    da0a:	20 93 21    	mov.w     #0x1932, w0
    da0c:	a0 0c 02    	call      0x10ca0 <_getCubeData>
    da0e:	01 00 00 

0000da10 <.L0>:
                &AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[0]
                );

    /* MATLAB Function: '<S591>/myMux Fun4' incorporates:
     *  DataStoreRead: '<S591>/Get mlAirData2'
     */
    /* MATLAB Function 'Sensor_Data_Adapter/Sensor Suite/If no HIL then Read all the Sensors/myMux Fun4': '<S621>:1' */
    /*  This block supports an embeddable subset of the MATLAB language. */
    /*  See the help menu for details.  */
    /* '<S621>:1:5' */
    AUAV_V3_TestSensors_B.y_l[0] =
    da10:	90 c9 80    	mov.w     0x1932, w0
    da12:	30 ca 88    	mov.w     w0, 0x1946
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[0];
    AUAV_V3_TestSensors_B.y_l[1] =
    da14:	a1 c9 80    	mov.w     0x1934, w1
    da16:	41 ca 88    	mov.w     w1, 0x1948
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[1];
    AUAV_V3_TestSensors_B.y_l[2] =
    da18:	b2 c9 80    	mov.w     0x1936, w2
    da1a:	52 ca 88    	mov.w     w2, 0x194a
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[2];
    AUAV_V3_TestSensors_B.y_l[3] =
    da1c:	c3 c9 80    	mov.w     0x1938, w3
    da1e:	63 ca 88    	mov.w     w3, 0x194c
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[3];
    AUAV_V3_TestSensors_B.y_l[4] =
    da20:	d0 c9 80    	mov.w     0x193a, w0
    da22:	70 ca 88    	mov.w     w0, 0x194e
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[4];
    AUAV_V3_TestSensors_B.y_l[5] =
    da24:	e1 c9 80    	mov.w     0x193c, w1
    da26:	81 ca 88    	mov.w     w1, 0x1950
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[5];
    AUAV_V3_TestSensors_B.y_l[6] =
    da28:	f2 c9 80    	mov.w     0x193e, w2
    da2a:	92 ca 88    	mov.w     w2, 0x1952
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[6];
    AUAV_V3_TestSensors_B.y_l[7] =
    da2c:	03 ca 80    	mov.w     0x1940, w3
    da2e:	a3 ca 88    	mov.w     w3, 0x1954
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[7];
    AUAV_V3_TestSensors_B.y_l[8] =
    da30:	10 ca 80    	mov.w     0x1942, w0
    da32:	b0 ca 88    	mov.w     w0, 0x1956
      AUAV_V3_TestSensors_B.ReadtheCubeDataadisCube16405c1[8];
    AUAV_V3_TestSensors_B.y_l[9] = i;
    da34:	cd ca 88    	mov.w     w13, 0x1958
    AUAV_V3_TestSensors_B.y_l[10] = rtb_DataTypeConversion1_ax;
    da36:	dc ca 88    	mov.w     w12, 0x195a
    AUAV_V3_TestSensors_B.y_l[11] = rtb_DataTypeConversion2_c;
    da38:	ea ca 88    	mov.w     w10, 0x195c

0000da3a <.L0>:
    AUAV_V3_TestSensors_B.y_l[12] = mlAirData.temperature;
    da3a:	18 04 78    	mov.w     [w8], w8
    da3c:	f8 ca 88    	mov.w     w8, 0x195e

0000da3e <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S591>/Is the GPS Novatel or Ublox? [gpsPort.c]1' */
    AUAV_V3_TestSensors_B.IstheGPSNovatelorUbloxgpsPortc1 = isGPSNovatel(
    da3e:	e8 11 02    	call      0x111e8 <_isGPSNovatel>
    da40:	01 00 00 
    da42:	91 a2 21    	mov.w     #0x1a29, w1
    da44:	80 48 78    	mov.b     w0, [w1]
      );

    /* Outputs for Enabled SubSystem: '<S591>/if GPS is Ublox' incorporates:
     *  EnablePort: '<S619>/Enable'
     */
    /* Logic: '<S591>/Logical Operator' */
    if (!(AUAV_V3_TestSensors_B.IstheGPSNovatelorUbloxgpsPortc1 != 0)) {
    da46:	00 04 e0    	cp0.b     w0
    da48:	04 00 3a    	bra       NZ, 0xda52 <.L0> <.L33>

0000da4a <.L0>:
      /* S-Function (MCHP_C_function_Call): '<S619>/Produce the GPS Main Data and update the AP State (lat lon hei cog sog) [gpsUblox.c]1' */
      getGpsUbloxMainData(
    da4a:	90 ca 2f    	mov.w     #0xfca9, w0
    da4c:	01 00 40    	add.w     w0, w1, w0
    da4e:	f8 e0 02    	call      0xe0f8 <_getGpsUbloxMainData>
    da50:	00 00 00 

0000da52 <.L0>:
                          &AUAV_V3_TestSensors_B.ProducetheGPSMainDataandupdat_a[
                          0]
                          );
    }

    /* End of Logic: '<S591>/Logical Operator' */
    /* End of Outputs for SubSystem: '<S591>/if GPS is Ublox' */
  }

  /* End of Outputs for SubSystem: '<S581>/If no HIL then Read all the Sensors' */

  /* Switch: '<S581>/Switch' */
  for (i = 0; i < 13; i++) {
    if (AUAV_V3_TestSensors_B.HILManualSwitch != 0.0) {
    da52:	f8 ae 80    	mov.w     0x15de, w8
    da54:	09 af 80    	mov.w     0x15e0, w9
    da56:	0c 96 21    	mov.w     #0x1960, w12
    da58:	6e fd 2f    	mov.w     #0xffd6, w14
    da5a:	0f 07 47    	add.w     w14, w15, w14
    da5c:	fa 06 46    	add.w     w12, #0x1a, w13

0000da5e <.L0>:
    da5e:	60 55 b8    	mul.uu    w10, #0x0, w10

0000da60 <.L49>:
    da60:	0a 01 be    	mov.d     w10, w2
    da62:	08 00 be    	mov.d     w8, w0
    da64:	c8 19 02    	call      0x19c8 <___nesf2>
    da66:	00 00 00 
    da68:	00 00 e0    	cp0.w     w0
    da6a:	02 00 32    	bra       Z, 0xda70 <.L110>

0000da6c <.L0>:
      rtb_Switch_d[i] = AUAV_V3_TestSensors_B.Switch_i[i];
    da6c:	1c 0f 78    	mov.w     [w12], [w14]
    da6e:	02 00 37    	bra       0xda74 <.L48>

0000da70 <.L110>:
    } else {
      rtb_Switch_d[i] = AUAV_V3_TestSensors_B.y_l[i];
    da70:	bc b0 97    	mov.w     [w12-26], w1
    da72:	01 0f 78    	mov.w     w1, [w14]

0000da74 <.L48>:
    da74:	0c 86 e8    	inc2.w    w12, w12
    da76:	0e 87 e8    	inc2.w    w14, w14
    da78:	8d 0f 56    	sub.w     w12, w13, [w15]
    da7a:	f2 ff 3a    	bra       NZ, 0xda60 <.L49>

0000da7c <.L0>:
    }
  }

  /* End of Switch: '<S581>/Switch' */

  /* MATLAB Function: '<S629>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S629>/Constant'
   *  Constant: '<S629>/Constant1'
   *  DataTypeConversion: '<S593>/Data Type Conversion5'
   */
  A_EmbeddedMATLABFunction_f((real_T)rtb_Switch_d[12], 0.01, 0.02,
    da7c:	7f b0 97    	mov.w     [w15-18], w0
    da7e:	cf 80 de    	asr.w     w0, #0xf, w1
    da80:	0c 19 02    	call      0x190c <___floatsisf>
    da82:	00 00 00 
    da84:	e7 0a 22    	mov.w     #0x20ae, w7
    da86:	86 b6 21    	mov.w     #0x1b68, w6
    da88:	a4 70 2d    	mov.w     #0xd70a, w4
    da8a:	35 ca 23    	mov.w     #0x3ca3, w5
    da8c:	a2 70 2d    	mov.w     #0xd70a, w2
    da8e:	33 c2 23    	mov.w     #0x3c23, w3
    da90:	05 fe 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000da92 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_g,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_g);

  /* Sum: '<S628>/Sum' incorporates:
   *  Constant: '<S628>/Bias'
   *  Product: '<S628>/Divide'
   */
  rtb_Sum_o = (real32_T)(1.5112853050231934 *
    da92:	c2 1c 27    	mov.w     #0x71cc, w2
    da94:	13 fc 23    	mov.w     #0x3fc1, w3
    da96:	40 db 80    	mov.w     0x1b68, w0
    da98:	51 db 80    	mov.w     0x1b6a, w1
    da9a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    da9c:	00 00 00 
    da9e:	62 90 2a    	mov.w     #0xa906, w2
    daa0:	83 4c 24    	mov.w     #0x44c8, w3
    daa2:	90 14 02    	call      0x1490 <___subsf3>
    daa4:	00 00 00 
    daa6:	00 04 be    	mov.d     w0, w8

0000daa8 <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_g.y) + -1605.28198F;

  /* RelationalOperator: '<S641>/Compare' incorporates:
   *  Constant: '<S641>/Constant'
   */
  rtb_Compare_gl = (uint8_T)(rtb_Sum_o < -130.0F);
    daa8:	1a c0 b3    	mov.b     #0x1, w10
    daaa:	02 00 20    	mov.w     #0x0, w2
    daac:	23 30 2c    	mov.w     #0xc302, w3
    daae:	8c 18 02    	call      0x188c <___eqsf2>
    dab0:	00 00 00 
    dab2:	00 00 e0    	cp0.w     w0
    dab4:	01 00 35    	bra       LT, 0xdab8 <.L0> <.L51>
    dab6:	00 45 eb    	clr.b     w10

0000dab8 <.L0>:

  /* Outputs for Enabled SubSystem: '<S626>/Hi Temp Compensation2' incorporates:
   *  EnablePort: '<S642>/Enable'
   */
  /* Logic: '<S626>/Logical Operator' */
  if (!(rtb_Compare_gl != 0)) {
    dab8:	0a 04 e0    	cp0.b     w10
    daba:	15 00 3a    	bra       NZ, 0xdae6 <.L0> <.L0> <.L50>

0000dabc <.L0>:
    /* Sum: '<S642>/Sum2' incorporates:
     *  Constant: '<S642>/Mean Temperature for Calibration'
     *  Constant: '<S642>/gains'
     *  Product: '<S642>/Divide1'
     *  Sum: '<S642>/Sum1'
     */
    AUAV_V3_TestSensors_B.Merge = (real32_T)rtb_Switch_d[10] - (rtb_Sum_o -
    dabc:	5f b0 97    	mov.w     [w15-22], w0
    dabe:	cf 80 de    	asr.w     w0, #0xf, w1
    dac0:	0c 19 02    	call      0x190c <___floatsisf>
    dac2:	00 00 00 
    dac4:	00 05 be    	mov.d     w0, w10
    dac6:	92 6c 28    	mov.w     #0x86c9, w2
    dac8:	23 39 24    	mov.w     #0x4392, w3
    daca:	08 00 be    	mov.d     w8, w0
    dacc:	90 14 02    	call      0x1490 <___subsf3>
    dace:	00 00 00 

0000dad0 <.L0>:
      293.053F) * -0.0950433F;
    dad0:	02 61 2a    	mov.w     #0xa610, w2
    dad2:	23 dc 23    	mov.w     #0x3dc2, w3
    dad4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dad6:	00 00 00 
    dad8:	00 01 be    	mov.d     w0, w2

0000dada <.L0>:
    dada:	0a 00 be    	mov.d     w10, w0
    dadc:	92 14 02    	call      0x1492 <___addsf3>
    dade:	00 00 00 
    dae0:	70 b2 88    	mov.w     w0, 0x164e
    dae2:	81 b2 88    	mov.w     w1, 0x1650
    dae4:	18 00 37    	bra       0xdb16 <.L0> <.L52>

0000dae6 <.L0>:
  }

  /* End of Logic: '<S626>/Logical Operator' */
  /* End of Outputs for SubSystem: '<S626>/Hi Temp Compensation2' */

  /* Outputs for Enabled SubSystem: '<S626>/Lo Temp Compensation' incorporates:
   *  EnablePort: '<S643>/Enable'
   */
  if (rtb_Compare_gl > 0) {
    /* Sum: '<S643>/Add' incorporates:
     *  Constant: '<S643>/Constant'
     *  Constant: '<S643>/Mean Temperature for Calibration'
     *  Constant: '<S643>/gains'
     *  Product: '<S643>/Divide1'
     *  Sum: '<S643>/Sum1'
     *  Sum: '<S643>/Sum2'
     */
    AUAV_V3_TestSensors_B.Merge = ((real32_T)rtb_Switch_d[10] - (rtb_Sum_o -
    dae6:	5f b0 97    	mov.w     [w15-22], w0
    dae8:	cf 80 de    	asr.w     w0, #0xf, w1
    daea:	0c 19 02    	call      0x190c <___floatsisf>
    daec:	00 00 00 
    daee:	00 05 be    	mov.d     w0, w10
    daf0:	42 e1 2e    	mov.w     #0xee14, w2
    daf2:	a3 34 24    	mov.w     #0x434a, w3
    daf4:	08 00 be    	mov.d     w8, w0
    daf6:	92 14 02    	call      0x1492 <___addsf3>
    daf8:	00 00 00 

0000dafa <.L0>:
      -202.93F) * -0.0552923F) + -41.0F;
    dafa:	e2 a2 27    	mov.w     #0x7a2e, w2
    dafc:	23 d6 23    	mov.w     #0x3d62, w3
    dafe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    db00:	00 00 00 
    db02:	00 01 be    	mov.d     w0, w2

0000db04 <.L0>:
    db04:	0a 00 be    	mov.d     w10, w0
    db06:	92 14 02    	call      0x1492 <___addsf3>
    db08:	00 00 00 

0000db0a <.L0>:
    db0a:	02 00 20    	mov.w     #0x0, w2
    db0c:	43 22 24    	mov.w     #0x4224, w3
    db0e:	90 14 02    	call      0x1490 <___subsf3>
    db10:	00 00 00 

0000db12 <.L0>:
    db12:	70 b2 88    	mov.w     w0, 0x164e
    db14:	81 b2 88    	mov.w     w1, 0x1650

0000db16 <.L0>:
  }

  /* End of Outputs for SubSystem: '<S626>/Lo Temp Compensation' */

  /* MATLAB Function: '<S631>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S631>/Constant'
   *  Constant: '<S631>/Constant1'
   *  DataTypeConversion: '<S593>/Data Type Conversion3'
   */
  A_EmbeddedMATLABFunction_f((real_T)AUAV_V3_TestSensors_B.Merge, 0.01, 4.0,
    db16:	a7 08 22    	mov.w     #0x208a, w7
    db18:	06 b6 21    	mov.w     #0x1b60, w6
    db1a:	04 00 20    	mov.w     #0x0, w4
    db1c:	05 08 24    	mov.w     #0x4080, w5
    db1e:	a2 70 2d    	mov.w     #0xd70a, w2
    db20:	33 c2 23    	mov.w     #0x3c23, w3
    db22:	70 b2 80    	mov.w     0x164e, w0
    db24:	81 b2 80    	mov.w     0x1650, w1
    db26:	ba fd 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000db28 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_lw,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_lw);

  /* Sum: '<S624>/Sum' incorporates:
   *  Constant: '<S624>/Bias'
   *  Constant: '<S624>/Gains'
   *  DataTypeConversion: '<S593>/Data Type Conversion4'
   *  Product: '<S624>/Divide'
   */
  rtb_u001maxDynPress = 1.05137849F * (real32_T)
    db28:	22 39 29    	mov.w     #0x9392, w2
    db2a:	63 f8 23    	mov.w     #0x3f86, w3
    db2c:	00 db 80    	mov.w     0x1b60, w0
    db2e:	11 db 80    	mov.w     0x1b62, w1
    db30:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    db32:	00 00 00 
    db34:	d2 83 27    	mov.w     #0x783d, w2
    db36:	b3 47 24    	mov.w     #0x447b, w3
    db38:	90 14 02    	call      0x1490 <___subsf3>
    db3a:	00 00 00 
    db3c:	00 05 be    	mov.d     w0, w10

0000db3e <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_lw.y + -1005.87872F;

  /* Saturate: '<S593>/[0.001  maxDynPress]' */
  if (rtb_u001maxDynPress > 3000.0F) {
    db3e:	02 00 28    	mov.w     #0x8000, w2
    db40:	b3 53 24    	mov.w     #0x453b, w3
    db42:	90 18 02    	call      0x1890 <___gesf2>
    db44:	00 00 00 
    db46:	00 00 e0    	cp0.w     w0
    db48:	08 00 3c    	bra       GT, 0xdb5a <.L0> <.L84>

0000db4a <.L0>:
    rtb_u001maxDynPress = 3000.0F;
  } else {
    if (rtb_u001maxDynPress < 0.001F) {
    db4a:	f2 26 21    	mov.w     #0x126f, w2
    db4c:	33 a8 23    	mov.w     #0x3a83, w3
    db4e:	0a 00 be    	mov.d     w10, w0
    db50:	8c 18 02    	call      0x188c <___eqsf2>
    db52:	00 00 00 
    db54:	00 00 e0    	cp0.w     w0
    db56:	04 00 35    	bra       LT, 0xdb60 <.L85>
    db58:	05 00 37    	bra       0xdb64 <.L0> <.L53>

0000db5a <.L0>:
    db5a:	0a 00 28    	mov.w     #0x8000, w10
    db5c:	bb 53 24    	mov.w     #0x453b, w11
    db5e:	02 00 37    	bra       0xdb64 <.L0> <.L53>

0000db60 <.L85>:
      rtb_u001maxDynPress = 0.001F;
    db60:	fa 26 21    	mov.w     #0x126f, w10
    db62:	3b a8 23    	mov.w     #0x3a83, w11

0000db64 <.L0>:
    }
  }

  /* End of Saturate: '<S593>/[0.001  maxDynPress]' */

  /* RelationalOperator: '<S644>/Compare' incorporates:
   *  Constant: '<S644>/Constant'
   */
  rtb_Compare_gl = (uint8_T)(rtb_Sum_o < -50.0F);
    db64:	1c c0 b3    	mov.b     #0x1, w12
    db66:	02 00 20    	mov.w     #0x0, w2
    db68:	83 24 2c    	mov.w     #0xc248, w3
    db6a:	08 00 be    	mov.d     w8, w0
    db6c:	8c 18 02    	call      0x188c <___eqsf2>
    db6e:	00 00 00 
    db70:	00 00 e0    	cp0.w     w0
    db72:	01 00 35    	bra       LT, 0xdb76 <.L0> <.L55>
    db74:	00 46 eb    	clr.b     w12

0000db76 <.L0>:

  /* Outputs for Enabled SubSystem: '<S627>/Hi Temp Compensation' incorporates:
   *  EnablePort: '<S645>/Enable'
   */
  /* Logic: '<S627>/Logical Operator' */
  if (!(rtb_Compare_gl != 0)) {
    db76:	0c 04 e0    	cp0.b     w12
    db78:	19 00 3a    	bra       NZ, 0xdbac <.L0> <.L54>

0000db7a <.L0>:
    /* Sum: '<S645>/Add' incorporates:
     *  Constant: '<S645>/Constant'
     *  Constant: '<S645>/Mean Temperature for Calibration'
     *  Constant: '<S645>/gains'
     *  Product: '<S645>/Divide1'
     *  Sum: '<S645>/Sum1'
     *  Sum: '<S645>/Sum2'
     */
    AUAV_V3_TestSensors_B.Merge_j = ((real32_T)rtb_Switch_d[9] - (rtb_Sum_o -
    db7a:	4f b0 97    	mov.w     [w15-24], w0
    db7c:	cf 80 de    	asr.w     w0, #0xf, w1
    db7e:	0c 19 02    	call      0x190c <___floatsisf>
    db80:	00 00 00 
    db82:	00 06 be    	mov.d     w0, w12
    db84:	12 d7 29    	mov.w     #0x9d71, w2
    db86:	d3 3a 24    	mov.w     #0x43ad, w3
    db88:	08 00 be    	mov.d     w8, w0
    db8a:	90 14 02    	call      0x1490 <___subsf3>
    db8c:	00 00 00 

0000db8e <.L0>:
      347.23F) * 0.0207608F) + -6.0F;
    db8e:	e2 28 21    	mov.w     #0x128e, w2
    db90:	a3 ca 23    	mov.w     #0x3caa, w3
    db92:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    db94:	00 00 00 
    db96:	00 01 be    	mov.d     w0, w2

0000db98 <.L0>:
    db98:	0c 00 be    	mov.d     w12, w0
    db9a:	90 14 02    	call      0x1490 <___subsf3>
    db9c:	00 00 00 

0000db9e <.L0>:
    db9e:	02 00 20    	mov.w     #0x0, w2
    dba0:	03 0c 24    	mov.w     #0x40c0, w3
    dba2:	90 14 02    	call      0x1490 <___subsf3>
    dba4:	00 00 00 

0000dba6 <.L0>:
    dba6:	90 b2 88    	mov.w     w0, 0x1652
    dba8:	a1 b2 88    	mov.w     w1, 0x1654
    dbaa:	14 00 37    	bra       0xdbd4 <.L0> <.L0> <.L56>

0000dbac <.L0>:
  }

  /* End of Logic: '<S627>/Logical Operator' */
  /* End of Outputs for SubSystem: '<S627>/Hi Temp Compensation' */

  /* Outputs for Enabled SubSystem: '<S627>/Lo Temp Compensation' incorporates:
   *  EnablePort: '<S646>/Enable'
   */
  if (rtb_Compare_gl > 0) {
    /* Sum: '<S646>/Sum2' incorporates:
     *  Constant: '<S646>/Mean Temperature for Calibration'
     *  Constant: '<S646>/gains'
     *  Product: '<S646>/Divide1'
     *  Sum: '<S646>/Sum1'
     */
    AUAV_V3_TestSensors_B.Merge_j = (real32_T)rtb_Switch_d[9] - (rtb_Sum_o -
    dbac:	4f b0 97    	mov.w     [w15-24], w0
    dbae:	cf 80 de    	asr.w     w0, #0xf, w1
    dbb0:	0c 19 02    	call      0x190c <___floatsisf>
    dbb2:	00 00 00 
    dbb4:	00 06 be    	mov.d     w0, w12
    dbb6:	d2 cc 24    	mov.w     #0x4ccd, w2
    dbb8:	13 32 24    	mov.w     #0x4321, w3
    dbba:	08 00 be    	mov.d     w8, w0
    dbbc:	92 14 02    	call      0x1492 <___addsf3>
    dbbe:	00 00 00 

0000dbc0 <.L0>:
      -161.3F) * -0.0102663F;
    dbc0:	c2 3f 23    	mov.w     #0x33fc, w2
    dbc2:	83 c2 23    	mov.w     #0x3c28, w3
    dbc4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dbc6:	00 00 00 
    dbc8:	00 01 be    	mov.d     w0, w2

0000dbca <.L0>:
    dbca:	0c 00 be    	mov.d     w12, w0
    dbcc:	92 14 02    	call      0x1492 <___addsf3>
    dbce:	00 00 00 
    dbd0:	90 b2 88    	mov.w     w0, 0x1652
    dbd2:	a1 b2 88    	mov.w     w1, 0x1654

0000dbd4 <.L0>:
  }

  /* End of Outputs for SubSystem: '<S627>/Lo Temp Compensation' */

  /* MATLAB Function: '<S632>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S632>/Constant'
   *  Constant: '<S632>/Constant1'
   *  DataTypeConversion: '<S593>/Data Type Conversion19'
   */
  A_EmbeddedMATLABFunction_f((real_T)AUAV_V3_TestSensors_B.Merge_j, 0.01, 4.0,
    dbd4:	87 07 22    	mov.w     #0x2078, w7
    dbd6:	c6 b5 21    	mov.w     #0x1b5c, w6
    dbd8:	04 00 20    	mov.w     #0x0, w4
    dbda:	05 08 24    	mov.w     #0x4080, w5
    dbdc:	a2 70 2d    	mov.w     #0xd70a, w2
    dbde:	33 c2 23    	mov.w     #0x3c23, w3
    dbe0:	90 b2 80    	mov.w     0x1652, w0
    dbe2:	a1 b2 80    	mov.w     0x1654, w1
    dbe4:	5b fd 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000dbe6 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_cn,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_cn);

  /* Sum: '<S623>/Sum' incorporates:
   *  Constant: '<S623>/Bias'
   *  Constant: '<S623>/Gains'
   *  DataTypeConversion: '<S593>/Data Type Conversion1'
   *  Product: '<S623>/Divide'
   */
  rtb_Sum_d = 27.127F * (real32_T)
    dbe6:	92 41 20    	mov.w     #0x419, w2
    dbe8:	93 1d 24    	mov.w     #0x41d9, w3
    dbea:	e0 da 80    	mov.w     0x1b5c, w0
    dbec:	f1 da 80    	mov.w     0x1b5e, w1
    dbee:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dbf0:	00 00 00 
    dbf2:	72 1c 29    	mov.w     #0x91c7, w2
    dbf4:	33 61 24    	mov.w     #0x4613, w3
    dbf6:	92 14 02    	call      0x1492 <___addsf3>
    dbf8:	00 00 00 
    dbfa:	00 06 be    	mov.d     w0, w12

0000dbfc <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_cn.y + 9444.44434F;

  /* MATLAB Function: '<S581>/myMux Fun' */
  AUAV_V3_TestSe_myMuxFun1_e(rtb_u001maxDynPress, rtb_Sum_d, rtb_Sum_o,
    dbfc:	06 b5 21    	mov.w     #0x1b50, w6
    dbfe:	08 02 be    	mov.d     w8, w4
    dc00:	00 01 be    	mov.d     w0, w2
    dc02:	0a 00 be    	mov.d     w10, w0
    dc04:	68 12 02    	call      0x11268 <_AUAV_V3_TestSe_myMuxFun1_e>
    dc06:	01 00 00 

0000dc08 <.L0>:
    &AUAV_V3_TestSensors_B.sf_myMuxFun);

  /* Outputs for Enabled SubSystem: '<S581>/If no HIL then update Air Data' incorporates:
   *  EnablePort: '<S592>/Enable'
   */
  //if (rtb_LogicalOperator) {
    /* Inport: '<S592>/AirData' */
    AUAV_V3_TestSensors_B.AirData[0] = AUAV_V3_TestSensors_B.sf_myMuxFun.y[0];
    dc08:	68 6c 21    	mov.w     #0x16c6, w8
    dc0a:	82 da 80    	mov.w     0x1b50, w2
    dc0c:	93 da 80    	mov.w     0x1b52, w3
    dc0e:	02 8c be    	mov.d     w2, [w8]
    AUAV_V3_TestSensors_B.AirData[1] = AUAV_V3_TestSensors_B.sf_myMuxFun.y[1];
    dc10:	a0 da 80    	mov.w     0x1b54, w0
    dc12:	b1 da 80    	mov.w     0x1b56, w1
    dc14:	50 b6 88    	mov.w     w0, 0x16ca
    dc16:	61 b6 88    	mov.w     w1, 0x16cc
    AUAV_V3_TestSensors_B.AirData[2] = AUAV_V3_TestSensors_B.sf_myMuxFun.y[2];
    dc18:	c2 da 80    	mov.w     0x1b58, w2
    dc1a:	d3 da 80    	mov.w     0x1b5a, w3
    dc1c:	72 b6 88    	mov.w     w2, 0x16ce
    dc1e:	83 b6 88    	mov.w     w3, 0x16d0

0000dc20 <.L0>:

    /* S-Function (MCHP_C_function_Call): '<S592>/Update the Air Calibrated Data [updateSensorMcuState.c]1' */
    updateAirData(
    dc20:	08 00 78    	mov.w     w8, w0
    dc22:	92 fc 02    	call      0xfc92 <_updateAirData>
    dc24:	00 00 00 

0000dc26 <.L0>:
                  &AUAV_V3_TestSensors_B.AirData[0]
                  );
  //}

  /* End of Outputs for SubSystem: '<S581>/If no HIL then update Air Data' */

  /* MATLAB Function: '<S581>/myMux Fun1' */
  /* MATLAB Function 'Sensor_Data_Adapter/Sensor Suite/myMux Fun1': '<S595>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S595>:1:5' */
  AUAV_V3_TestSensors_B.y_o[0] = rtb_u001maxDynPress;
    dc26:	78 00 54    	sub.w     w8, #0x18, w0
    dc28:	0a 88 be    	mov.d     w10, [w0]
  AUAV_V3_TestSensors_B.y_o[1] = AUAV_V3_TestSensors_B.AirData[0];
    dc2a:	18 01 be    	mov.d     [w8], w2
    dc2c:	92 b5 88    	mov.w     w2, 0x16b2
    dc2e:	a3 b5 88    	mov.w     w3, 0x16b4
  AUAV_V3_TestSensors_B.y_o[2] = 0.0F;
    dc30:	60 11 b8    	mul.uu    w2, #0x0, w2
    dc32:	b2 b5 88    	mov.w     w2, 0x16b6
    dc34:	c3 b5 88    	mov.w     w3, 0x16b8

0000dc36 <.L0>:
  AUAV_V3_TestSensors_B.y_o[3] = 0.0F;
    dc36:	d2 b5 88    	mov.w     w2, 0x16ba
    dc38:	e3 b5 88    	mov.w     w3, 0x16bc

0000dc3a <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S581>/Sensor DSC Diag [updateSensorMcuState.c]1' */
  updateSensorDiag(
    dc3a:	4a ff 02    	call      0xff4a <_updateSensorDiag>
    dc3c:	00 00 00 
                   &AUAV_V3_TestSensors_B.y_o[0]
                   );

  /* S-Function "MCHP_MCU_LOAD" Block: <S590>/Calculus Time Step1 */
  AUAV_V3_TestSensors_B.CalculusTimeStep1 = MCHP_MCULoadResult[0];
    dc3e:	a0 82 80    	mov.w     0x1054, w0
    dc40:	30 cf 88    	mov.w     w0, 0x19e6

0000dc42 <.LBB2>:

  /* S-Function "MCHP_MCU_OVERLOAD" Block: <S590>/Calculus Time Step2 */
  {
    uint16_T register tmp = MCHP_MCU_Overload.val;
    dc42:	8a 24 82    	mov.w     0x4490, w10
    MCHP_MCU_Overload.val ^= tmp;      /* Multi Tasking: potential simultaneous access ==> using xor to protect from potential miss */
    dc44:	81 24 82    	mov.w     0x4490, w1
    dc46:	8a 80 68    	xor.w     w1, w10, w1
    dc48:	81 24 8a    	mov.w     w1, 0x4490
    AUAV_V3_TestSensors_B.CalculusTimeStep2 = tmp;
    dc4a:	4a cf 88    	mov.w     w10, 0x19e8

0000dc4c <.L0>:
  }

  /* DataTypeConversion: '<S590>/Data Type Conversion12' incorporates:
   *  DataTypeConversion: '<S590>/Data Type Conversion1'
   *  DataTypeConversion: '<S590>/Data Type Conversion2'
   *  Gain: '<S590>/Gain'
   *  Product: '<S590>/Divide'
   *  Rounding: '<S590>/Rounding Function'
   */
  tmp_0 = floor((real_T)AUAV_V3_TestSensors_B.CalculusTimeStep1 / (real_T)
    dc4c:	80 00 eb    	clr.w     w1
    dc4e:	12 19 02    	call      0x1912 <___floatunsisf>
    dc50:	00 00 00 
    dc52:	00 04 be    	mov.d     w0, w8
    dc54:	61 50 b8    	mul.uu    w10, #0x1, w0
    dc56:	12 19 02    	call      0x1912 <___floatunsisf>
    dc58:	00 00 00 
    dc5a:	00 01 be    	mov.d     w0, w2
    dc5c:	08 00 be    	mov.d     w8, w0
    dc5e:	26 17 02    	call      0x1726 <___divsf3>
    dc60:	00 00 00 

0000dc62 <.L0>:
                AUAV_V3_TestSensors_B.CalculusTimeStep2 * 100.0);
    dc62:	02 00 20    	mov.w     #0x0, w2
    dc64:	83 2c 24    	mov.w     #0x42c8, w3
    dc66:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dc68:	00 00 00 

0000dc6a <.L0>:
    dc6a:	16 19 02    	call      0x1916 <_floorf>
    dc6c:	00 00 00 
    dc6e:	00 04 be    	mov.d     w0, w8

0000dc70 <.L0>:
  if (rtIsNaN(tmp_0) || rtIsInf(tmp_0)) {
    dc70:	0c 0e 02    	call      0x10e0c <_rtIsNaN>
    dc72:	01 00 00 
    dc74:	00 04 e0    	cp0.b     w0
    dc76:	f2 01 3a    	bra       NZ, 0xe05c <.L57>
    dc78:	08 00 be    	mov.d     w8, w0
    dc7a:	b4 0d 02    	call      0x10db4 <_rtIsInf>
    dc7c:	01 00 00 
    dc7e:	00 04 e0    	cp0.b     w0
    dc80:	ed 01 3a    	bra       NZ, 0xe05c <.L57>

0000dc82 <.L0>:
    tmp_0 = 0.0;
  } else {
    tmp_0 = fmod(tmp_0, 256.0);
    dc82:	02 00 20    	mov.w     #0x0, w2
    dc84:	03 38 24    	mov.w     #0x4380, w3
    dc86:	08 00 be    	mov.d     w8, w0
    dc88:	26 19 02    	call      0x1926 <_fmodf>
    dc8a:	00 00 00 
    dc8c:	00 04 be    	mov.d     w0, w8

0000dc8e <.L0>:
  }

  AUAV_V3_TestSensors_B.DataTypeConversion12 = (uint8_T)(tmp_0 < 0.0 ? (int16_T)
    dc8e:	60 11 b8    	mul.uu    w2, #0x0, w2
    dc90:	8c 18 02    	call      0x188c <___eqsf2>
    dc92:	00 00 00 
    dc94:	00 00 e0    	cp0.w     w0
    dc96:	06 00 3d    	bra       GE, 0xdca4 <.L0> <.L0> <.L58>

0000dc98 <.L0>:
    (uint8_T)-(int8_T)(uint8_T)-tmp_0 : (int16_T)(uint8_T)tmp_0);
    dc98:	08 00 be    	mov.d     w8, w0
    dc9a:	01 f0 a2    	btg.w     w1, #0xf
    dc9c:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    dc9e:	00 00 00 
    dca0:	00 40 ea    	neg.b     w0, w0
    dca2:	03 00 37    	bra       0xdcaa <.L60>

0000dca4 <.L0>:
    dca4:	08 00 be    	mov.d     w8, w0
    dca6:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    dca8:	00 00 00 

0000dcaa <.L60>:
    dcaa:	71 a2 21    	mov.w     #0x1a27, w1
    dcac:	80 48 78    	mov.b     w0, [w1]

0000dcae <.L0>:

  /* End of DataTypeConversion: '<S590>/Data Type Conversion12' */

  /* MATLAB Function: '<S630>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S630>/Constant'
   *  Constant: '<S630>/Constant1'
   *  DataTypeConversion: '<S593>/Data Type Conversion6'
   */
  A_EmbeddedMATLABFunction_f((real_T)rtb_Switch_d[11], 0.01, 0.02,
    dcae:	6f b0 97    	mov.w     [w15-20], w0
    dcb0:	cf 80 de    	asr.w     w0, #0xf, w1
    dcb2:	0c 19 02    	call      0x190c <___floatsisf>
    dcb4:	00 00 00 
    dcb6:	c7 09 22    	mov.w     #0x209c, w7
    dcb8:	46 b6 21    	mov.w     #0x1b64, w6
    dcba:	a4 70 2d    	mov.w     #0xd70a, w4
    dcbc:	35 ca 23    	mov.w     #0x3ca3, w5
    dcbe:	a2 70 2d    	mov.w     #0xd70a, w2
    dcc0:	33 c2 23    	mov.w     #0x3c23, w3
    dcc2:	ec fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000dcc4 <.L0>:
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_np,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_np);

  /* DataTypeConversion: '<S593>/Data Type Conversion8' incorporates:
   *  Constant: '<S625>/Bias'
   *  Product: '<S625>/Divide'
   *  Sum: '<S625>/Sum'
   */
  rtb_Sum_o = (real32_T)floor((real32_T)(3.1760616302490234 *
    dcc4:	82 49 24    	mov.w     #0x4498, w2
    dcc6:	b3 04 24    	mov.w     #0x404b, w3
    dcc8:	20 db 80    	mov.w     0x1b64, w0
    dcca:	31 db 80    	mov.w     0x1b66, w1
    dccc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dcce:	00 00 00 
    dcd0:	02 cb 2e    	mov.w     #0xecb0, w2
    dcd2:	33 46 24    	mov.w     #0x4463, w3
    dcd4:	92 14 02    	call      0x1492 <___addsf3>
    dcd6:	00 00 00 
    dcd8:	16 19 02    	call      0x1916 <_floorf>
    dcda:	00 00 00 
    dcdc:	00 04 be    	mov.d     w0, w8

0000dcde <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_np.y) + 911.698242F);
  if (rtIsNaNF(rtb_Sum_o) || rtIsInfF(rtb_Sum_o)) {
    dcde:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
    dce0:	01 00 00 
    dce2:	00 04 e0    	cp0.b     w0
    dce4:	bd 01 3a    	bra       NZ, 0xe060 <.L61>
    dce6:	08 00 be    	mov.d     w8, w0
    dce8:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
    dcea:	01 00 00 
    dcec:	00 04 e0    	cp0.b     w0
    dcee:	b8 01 3a    	bra       NZ, 0xe060 <.L61>

0000dcf0 <.L0>:
    rtb_Sum_o = 0.0F;
  } else {
    rtb_Sum_o = (real32_T)fmod(rtb_Sum_o, 65536.0F);
    dcf0:	02 00 20    	mov.w     #0x0, w2
    dcf2:	03 78 24    	mov.w     #0x4780, w3
    dcf4:	08 00 be    	mov.d     w8, w0
    dcf6:	26 19 02    	call      0x1926 <_fmodf>
    dcf8:	00 00 00 
    dcfa:	00 04 be    	mov.d     w0, w8

0000dcfc <.L0>:
  }

  AUAV_V3_TestSensors_B.DataTypeConversion8 = rtb_Sum_o < 0.0F ? (uint16_T)
    -(int16_T)(uint16_T)-rtb_Sum_o : (uint16_T)rtb_Sum_o;
    dcfc:	60 11 b8    	mul.uu    w2, #0x0, w2
    dcfe:	8c 18 02    	call      0x188c <___eqsf2>
    dd00:	00 00 00 
    dd02:	00 00 e0    	cp0.w     w0
    dd04:	06 00 3d    	bra       GE, 0xdd12 <.L62>
    dd06:	08 00 be    	mov.d     w8, w0
    dd08:	01 f0 a2    	btg.w     w1, #0xf
    dd0a:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    dd0c:	00 00 00 
    dd0e:	00 00 ea    	neg.w     w0, w0
    dd10:	03 00 37    	bra       0xdd18 <.L0> <.L64>

0000dd12 <.L62>:
    dd12:	08 00 be    	mov.d     w8, w0
    dd14:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    dd16:	00 00 00 

0000dd18 <.L0>:
    dd18:	50 cf 88    	mov.w     w0, 0x19ea

0000dd1a <.L0>:

  /* End of DataTypeConversion: '<S593>/Data Type Conversion8' */

  /* S-Function (MCHP_C_function_Call): '<S581>/Update the Load and Power Data [updateSensorMcuState.c]1' */
  updateLoadData(
    dd1a:	80 00 78    	mov.w     w0, w1
    dd1c:	70 a2 21    	mov.w     #0x1a27, w0
    dd1e:	10 40 78    	mov.b     [w0], w0
    dd20:	90 fd 02    	call      0xfd90 <_updateLoadData>
    dd22:	00 00 00 

0000dd24 <.L0>:
                 AUAV_V3_TestSensors_B.DataTypeConversion12
                 , AUAV_V3_TestSensors_B.DataTypeConversion8
                 );

  /* S-Function (MCHP_C_function_Call): '<S588>/Produce the GPS Main Data and update the AP State (lat lon hei cog sog) [gpsUblox.c]1' */
  getGpsUbloxData(
    dd24:	60 65 21    	mov.w     #0x1656, w0
    dd26:	64 e1 02    	call      0xe164 <_getGpsUbloxData>
    dd28:	00 00 00 

0000dd2a <.L0>:
                  &AUAV_V3_TestSensors_B.ProducetheGPSMainDataandupdatet[0]
                  );

  /* MATLAB Function: '<S596>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S589>/Gyro Gains'
   *  Constant: '<S596>/Constant'
   *  Constant: '<S596>/Constant1'
   *  DataTypeConversion: '<S589>/Data Type Conversion2'
   *  Gain: '<S599>/[ -1 1 -1]'
   *  Product: '<S589>/Divide'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[0] *
    dd2a:	3f a8 97    	mov.w     [w15-42], w0
    dd2c:	cf 80 de    	asr.w     w0, #0xf, w1
    dd2e:	0c 19 02    	call      0x190c <___floatsisf>
    dd30:	00 00 00 
    dd32:	d2 3f 2b    	mov.w     #0xb3fd, w2
    dd34:	b3 98 23    	mov.w     #0x398b, w3
    dd36:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dd38:	00 00 00 
    dd3a:	01 f0 a2    	btg.w     w1, #0xf
    dd3c:	87 15 22    	mov.w     #0x2158, w7
    dd3e:	86 bc 21    	mov.w     #0x1bc8, w6
    dd40:	04 00 20    	mov.w     #0x0, w4
    dd42:	05 22 24    	mov.w     #0x4220, w5
    dd44:	a2 70 2d    	mov.w     #0xd70a, w2
    dd46:	33 c2 23    	mov.w     #0x3c23, w3
    dd48:	a9 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000dd4a <.L0>:
    0.000266462477F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_f,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_f);

  /* MATLAB Function: '<S596>/Embedded MATLAB Function1' incorporates:
   *  Constant: '<S589>/Gyro Gains'
   *  Constant: '<S596>/Constant2'
   *  Constant: '<S596>/Constant3'
   *  DataTypeConversion: '<S589>/Data Type Conversion2'
   *  Product: '<S589>/Divide'
   */
  A_EmbeddedMATLABFunction_f((real_T)((real32_T)rtb_Switch_d[1] *
    dd4a:	4f a8 97    	mov.w     [w15-40], w0
    dd4c:	cf 80 de    	asr.w     w0, #0xf, w1
    dd4e:	0c 19 02    	call      0x190c <___floatsisf>
    dd50:	00 00 00 
    dd52:	d2 3f 2b    	mov.w     #0xb3fd, w2
    dd54:	b3 98 23    	mov.w     #0x398b, w3
    dd56:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dd58:	00 00 00 
    dd5a:	67 14 22    	mov.w     #0x2146, w7
    dd5c:	46 bc 21    	mov.w     #0x1bc4, w6
    dd5e:	04 00 20    	mov.w     #0x0, w4
    dd60:	05 22 24    	mov.w     #0x4220, w5
    dd62:	a2 70 2d    	mov.w     #0xd70a, w2
    dd64:	33 c2 23    	mov.w     #0x3c23, w3
    dd66:	9a fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000dd68 <.L0>:
    0.000266462477F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_i,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_i);

  /* MATLAB Function: '<S596>/Embedded MATLAB Function2' incorporates:
   *  Constant: '<S589>/Gyro Gains'
   *  Constant: '<S596>/Constant4'
   *  Constant: '<S596>/Constant5'
   *  DataTypeConversion: '<S589>/Data Type Conversion2'
   *  Gain: '<S599>/[ -1 1 -1]'
   *  Product: '<S589>/Divide'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[2] *
    dd68:	5f a8 97    	mov.w     [w15-38], w0
    dd6a:	cf 80 de    	asr.w     w0, #0xf, w1
    dd6c:	0c 19 02    	call      0x190c <___floatsisf>
    dd6e:	00 00 00 
    dd70:	d2 3f 2b    	mov.w     #0xb3fd, w2
    dd72:	b3 98 23    	mov.w     #0x398b, w3
    dd74:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dd76:	00 00 00 
    dd78:	01 f0 a2    	btg.w     w1, #0xf
    dd7a:	47 13 22    	mov.w     #0x2134, w7
    dd7c:	06 bc 21    	mov.w     #0x1bc0, w6
    dd7e:	04 00 20    	mov.w     #0x0, w4
    dd80:	05 22 24    	mov.w     #0x4220, w5
    dd82:	a2 70 2d    	mov.w     #0xd70a, w2
    dd84:	33 c2 23    	mov.w     #0x3c23, w3
    dd86:	8a fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000dd88 <.L0>:
    0.000266462477F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_h,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_h);

  /* MATLAB Function: '<S596>/myMux Fun' */
  AUAV_V3_TestSen_myMuxFun_i(AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_f.y,
    dd88:	46 bb 21    	mov.w     #0x1bb4, w6
    dd8a:	04 de 80    	mov.w     0x1bc0, w4
    dd8c:	15 de 80    	mov.w     0x1bc2, w5
    dd8e:	22 de 80    	mov.w     0x1bc4, w2
    dd90:	33 de 80    	mov.w     0x1bc6, w3
    dd92:	40 de 80    	mov.w     0x1bc8, w0
    dd94:	51 de 80    	mov.w     0x1bca, w1
    dd96:	d2 fc 07    	rcall     0xd73c <_AUAV_V3_TestSen_myMuxFun_i> <L0> <.LFB1469> <.LFE1468>

0000dd98 <.L0>:
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_i.y,
    AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_h.y,
    &AUAV_V3_TestSensors_B.sf_myMuxFun_i);

  /* DataTypeConversion: '<S589>/Data Type Conversion7' */
  AUAV_V3_TestSensors_B.DataTypeConversion7[0] = (real32_T)
    dd98:	a0 dd 80    	mov.w     0x1bb4, w0
    dd9a:	b1 dd 80    	mov.w     0x1bb6, w1
    dd9c:	50 b3 88    	mov.w     w0, 0x166a
    dd9e:	61 b3 88    	mov.w     w1, 0x166c
    AUAV_V3_TestSensors_B.sf_myMuxFun_i.y[0];
  AUAV_V3_TestSensors_B.DataTypeConversion7[1] = (real32_T)
    dda0:	c2 dd 80    	mov.w     0x1bb8, w2
    dda2:	d3 dd 80    	mov.w     0x1bba, w3
    dda4:	72 b3 88    	mov.w     w2, 0x166e
    dda6:	83 b3 88    	mov.w     w3, 0x1670
    AUAV_V3_TestSensors_B.sf_myMuxFun_i.y[1];
  AUAV_V3_TestSensors_B.DataTypeConversion7[2] = (real32_T)
    dda8:	e0 dd 80    	mov.w     0x1bbc, w0
    ddaa:	f1 dd 80    	mov.w     0x1bbe, w1
    ddac:	90 b3 88    	mov.w     w0, 0x1672
    ddae:	a1 b3 88    	mov.w     w1, 0x1674

0000ddb0 <.L0>:
    AUAV_V3_TestSensors_B.sf_myMuxFun_i.y[2];

  /* MATLAB Function: '<S597>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S589>/Gyro Gains1'
   *  Constant: '<S597>/Constant'
   *  Constant: '<S597>/Constant1'
   *  DataTypeConversion: '<S589>/Data Type Conversion1'
   *  Gain: '<S600>/[ -1 1 -1]'
   *  Product: '<S589>/Divide1'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[3] *
    ddb0:	6f a8 97    	mov.w     [w15-36], w0
    ddb2:	cf 80 de    	asr.w     w0, #0xf, w1
    ddb4:	0c 19 02    	call      0x190c <___floatsisf>
    ddb6:	00 00 00 
    ddb8:	d2 a3 20    	mov.w     #0xa3d, w2
    ddba:	d3 a1 23    	mov.w     #0x3a1d, w3
    ddbc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ddbe:	00 00 00 
    ddc0:	01 f0 a2    	btg.w     w1, #0xf
    ddc2:	27 12 22    	mov.w     #0x2122, w7
    ddc4:	06 bb 21    	mov.w     #0x1bb0, w6
    ddc6:	04 00 20    	mov.w     #0x0, w4
    ddc8:	05 22 24    	mov.w     #0x4220, w5
    ddca:	a2 70 2d    	mov.w     #0xd70a, w2
    ddcc:	33 c2 23    	mov.w     #0x3c23, w3
    ddce:	66 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000ddd0 <.L0>:
    0.000599060033F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_kq,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_kq);

  /* MATLAB Function: '<S597>/Embedded MATLAB Function1' incorporates:
   *  Constant: '<S589>/Gyro Gains1'
   *  Constant: '<S597>/Constant2'
   *  Constant: '<S597>/Constant3'
   *  DataTypeConversion: '<S589>/Data Type Conversion1'
   *  Product: '<S589>/Divide1'
   */
  A_EmbeddedMATLABFunction_f((real_T)((real32_T)rtb_Switch_d[4] *
    ddd0:	7f a8 97    	mov.w     [w15-34], w0
    ddd2:	cf 80 de    	asr.w     w0, #0xf, w1
    ddd4:	0c 19 02    	call      0x190c <___floatsisf>
    ddd6:	00 00 00 
    ddd8:	d2 a3 20    	mov.w     #0xa3d, w2
    ddda:	d3 a1 23    	mov.w     #0x3a1d, w3
    dddc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ddde:	00 00 00 
    dde0:	07 11 22    	mov.w     #0x2110, w7
    dde2:	c6 ba 21    	mov.w     #0x1bac, w6
    dde4:	04 00 20    	mov.w     #0x0, w4
    dde6:	05 22 24    	mov.w     #0x4220, w5
    dde8:	a2 70 2d    	mov.w     #0xd70a, w2
    ddea:	33 c2 23    	mov.w     #0x3c23, w3
    ddec:	57 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000ddee <.L0>:
    0.000599060033F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_f,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_f);

  /* MATLAB Function: '<S597>/Embedded MATLAB Function2' incorporates:
   *  Constant: '<S589>/Gyro Gains1'
   *  Constant: '<S597>/Constant4'
   *  Constant: '<S597>/Constant5'
   *  DataTypeConversion: '<S589>/Data Type Conversion1'
   *  Gain: '<S600>/[ -1 1 -1]'
   *  Product: '<S589>/Divide1'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[5] *
    ddee:	0f b0 97    	mov.w     [w15-32], w0
    ddf0:	cf 80 de    	asr.w     w0, #0xf, w1
    ddf2:	0c 19 02    	call      0x190c <___floatsisf>
    ddf4:	00 00 00 
    ddf6:	d2 a3 20    	mov.w     #0xa3d, w2
    ddf8:	d3 a1 23    	mov.w     #0x3a1d, w3
    ddfa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ddfc:	00 00 00 
    ddfe:	01 f0 a2    	btg.w     w1, #0xf
    de00:	e7 0f 22    	mov.w     #0x20fe, w7
    de02:	86 ba 21    	mov.w     #0x1ba8, w6
    de04:	04 00 20    	mov.w     #0x0, w4
    de06:	05 22 24    	mov.w     #0x4220, w5
    de08:	a2 70 2d    	mov.w     #0xd70a, w2
    de0a:	33 c2 23    	mov.w     #0x3c23, w3
    de0c:	47 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000de0e <.L0>:
    0.000599060033F), 0.01, 40.0,
    &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_f,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_f);

  /* MATLAB Function: '<S597>/myMux Fun' */
  AUAV_V3_TestSen_myMuxFun_i
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_kq.y,
    de0e:	c6 b9 21    	mov.w     #0x1b9c, w6
    de10:	44 dd 80    	mov.w     0x1ba8, w4
    de12:	55 dd 80    	mov.w     0x1baa, w5
    de14:	62 dd 80    	mov.w     0x1bac, w2
    de16:	73 dd 80    	mov.w     0x1bae, w3
    de18:	80 dd 80    	mov.w     0x1bb0, w0
    de1a:	91 dd 80    	mov.w     0x1bb2, w1
    de1c:	8f fc 07    	rcall     0xd73c <_AUAV_V3_TestSen_myMuxFun_i> <L0> <.LFB1469> <.LFE1468>

0000de1e <.L0>:
     AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_f.y,
     AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_f.y,
     &AUAV_V3_TestSensors_B.sf_myMuxFun_m);

  /* DataTypeConversion: '<S589>/Data Type Conversion3' */
  AUAV_V3_TestSensors_B.DataTypeConversion3[0] = (real32_T)
    de1e:	e2 dc 80    	mov.w     0x1b9c, w2
    de20:	f3 dc 80    	mov.w     0x1b9e, w3
    de22:	b2 b3 88    	mov.w     w2, 0x1676
    de24:	c3 b3 88    	mov.w     w3, 0x1678
    AUAV_V3_TestSensors_B.sf_myMuxFun_m.y[0];
  AUAV_V3_TestSensors_B.DataTypeConversion3[1] = (real32_T)
    de26:	00 dd 80    	mov.w     0x1ba0, w0
    de28:	11 dd 80    	mov.w     0x1ba2, w1
    de2a:	d0 b3 88    	mov.w     w0, 0x167a
    de2c:	e1 b3 88    	mov.w     w1, 0x167c
    AUAV_V3_TestSensors_B.sf_myMuxFun_m.y[1];
  AUAV_V3_TestSensors_B.DataTypeConversion3[2] = (real32_T)
    de2e:	22 dd 80    	mov.w     0x1ba4, w2
    de30:	33 dd 80    	mov.w     0x1ba6, w3
    de32:	f2 b3 88    	mov.w     w2, 0x167e
    de34:	03 b4 88    	mov.w     w3, 0x1680

0000de36 <.L0>:
    AUAV_V3_TestSensors_B.sf_myMuxFun_m.y[2];

  /* MATLAB Function: '<S598>/Embedded MATLAB Function' incorporates:
   *  Constant: '<S589>/Gyro Gains2'
   *  Constant: '<S598>/Constant'
   *  Constant: '<S598>/Constant1'
   *  DataTypeConversion: '<S589>/Data Type Conversion5'
   *  Product: '<S589>/Divide2'
   */
  A_EmbeddedMATLABFunction_f((real_T)((real32_T)rtb_Switch_d[6] * 0.8F), 0.01,
    de36:	1f b0 97    	mov.w     [w15-30], w0
    de38:	cf 80 de    	asr.w     w0, #0xf, w1
    de3a:	0c 19 02    	call      0x190c <___floatsisf>
    de3c:	00 00 00 
    de3e:	d2 cc 2c    	mov.w     #0xcccd, w2
    de40:	c3 f4 23    	mov.w     #0x3f4c, w3
    de42:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    de44:	00 00 00 
    de46:	c7 0e 22    	mov.w     #0x20ec, w7
    de48:	86 b9 21    	mov.w     #0x1b98, w6
    de4a:	04 00 20    	mov.w     #0x0, w4
    de4c:	05 22 24    	mov.w     #0x4220, w5
    de4e:	a2 70 2d    	mov.w     #0xd70a, w2
    de50:	33 c2 23    	mov.w     #0x3c23, w3
    de52:	24 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000de54 <.L0>:
    40.0, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ft,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction_ft);

  /* MATLAB Function: '<S598>/Embedded MATLAB Function1' incorporates:
   *  Constant: '<S589>/Gyro Gains2'
   *  Constant: '<S598>/Constant2'
   *  Constant: '<S598>/Constant3'
   *  DataTypeConversion: '<S589>/Data Type Conversion5'
   *  Gain: '<S601>/[ 1 -1 -1]'
   *  Product: '<S589>/Divide2'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[8] * 0.8F), 0.01,
    de54:	3f b0 97    	mov.w     [w15-26], w0
    de56:	cf 80 de    	asr.w     w0, #0xf, w1
    de58:	0c 19 02    	call      0x190c <___floatsisf>
    de5a:	00 00 00 
    de5c:	d2 cc 2c    	mov.w     #0xcccd, w2
    de5e:	c3 f4 23    	mov.w     #0x3f4c, w3
    de60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    de62:	00 00 00 
    de64:	01 f0 a2    	btg.w     w1, #0xf
    de66:	a7 0d 22    	mov.w     #0x20da, w7
    de68:	46 b9 21    	mov.w     #0x1b94, w6
    de6a:	04 00 20    	mov.w     #0x0, w4
    de6c:	05 22 24    	mov.w     #0x4220, w5
    de6e:	a2 70 2d    	mov.w     #0xd70a, w2
    de70:	33 c2 23    	mov.w     #0x3c23, w3
    de72:	14 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000de74 <.L0>:
    40.0, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_in,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction1_in);

  /* MATLAB Function: '<S598>/Embedded MATLAB Function2' incorporates:
   *  Constant: '<S589>/Gyro Gains2'
   *  Constant: '<S598>/Constant4'
   *  Constant: '<S598>/Constant5'
   *  DataTypeConversion: '<S589>/Data Type Conversion5'
   *  Gain: '<S601>/[ 1 -1 -1]'
   *  Product: '<S589>/Divide2'
   */
  A_EmbeddedMATLABFunction_f((real_T)-((real32_T)rtb_Switch_d[7] * 0.8F), 0.01,
    de74:	2f b0 97    	mov.w     [w15-28], w0
    de76:	cf 80 de    	asr.w     w0, #0xf, w1
    de78:	0c 19 02    	call      0x190c <___floatsisf>
    de7a:	00 00 00 
    de7c:	d2 cc 2c    	mov.w     #0xcccd, w2
    de7e:	c3 f4 23    	mov.w     #0x3f4c, w3
    de80:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    de82:	00 00 00 
    de84:	01 f0 a2    	btg.w     w1, #0xf
    de86:	87 0c 22    	mov.w     #0x20c8, w7
    de88:	06 b9 21    	mov.w     #0x1b90, w6
    de8a:	04 00 20    	mov.w     #0x0, w4
    de8c:	05 22 24    	mov.w     #0x4220, w5
    de8e:	a2 70 2d    	mov.w     #0xd70a, w2
    de90:	33 c2 23    	mov.w     #0x3c23, w3
    de92:	04 fc 07    	rcall     0xd69c <_A_EmbeddedMATLABFunction_f> <L0> <.LFB1468> <.LFE1467>

0000de94 <.L0>:
    40.0, &AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_fu,
    &AUAV_V3_TestSensors_DWork.sf_EmbeddedMATLABFunction2_fu);

  /* MATLAB Function: '<S598>/myMux Fun' */
  AUAV_V3_TestSen_myMuxFun_i
    (AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction_ft.y,
    de94:	46 b8 21    	mov.w     #0x1b84, w6
    de96:	84 dc 80    	mov.w     0x1b90, w4
    de98:	95 dc 80    	mov.w     0x1b92, w5
    de9a:	a2 dc 80    	mov.w     0x1b94, w2
    de9c:	b3 dc 80    	mov.w     0x1b96, w3
    de9e:	c0 dc 80    	mov.w     0x1b98, w0
    dea0:	d1 dc 80    	mov.w     0x1b9a, w1
    dea2:	4c fc 07    	rcall     0xd73c <_AUAV_V3_TestSen_myMuxFun_i> <L0> <.LFB1469> <.LFE1468>

0000dea4 <.L0>:
     AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction1_in.y,
     AUAV_V3_TestSensors_B.sf_EmbeddedMATLABFunction2_fu.y,
     &AUAV_V3_TestSensors_B.sf_myMuxFun_a);

  /* DataTypeConversion: '<S589>/Data Type Conversion6' */
  AUAV_V3_TestSensors_B.DataTypeConversion6[0] = (real32_T)
    dea4:	20 dc 80    	mov.w     0x1b84, w0
    dea6:	31 dc 80    	mov.w     0x1b86, w1
    dea8:	10 b4 88    	mov.w     w0, 0x1682
    deaa:	21 b4 88    	mov.w     w1, 0x1684

0000deac <.L0>:
    AUAV_V3_TestSensors_B.sf_myMuxFun_a.y[0];
  AUAV_V3_TestSensors_B.DataTypeConversion6[1] = (real32_T)
    deac:	42 dc 80    	mov.w     0x1b88, w2
    deae:	53 dc 80    	mov.w     0x1b8a, w3
    deb0:	32 b4 88    	mov.w     w2, 0x1686
    deb2:	43 b4 88    	mov.w     w3, 0x1688
    AUAV_V3_TestSensors_B.sf_myMuxFun_a.y[1];
  AUAV_V3_TestSensors_B.DataTypeConversion6[2] = (real32_T)
    deb4:	60 dc 80    	mov.w     0x1b8c, w0
    deb6:	71 dc 80    	mov.w     0x1b8e, w1
    deb8:	50 b4 88    	mov.w     w0, 0x168a
    deba:	61 b4 88    	mov.w     w1, 0x168c

0000debc <.L0>:
    AUAV_V3_TestSensors_B.sf_myMuxFun_a.y[2];

  /* MATLAB Function: '<S622>/Enables//Disables the Computation of  initial Baro Bias' */
  EnablesDisablestheComputat
    (&AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputat_b,
    debc:	01 0c 22    	mov.w     #0x20c0, w1
    debe:	c0 b6 21    	mov.w     #0x1b6c, w0
    dec0:	4e 11 02    	call      0x1114e <_EnablesDisablestheComputat>
    dec2:	01 00 00 

0000dec4 <.L0>:
     &AUAV_V3_TestSensors_DWork.sf_EnablesDisablestheComputat_b);

  /* Outputs for Enabled SubSystem: '<S622>/Initial Baro Bias' incorporates:
   *  EnablePort: '<S637>/Enable'
   */
  if (AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputat_b.tOut > 0.0) {
    dec4:	60 11 b8    	mul.uu    w2, #0x0, w2
    dec6:	60 db 80    	mov.w     0x1b6c, w0
    dec8:	71 db 80    	mov.w     0x1b6e, w1
    deca:	90 18 02    	call      0x1890 <___gesf2>
    decc:	00 00 00 
    dece:	00 00 e0    	cp0.w     w0
    ded0:	34 00 34    	bra       LE, 0xdf3a <.L0> <.L65>

0000ded2 <.L0>:
    /* DataTypeConversion: '<S637>/Data Type Conversion' */
    rtb_DataTypeConversion_n = rtb_Sum_d;

    /* DiscreteZeroPole: '<S640>/Discrete Zero-Pole' */
    {
      rtb_DiscreteZeroPole_i = 0.014778325123152709*rtb_DataTypeConversion_n;
    ded2:	a2 0c 22    	mov.w     #0x20ca, w2
    ded4:	23 c7 23    	mov.w     #0x3c72, w3
    ded6:	0c 00 be    	mov.d     w12, w0
    ded8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    deda:	00 00 00 
    dedc:	00 04 be    	mov.d     w0, w8

0000dede <.L0>:
      rtb_DiscreteZeroPole_i += 0.029119852459414206*
    dede:	22 cc 28    	mov.w     #0x8cc2, w2
    dee0:	e3 ce 23    	mov.w     #0x3cee, w3
    dee2:	e0 ea 80    	mov.w     0x1d5c, w0
    dee4:	f1 ea 80    	mov.w     0x1d5e, w1
    dee6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    dee8:	00 00 00 
    deea:	08 01 be    	mov.d     w8, w2
    deec:	92 14 02    	call      0x1492 <___addsf3>
    deee:	00 00 00 
    def0:	00 04 be    	mov.d     w0, w8

0000def2 <.L0>:
        AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE;
    }

    /* Saturate: '<S637>/[80k - 120k]' incorporates:
     *  DataTypeConversion: '<S637>/Data Type Conversion1'
     */
    if ((real32_T)rtb_DiscreteZeroPole_i > 120000.0F) {
    def2:	02 00 26    	mov.w     #0x6000, w2
    def4:	a3 7e 24    	mov.w     #0x47ea, w3
    def6:	90 18 02    	call      0x1890 <___gesf2>
    def8:	00 00 00 
    defa:	00 00 e0    	cp0.w     w0
    defc:	05 00 34    	bra       LE, 0xdf08 <.L0> <.L111>

0000defe <.L0>:
      AUAV_V3_TestSensors_B.u0k120k = 120000.0F;
    defe:	00 00 26    	mov.w     #0x6000, w0
    df00:	a1 7e 24    	mov.w     #0x47ea, w1
    df02:	10 b6 88    	mov.w     w0, 0x16c2
    df04:	21 b6 88    	mov.w     w1, 0x16c4
    df06:	0e 00 37    	bra       0xdf24 <.L69>

0000df08 <.L0>:
    } else if ((real32_T)rtb_DiscreteZeroPole_i < 80000.0F) {
    df08:	02 00 24    	mov.w     #0x4000, w2
    df0a:	c3 79 24    	mov.w     #0x479c, w3
    df0c:	08 00 be    	mov.d     w8, w0
    df0e:	8c 18 02    	call      0x188c <___eqsf2>
    df10:	00 00 00 
    df12:	00 00 e0    	cp0.w     w0
    df14:	05 00 3d    	bra       GE, 0xdf20 <.L112>

0000df16 <.L0>:
      AUAV_V3_TestSensors_B.u0k120k = 80000.0F;
    df16:	00 00 24    	mov.w     #0x4000, w0
    df18:	c1 79 24    	mov.w     #0x479c, w1
    df1a:	10 b6 88    	mov.w     w0, 0x16c2
    df1c:	21 b6 88    	mov.w     w1, 0x16c4
    df1e:	02 00 37    	bra       0xdf24 <.L69>

0000df20 <.L112>:
    } else {
      AUAV_V3_TestSensors_B.u0k120k = (real32_T)rtb_DiscreteZeroPole_i;
    df20:	18 b6 88    	mov.w     w8, 0x16c2
    df22:	29 b6 88    	mov.w     w9, 0x16c4

0000df24 <.L69>:
    }

    /* End of Saturate: '<S637>/[80k - 120k]' */
    /* Update for DiscreteZeroPole: '<S640>/Discrete Zero-Pole' */
    {
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE =
    df24:	c8 d5 21    	mov.w     #0x1d5c, w8

0000df26 <.L0>:
        rtb_DataTypeConversion_n + 0.97044334975369462*
    df26:	a2 ef 26    	mov.w     #0x6efa, w2
    df28:	83 f7 23    	mov.w     #0x3f78, w3
    df2a:	18 00 be    	mov.d     [w8], w0
    df2c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df2e:	00 00 00 
    df30:	00 01 be    	mov.d     w0, w2
    df32:	0c 00 be    	mov.d     w12, w0
    df34:	92 14 02    	call      0x1492 <___addsf3>
    df36:	00 00 00 

0000df38 <.L0>:
    df38:	00 8c be    	mov.d     w0, [w8]

0000df3a <.L0>:
        AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE;
    }
  }

  /* End of Outputs for SubSystem: '<S622>/Initial Baro Bias' */

  /* Product: '<S633>/Divide' incorporates:
   *  Sum: '<S633>/Sum2'
   */
  rtb_Sum_o = (rtb_Sum_d - AUAV_V3_TestSensors_B.u0k120k) /
    df3a:	18 b6 80    	mov.w     0x16c2, w8
    df3c:	29 b6 80    	mov.w     0x16c4, w9
    df3e:	08 01 be    	mov.d     w8, w2
    df40:	0c 00 be    	mov.d     w12, w0
    df42:	90 14 02    	call      0x1490 <___subsf3>
    df44:	00 00 00 
    df46:	08 01 be    	mov.d     w8, w2
    df48:	26 17 02    	call      0x1726 <___divsf3>
    df4a:	00 00 00 
    df4c:	00 04 be    	mov.d     w0, w8

0000df4e <.L0>:
    AUAV_V3_TestSensors_B.u0k120k;

  /* S-Function (MCHP_C_function_Call): '<S636>/Get the GS Location [updateSensorMCUState.c]1' */
  getGSLocation(
    df4e:	e0 68 21    	mov.w     #0x168e, w0
    df50:	c8 fd 02    	call      0xfdc8 <_getGSLocation>
    df52:	00 00 00 

0000df54 <.L0>:
                &AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorMCU[0]
                );

  /* Sum: '<S633>/Sum1' incorporates:
   *  Constant: '<S633>/Constant2'
   *  Constant: '<S633>/Constant3'
   *  Constant: '<S633>/Constant4'
   *  Constant: '<S633>/Constant5'
   *  Gain: '<S639>/Unit Conversion'
   *  Product: '<S633>/Divide1'
   *  Product: '<S633>/Divide2'
   *  Product: '<S633>/Divide3'
   *  Product: '<S633>/Divide4'
   *  Sum: '<S633>/Sum3'
   */
  rtb_Sum_o = ((rtb_Sum_o * rtb_Sum_o * 0.093502529F + rtb_Sum_o * -0.188893303F)
    df54:	08 01 be    	mov.d     w8, w2
    df56:	08 00 be    	mov.d     w8, w0
    df58:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df5a:	00 00 00 
    df5c:	12 e4 27    	mov.w     #0x7e41, w2
    df5e:	f3 db 23    	mov.w     #0x3dbf, w3
    df60:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df62:	00 00 00 
    df64:	00 05 be    	mov.d     w0, w10
    df66:	f2 d3 26    	mov.w     #0x6d3f, w2
    df68:	13 e4 2b    	mov.w     #0xbe41, w3
    df6a:	08 00 be    	mov.d     w8, w0
    df6c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df6e:	00 00 00 
    df70:	00 01 be    	mov.d     w0, w2
    df72:	0a 00 be    	mov.d     w10, w0
    df74:	92 14 02    	call      0x1492 <___addsf3>
    df76:	00 00 00 

0000df78 <.L0>:
               + 2.18031291E-5F) * 145473.5F * 0.3048F +
    df78:	d2 5d 2e    	mov.w     #0xe5dd, w2
    df7a:	63 7b 23    	mov.w     #0x37b6, w3
    df7c:	92 14 02    	call      0x1492 <___addsf3>
    df7e:	00 00 00 
    df80:	02 06 21    	mov.w     #0x1060, w2
    df82:	e3 80 24    	mov.w     #0x480e, w3
    df84:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df86:	00 00 00 
    df88:	f2 eb 20    	mov.w     #0xebf, w2
    df8a:	c3 e9 23    	mov.w     #0x3e9c, w3
    df8c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    df8e:	00 00 00 

0000df90 <.L0>:
    AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorMCU[0];
    df90:	7c b4 80    	mov.w     0x168e, w12
    df92:	8d b4 80    	mov.w     0x1690, w13

0000df94 <.L0>:
    df94:	0c 01 be    	mov.d     w12, w2
    df96:	92 14 02    	call      0x1492 <___addsf3>
    df98:	00 00 00 
    df9a:	00 04 be    	mov.d     w0, w8

0000df9c <.L0>:

  /* Outputs for Enabled SubSystem: '<S622>/Zero Out Height' incorporates:
   *  EnablePort: '<S638>/Enable'
   */
  if (AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputat_b.tOut > 0.0) {
    df9c:	6a db 80    	mov.w     0x1b6c, w10
    df9e:	7b db 80    	mov.w     0x1b6e, w11
    dfa0:	60 11 b8    	mul.uu    w2, #0x0, w2
    dfa2:	0a 00 be    	mov.d     w10, w0
    dfa4:	90 18 02    	call      0x1890 <___gesf2>
    dfa6:	00 00 00 
    dfa8:	00 00 e0    	cp0.w     w0
    dfaa:	08 00 34    	bra       LE, 0xdfbc <.L0> <.L72>

0000dfac <.L0>:
    /* Sum: '<S638>/Sum' incorporates:
     *  Delay: '<S638>/Integer Delay'
     */
    AUAV_V3_TestSensors_B.Sum =
      AUAV_V3_TestSensors_B.GettheGSLocationupdateSensorMCU[0] -
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE;
    dfac:	0e da 21    	mov.w     #0x1da0, w14

0000dfae <.L0>:
    dfae:	1e 01 be    	mov.d     [w14], w2
    dfb0:	0c 00 be    	mov.d     w12, w0
    dfb2:	90 14 02    	call      0x1490 <___subsf3>
    dfb4:	00 00 00 

0000dfb6 <.L0>:
    dfb6:	f0 b5 88    	mov.w     w0, 0x16be
    dfb8:	01 b6 88    	mov.w     w1, 0x16c0

    /* Update for Delay: '<S638>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE = rtb_Sum_o;
    dfba:	08 8f be    	mov.d     w8, [w14]

0000dfbc <.L0>:
  }

  /* End of Outputs for SubSystem: '<S622>/Zero Out Height' */

  /* Outputs for Enabled SubSystem: '<S622>/Enabled Subsystem' */

  /* Logic: '<S622>/Logical Operator' incorporates:
   *  Sum: '<S622>/Sum1'
   */
  AUAV_V3_T_EnabledSubsystem
    (!(AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputat_b.tOut != 0.0),
    dfbc:	f2 b5 80    	mov.w     0x16be, w2
    dfbe:	03 b6 80    	mov.w     0x16c0, w3
    dfc0:	08 00 be    	mov.d     w8, w0
    dfc2:	92 14 02    	call      0x1492 <___addsf3>
    dfc4:	00 00 00 
    dfc6:	00 04 be    	mov.d     w0, w8
    dfc8:	1c c0 b3    	mov.b     #0x1, w12
    dfca:	60 11 b8    	mul.uu    w2, #0x0, w2
    dfcc:	0a 00 be    	mov.d     w10, w0
    dfce:	c8 19 02    	call      0x19c8 <___nesf2>
    dfd0:	00 00 00 
    dfd2:	00 00 e0    	cp0.w     w0
    dfd4:	01 00 3a    	bra       NZ, 0xdfd8 <.L74>
    dfd6:	00 46 eb    	clr.b     w12

0000dfd8 <.L74>:
    dfd8:	0c 04 a2    	btg.b     w12, #0x0
    dfda:	0c 80 fb    	ze        w12, w0
    dfdc:	01 b7 21    	mov.w     #0x1b70, w1
    dfde:	08 01 be    	mov.d     w8, w2
    dfe0:	7e 12 02    	call      0x1127e <_AUAV_V3_T_EnabledSubsystem>
    dfe2:	01 00 00 
    dfe4:	a0 69 21    	mov.w     #0x169a, w0

0000dfe6 <.L0>:
    dfe6:	f4 00 40    	add.w     w0, #0x14, w1

0000dfe8 <.L77>:
     AUAV_V3_TestSensors_B.Sum + rtb_Sum_o,
     &AUAV_V3_TestSensors_B.EnabledSubsystem_m);

  /* End of Outputs for SubSystem: '<S622>/Enabled Subsystem' */

  /* Switch: '<S581>/Switch1' */
  for (i = 0; i < 5; i++) {
    if (rtb_LogicalOperator) {
    dfe8:	0f f1 97    	mov.b     [w15-16], w2
    dfea:	02 04 e0    	cp0.b     w2
    dfec:	04 00 32    	bra       Z, 0xdff6 <.L75>
      AUAV_V3_TestSensors_B.Switch1[i] =
    dfee:	40 19 90    	mov.w     [w0+56], w2
    dff0:	d0 19 90    	mov.w     [w0+58], w3
    dff2:	02 88 be    	mov.d     w2, [w0]
    dff4:	03 00 37    	bra       0xdffc <.L76>

0000dff6 <.L75>:
        AUAV_V3_TestSensors_B.ProducetheGPSMainDataandupdat_a[i];
    } else {
      AUAV_V3_TestSensors_B.Switch1[i] =
    dff6:	60 99 97    	mov.w     [w0-68], w2
    dff8:	f0 99 97    	mov.w     [w0-66], w3
    dffa:	02 88 be    	mov.d     w2, [w0]

0000dffc <.L76>:
    dffc:	64 00 40    	add.w     w0, #0x4, w0

0000dffe <.L0>:
    dffe:	81 0f 50    	sub.w     w0, w1, [w15]
    e000:	f3 ff 3a    	bra       NZ, 0xdfe8 <.L77>

0000e002 <.L0>:
        AUAV_V3_TestSensors_B.ProducetheGPSMainDataandupdatet[i];
    }
  }

  /* End of Switch: '<S581>/Switch1' */

  /* S-Function (MCHP_C_function_Call): '<S16>/Checks if FixType is 3 [updateSensorMCUState.c]1' */
  AUAV_V3_TestSensors_B.ChecksifFixTypeis3updateSensorM = isFixValid(
    e002:	3c ff 02    	call      0xff3c <_isFixValid>
    e004:	00 00 00 
    e006:	81 a2 21    	mov.w     #0x1a28, w1
    e008:	80 48 78    	mov.b     w0, [w1]

0000e00a <.L0>:
    );

  /* Outputs for Enabled SubSystem: '<S16>/Initialize GS Location' incorporates:
   *  EnablePort: '<S579>/Enable'
   */
  /* Logic: '<S16>/Logical Operator' incorporates:
   *  DataStoreRead: '<S16>/Data Store Read'
   */
  if ((AUAV_V3_TestSensors_B.ChecksifFixTypeis3updateSensorM != 0) &&
    e00a:	00 04 e0    	cp0.b     w0
    e00c:	2b 00 32    	bra       Z, 0xe064 <.L9>
    e00e:	60 11 b8    	mul.uu    w2, #0x0, w2
    e010:	40 ec 80    	mov.w     0x1d88, w0
    e012:	51 ec 80    	mov.w     0x1d8a, w1
    e014:	c8 19 02    	call      0x19c8 <___nesf2>
    e016:	00 00 00 
    e018:	00 00 e0    	cp0.w     w0
    e01a:	24 00 32    	bra       Z, 0xe064 <.L9>

0000e01c <.L0>:
      (AUAV_V3_TestSensors_DWork.GS_INIT_FLAG != 0.0)) {
    /* DataStoreWrite: '<S579>/Data Store Write' incorporates:
     *  Constant: '<S579>/Constant'
     */
    AUAV_V3_TestSensors_DWork.GS_INIT_FLAG = 0.0;
    e01c:	60 00 b8    	mul.uu    w0, #0x0, w0
    e01e:	40 ec 88    	mov.w     w0, 0x1d88
    e020:	51 ec 88    	mov.w     w1, 0x1d8a

0000e022 <.L0>:

    /* DataStoreWrite: '<S579>/Data Store Write1' incorporates:
     *  DataStoreRead: '<S579>/Data Store Read1'
     *  DataTypeConversion: '<S579>/Data Type Conversion'
     *  DataTypeConversion: '<S579>/Data Type Conversion1'
     *  DataTypeConversion: '<S579>/Data Type Conversion2'
     */
    mlGSLocationFloat.lat = (real32_T)mlGpsData.lat;
    e022:	10 83 80    	mov.w     0x1062, w0
    e024:	21 83 80    	mov.w     0x1064, w1
    e026:	0c 19 02    	call      0x190c <___floatsisf>
    e028:	00 00 00 
    e02a:	f0 87 88    	mov.w     w0, 0x10fe
    e02c:	01 88 88    	mov.w     w1, 0x1100

0000e02e <.L0>:
    mlGSLocationFloat.lon = (real32_T)mlGpsData.lon;
    e02e:	30 83 80    	mov.w     0x1066, w0
    e030:	41 83 80    	mov.w     0x1068, w1
    e032:	0c 19 02    	call      0x190c <___floatsisf>
    e034:	00 00 00 
    e036:	10 88 88    	mov.w     w0, 0x1102
    e038:	21 88 88    	mov.w     w1, 0x1104

0000e03a <.L0>:
    mlGSLocationFloat.alt = (real32_T)mlGpsData.alt;
    e03a:	50 83 80    	mov.w     0x106a, w0
    e03c:	61 83 80    	mov.w     0x106c, w1
    e03e:	0c 19 02    	call      0x190c <___floatsisf>
    e040:	00 00 00 
    e042:	30 88 88    	mov.w     w0, 0x1106
    e044:	41 88 88    	mov.w     w1, 0x1108
    e046:	0e 00 37    	bra       0xe064 <.L9>

0000e048 <.L0>:
    e048:	23 84 80    	mov.w     0x1084, w3
    e04a:	83 bf 9f    	mov.w     w3, [w15-16]
    e04c:	60 44 b8    	mul.uu    w8, #0x0, w8
    e04e:	18 fc 37    	bra       0xd880 <.L0> <.L19>

0000e050 <.L34>:
    e050:	60 44 b8    	mul.uu    w8, #0x0, w8
    e052:	81 fc 37    	bra       0xd956 <.L35>

0000e054 <.L38>:
    e054:	60 44 b8    	mul.uu    w8, #0x0, w8
    e056:	a5 fc 37    	bra       0xd9a2 <.L0> <.L0> <.L39>

0000e058 <.L42>:
    e058:	60 44 b8    	mul.uu    w8, #0x0, w8
    e05a:	c9 fc 37    	bra       0xd9ee <.L0> <.L0> <.L43>

0000e05c <.L57>:
    e05c:	60 44 b8    	mul.uu    w8, #0x0, w8
    e05e:	22 fe 37    	bra       0xdca4 <.L0> <.L0> <.L58>

0000e060 <.L61>:
    e060:	60 44 b8    	mul.uu    w8, #0x0, w8
    e062:	57 fe 37    	bra       0xdd12 <.L62>

0000e064 <.L9>:
  }

  /* End of Logic: '<S16>/Logical Operator' */
  /* End of Outputs for SubSystem: '<S16>/Initialize GS Location' */
}
    e064:	4f 07 78    	mov.w     [--w15], w14
    e066:	4f 06 be    	mov.d     [--w15], w12
    e068:	4f 05 be    	mov.d     [--w15], w10
    e06a:	4f 04 be    	mov.d     [--w15], w8
    e06c:	ef 01 b1    	sub.w     #0x1e, w15
    e06e:	00 00 06    	return    

0000e070 <_hex2char>:
extern void TxN_Data_OverU1(uint16_t N);

extern uint16_t PackTextMsg(uint8_t system_id, uint8_t component_id, unsigned char buf);

char hex2char(char halfhex) {
    e070:	80 40 78    	mov.b     w0, w1
    char rv;

    // Test for numeric characters
    if ((rv = halfhex - '0') <= 9 && rv >= 0) {
    e072:	00 cd b3    	mov.b     #0xd0, w0
    e074:	00 c0 40    	add.b     w1, w0, w0
    e076:	e9 4f 50    	sub.b     w0, #0x9, [w15]
    e078:	02 00 3c    	bra       GT, 0xe07e <.L2>
    e07a:	00 04 e0    	cp0.b     w0
    e07c:	10 00 3d    	bra       GE, 0xe09e <.L3>

0000e07e <.L2>:
        return rv;
    }        // Otherwise check for upper-case A-F
    else if ((rv = halfhex - 'A') <= 5 && rv >= 0) {
    e07e:	f0 cb b3    	mov.b     #0xbf, w0
    e080:	00 c0 40    	add.b     w1, w0, w0
    e082:	e5 4f 50    	sub.b     w0, #0x5, [w15]
    e084:	04 00 3c    	bra       GT, 0xe08e <.L4>
    e086:	00 04 e0    	cp0.b     w0
    e088:	02 00 35    	bra       LT, 0xe08e <.L4>
        return rv + 10;
    e08a:	6a 40 40    	add.b     w0, #0xa, w0
    e08c:	08 00 37    	bra       0xe09e <.L3>

0000e08e <.L4>:
    }        // Finally check for lower-case a-f
    else if ((rv = halfhex - 'a') <= 5 && rv >= 0) {
    e08e:	f0 c9 b3    	mov.b     #0x9f, w0
    e090:	80 c0 40    	add.b     w1, w0, w1
        return rv + 10;
    }

    // Otherwise return -1 as an error
    return -1;
    e092:	00 c0 eb    	setm.b    w0
    e094:	e5 cf 50    	sub.b     w1, #0x5, [w15]
    e096:	03 00 3c    	bra       GT, 0xe09e <.L3>
    e098:	01 04 e0    	cp0.b     w1
    e09a:	01 00 35    	bra       LT, 0xe09e <.L3>
    e09c:	6a c0 40    	add.b     w1, #0xa, w0

0000e09e <.L3>:
}
    e09e:	00 00 06    	return    

0000e0a0 <_degMinToDeg>:

float degMinToDeg(unsigned char degrees, float minutes) {
    e0a0:	88 9f be    	mov.d     w8, [w15++]
    e0a2:	8a 9f be    	mov.d     w10, [w15++]
    e0a4:	80 40 78    	mov.b     w0, w1
    e0a6:	02 05 be    	mov.d     w2, w10

0000e0a8 <.L0>:
    return ((float) degrees + minutes / 60.0);
    e0a8:	01 80 fb    	ze        w1, w0
    e0aa:	80 00 eb    	clr.w     w1
    e0ac:	12 19 02    	call      0x1912 <___floatunsisf>
    e0ae:	00 00 00 
    e0b0:	00 04 be    	mov.d     w0, w8
    e0b2:	02 00 20    	mov.w     #0x0, w2
    e0b4:	03 27 24    	mov.w     #0x4270, w3
    e0b6:	0a 00 be    	mov.d     w10, w0
    e0b8:	26 17 02    	call      0x1726 <___divsf3>
    e0ba:	00 00 00 
    e0bc:	00 01 be    	mov.d     w0, w2
    e0be:	08 00 be    	mov.d     w8, w0
    e0c0:	92 14 02    	call      0x1492 <___addsf3>
    e0c2:	00 00 00 

0000e0c4 <.L0>:
}
    e0c4:	4f 05 be    	mov.d     [--w15], w10
    e0c6:	4f 04 be    	mov.d     [--w15], w8
    e0c8:	00 00 06    	return    

0000e0ca <_gpsUbloxParse>:


// this function reads the serial stream as it comes in
// then assembles full messages, verifies the checksum and
// if valid sends it out to the parser

unsigned char gpsUbloxSeparate(unsigned char* outStream) {
    // Static variables CAREFUL
    static unsigned char outBuf [MSIZE] = {0};
    static unsigned char previousComplete = 1;
    static unsigned char indexLast = 0;

    // local variables
    unsigned char i = 0;
    unsigned char tmpChksum = 0;
    unsigned char chsmStr_0, chsmStr_1;
    unsigned char isValid = 0;
    unsigned char chksumHeader = 0;
    unsigned char tmpIndex = 0;
    unsigned char tmpLen = getLength(uartBuffer);

    // If the previous message was complete, then
    // go over the buffer and advance until you find a dollar sign
    if (previousComplete) {
        while (tmpLen > 0 && peak(uartBuffer) != '$') {
            readFront(uartBuffer);
            tmpLen--;
        }
    }

    // read until you find a CR or run out of bytes to read
    while (tmpLen > 0 && peak(uartBuffer) != 13) { //CR = 13
        outBuf[indexLast] = readFront(uartBuffer);
        indexLast++;
        tmpLen--;
    }

    // if we found a carriage return, then the message is complete
    if (peak(uartBuffer) == 13) {
        // validate the checksum
        chsmStr_0 = hex2char(outBuf[indexLast - 2]);
        chsmStr_1 = hex2char(outBuf[indexLast - 1]);
        // convert the hex checksum to decimal
        tmpChksum = (unsigned char) (chsmStr_0 * 16 + chsmStr_1);

        // verify the validity
        isValid = (tmpChksum == getChecksum(outBuf, indexLast));

        // turn on the flag of complete stream
        previousComplete = 1;
        // set the outStream valid flag
        outStream[MSIZE - 1] = isValid;

        // save the index value for copying purposes
        tmpIndex = indexLast;

        // reset the array index
        indexLast = 0;
    } else { // if we did not find a CR, i.e. we ran out of bytes
        // turn off the previousComplete flag
        previousComplete = 0;
    }

    // If we found a complete sentence and it is valid
    if (previousComplete && isValid) {
        // copy the data to the outstream
        for (i = 1; i <= tmpIndex; ++i) {
            outStream[i] = outBuf[i - 1];
        }

        // finally compute the type of message
        chksumHeader = getChecksum(outBuf, 6);
        gpsDebugMsg(getLength(uartBuffer));
        // based on the obtained header checksum set the type
        switch (chksumHeader) {
                        

            case GGACS:
                outStream[0] = GGAID;
                break;
            case RMCCS:
                outStream[0] = RMCID;
                break;
            default:
                outStream[0] = UNKID;
                break;
        }
    }
    return tmpLen;
}

void gpsUbloxParse(void) {
    e0ca:	88 1f 78    	mov.w     w8, [w15++]
    e0cc:	8a 9f be    	mov.d     w10, [w15++]

0000e0ce <.L0>:

    unsigned char inStream[MSIZE];
    unsigned char bufferLen = 11;
    int32_t bytesRead;
    int16_t i;
#ifdef WIN

    memset(inStream, 0, MSIZE);
    
    //gpsDebugMsg(getLength(bufferLen));
    
    while (bufferLen > 10) {
        bufferLen = gpsUbloxSeparate(inStream);
        
        // if the sentence is valid
        if (inStream[MSIZE - 1] == 1) {
            // parse the data according to the header
            switch (inStream[0]) {
                case RMCID:
                    parseRMC(inStream);
                    break;
                case GGAID:
                    parseGGA(inStream);
                    break;
            }
        }

        memset(inStream, 0, MSIZE);
    }
#else
    bytesRead = getLength(uartBuffer);
    e0ce:	c0 b2 81    	mov.w     0x3658, w0
    e0d0:	c0 0a 02    	call      0x10ac0 <_getLength>
    e0d2:	01 00 00 
    e0d4:	61 05 b8    	mul.uu    w0, #0x1, w10

0000e0d6 <.L0>:
    for (i = 0; i < bytesRead; i++) {
    e0d6:	e0 0f 55    	sub.w     w10, #0x0, [w15]
    e0d8:	e0 8f 5d    	subb.w    w11, #0x0, [w15]
    e0da:	0b 00 34    	bra       LE, 0xe0f2 <.L8>
    e0dc:	00 04 eb    	clr.w     w8

0000e0de <.L0>:
				udb_gps_callback_received_byte(readFront(uartBuffer));
    e0de:	c0 b2 81    	mov.w     0x3658, w0
    e0e0:	14 0b 02    	call      0x10b14 <_readFront>
    e0e2:	01 00 00 
    e0e4:	f8 f1 02    	call      0xf1f8 <_udb_gps_callback_received_byte>
    e0e6:	00 00 00 

0000e0e8 <.L0>:
    e0e8:	08 04 e8    	inc.w     w8, w8
    e0ea:	61 40 b9    	mul.su    w8, #0x1, w0
    e0ec:	80 0f 55    	sub.w     w10, w0, [w15]
    e0ee:	81 8f 5d    	subb.w    w11, w1, [w15]
    e0f0:	f6 ff 3c    	bra       GT, 0xe0de <.L0> <.L10>

0000e0f2 <.L8>:
	}
#endif
}
    e0f2:	4f 05 be    	mov.d     [--w15], w10
    e0f4:	4f 04 78    	mov.w     [--w15], w8
    e0f6:	00 00 06    	return    

0000e0f8 <_getGpsUbloxMainData>:

void getGpsUbloxMainData(float* data) {
    e0f8:	88 1f 78    	mov.w     w8, [w15++]

0000e0fa <.L0>:
    gpsUbloxParse();
    e0fa:	00 04 78    	mov.w     w0, w8
    e0fc:	e6 ff 07    	rcall     0xe0ca <_gpsUbloxParse> <L0> <.LFB1466> <.LFE1464>

0000e0fe <.L0>:
    data[0] = INT32_1E7_TO_FLOAT(mlGpsData.lat);
    e0fe:	10 83 80    	mov.w     0x1062, w0
    e100:	21 83 80    	mov.w     0x1064, w1
    e102:	0c 19 02    	call      0x190c <___floatsisf>
    e104:	00 00 00 
    e106:	52 f9 2b    	mov.w     #0xbf95, w2
    e108:	63 3d 23    	mov.w     #0x33d6, w3
    e10a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e10c:	00 00 00 
    e10e:	00 8c be    	mov.d     w0, [w8]

0000e110 <.L0>:
    data[1] = INT32_1E7_TO_FLOAT(mlGpsData.lon);
    e110:	30 83 80    	mov.w     0x1066, w0
    e112:	41 83 80    	mov.w     0x1068, w1
    e114:	0c 19 02    	call      0x190c <___floatsisf>
    e116:	00 00 00 
    e118:	52 f9 2b    	mov.w     #0xbf95, w2
    e11a:	63 3d 23    	mov.w     #0x33d6, w3
    e11c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e11e:	00 00 00 
    e120:	20 04 98    	mov.w     w0, [w8+4]
    e122:	31 04 98    	mov.w     w1, [w8+6]

0000e124 <.L0>:
    data[2] = INT32_1E3_TO_FLOAT(mlGpsData.alt);
    e124:	50 83 80    	mov.w     0x106a, w0
    e126:	61 83 80    	mov.w     0x106c, w1
    e128:	0c 19 02    	call      0x190c <___floatsisf>
    e12a:	00 00 00 
    e12c:	f2 26 21    	mov.w     #0x126f, w2
    e12e:	33 a8 23    	mov.w     #0x3a83, w3
    e130:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e132:	00 00 00 
    e134:	40 04 98    	mov.w     w0, [w8+8]
    e136:	51 04 98    	mov.w     w1, [w8+10]

0000e138 <.L0>:
    data[3] = UINT16_1E2_TO_FLOAT(mlGpsData.cog);
    e138:	a0 83 80    	mov.w     0x1074, w0
    e13a:	80 00 eb    	clr.w     w1
    e13c:	12 19 02    	call      0x1912 <___floatunsisf>
    e13e:	00 00 00 
    e140:	a2 70 2d    	mov.w     #0xd70a, w2
    e142:	33 c2 23    	mov.w     #0x3c23, w3
    e144:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e146:	00 00 00 
    e148:	60 04 98    	mov.w     w0, [w8+12]
    e14a:	71 04 98    	mov.w     w1, [w8+14]

0000e14c <.L0>:
    data[4] = UINT16_1E2_TO_FLOAT(mlGpsData.vel);
    e14c:	90 83 80    	mov.w     0x1072, w0
    e14e:	80 00 eb    	clr.w     w1
    e150:	12 19 02    	call      0x1912 <___floatunsisf>
    e152:	00 00 00 
    e154:	a2 70 2d    	mov.w     #0xd70a, w2
    e156:	33 c2 23    	mov.w     #0x3c23, w3
    e158:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e15a:	00 00 00 
    e15c:	00 0c 98    	mov.w     w0, [w8+16]
    e15e:	11 0c 98    	mov.w     w1, [w8+18]

0000e160 <.L0>:
}
    e160:	4f 04 78    	mov.w     [--w15], w8
    e162:	00 00 06    	return    

0000e164 <_getGpsUbloxData>:

void getGpsUbloxData(float* data) {
    e164:	88 1f 78    	mov.w     w8, [w15++]
    e166:	00 04 78    	mov.w     w0, w8

0000e168 <.L0>:
	data[0] = INT32_1E7_TO_FLOAT(mlGpsData.lat);
    e168:	10 83 80    	mov.w     0x1062, w0
    e16a:	21 83 80    	mov.w     0x1064, w1
    e16c:	0c 19 02    	call      0x190c <___floatsisf>
    e16e:	00 00 00 
    e170:	52 f9 2b    	mov.w     #0xbf95, w2
    e172:	63 3d 23    	mov.w     #0x33d6, w3
    e174:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e176:	00 00 00 
    e178:	00 8c be    	mov.d     w0, [w8]

0000e17a <.L0>:
	data[1] = INT32_1E7_TO_FLOAT(mlGpsData.lon);
    e17a:	30 83 80    	mov.w     0x1066, w0
    e17c:	41 83 80    	mov.w     0x1068, w1
    e17e:	0c 19 02    	call      0x190c <___floatsisf>
    e180:	00 00 00 
    e182:	52 f9 2b    	mov.w     #0xbf95, w2
    e184:	63 3d 23    	mov.w     #0x33d6, w3
    e186:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e188:	00 00 00 
    e18a:	20 04 98    	mov.w     w0, [w8+4]
    e18c:	31 04 98    	mov.w     w1, [w8+6]

0000e18e <.L0>:
	data[2] = INT32_1E3_TO_FLOAT(mlGpsData.alt);
    e18e:	50 83 80    	mov.w     0x106a, w0
    e190:	61 83 80    	mov.w     0x106c, w1
    e192:	0c 19 02    	call      0x190c <___floatsisf>
    e194:	00 00 00 
    e196:	f2 26 21    	mov.w     #0x126f, w2
    e198:	33 a8 23    	mov.w     #0x3a83, w3
    e19a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e19c:	00 00 00 
    e19e:	40 04 98    	mov.w     w0, [w8+8]
    e1a0:	51 04 98    	mov.w     w1, [w8+10]

0000e1a2 <.L0>:
	data[3] = UINT16_1E2_TO_FLOAT(mlGpsData.cog);
    e1a2:	a0 83 80    	mov.w     0x1074, w0
    e1a4:	80 00 eb    	clr.w     w1
    e1a6:	12 19 02    	call      0x1912 <___floatunsisf>
    e1a8:	00 00 00 
    e1aa:	a2 70 2d    	mov.w     #0xd70a, w2
    e1ac:	33 c2 23    	mov.w     #0x3c23, w3
    e1ae:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e1b0:	00 00 00 
    e1b2:	60 04 98    	mov.w     w0, [w8+12]
    e1b4:	71 04 98    	mov.w     w1, [w8+14]

0000e1b6 <.L0>:
	data[4] = UINT16_1E2_TO_FLOAT(mlGpsData.vel);
    e1b6:	90 83 80    	mov.w     0x1072, w0
    e1b8:	80 00 eb    	clr.w     w1
    e1ba:	12 19 02    	call      0x1912 <___floatunsisf>
    e1bc:	00 00 00 
    e1be:	a2 70 2d    	mov.w     #0xd70a, w2
    e1c0:	33 c2 23    	mov.w     #0x3c23, w3
    e1c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e1c4:	00 00 00 
    e1c6:	00 0c 98    	mov.w     w0, [w8+16]
    e1c8:	11 0c 98    	mov.w     w1, [w8+18]

0000e1ca <.L0>:
}
    e1ca:	4f 04 78    	mov.w     [--w15], w8
    e1cc:	00 00 06    	return    

0000e1ce <_gpSmbl>:

char gpSmbl(char symbl) {
    switch (symbl) {
        case 'N': return 1; /*North*/
        case 'E': return 1; /*East*/
        case 'S': return -1; /*South*/
        case 'W': return -1; /*West*/
        case 'A': return 3; /*Valid or Autonomous*/
        case 'D': return 1; /*Differential*/
        case 'V': return 0; /*Non-Valid*/
        case 'M': return 100; /*Meters*/
    e1ce:	41 c6 b3    	mov.b     #0x64, w1
    e1d0:	d2 c4 b3    	mov.b     #0x4d, w2
    e1d2:	82 4f 50    	sub.b     w0, w2, [w15]
    e1d4:	22 00 32    	bra       Z, 0xe21a <.L19>
    e1d6:	0c 00 3c    	bra       GT, 0xe1f0 <.L21>
    e1d8:	31 c0 b3    	mov.b     #0x3, w1
    e1da:	6c 41 51    	sub.b     w2, #0xc, w2
    e1dc:	82 4f 50    	sub.b     w0, w2, [w15]
    e1de:	1d 00 32    	bra       Z, 0xe21a <.L19>
    e1e0:	82 40 78    	mov.b     w2, w1
    e1e2:	81 4f 50    	sub.b     w0, w1, [w15]
    e1e4:	17 00 35    	bra       LT, 0xe214 <.L15>
    e1e6:	c1 cb b3    	mov.b     #0xbc, w1
    e1e8:	01 40 40    	add.b     w0, w1, w0
    e1ea:	e1 4f 50    	sub.b     w0, #0x1, [w15]
    e1ec:	13 00 3e    	bra       GTU, 0xe214 <.L15>
    e1ee:	10 00 37    	bra       0xe210 <.L17>

0000e1f0 <.L21>:
    e1f0:	31 c5 b3    	mov.b     #0x53, w1
    e1f2:	81 4f 50    	sub.b     w0, w1, [w15]
    e1f4:	11 00 32    	bra       Z, 0xe218 <.L23>
    e1f6:	04 00 3c    	bra       GT, 0xe200 <.L22>
    e1f8:	e5 c0 50    	sub.b     w1, #0x5, w1
    e1fa:	81 4f 50    	sub.b     w0, w1, [w15]
    e1fc:	0b 00 3a    	bra       NZ, 0xe214 <.L15>
    e1fe:	08 00 37    	bra       0xe210 <.L17>

0000e200 <.L22>:
    e200:	80 40 eb    	clr.b     w1
    e202:	62 c5 b3    	mov.b     #0x56, w2
    e204:	82 4f 50    	sub.b     w0, w2, [w15]
    e206:	09 00 32    	bra       Z, 0xe21a <.L19>
    e208:	71 c5 b3    	mov.b     #0x57, w1
    e20a:	81 4f 50    	sub.b     w0, w1, [w15]
    e20c:	03 00 3a    	bra       NZ, 0xe214 <.L15>
    e20e:	04 00 37    	bra       0xe218 <.L23>

0000e210 <.L17>:
    e210:	11 c0 b3    	mov.b     #0x1, w1
    e212:	03 00 37    	bra       0xe21a <.L19>

0000e214 <.L15>:
        default: return 0; /*Non-Valid*/
    e214:	80 40 eb    	clr.b     w1
    e216:	01 00 37    	bra       0xe21a <.L19>

0000e218 <.L23>:
    e218:	80 c0 eb    	setm.b    w1

0000e21a <.L19>:
    }
}
    e21a:	01 40 78    	mov.b     w1, w0
    e21c:	00 00 06    	return    

0000e21e <_myTokenizer>:

// a return value of 1 means the string is done. No more tokens
// This function is stateful, call it once with the String and then with NULL
// similar to strtok but this will support succesive tokens like
// "find,,,the,,commas"

unsigned char myTokenizer(char* stringToTokenize, char token, char * returnToken) {
    e21e:	88 9f be    	mov.d     w8, [w15++]
    e220:	00 04 78    	mov.w     w0, w8
    e222:	82 04 78    	mov.w     w2, w9
    static char * pch;
    static char * prevPch;
    static char * lastByte;

    // Make sure the return token is "empty"
    memset(returnToken, 0, TOKEN_SIZE);
    e224:	0e 00 09    	.pword 0x09000e
    e226:	80 5c eb    	clr.b     [w9++]
    e228:	f9 00 b1    	sub.w     #0xf, w9

    // get the pointer to next token if it exists 
    // and the stringToTokenize is null
    // Bahavior similar to strtok
    if (stringToTokenize == NULL) {
    e22a:	08 00 e0    	cp0.w     w8
    e22c:	06 00 3a    	bra       NZ, 0xe23a <.L0> <.L0> <.L25>

0000e22e <.L0>:
        pch = strchr(prevPch, token);
    e22e:	81 00 fb    	se        w1, w1
    e230:	20 c3 81    	mov.w     0x3864, w0
    e232:	e4 23 02    	call      0x23e4 <_strchr>
    e234:	00 00 00 
    e236:	30 c3 89    	mov.w     w0, 0x3866
    e238:	0b 00 37    	bra       0xe250 <.L0> <.L26>

0000e23a <.L0>:
    } else {
        pch = strchr(stringToTokenize, token);
    e23a:	81 00 fb    	se        w1, w1
    e23c:	08 00 78    	mov.w     w8, w0
    e23e:	e4 23 02    	call      0x23e4 <_strchr>
    e240:	00 00 00 
    e242:	30 c3 89    	mov.w     w0, 0x3866

0000e244 <.L0>:
        prevPch = stringToTokenize;
    e244:	28 c3 89    	mov.w     w8, 0x3864

0000e246 <.L0>:
        lastByte = stringToTokenize + strlen(stringToTokenize);
    e246:	08 00 78    	mov.w     w8, w0
    e248:	f8 23 02    	call      0x23f8 <_strlen>
    e24a:	00 00 00 
    e24c:	00 04 44    	add.w     w8, w0, w8
    e24e:	18 c3 89    	mov.w     w8, 0x3862

0000e250 <.L0>:
    }

    if (pch != NULL) {
    e250:	38 c3 81    	mov.w     0x3866, w8
    e252:	08 00 e0    	cp0.w     w8
    e254:	08 00 32    	bra       Z, 0xe266 <.L0> <.L27>

0000e256 <.L0>:
        memcpy(returnToken, prevPch, pch - prevPch);
    e256:	21 c3 81    	mov.w     0x3864, w1
    e258:	01 01 54    	sub.w     w8, w1, w2
    e25a:	09 00 78    	mov.w     w9, w0
    e25c:	c8 23 02    	call      0x23c8 <_memcpy>
    e25e:	00 00 00 

0000e260 <.L0>:
        prevPch = pch + 1;
    e260:	08 04 e8    	inc.w     w8, w8
    e262:	28 c3 89    	mov.w     w8, 0x3864
    e264:	06 00 37    	bra       0xe272 <.L0> <.L28>

0000e266 <.L0>:
    } else {
        memcpy(returnToken, prevPch, lastByte - prevPch);
    e266:	21 c3 81    	mov.w     0x3864, w1
    e268:	12 c3 81    	mov.w     0x3862, w2
    e26a:	01 01 51    	sub.w     w2, w1, w2
    e26c:	09 00 78    	mov.w     w9, w0
    e26e:	c8 23 02    	call      0x23c8 <_memcpy>
    e270:	00 00 00 

0000e272 <.L0>:
    }

    return pch == NULL;
    e272:	30 c3 81    	mov.w     0x3866, w0
    e274:	00 f0 a7    	btsc.w    w0, #0xf
    e276:	00 00 ea    	neg.w     w0, w0
    e278:	00 00 e9    	dec.w     w0, w0
    e27a:	4f 00 de    	lsr.w     w0, #0xf, w0
}
    e27c:	4f 04 be    	mov.d     [--w15], w8
    e27e:	00 00 06    	return    

0000e280 <_parseRMC>:

void parseRMC(unsigned char* stream) {
    e280:	16 00 fa    	lnk       #0x16
    e282:	88 1f 78    	mov.w     w8, [w15++]
    // declare the local vars
    char token[TOKEN_SIZE];
    char tmp [3] = {0, 0, '\0'}, tmp3[4] = {0, 0, 0, '\0'};
    e284:	80 40 eb    	clr.b     w1
    e286:	f1 f7 9f    	mov.b     w1, [w15-9]
    e288:	81 ff 9f    	mov.b     w1, [w15-8]
    e28a:	91 ff 9f    	mov.b     w1, [w15-7]
    e28c:	60 11 b8    	mul.uu    w2, #0x0, w2
    e28e:	d2 bf 9f    	mov.w     w2, [w15-6]
    e290:	e3 bf 9f    	mov.w     w3, [w15-4]

0000e292 <.L0>:
    unsigned char chTmp = 0;


    // initialize tokenizer, let go first token which holds the msg type
    // token = strtok(stream, ",");
    myTokenizer((char *)stream, ',', token);
    e292:	78 81 57    	sub.w     w15, #0x18, w2
    e294:	c1 c2 b3    	mov.b     #0x2c, w1
    e296:	c3 ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e298 <.L0>:

    // 1.- hhmmss.ssss
    myTokenizer(NULL, ',', token);
    e298:	78 81 57    	sub.w     w15, #0x18, w2
    e29a:	c1 c2 b3    	mov.b     #0x2c, w1
    e29c:	00 00 eb    	clr.w     w0
    e29e:	bf ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e2a0 <.L0>:
    if (strlen(token) > 5) {
//        tmp[0] = token[0];
//        tmp[1] = token[1];
//        mlGpsDateTime.hour = (unsigned char) atoi(tmp);
//        tmp[0] = token[2];
//        tmp[1] = token[3];
//        mlGpsDateTime.min = (unsigned char) atoi(tmp);
//        tmp[0] = token[4];
//        tmp[1] = token[5];
//        mlGpsDateTime.sec = (unsigned char) atoi(tmp);
    }

    // 2.- Status of position Fix
    myTokenizer(NULL, ',', token);
    e2a0:	78 81 57    	sub.w     w15, #0x18, w2
    e2a2:	c1 c2 b3    	mov.b     #0x2c, w1
    e2a4:	00 00 eb    	clr.w     w0
    e2a6:	bb ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e2a8 <.L0>:
    if (strlen(token) == 1) {
    e2a8:	78 80 57    	sub.w     w15, #0x18, w0
    e2aa:	f8 23 02    	call      0x23f8 <_strlen>
    e2ac:	00 00 00 
    e2ae:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    e2b0:	04 00 3a    	bra       NZ, 0xe2ba <.L0> <.L0> <.L30>

0000e2b2 <.L0>:
        mlGpsData.fix_type = gpSmbl((char) token[0]);
    e2b2:	0f e8 97    	mov.b     [w15-24], w0
    e2b4:	8c ff 07    	rcall     0xe1ce <_gpSmbl> <L0> <.LFB1469> <.LFE1468>
    e2b6:	61 07 21    	mov.w     #0x1076, w1
    e2b8:	80 48 78    	mov.b     w0, [w1]

0000e2ba <.L0>:
    }

    // 3.- Latitude
    // ddmm.mmmmmm
    myTokenizer(NULL, ',', token);
    e2ba:	78 81 57    	sub.w     w15, #0x18, w2
    e2bc:	c1 c2 b3    	mov.b     #0x2c, w1
    e2be:	00 00 eb    	clr.w     w0
    e2c0:	ae ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e2c2 <.L0>:
    if (strlen(token) > 0) {
    e2c2:	0f e8 97    	mov.b     [w15-24], w0
    e2c4:	00 04 e0    	cp0.b     w0
    e2c6:	2f 00 32    	bra       Z, 0xe326 <.L0> <.L0> <.L31>
        // get the first two values
        tmp[0] = token[0];
    e2c8:	f0 f7 9f    	mov.b     w0, [w15-9]
        tmp[1] = token[1];
    e2ca:	1f e8 97    	mov.b     [w15-23], w0
    e2cc:	80 ff 9f    	mov.b     w0, [w15-8]

0000e2ce <.L0>:
        // get the degrees
        chTmp = (unsigned char) atoi(tmp);
    e2ce:	69 80 57    	sub.w     w15, #0x9, w0
    e2d0:	8a 23 02    	call      0x238a <_atoi>
    e2d2:	00 00 00 
    e2d4:	00 04 78    	mov.w     w0, w8

0000e2d6 <.L0>:
        // make the degrees zero for minutes conversion
        token[0] = '0';
    e2d6:	00 c3 b3    	mov.b     #0x30, w0
    e2d8:	80 ef 9f    	mov.b     w0, [w15-24]
        token[1] = '0';
    e2da:	90 ef 9f    	mov.b     w0, [w15-23]

0000e2dc <.L0>:
        // get the float
        mlGpsData.lat = FLOAT_TO_INT32_1E7(degMinToDeg(chTmp, atof(token)));
    e2dc:	78 80 57    	sub.w     w15, #0x18, w0
    e2de:	86 23 02    	call      0x2386 <_atof>
    e2e0:	00 00 00 
    e2e2:	00 01 be    	mov.d     w0, w2
    e2e4:	08 40 78    	mov.b     w8, w0
    e2e6:	dc fe 07    	rcall     0xe0a0 <_degMinToDeg> <L0> <.LFB1464> <.LFE1463>
    e2e8:	02 68 29    	mov.w     #0x9680, w2
    e2ea:	83 b1 24    	mov.w     #0x4b18, w3
    e2ec:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e2ee:	00 00 00 
    e2f0:	94 18 02    	call      0x1894 <___fixsfsi>
    e2f2:	00 00 00 
    e2f4:	10 83 88    	mov.w     w0, 0x1062
    e2f6:	21 83 88    	mov.w     w1, 0x1064

0000e2f8 <.L0>:

        // 4.- Latitude Sector
        myTokenizer(NULL, ',', token);
    e2f8:	78 81 57    	sub.w     w15, #0x18, w2
    e2fa:	c1 c2 b3    	mov.b     #0x2c, w1
    e2fc:	00 00 eb    	clr.w     w0
    e2fe:	8f ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e300 <.L0>:
        if (strlen(token) == 1) {
    e300:	78 80 57    	sub.w     w15, #0x18, w0
    e302:	f8 23 02    	call      0x23f8 <_strlen>
    e304:	00 00 00 
    e306:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    e308:	0e 00 3a    	bra       NZ, 0xe326 <.L0> <.L0> <.L31>

0000e30a <.L0>:
            // set the sign of the float value
            mlGpsData.lat *= gpSmbl((char) token[0]);
    e30a:	0f e8 97    	mov.b     [w15-24], w0
    e30c:	60 ff 07    	rcall     0xe1ce <_gpSmbl> <L0> <.LFB1469> <.LFE1468>
    e30e:	00 41 78    	mov.b     w0, w2
    e310:	21 06 21    	mov.w     #0x1062, w1
    e312:	02 01 fb    	se        w2, w2
    e314:	cf 91 de    	asr.w     w2, #0xf, w3
    e316:	11 00 78    	mov.w     [w1], w0
    e318:	83 82 b9    	.pword 0xb98283
    e31a:	11 03 90    	mov.w     [w1+2], w6
    e31c:	82 b3 b9    	.pword 0xb9b382
    e31e:	06 02 42    	add.w     w4, w6, w4
    e320:	02 01 b8    	mul.uu    w0, w2, w2
    e322:	83 01 42    	add.w     w4, w3, w3
    e324:	82 88 be    	mov.d     w2, [w1]

0000e326 <.L0>:
        }
    }

    // 5.- Longitude
    // dddmm.mmmmmm
    myTokenizer(NULL, ',', token);
    e326:	78 81 57    	sub.w     w15, #0x18, w2
    e328:	c1 c2 b3    	mov.b     #0x2c, w1
    e32a:	00 00 eb    	clr.w     w0
    e32c:	78 ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e32e <.L0>:
    if (strlen(token) > 0) {
    e32e:	0f e8 97    	mov.b     [w15-24], w0
    e330:	00 04 e0    	cp0.b     w0
    e332:	32 00 32    	bra       Z, 0xe398 <.L0> <.L0> <.L32>
        // get the first two values
        tmp3[0] = token[0];
    e334:	a0 ff 9f    	mov.b     w0, [w15-6]
        tmp3[1] = token[1];
    e336:	1f e8 97    	mov.b     [w15-23], w0
    e338:	b0 ff 9f    	mov.b     w0, [w15-5]
        tmp3[2] = token[2];
    e33a:	2f e8 97    	mov.b     [w15-22], w0
    e33c:	c0 ff 9f    	mov.b     w0, [w15-4]

0000e33e <.L0>:
        // get the degrees
        chTmp = (unsigned char) atoi(tmp3);
    e33e:	66 80 57    	sub.w     w15, #0x6, w0
    e340:	8a 23 02    	call      0x238a <_atoi>
    e342:	00 00 00 
    e344:	00 04 78    	mov.w     w0, w8

0000e346 <.L0>:
        // make the degrees zero for minutes conversion
        token[0] = '0';
    e346:	00 c3 b3    	mov.b     #0x30, w0
    e348:	80 ef 9f    	mov.b     w0, [w15-24]
        token[1] = '0';
    e34a:	90 ef 9f    	mov.b     w0, [w15-23]
        token [2] = '0';
    e34c:	a0 ef 9f    	mov.b     w0, [w15-22]

0000e34e <.L0>:
        // get the float
        mlGpsData.lon = FLOAT_TO_INT32_1E7(degMinToDeg(chTmp, atof(token)));
    e34e:	78 80 57    	sub.w     w15, #0x18, w0
    e350:	86 23 02    	call      0x2386 <_atof>
    e352:	00 00 00 
    e354:	00 01 be    	mov.d     w0, w2
    e356:	08 40 78    	mov.b     w8, w0
    e358:	a3 fe 07    	rcall     0xe0a0 <_degMinToDeg> <L0> <.LFB1464> <.LFE1463>
    e35a:	02 68 29    	mov.w     #0x9680, w2
    e35c:	83 b1 24    	mov.w     #0x4b18, w3
    e35e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e360:	00 00 00 
    e362:	94 18 02    	call      0x1894 <___fixsfsi>
    e364:	00 00 00 
    e366:	30 83 88    	mov.w     w0, 0x1066
    e368:	41 83 88    	mov.w     w1, 0x1068

0000e36a <.L0>:

        // 6.- Longitude Sector
        myTokenizer(NULL, ',', token);
    e36a:	78 81 57    	sub.w     w15, #0x18, w2
    e36c:	c1 c2 b3    	mov.b     #0x2c, w1
    e36e:	00 00 eb    	clr.w     w0
    e370:	56 ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e372 <.L0>:
        if (strlen(token) == 1) {
    e372:	78 80 57    	sub.w     w15, #0x18, w0
    e374:	f8 23 02    	call      0x23f8 <_strlen>
    e376:	00 00 00 
    e378:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    e37a:	0e 00 3a    	bra       NZ, 0xe398 <.L0> <.L0> <.L32>

0000e37c <.L0>:
            // set the sign of the float value
            mlGpsData.lon *= gpSmbl((char) token[0]);
    e37c:	0f e8 97    	mov.b     [w15-24], w0
    e37e:	27 ff 07    	rcall     0xe1ce <_gpSmbl> <L0> <.LFB1469> <.LFE1468>
    e380:	00 41 78    	mov.b     w0, w2
    e382:	61 06 21    	mov.w     #0x1066, w1
    e384:	02 01 fb    	se        w2, w2
    e386:	cf 91 de    	asr.w     w2, #0xf, w3
    e388:	11 00 78    	mov.w     [w1], w0
    e38a:	83 82 b9    	.pword 0xb98283
    e38c:	11 03 90    	mov.w     [w1+2], w6
    e38e:	82 b3 b9    	.pword 0xb9b382
    e390:	06 02 42    	add.w     w4, w6, w4
    e392:	02 01 b8    	mul.uu    w0, w2, w2
    e394:	83 01 42    	add.w     w4, w3, w3
    e396:	82 88 be    	mov.d     w2, [w1]

0000e398 <.L0>:
        }
    }

    // 7.- SOG in knots but gets stored in m/s CAUTION
    // xx.xx
    myTokenizer(NULL, ',', token);
    e398:	78 81 57    	sub.w     w15, #0x18, w2
    e39a:	c1 c2 b3    	mov.b     #0x2c, w1
    e39c:	00 00 eb    	clr.w     w0
    e39e:	3f ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e3a0 <.L0>:
    if (strlen(token) > 0) {
    e3a0:	0f e8 97    	mov.b     [w15-24], w0
    e3a2:	00 04 e0    	cp0.b     w0
    e3a4:	13 00 32    	bra       Z, 0xe3cc <.L0> <.L0> <.L33>

0000e3a6 <.L0>:
        mlGpsData.vel = FLOAT_TO_UINT16_1E2((unsigned short) (atof(token) * KTS2MPS));
    e3a6:	78 80 57    	sub.w     w15, #0x18, w0
    e3a8:	86 23 02    	call      0x2386 <_atof>
    e3aa:	00 00 00 
    e3ac:	22 2a 2b    	mov.w     #0xb2a2, w2
    e3ae:	33 f0 23    	mov.w     #0x3f03, w3
    e3b0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e3b2:	00 00 00 
    e3b4:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e3b6:	00 00 00 
    e3b8:	80 00 eb    	clr.w     w1
    e3ba:	12 19 02    	call      0x1912 <___floatunsisf>
    e3bc:	00 00 00 
    e3be:	02 00 20    	mov.w     #0x0, w2
    e3c0:	83 2c 24    	mov.w     #0x42c8, w3
    e3c2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e3c4:	00 00 00 
    e3c6:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e3c8:	00 00 00 
    e3ca:	90 83 88    	mov.w     w0, 0x1072

0000e3cc <.L0>:
    }

    // 8.- COG in degrees
    // xxx.xxx
    myTokenizer(NULL, ',', token);
    e3cc:	78 81 57    	sub.w     w15, #0x18, w2
    e3ce:	c1 c2 b3    	mov.b     #0x2c, w1
    e3d0:	00 00 eb    	clr.w     w0
    e3d2:	25 ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e3d4 <.L0>:
    if (strlen(token) > 0) {
    e3d4:	0f e8 97    	mov.b     [w15-24], w0
    e3d6:	00 04 e0    	cp0.b     w0
    e3d8:	0f 00 32    	bra       Z, 0xe3f8 <.L0> <.L0> <.L34>

0000e3da <.L0>:
        mlGpsData.cog = FLOAT_TO_UINT16_1E2((unsigned short) atof(token));
    e3da:	78 80 57    	sub.w     w15, #0x18, w0
    e3dc:	86 23 02    	call      0x2386 <_atof>
    e3de:	00 00 00 
    e3e0:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e3e2:	00 00 00 
    e3e4:	80 00 eb    	clr.w     w1
    e3e6:	12 19 02    	call      0x1912 <___floatunsisf>
    e3e8:	00 00 00 
    e3ea:	02 00 20    	mov.w     #0x0, w2
    e3ec:	83 2c 24    	mov.w     #0x42c8, w3
    e3ee:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e3f0:	00 00 00 
    e3f2:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e3f4:	00 00 00 
    e3f6:	a0 83 88    	mov.w     w0, 0x1074

0000e3f8 <.L0>:
    }

    // 9.- UTC Date
    // ddmmyy
    myTokenizer(NULL, ',', token);
    e3f8:	78 81 57    	sub.w     w15, #0x18, w2
    e3fa:	c1 c2 b3    	mov.b     #0x2c, w1
    e3fc:	00 00 eb    	clr.w     w0
    e3fe:	0f ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e400 <.L0>:
    if (strlen(token) > 5) {
        // get day
//        tmp[0] = token[0];
//        tmp[1] = token[1];
//        mlGpsDateTime.day = (unsigned char) atoi(tmp);
//        // get month
//        tmp[0] = token[2];
//        tmp[1] = token[3];
//        mlGpsDateTime.month = (unsigned char) atoi(tmp);
//        // get year
//        tmp[0] = token[4];
//        tmp[1] = token[5];
//        mlGpsDateTime.year = (unsigned char) atoi(tmp);
    }
}
    e400:	4f 04 78    	mov.w     [--w15], w8
    e402:	00 80 fa    	ulnk      
    e404:	00 00 06    	return    

0000e406 <_parseGGA>:

void parseGGA(unsigned char* stream) {
    e406:	16 00 fa    	lnk       #0x16
    e408:	88 1f 78    	mov.w     w8, [w15++]
    // declare the local vars
    char token[TOKEN_SIZE];
    char tmp [3] = {0, 0, '\0'}, tmp3[4] = {0, 0, 0, '\0'};
    e40a:	80 40 eb    	clr.b     w1
    e40c:	f1 f7 9f    	mov.b     w1, [w15-9]
    e40e:	81 ff 9f    	mov.b     w1, [w15-8]
    e410:	91 ff 9f    	mov.b     w1, [w15-7]
    e412:	60 11 b8    	mul.uu    w2, #0x0, w2
    e414:	d2 bf 9f    	mov.w     w2, [w15-6]
    e416:	e3 bf 9f    	mov.w     w3, [w15-4]

0000e418 <.L0>:
    unsigned char chTmp = 0;

    // initialize tokenizer, let go first token which holds the msg type
    myTokenizer((char *)stream, ',', token);
    e418:	78 81 57    	sub.w     w15, #0x18, w2
    e41a:	c1 c2 b3    	mov.b     #0x2c, w1
    e41c:	00 ff 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e41e <.L0>:

    // 1.- hhmmss.ssss
    myTokenizer(NULL, ',', token);
    e41e:	78 81 57    	sub.w     w15, #0x18, w2
    e420:	c1 c2 b3    	mov.b     #0x2c, w1
    e422:	00 00 eb    	clr.w     w0
    e424:	fc fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e426 <.L0>:
    if (strlen(token) > 5) {
//        tmp[0] = token[0];
//        tmp[1] = token[1];
//        mlGpsDateTime.hour = (unsigned char) atoi(tmp);
//        tmp[0] = token[2];
//        tmp[1] = token[3];
//        mlGpsDateTime.min = (unsigned char) atoi(tmp);
//        tmp[0] = token[4];
//        tmp[1] = token[5];
//        mlGpsDateTime.sec = (unsigned char) atoi(tmp);
    }
    // 2.- Latitude
    // ddmm.mmmmmm
    myTokenizer(NULL, ',', token);
    e426:	78 81 57    	sub.w     w15, #0x18, w2
    e428:	c1 c2 b3    	mov.b     #0x2c, w1
    e42a:	00 00 eb    	clr.w     w0
    e42c:	f8 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e42e <.L0>:
    if (strlen(token) > 0) {
    e42e:	0f e8 97    	mov.b     [w15-24], w0
    e430:	00 04 e0    	cp0.b     w0
    e432:	2f 00 32    	bra       Z, 0xe492 <.L0> <.L0> <.L36>
        // get the first two values
        tmp[0] = token[0];
    e434:	f0 f7 9f    	mov.b     w0, [w15-9]
        tmp[1] = token[1];
    e436:	1f e8 97    	mov.b     [w15-23], w0
    e438:	80 ff 9f    	mov.b     w0, [w15-8]

0000e43a <.L0>:
        // get the degrees
        chTmp = (unsigned char) atoi(tmp);
    e43a:	69 80 57    	sub.w     w15, #0x9, w0
    e43c:	8a 23 02    	call      0x238a <_atoi>
    e43e:	00 00 00 
    e440:	00 04 78    	mov.w     w0, w8

0000e442 <.L0>:
        // make the degrees zero for minutes conversion
        token[0] = '0';
    e442:	00 c3 b3    	mov.b     #0x30, w0
    e444:	80 ef 9f    	mov.b     w0, [w15-24]
        token[1] = '0';
    e446:	90 ef 9f    	mov.b     w0, [w15-23]

0000e448 <.L0>:
        // get the float
        mlGpsData.lat = FLOAT_TO_INT32_1E7(degMinToDeg(chTmp, atof(token)));
    e448:	78 80 57    	sub.w     w15, #0x18, w0
    e44a:	86 23 02    	call      0x2386 <_atof>
    e44c:	00 00 00 
    e44e:	00 01 be    	mov.d     w0, w2
    e450:	08 40 78    	mov.b     w8, w0
    e452:	26 fe 07    	rcall     0xe0a0 <_degMinToDeg> <L0> <.LFB1464> <.LFE1463>
    e454:	02 68 29    	mov.w     #0x9680, w2
    e456:	83 b1 24    	mov.w     #0x4b18, w3
    e458:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e45a:	00 00 00 
    e45c:	94 18 02    	call      0x1894 <___fixsfsi>
    e45e:	00 00 00 
    e460:	10 83 88    	mov.w     w0, 0x1062
    e462:	21 83 88    	mov.w     w1, 0x1064

0000e464 <.L0>:
        // 3.- Latitude Sector
        myTokenizer(NULL, ',', token);
    e464:	78 81 57    	sub.w     w15, #0x18, w2
    e466:	c1 c2 b3    	mov.b     #0x2c, w1
    e468:	00 00 eb    	clr.w     w0
    e46a:	d9 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e46c <.L0>:
        if (strlen(token) == 1) {
    e46c:	78 80 57    	sub.w     w15, #0x18, w0
    e46e:	f8 23 02    	call      0x23f8 <_strlen>
    e470:	00 00 00 
    e472:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    e474:	0e 00 3a    	bra       NZ, 0xe492 <.L0> <.L0> <.L36>

0000e476 <.L0>:
            // set the sign of the float value
            mlGpsData.lat *= gpSmbl((char) token[0]);
    e476:	0f e8 97    	mov.b     [w15-24], w0
    e478:	aa fe 07    	rcall     0xe1ce <_gpSmbl> <L0> <.LFB1469> <.LFE1468>
    e47a:	00 41 78    	mov.b     w0, w2
    e47c:	21 06 21    	mov.w     #0x1062, w1
    e47e:	02 01 fb    	se        w2, w2
    e480:	cf 91 de    	asr.w     w2, #0xf, w3
    e482:	11 00 78    	mov.w     [w1], w0
    e484:	83 82 b9    	.pword 0xb98283
    e486:	11 03 90    	mov.w     [w1+2], w6
    e488:	82 b3 b9    	.pword 0xb9b382
    e48a:	06 02 42    	add.w     w4, w6, w4
    e48c:	02 01 b8    	mul.uu    w0, w2, w2
    e48e:	83 01 42    	add.w     w4, w3, w3
    e490:	82 88 be    	mov.d     w2, [w1]

0000e492 <.L0>:
        }
    }

    // 4.- Longitude
    // ddmm.mmmmmm
    myTokenizer(NULL, ',', token);
    e492:	78 81 57    	sub.w     w15, #0x18, w2
    e494:	c1 c2 b3    	mov.b     #0x2c, w1
    e496:	00 00 eb    	clr.w     w0
    e498:	c2 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e49a <.L0>:
    if (strlen(token) > 0) {
    e49a:	0f e8 97    	mov.b     [w15-24], w0
    e49c:	00 04 e0    	cp0.b     w0
    e49e:	2f 00 32    	bra       Z, 0xe4fe <.L0> <.L37>
        // get the first two values
        tmp3[0] = token[0];
    e4a0:	a0 ff 9f    	mov.b     w0, [w15-6]
        tmp3[1] = token[1];
    e4a2:	1f e8 97    	mov.b     [w15-23], w0
    e4a4:	b0 ff 9f    	mov.b     w0, [w15-5]
        tmp3[2] = token[2];
    e4a6:	2f e8 97    	mov.b     [w15-22], w0
    e4a8:	c0 ff 9f    	mov.b     w0, [w15-4]

0000e4aa <.L0>:
        // get the degrees
        chTmp = (unsigned char) atoi(tmp3);
    e4aa:	66 80 57    	sub.w     w15, #0x6, w0
    e4ac:	8a 23 02    	call      0x238a <_atoi>
    e4ae:	00 00 00 
    e4b0:	00 04 78    	mov.w     w0, w8

0000e4b2 <.L0>:
        // make the degrees zero for minutes conversion
        token[0] = '0';
    e4b2:	00 c3 b3    	mov.b     #0x30, w0
    e4b4:	80 ef 9f    	mov.b     w0, [w15-24]
        token[1] = '0';
    e4b6:	90 ef 9f    	mov.b     w0, [w15-23]
        token [2] = '0';
    e4b8:	a0 ef 9f    	mov.b     w0, [w15-22]

0000e4ba <.L0>:
        // get the float
        mlGpsData.lon = FLOAT_TO_INT32_1E7(degMinToDeg(chTmp, atof(token)));
    e4ba:	78 80 57    	sub.w     w15, #0x18, w0
    e4bc:	86 23 02    	call      0x2386 <_atof>
    e4be:	00 00 00 
    e4c0:	00 01 be    	mov.d     w0, w2
    e4c2:	08 40 78    	mov.b     w8, w0
    e4c4:	ed fd 07    	rcall     0xe0a0 <_degMinToDeg> <L0> <.LFB1464> <.LFE1463>
    e4c6:	02 68 29    	mov.w     #0x9680, w2
    e4c8:	83 b1 24    	mov.w     #0x4b18, w3
    e4ca:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e4cc:	00 00 00 
    e4ce:	94 18 02    	call      0x1894 <___fixsfsi>
    e4d0:	00 00 00 
    e4d2:	30 83 88    	mov.w     w0, 0x1066
    e4d4:	41 83 88    	mov.w     w1, 0x1068

0000e4d6 <.L0>:

        // 5.- Longitude Sector
        myTokenizer(NULL, ',', token);
    e4d6:	78 81 57    	sub.w     w15, #0x18, w2
    e4d8:	c1 c2 b3    	mov.b     #0x2c, w1
    e4da:	00 00 eb    	clr.w     w0
    e4dc:	a0 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e4de <.L0>:

        if (strlen(token) > 0) {
    e4de:	0f e8 97    	mov.b     [w15-24], w0
    e4e0:	00 04 e0    	cp0.b     w0

0000e4e2 <.L0>:
            // set the sign of the float value
            mlGpsData.lon *= gpSmbl((char) token[0]);
    e4e2:	0d 00 32    	bra       Z, 0xe4fe <.L0> <.L37>
    e4e4:	74 fe 07    	rcall     0xe1ce <_gpSmbl> <L0> <.LFB1469> <.LFE1468>
    e4e6:	00 41 78    	mov.b     w0, w2
    e4e8:	61 06 21    	mov.w     #0x1066, w1
    e4ea:	02 01 fb    	se        w2, w2
    e4ec:	cf 91 de    	asr.w     w2, #0xf, w3
    e4ee:	11 00 78    	mov.w     [w1], w0
    e4f0:	83 82 b9    	.pword 0xb98283
    e4f2:	11 03 90    	mov.w     [w1+2], w6
    e4f4:	82 b3 b9    	.pword 0xb9b382
    e4f6:	06 02 42    	add.w     w4, w6, w4
    e4f8:	02 01 b8    	mul.uu    w0, w2, w2
    e4fa:	83 01 42    	add.w     w4, w3, w3
    e4fc:	82 88 be    	mov.d     w2, [w1]

0000e4fe <.L0>:
        }
    }

    // 6.- Quality Indicator
    myTokenizer(NULL, ',', token);
    e4fe:	78 81 57    	sub.w     w15, #0x18, w2
    e500:	c1 c2 b3    	mov.b     #0x2c, w1
    e502:	00 00 eb    	clr.w     w0
    e504:	8c fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e506 <.L0>:
    if (strlen(token) == 1) {
    e506:	78 80 57    	sub.w     w15, #0x18, w0
    e508:	f8 23 02    	call      0x23f8 <_strlen>
    e50a:	00 00 00 
    e50c:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    e50e:	0a 00 3a    	bra       NZ, 0xe524 <.L0> <.L38>

0000e510 <.L0>:
        chTmp = (unsigned char) atoi(token);
    e510:	78 80 57    	sub.w     w15, #0x18, w0
    e512:	8a 23 02    	call      0x238a <_atoi>
    e514:	00 00 00 

0000e516 <.L0>:
        mlGpsData.fix_type =  (chTmp>1 && chTmp < 6)? GPS_FIX_3D : GPS_FIX_NONE ;
    e516:	00 c0 e9    	dec2.b    w0, w0
    e518:	80 40 eb    	clr.b     w1
    e51a:	e3 4f 50    	sub.b     w0, #0x3, [w15]
    e51c:	01 00 3e    	bra       GTU, 0xe520 <.L39>
    e51e:	31 c0 b3    	mov.b     #0x3, w1

0000e520 <.L39>:
    e520:	60 07 21    	mov.w     #0x1076, w0
    e522:	01 48 78    	mov.b     w1, [w0]

0000e524 <.L0>:
    }

    // 7.- Sats used in solution
    // xx
    myTokenizer(NULL, ',', token);
    e524:	78 81 57    	sub.w     w15, #0x18, w2
    e526:	c1 c2 b3    	mov.b     #0x2c, w1
    e528:	00 00 eb    	clr.w     w0
    e52a:	79 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e52c <.L0>:
    if (strlen(token) > 0) {
    e52c:	0f e8 97    	mov.b     [w15-24], w0
    e52e:	00 04 e0    	cp0.b     w0
    e530:	05 00 32    	bra       Z, 0xe53c <.L0> <.L0> <.L40>

0000e532 <.L0>:
        //mlGpsDateTime.visSat = (unsigned char) atoi(token);
        mlGpsData.satellites_visible = (unsigned char) atoi(token);
    e532:	78 80 57    	sub.w     w15, #0x18, w0
    e534:	8a 23 02    	call      0x238a <_atoi>
    e536:	00 00 00 
    e538:	71 07 21    	mov.w     #0x1077, w1
    e53a:	80 48 78    	mov.b     w0, [w1]

0000e53c <.L0>:
    }

    // 8.- HDOP given from 0 to 99.99 but stored from 0 - 990 
    //in integers, i.e HDOP = HDOP_stored/100 CAUTION
    // xx.xx
    myTokenizer(NULL, ',', token);
    e53c:	78 81 57    	sub.w     w15, #0x18, w2
    e53e:	c1 c2 b3    	mov.b     #0x2c, w1
    e540:	00 00 eb    	clr.w     w0
    e542:	6d fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e544 <.L0>:
    if (strlen(token) > 0) {
    e544:	0f e8 97    	mov.b     [w15-24], w0
    e546:	00 04 e0    	cp0.b     w0
    e548:	13 00 32    	bra       Z, 0xe570 <.L0> <.L0> <.L41>

0000e54a <.L0>:
        mlGpsData.eph = FLOAT_TO_UINT16_1E2((unsigned short) (atof(token) * 10.0));
    e54a:	78 80 57    	sub.w     w15, #0x18, w0
    e54c:	86 23 02    	call      0x2386 <_atof>
    e54e:	00 00 00 
    e550:	02 00 20    	mov.w     #0x0, w2
    e552:	03 12 24    	mov.w     #0x4120, w3
    e554:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e556:	00 00 00 
    e558:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e55a:	00 00 00 
    e55c:	80 00 eb    	clr.w     w1
    e55e:	12 19 02    	call      0x1912 <___floatunsisf>
    e560:	00 00 00 
    e562:	02 00 20    	mov.w     #0x0, w2
    e564:	83 2c 24    	mov.w     #0x42c8, w3
    e566:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e568:	00 00 00 
    e56a:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    e56c:	00 00 00 
    e56e:	70 83 88    	mov.w     w0, 0x106e

0000e570 <.L0>:
    }

    // 9.- Altitude above mean sea level given in meters
    // xxx.xxx
    myTokenizer(NULL, ',', token);
    e570:	78 81 57    	sub.w     w15, #0x18, w2
    e572:	c1 c2 b3    	mov.b     #0x2c, w1
    e574:	00 00 eb    	clr.w     w0
    e576:	53 fe 07    	rcall     0xe21e <_myTokenizer> <L0> <.LFB1470> <.LFE1469>

0000e578 <.L0>:
    if (strlen(token) > 0) {
    e578:	0f e8 97    	mov.b     [w15-24], w0
    e57a:	00 04 e0    	cp0.b     w0
    e57c:	0b 00 32    	bra       Z, 0xe594 <.L0> <.L35>

0000e57e <.L0>:
        mlGpsData.alt = FLOAT_TO_INT32_1E3(atof(token));
    e57e:	78 80 57    	sub.w     w15, #0x18, w0
    e580:	86 23 02    	call      0x2386 <_atof>
    e582:	00 00 00 
    e584:	02 00 20    	mov.w     #0x0, w2
    e586:	a3 47 24    	mov.w     #0x447a, w3
    e588:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    e58a:	00 00 00 
    e58c:	94 18 02    	call      0x1894 <___fixsfsi>
    e58e:	00 00 00 
    e590:	50 83 88    	mov.w     w0, 0x106a
    e592:	61 83 88    	mov.w     w1, 0x106c

0000e594 <.L0>:
    }

}
    e594:	4f 04 78    	mov.w     [--w15], w8
    e596:	00 80 fa    	ulnk      
    e598:	00 00 06    	return    

0000e59a <_getChecksum>:

// GPS checksum code based on 
// http://www.codeproject.com/KB/mobile/WritingGPSApplications2.aspx
// original code in C# written by Jon Person, author of "GPS.NET" (www.gpsdotnet.com)

unsigned char getChecksum(unsigned char* sentence, unsigned char size) {

    // Loop through all chars to get a checksum
    unsigned char checkSum = 0;
    e59a:	00 42 eb    	clr.b     w4
    unsigned char i;
    for (i = 0; i < size; i++) {
    e59c:	01 04 e0    	cp0.b     w1
    e59e:	11 00 32    	bra       Z, 0xe5c2 <.L45>
    e5a0:	04 41 78    	mov.b     w4, w2
    e5a2:	02 42 78    	mov.b     w2, w4
        if (sentence[i] == DOLLAR) {
    e5a4:	45 c2 b3    	mov.b     #0x24, w5
            // Ignore the dollar sign
        } else if (sentence[i] == STAR) {
    e5a6:	a6 c2 b3    	mov.b     #0x2a, w6

0000e5a8 <.L47>:
    e5a8:	b0 41 78    	mov.b     [w0++], w3
    e5aa:	85 cf 51    	sub.b     w3, w5, [w15]
    e5ac:	07 00 32    	bra       Z, 0xe5bc <.L46>
    e5ae:	86 cf 51    	sub.b     w3, w6, [w15]
    e5b0:	08 00 32    	bra       Z, 0xe5c2 <.L45>
            // Stop processing before the asterisk
            break;
        } else {
            // Is this the first value for the checksum?
            if (i == 0) {
    e5b2:	02 04 e0    	cp0.b     w2
    e5b4:	02 00 32    	bra       Z, 0xe5ba <.L49>
                // Yes. Set the checksum to the value
                checkSum = sentence[i];
            } else {
                // No. XOR the checksum with this character's value
                checkSum ^= sentence[i];
    e5b6:	03 42 6a    	xor.b     w4, w3, w4
    e5b8:	01 00 37    	bra       0xe5bc <.L46>

0000e5ba <.L49>:
    e5ba:	03 42 78    	mov.b     w3, w4

0000e5bc <.L46>:
    e5bc:	02 41 e8    	inc.b     w2, w2
    e5be:	82 cf 50    	sub.b     w1, w2, [w15]
    e5c0:	f3 ff 3e    	bra       GTU, 0xe5a8 <.L47>

0000e5c2 <.L45>:
            }
        }
    }
    // Return the checksum 
    return checkSum;
}
    e5c2:	04 40 78    	mov.b     w4, w0
    e5c4:	00 00 06    	return    

0000e5c6 <_gpsDebugMsg>:

void gpsDebugMsg(unsigned char buf)
{
  uint16_t msg_length = PackTextMsg(101,1,buf);
    e5c6:	00 41 78    	mov.b     w0, w2
    e5c8:	11 c0 b3    	mov.b     #0x1, w1
    e5ca:	50 c6 b3    	mov.b     #0x65, w0
    e5cc:	72 d0 02    	call      0xd072 <_PackTextMsg>
    e5ce:	00 00 00 

0000e5d0 <.L0>:

  TxN_Data_OverU1(
    e5d0:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
    e5d2:	00 00 00 
                  msg_length
                  );
}
    e5d4:	00 00 06    	return    

0000e5d6 <_gpsUbloxSeparate>:
    e5d6:	88 9f be    	mov.d     w8, [w15++]
    e5d8:	8a 9f be    	mov.d     w10, [w15++]
    e5da:	8c 9f be    	mov.d     w12, [w15++]
    e5dc:	8e 1f 78    	mov.w     w14, [w15++]
    e5de:	00 06 78    	mov.w     w0, w12

0000e5e0 <.L0>:
    e5e0:	c0 b2 81    	mov.w     0x3658, w0
    e5e2:	c0 0a 02    	call      0x10ac0 <_getLength>
    e5e4:	01 00 00 
    e5e6:	00 44 78    	mov.b     w0, w8

0000e5e8 <.L0>:
    e5e8:	00 4a 24    	mov.w     #0x44a0, w0
    e5ea:	10 04 e0    	cp0.b     [w0]
    e5ec:	0e 00 32    	bra       Z, 0xe60a <.L0> <.L53>
    e5ee:	49 c2 b3    	mov.b     #0x24, w9
    e5f0:	08 04 e0    	cp0.b     w8
    e5f2:	06 00 3a    	bra       NZ, 0xe600 <.L69>
    e5f4:	1e 00 37    	bra       0xe632 <.L0> <.L0> <.L58>

0000e5f6 <.L0>:
    e5f6:	c0 b2 81    	mov.w     0x3658, w0
    e5f8:	14 0b 02    	call      0x10b14 <_readFront>
    e5fa:	01 00 00 

0000e5fc <.L0>:
    e5fc:	08 44 e9    	dec.b     w8, w8

0000e5fe <.L0>:
    e5fe:	19 00 32    	bra       Z, 0xe632 <.L0> <.L0> <.L58>

0000e600 <.L69>:
    e600:	c0 b2 81    	mov.w     0x3658, w0
    e602:	f4 0a 02    	call      0x10af4 <_peak>
    e604:	01 00 00 
    e606:	89 4f 50    	sub.b     w0, w9, [w15]
    e608:	f6 ff 3a    	bra       NZ, 0xe5f6 <.L0> <.L56>

0000e60a <.L0>:
    e60a:	08 04 e0    	cp0.b     w8
    e60c:	0b 00 3a    	bra       NZ, 0xe624 <.L57>
    e60e:	11 00 37    	bra       0xe632 <.L0> <.L0> <.L58>

0000e610 <.L0>:
    e610:	19 85 fb    	ze        [w9], w10
    e612:	c0 b2 81    	mov.w     0x3658, w0
    e614:	14 0b 02    	call      0x10b14 <_readFront>
    e616:	01 00 00 
    e618:	0a 85 45    	add.w     w11, w10, w10
    e61a:	00 4d 78    	mov.b     w0, [w10]

0000e61c <.L0>:
    e61c:	99 4c e8    	inc.b     [w9], [w9]
    e61e:	08 44 e9    	dec.b     w8, w8
    e620:	03 00 3a    	bra       NZ, 0xe628 <.L0> <.L70>
    e622:	07 00 37    	bra       0xe632 <.L0> <.L0> <.L58>

0000e624 <.L57>:
    e624:	89 86 23    	mov.w     #0x3868, w9
    e626:	9b 86 23    	mov.w     #0x3869, w11

0000e628 <.L0>:
    e628:	c0 b2 81    	mov.w     0x3658, w0
    e62a:	f4 0a 02    	call      0x10af4 <_peak>
    e62c:	01 00 00 
    e62e:	ed 4f 50    	sub.b     w0, #0xd, [w15]
    e630:	ef ff 3a    	bra       NZ, 0xe610 <.L0> <.L59>

0000e632 <.L0>:
    e632:	c0 b2 81    	mov.w     0x3658, w0
    e634:	f4 0a 02    	call      0x10af4 <_peak>
    e636:	01 00 00 
    e638:	ed 4f 50    	sub.b     w0, #0xd, [w15]
    e63a:	1d 00 3a    	bra       NZ, 0xe676 <.L60>

0000e63c <.L0>:
    e63c:	8d 86 23    	mov.w     #0x3868, w13
    e63e:	9d 44 78    	mov.b     [w13], w9
    e640:	89 85 fb    	ze        w9, w11
    e642:	9a 86 23    	mov.w     #0x3869, w10
    e644:	0b 00 45    	add.w     w10, w11, w0
    e646:	60 f8 97    	mov.b     [w0-2], w0
    e648:	13 fd 07    	rcall     0xe070 <_hex2char> <L0> <.L0> <.LFB1463> <.LFE1472> <.Letext0> <.Ltext0>
    e64a:	00 47 78    	mov.b     w0, w14

0000e64c <.L0>:
    e64c:	8b 05 45    	add.w     w10, w11, w11
    e64e:	7b f8 97    	mov.b     [w11-1], w0
    e650:	0f fd 07    	rcall     0xe070 <_hex2char> <L0> <.L0> <.LFB1463> <.LFE1472> <.Letext0> <.Ltext0>
    e652:	80 45 78    	mov.b     w0, w11

0000e654 <.L0>:
    e654:	89 40 78    	mov.b     w9, w1
    e656:	0a 00 78    	mov.w     w10, w0
    e658:	a0 ff 07    	rcall     0xe59a <_getChecksum> <L0> <.LFB1473> <.LFE1472>

0000e65a <.L0>:
    e65a:	41 00 20    	mov.w     #0x4, w1
    e65c:	01 77 dd    	sl.w      w14, w1, w14
    e65e:	8b 45 47    	add.b     w14, w11, w11
    e660:	0b 40 68    	xor.b     w0, w11, w0
    e662:	00 80 fb    	ze        w0, w0
    e664:	00 00 e9    	dec.w     w0, w0
    e666:	4f 00 de    	lsr.w     w0, #0xf, w0
    e668:	12 c0 b3    	mov.b     #0x1, w2
    e66a:	01 4a 24    	mov.w     #0x44a0, w1
    e66c:	82 48 78    	mov.b     w2, [w1]
    e66e:	70 fe 9b    	mov.b     w0, [w12+511]
    e670:	80 4e eb    	clr.b     [w13]
    e672:	04 00 3a    	bra       NZ, 0xe67c <.L61>
    e674:	25 00 37    	bra       0xe6c0 <.L62>

0000e676 <.L60>:
    e676:	00 4a 24    	mov.w     #0x44a0, w0
    e678:	00 48 eb    	clr.b     [w0]
    e67a:	22 00 37    	bra       0xe6c0 <.L62>

0000e67c <.L61>:
    e67c:	09 04 e0    	cp0.b     w9
    e67e:	0a 00 32    	bra       Z, 0xe694 <.L0> <.L63>
    e680:	10 c0 b3    	mov.b     #0x1, w0
    e682:	93 86 23    	mov.w     #0x3869, w3

0000e684 <.L64>:
    e684:	80 80 fb    	ze        w0, w1
    e686:	01 01 46    	add.w     w12, w1, w2
    e688:	81 80 41    	add.w     w3, w1, w1
    e68a:	f1 f8 97    	mov.b     [w1-1], w1
    e68c:	01 49 78    	mov.b     w1, [w2]
    e68e:	00 40 e8    	inc.b     w0, w0
    e690:	80 cf 54    	sub.b     w9, w0, [w15]
    e692:	f8 ff 31    	bra       C, 0xe684 <.L64>

0000e694 <.L0>:
    e694:	61 c0 b3    	mov.b     #0x6, w1
    e696:	90 86 23    	mov.w     #0x3869, w0
    e698:	80 ff 07    	rcall     0xe59a <_getChecksum> <L0> <.LFB1473> <.LFE1472>
    e69a:	80 44 78    	mov.b     w0, w9

0000e69c <.L0>:
    e69c:	c0 b2 81    	mov.w     0x3658, w0
    e69e:	c0 0a 02    	call      0x10ac0 <_getLength>
    e6a0:	01 00 00 
    e6a2:	91 ff 07    	rcall     0xe5c6 <_gpsDebugMsg> <L0> <.L0> <.LFB1474> <.LFE1473>

0000e6a4 <.L0>:
    e6a4:	b0 c4 b3    	mov.b     #0x4b, w0
    e6a6:	80 cf 54    	sub.b     w9, w0, [w15]
    e6a8:	06 00 32    	bra       Z, 0xe6b6 <.L66>
    e6aa:	6b 40 40    	add.b     w0, #0xb, w0
    e6ac:	80 cf 54    	sub.b     w9, w0, [w15]
    e6ae:	06 00 3a    	bra       NZ, 0xe6bc <.L71>
    e6b0:	10 c0 b3    	mov.b     #0x1, w0
    e6b2:	00 4e 78    	mov.b     w0, [w12]
    e6b4:	05 00 37    	bra       0xe6c0 <.L62>

0000e6b6 <.L66>:
    e6b6:	20 c0 b3    	mov.b     #0x2, w0
    e6b8:	00 4e 78    	mov.b     w0, [w12]
    e6ba:	02 00 37    	bra       0xe6c0 <.L62>

0000e6bc <.L71>:
    e6bc:	e0 cf b3    	mov.b     #0xfe, w0
    e6be:	00 4e 78    	mov.b     w0, [w12]

0000e6c0 <.L62>:
    e6c0:	08 40 78    	mov.b     w8, w0
    e6c2:	4f 07 78    	mov.w     [--w15], w14
    e6c4:	4f 06 be    	mov.d     [--w15], w12
    e6c6:	4f 05 be    	mov.d     [--w15], w10
    e6c8:	4f 04 be    	mov.d     [--w15], w8
    e6ca:	00 00 06    	return    

0000e6cc <_AUAV_Barometer_Driver_Init>:
    e6cc:	10 00 20    	mov.w     #0x1, w0
    e6ce:	a0 ff 88    	mov.w     w0, 0x1ff4

0000e6d0 <.L0>:
    e6d0:	60 1d 22    	mov.w     #0x21d6, w0
    e6d2:	42 11 02    	call      0x11142 <_EnablesDisablestheCom_Init>
    e6d4:	01 00 00 

0000e6d6 <.L0>:
    e6d6:	00 00 06    	return    

0000e6d8 <_AUA_Barometer_Driver_Start>:
    e6d8:	f0 1f 20    	mov.w     #0x1ff, w0
    e6da:	a0 10 88    	mov.w     w0, 0x214
    e6dc:	00 30 28    	mov.w     #0x8300, w0
    e6de:	b0 10 88    	mov.w     w0, 0x216
    e6e0:	04 6e a9    	bclr.b    0xe04, #0x3
    e6e2:	04 4e a9    	bclr.b    0xe04, #0x2
    e6e4:	c0 42 80    	mov.w     0x858, w0
    e6e6:	00 80 a1    	bclr.w    w0, #0x8
    e6e8:	00 90 a0    	bset.w    w0, #0x9
    e6ea:	00 a0 a0    	bset.w    w0, #0xa
    e6ec:	c0 42 88    	mov.w     w0, 0x858
    e6ee:	06 48 a9    	bclr.b    0x806, #0x2
    e6f0:	26 48 a8    	bset.b    0x826, #0x2
    e6f2:	00 00 06    	return    

0000e6f4 <_AUAV_V3_T_Barometer_Driver>:
}

/* Output and update for atomic system: '<Root>/Barometer_Driver' */
void AUAV_V3_T_Barometer_Driver(void)
{
    e6f4:	fc 87 47    	add.w     w15, #0x1c, w15
    e6f6:	88 9f be    	mov.d     w8, [w15++]
    e6f8:	8a 9f be    	mov.d     w10, [w15++]
    e6fa:	8c 9f be    	mov.d     w12, [w15++]
    e6fc:	8e 1f 78    	mov.w     w14, [w15++]
  /* local block i/o variables */
  real_T rtb_DataTypeConversion;
  real_T rtb_DiscreteZeroPole;
  uint16_T rtb_Sum1_n;
  uint16_T rtb_SumB21;
  boolean_T rtb_LogicalOperator;
  int16_T rtb_B6;
  int32_T rtb_Bias5;
  uint32_T rtb_B4;
  real32_T rtb_x;
  uint32_T rtb_Sum6;
  uint32_T qY;
  uint32_T qY_0;

  /* S-Function (MCHP_BUS_I2C_MASTER): '<S1>/BUS I2C Initialize BMP180 Read T, Convert P @ 100Hz' */
  /* number of I2C blocks : 5 ; Current: 2 ; MCHP_I2C_StartImplemented =  3*/
  if (MCHP_I2C22_Request == 0)         /* Last I2C sequence from this block is finished (not in the queue ?) */
    e6fe:	10 1d 82    	mov.w     0x43a2, w0
    e700:	00 00 e0    	cp0.w     w0
    e702:	1b 00 3a    	bra       NZ, 0xe73a <.L4>
  {
    AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadTConv[0] = I2C22_Buff8[0];
    e704:	40 aa 21    	mov.w     #0x1aa4, w0
    e706:	c1 3b 24    	mov.w     #0x43bc, w1
    e708:	11 48 78    	mov.b     [w1], [w0]
    AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadTConv[1] = I2C22_Buff8[1];
    e70a:	00 00 e8    	inc.w     w0, w0
    e70c:	81 00 e8    	inc.w     w1, w1
    e70e:	11 48 78    	mov.b     [w1], [w0]
    MCHP_I2C22_Request ++;
    e710:	10 1d 82    	mov.w     0x43a2, w0
    e712:	00 00 e8    	inc.w     w0, w0
    e714:	10 1d 8a    	mov.w     w0, 0x43a2
    MCHP_I2C2_Queue.buffer[MCHP_I2C2_Queue.head] = 4;
    e716:	a0 3b 24    	mov.w     #0x43ba, w0
    e718:	90 00 78    	mov.w     [w0], w1
    e71a:	81 80 40    	add.w     w1, w1, w1
    e71c:	6e 01 50    	sub.w     w0, #0xe, w2
    e71e:	81 00 41    	add.w     w2, w1, w1
    e720:	42 00 20    	mov.w     #0x4, w2
    e722:	82 08 78    	mov.w     w2, [w1]
    if (MCHP_I2C2_Queue.head >= 5)     /* There are 5 blocks I2C2, max idx for queue is 5 */
    e724:	90 0f 11    	subr.w    w2, [w0], [w15]
    e726:	02 00 36    	bra       LEU, 0xe72c <.L5>
      MCHP_I2C2_Queue.head = 0;
    e728:	00 08 eb    	clr.w     [w0]
    e72a:	02 00 37    	bra       0xe730 <.L6>

0000e72c <.L5>:
    else
      MCHP_I2C2_Queue.head ++;
    e72c:	a0 3b 24    	mov.w     #0x43ba, w0
    e72e:	10 08 e8    	inc.w     [w0], [w0]

0000e730 <.L6>:
    if (MCHP_I2C2_State == 0)
    e730:	00 1d 82    	mov.w     0x43a0, w0
    e732:	00 00 e0    	cp0.w     w0
    e734:	11 00 3a    	bra       NZ, 0xe758 <.L7>
      _MI2C2IF = 1;                    /* Force Interrupt */
    e736:	06 48 a8    	bset.b    0x806, #0x2
    e738:	0f 00 37    	bra       0xe758 <.L7>

0000e73a <.L4>:
  } else if (MCHP_I2C22_Request > 3) {
    e73a:	10 1d 82    	mov.w     0x43a2, w0
    e73c:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    e73e:	09 00 36    	bra       LEU, 0xe752 <.L8>
    I2C2CONbits.I2CEN = 0;             /* Switch Off I2C*/
    e740:	17 e2 a9    	bclr.b    0x217, #0x7
    TRISAbits.TRISA3 = 0;              /* Set I2C Port as Port Output */
    e742:	00 6e a9    	bclr.b    0xe00, #0x3
    TRISAbits.TRISA2 = 0;
    e744:	00 4e a9    	bclr.b    0xe00, #0x2
    MCHP_I2C22_Request = 0;            /* This block might still be in the queue provided another I2C block stuck the bus, Next block execution will however add another Request */
    e746:	00 00 eb    	clr.w     w0
    e748:	10 1d 8a    	mov.w     w0, 0x43a2
    MCHP_I2C2_State = 1;               /* try to Reset I2C BUS */
    e74a:	10 00 20    	mov.w     #0x1, w0
    e74c:	00 1d 8a    	mov.w     w0, 0x43a0
    _MI2C2IF = 1;                      /* Force Interrupt */
    e74e:	06 48 a8    	bset.b    0x806, #0x2
    e750:	03 00 37    	bra       0xe758 <.L7>

0000e752 <.L8>:
  } else
    MCHP_I2C22_Request++;
    e752:	10 1d 82    	mov.w     0x43a2, w0
    e754:	00 00 e8    	inc.w     w0, w0
    e756:	10 1d 8a    	mov.w     w0, 0x43a2

0000e758 <.L7>:

  /* Sum: '<S32>/SumA21' incorporates:
   *  DataTypeConversion: '<S34>/Data Type Conversion1'
   *  DataTypeConversion: '<S34>/Data Type Conversion3'
   *  Delay: '<S32>/Delay11'
   *  Gain: '<S32>/a(2)(1)'
   *  Gain: '<S32>/s(1)'
   *  Gain: '<S34>/Gain'
   *  S-Function (sfix_bitop): '<S34>/Bitwise Operator'
   */
  rtb_B4 = ((uint16_T)AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadTConv[0] <<
    e758:	40 aa 21    	mov.w     #0x1aa4, w0
    e75a:	10 84 fb    	ze        [w0], w8
    e75c:	48 44 dd    	sl.w      w8, #0x8, w8
            8 | AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadTConv[1]) *
    e75e:	00 00 e8    	inc.w     w0, w0
    e760:	10 80 fb    	ze        [w0], w0
    e762:	08 04 70    	ior.w     w0, w8, w8
    e764:	d0 cc 27    	mov.w     #0x7ccd, w0
    e766:	00 44 b8    	mul.uu    w8, w0, w8
    e768:	4b 48 dd    	sl.w      w9, #0xb, w0
    e76a:	45 44 de    	lsr.w     w8, #0x5, w8
    e76c:	08 04 70    	ior.w     w0, w8, w8
    e76e:	c5 4c de    	lsr.w     w9, #0x5, w9

0000e770 <.L0>:
    31949UL >> 5;
  qY_0 = rtb_B4 + mul_u32_u32_u32_sr15(30771UL,
    e770:	a2 fd 80    	mov.w     0x1fb4, w2
    e772:	b3 fd 80    	mov.w     0x1fb6, w3
    e774:	30 83 27    	mov.w     #0x7833, w0
    e776:	01 00 20    	mov.w     #0x0, w1
    e778:	36 48 02    	call      0x4836 <_mul_u32_u32_u32_sr15>
    e77a:	00 00 00 
    e77c:	00 01 44    	add.w     w8, w0, w2
    e77e:	81 81 4c    	addc.w    w9, w1, w3
    e780:	f2 b7 9f    	mov.w     w2, [w15-18]
    e782:	83 bf 9f    	mov.w     w3, [w15-16]

0000e784 <.L0>:
    AUAV_V3_TestSensors_DWork.Delay11_DSTATE);
  if (qY_0 < rtb_B4) {
    e784:	82 0f 54    	sub.w     w8, w2, [w15]
    e786:	83 8f 5c    	subb.w    w9, w3, [w15]
    e788:	08 00 3e    	bra       GTU, 0xe79a <.L42>
    qY_0 = MAX_uint32_T;
  }

  /* Sum: '<S32>/SumB21' incorporates:
   *  Delay: '<S32>/Delay11'
   *  Sum: '<S32>/SumA21'
   */
  if (qY_0 > 2147483647UL) {
    rtb_B4 = MAX_uint32_T;
    e78a:	00 80 eb    	setm.w    w0
    e78c:	80 80 eb    	setm.w    w1
    e78e:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    e790:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    e792:	09 00 35    	bra       LT, 0xe7a6 <.L9>
  } else {
    rtb_B4 = qY_0 << 1;
    e794:	02 00 41    	add.w     w2, w2, w0
    e796:	83 80 49    	addc.w    w3, w3, w1
    e798:	06 00 37    	bra       0xe7a6 <.L9>

0000e79a <.L42>:
    e79a:	00 80 eb    	setm.w    w0
    e79c:	80 80 eb    	setm.w    w1
    e79e:	f0 b7 9f    	mov.w     w0, [w15-18]
    e7a0:	81 bf 9f    	mov.w     w1, [w15-16]
    e7a2:	00 80 eb    	setm.w    w0
    e7a4:	80 80 eb    	setm.w    w1

0000e7a6 <.L9>:
  }

  if (AUAV_V3_TestSensors_DWork.Delay11_DSTATE > 2147483647UL) {
    e7a6:	a4 fd 80    	mov.w     0x1fb4, w4
    e7a8:	b5 fd 80    	mov.w     0x1fb6, w5
    rtb_Sum6 = MAX_uint32_T;
    e7aa:	00 81 eb    	setm.w    w2
    e7ac:	80 81 eb    	setm.w    w3
    e7ae:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    e7b0:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    e7b2:	02 00 35    	bra       LT, 0xe7b8 <.L10>
  } else {
    rtb_Sum6 = AUAV_V3_TestSensors_DWork.Delay11_DSTATE << 1;
    e7b4:	04 01 42    	add.w     w4, w4, w2
    e7b6:	85 81 4a    	addc.w    w5, w5, w3

0000e7b8 <.L10>:
  }

  qY = rtb_B4 + rtb_Sum6;
    e7b8:	02 01 40    	add.w     w0, w2, w2
    e7ba:	83 81 48    	addc.w    w1, w3, w3
  if (qY < rtb_B4) {
    e7bc:	82 0f 50    	sub.w     w0, w2, [w15]
    e7be:	83 8f 58    	subb.w    w1, w3, [w15]
    e7c0:	02 00 36    	bra       LEU, 0xe7c6 <.L11>
    qY = MAX_uint32_T;
    e7c2:	00 81 eb    	setm.w    w2
    e7c4:	80 81 eb    	setm.w    w3

0000e7c6 <.L11>:
  }

  rtb_Sum1_n = (uint16_T)(qY >> 16);
    e7c6:	83 00 78    	mov.w     w3, w1
    e7c8:	c1 b7 9f    	mov.w     w1, [w15-24]

  /* End of Sum: '<S32>/SumB21' */

  /* S-Function (MCHP_BUS_I2C_MASTER): '<S1>/BUS I2C Initialize BMP180 Read P, Convert T @100Hz' */
  /* number of I2C blocks : 5 ; Current: 3 ; MCHP_I2C_StartImplemented =  3*/
  if (MCHP_I2C23_Request == 0)         /* Last I2C sequence from this block is finished (not in the queue ?) */
    e7ca:	20 1d 82    	mov.w     0x43a4, w0
    e7cc:	00 00 e0    	cp0.w     w0
    e7ce:	1c 00 3a    	bra       NZ, 0xe808 <.L12>
  {
    AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadPConv[0] = I2C23_Buff8[0];
    e7d0:	60 aa 21    	mov.w     #0x1aa6, w0
    e7d2:	e1 3b 24    	mov.w     #0x43be, w1
    e7d4:	11 48 78    	mov.b     [w1], [w0]
    AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadPConv[1] = I2C23_Buff8[1];
    e7d6:	00 00 e8    	inc.w     w0, w0
    e7d8:	81 00 e8    	inc.w     w1, w1
    e7da:	11 48 78    	mov.b     [w1], [w0]
    MCHP_I2C23_Request ++;
    e7dc:	20 1d 82    	mov.w     0x43a4, w0
    e7de:	00 00 e8    	inc.w     w0, w0
    e7e0:	20 1d 8a    	mov.w     w0, 0x43a4
    MCHP_I2C2_Queue.buffer[MCHP_I2C2_Queue.head] = 20;
    e7e2:	a0 3b 24    	mov.w     #0x43ba, w0
    e7e4:	90 00 78    	mov.w     [w0], w1
    e7e6:	81 80 40    	add.w     w1, w1, w1
    e7e8:	6e 01 50    	sub.w     w0, #0xe, w2
    e7ea:	81 00 41    	add.w     w2, w1, w1
    e7ec:	42 01 20    	mov.w     #0x14, w2
    e7ee:	82 08 78    	mov.w     w2, [w1]
    if (MCHP_I2C2_Queue.head >= 5)     /* There are 5 blocks I2C2, max idx for queue is 5 */
    e7f0:	42 00 20    	mov.w     #0x4, w2
    e7f2:	90 0f 11    	subr.w    w2, [w0], [w15]
    e7f4:	02 00 36    	bra       LEU, 0xe7fa <.L13>
      MCHP_I2C2_Queue.head = 0;
    e7f6:	00 08 eb    	clr.w     [w0]
    e7f8:	02 00 37    	bra       0xe7fe <.L14>

0000e7fa <.L13>:
    else
      MCHP_I2C2_Queue.head ++;
    e7fa:	a0 3b 24    	mov.w     #0x43ba, w0
    e7fc:	10 08 e8    	inc.w     [w0], [w0]

0000e7fe <.L14>:
    if (MCHP_I2C2_State == 0)
    e7fe:	00 1d 82    	mov.w     0x43a0, w0
    e800:	00 00 e0    	cp0.w     w0
    e802:	11 00 3a    	bra       NZ, 0xe826 <.L15>
      _MI2C2IF = 1;                    /* Force Interrupt */
    e804:	06 48 a8    	bset.b    0x806, #0x2
    e806:	0f 00 37    	bra       0xe826 <.L15>

0000e808 <.L12>:
  } else if (MCHP_I2C23_Request > 3) {
    e808:	20 1d 82    	mov.w     0x43a4, w0
    e80a:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    e80c:	09 00 36    	bra       LEU, 0xe820 <.L16>
    I2C2CONbits.I2CEN = 0;             /* Switch Off I2C*/
    e80e:	17 e2 a9    	bclr.b    0x217, #0x7
    TRISAbits.TRISA3 = 0;              /* Set I2C Port as Port Output */
    e810:	00 6e a9    	bclr.b    0xe00, #0x3
    TRISAbits.TRISA2 = 0;
    e812:	00 4e a9    	bclr.b    0xe00, #0x2
    MCHP_I2C23_Request = 0;            /* This block might still be in the queue provided another I2C block stuck the bus, Next block execution will however add another Request */
    e814:	00 00 eb    	clr.w     w0
    e816:	20 1d 8a    	mov.w     w0, 0x43a4
    MCHP_I2C2_State = 1;               /* try to Reset I2C BUS */
    e818:	10 00 20    	mov.w     #0x1, w0
    e81a:	00 1d 8a    	mov.w     w0, 0x43a0
    _MI2C2IF = 1;                      /* Force Interrupt */
    e81c:	06 48 a8    	bset.b    0x806, #0x2
    e81e:	03 00 37    	bra       0xe826 <.L15>

0000e820 <.L16>:
  } else
    MCHP_I2C23_Request++;
    e820:	20 1d 82    	mov.w     0x43a4, w0
    e822:	00 00 e8    	inc.w     w0, w0
    e824:	20 1d 8a    	mov.w     w0, 0x43a4

0000e826 <.L15>:

  /* Sum: '<S33>/SumA21' incorporates:
   *  DataTypeConversion: '<S35>/Data Type Conversion1'
   *  DataTypeConversion: '<S35>/Data Type Conversion3'
   *  Delay: '<S33>/Delay11'
   *  Gain: '<S33>/a(2)(1)'
   *  Gain: '<S33>/s(1)'
   *  Gain: '<S35>/Gain'
   *  S-Function (sfix_bitop): '<S35>/Bitwise Operator'
   */
  rtb_B4 = ((uint16_T)AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadPConv[0] <<
    e826:	60 aa 21    	mov.w     #0x1aa6, w0
    e828:	10 84 fb    	ze        [w0], w8
    e82a:	48 44 dd    	sl.w      w8, #0x8, w8
            8 | AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180ReadPConv[1]) *
    e82c:	00 00 e8    	inc.w     w0, w0
    e82e:	10 80 fb    	ze        [w0], w0
    e830:	08 04 70    	ior.w     w0, w8, w8
    e832:	d0 cc 27    	mov.w     #0x7ccd, w0
    e834:	00 44 b8    	mul.uu    w8, w0, w8
    e836:	cb 49 dd    	sl.w      w9, #0xb, w3
    e838:	45 44 de    	lsr.w     w8, #0x5, w8
    e83a:	08 84 71    	ior.w     w3, w8, w8
    e83c:	c5 4c de    	lsr.w     w9, #0x5, w9

0000e83e <.L0>:
    31949UL >> 5;
  qY = rtb_B4 + mul_u32_u32_u32_sr15(30771UL,
    e83e:	c2 fd 80    	mov.w     0x1fb8, w2
    e840:	d3 fd 80    	mov.w     0x1fba, w3
    e842:	30 83 27    	mov.w     #0x7833, w0
    e844:	01 00 20    	mov.w     #0x0, w1
    e846:	36 48 02    	call      0x4836 <_mul_u32_u32_u32_sr15>
    e848:	00 00 00 
    e84a:	00 01 44    	add.w     w8, w0, w2
    e84c:	81 81 4c    	addc.w    w9, w1, w3
    e84e:	d2 b7 9f    	mov.w     w2, [w15-22]
    e850:	e3 b7 9f    	mov.w     w3, [w15-20]

0000e852 <.L0>:
    AUAV_V3_TestSensors_DWork.Delay11_DSTATE_j);
  if (qY < rtb_B4) {
    e852:	82 0f 54    	sub.w     w8, w2, [w15]
    e854:	83 8f 5c    	subb.w    w9, w3, [w15]
    e856:	08 00 3e    	bra       GTU, 0xe868 <.L46>
    qY = MAX_uint32_T;
  }

  /* Sum: '<S33>/SumB21' incorporates:
   *  Delay: '<S33>/Delay11'
   *  Sum: '<S33>/SumA21'
   */
  if (qY > 2147483647UL) {
    rtb_B4 = MAX_uint32_T;
    e858:	00 80 eb    	setm.w    w0
    e85a:	80 80 eb    	setm.w    w1
    e85c:	e0 0f 51    	sub.w     w2, #0x0, [w15]
    e85e:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    e860:	09 00 35    	bra       LT, 0xe874 <.L17>
  } else {
    rtb_B4 = qY << 1;
    e862:	02 00 41    	add.w     w2, w2, w0
    e864:	83 80 49    	addc.w    w3, w3, w1
    e866:	06 00 37    	bra       0xe874 <.L17>

0000e868 <.L46>:
    e868:	00 80 eb    	setm.w    w0
    e86a:	80 80 eb    	setm.w    w1
    e86c:	d0 b7 9f    	mov.w     w0, [w15-22]
    e86e:	e1 b7 9f    	mov.w     w1, [w15-20]
    e870:	00 80 eb    	setm.w    w0
    e872:	80 80 eb    	setm.w    w1

0000e874 <.L17>:
  }

  if (AUAV_V3_TestSensors_DWork.Delay11_DSTATE_j > 2147483647UL) {
    e874:	c4 fd 80    	mov.w     0x1fb8, w4
    e876:	d5 fd 80    	mov.w     0x1fba, w5
    rtb_Sum6 = MAX_uint32_T;
    e878:	00 81 eb    	setm.w    w2
    e87a:	80 81 eb    	setm.w    w3
    e87c:	e0 0f 52    	sub.w     w4, #0x0, [w15]
    e87e:	e0 8f 5a    	subb.w    w5, #0x0, [w15]
    e880:	02 00 35    	bra       LT, 0xe886 <.L18>
  } else {
    rtb_Sum6 = AUAV_V3_TestSensors_DWork.Delay11_DSTATE_j << 1;
    e882:	04 01 42    	add.w     w4, w4, w2
    e884:	85 81 4a    	addc.w    w5, w5, w3

0000e886 <.L18>:
  }

  rtb_Sum6 += rtb_B4;
    e886:	02 01 40    	add.w     w0, w2, w2
    e888:	83 81 48    	addc.w    w1, w3, w3
  if (rtb_Sum6 < rtb_B4) {
    e88a:	82 0f 50    	sub.w     w0, w2, [w15]
    e88c:	83 8f 58    	subb.w    w1, w3, [w15]
    e88e:	02 00 36    	bra       LEU, 0xe894 <.L19>
    rtb_Sum6 = MAX_uint32_T;
    e890:	00 81 eb    	setm.w    w2
    e892:	80 81 eb    	setm.w    w3

0000e894 <.L19>:
  }

  rtb_SumB21 = (uint16_T)(rtb_Sum6 >> 16);
    e894:	83 00 78    	mov.w     w3, w1
    e896:	a1 b7 9f    	mov.w     w1, [w15-28]

0000e898 <.L0>:

  /* End of Sum: '<S33>/SumB21' */

  /* Logic: '<S1>/Logical Operator' */
  rtb_LogicalOperator = !(AUAV_V3_TestSensors_B.HILManualSwitch != 0.0);
    e898:	18 c0 b3    	mov.b     #0x1, w8
    e89a:	60 11 b8    	mul.uu    w2, #0x0, w2
    e89c:	f0 ae 80    	mov.w     0x15de, w0
    e89e:	01 af 80    	mov.w     0x15e0, w1
    e8a0:	c8 19 02    	call      0x19c8 <___nesf2>
    e8a2:	00 00 00 
    e8a4:	00 00 e0    	cp0.w     w0
    e8a6:	01 00 3a    	bra       NZ, 0xe8aa <.L20>
    e8a8:	00 44 eb    	clr.b     w8

0000e8aa <.L20>:
    e8aa:	08 04 a2    	btg.b     w8, #0x0
    e8ac:	e8 e7 9f    	mov.b     w8, [w15-26]

0000e8ae <.L0>:

  /* Outputs for Enabled SubSystem: '<S1>/Disable path through in HIL Subsystem' incorporates:
   *  EnablePort: '<S29>/Enable'
   */
  if (rtb_LogicalOperator) {
    e8ae:	08 41 78    	mov.b     w8, w2
    e8b0:	02 04 e0    	cp0.b     w2
    e8b2:	04 00 32    	bra       Z, 0xe8bc <.L21>
    /* DataStoreWrite: '<S29>/Update RawPressure' incorporates:
     *  DataTypeConversion: '<S1>/Data Type Conversion7'
     *  DataTypeConversion: '<S1>/Data Type Conversion8'
     */
    mlRawPressureData.press_abs = (int16_T)rtb_Sum1_n;
    e8b4:	cf b1 97    	mov.w     [w15-24], w3
    e8b6:	f3 85 88    	mov.w     w3, 0x10be
    mlRawPressureData.temperature = (int16_T)rtb_SumB21;
    e8b8:	2f b2 97    	mov.w     [w15-28], w4
    e8ba:	24 86 88    	mov.w     w4, 0x10c4

0000e8bc <.L21>:
  }

  /* End of Outputs for SubSystem: '<S1>/Disable path through in HIL Subsystem' */

  /* Outputs for Enabled SubSystem: '<S1>/I2C Initialisation Read EEPROM Calibration data Once (Blocking Function)' incorporates:
   *  EnablePort: '<S31>/Enable'
   */
  /* Delay: '<S1>/Delay' */
  if (AUAV_V3_TestSensors_DWork.Delay_DSTATE > 0U) {
    e8bc:	a0 ff 80    	mov.w     0x1ff4, w0
    e8be:	00 00 e0    	cp0.w     w0
    e8c0:	ab 00 32    	bra       Z, 0xea18 <.L22>
    /* S-Function (MCHP_BUS_I2C_MASTER): '<S31>/BUS I2C Initialize BMP180 read Calibration data @ 100Hz' */
    /* number of I2C blocks : 5 ; Current: 1 ; MCHP_I2C_StartImplemented =  3*/
    {
      /* Enable I2C sequence */
      MCHP_I2C21_Request ++;
    e8c2:	30 1d 82    	mov.w     0x43a6, w0
    e8c4:	00 00 e8    	inc.w     w0, w0
    e8c6:	30 1d 8a    	mov.w     w0, 0x43a6
      MCHP_I2C2_Queue.buffer[MCHP_I2C2_Queue.head] = 36;
    e8c8:	a0 3b 24    	mov.w     #0x43ba, w0
    e8ca:	90 00 78    	mov.w     [w0], w1
    e8cc:	81 80 40    	add.w     w1, w1, w1
    e8ce:	6e 01 50    	sub.w     w0, #0xe, w2
    e8d0:	81 00 41    	add.w     w2, w1, w1
    e8d2:	42 02 20    	mov.w     #0x24, w2
    e8d4:	82 08 78    	mov.w     w2, [w1]
      if (MCHP_I2C2_Queue.head >= 5)   /* There are 5 blocks I2C2, max idx for queue is 5 */
    e8d6:	49 00 20    	mov.w     #0x4, w9
    e8d8:	90 8f 14    	subr.w    w9, [w0], [w15]
    e8da:	02 00 36    	bra       LEU, 0xe8e0 <.L23>
        MCHP_I2C2_Queue.head = 0;
    e8dc:	00 08 eb    	clr.w     [w0]
    e8de:	02 00 37    	bra       0xe8e4 <.L24>

0000e8e0 <.L23>:
      else
        MCHP_I2C2_Queue.head ++;
    e8e0:	a0 3b 24    	mov.w     #0x43ba, w0
    e8e2:	10 08 e8    	inc.w     [w0], [w0]

0000e8e4 <.L24>:
      if (MCHP_I2C2_State == 0)
    e8e4:	00 1d 82    	mov.w     0x43a0, w0
    e8e6:	00 00 e0    	cp0.w     w0
    e8e8:	01 00 3a    	bra       NZ, 0xe8ec <.L55>
        _MI2C2IF = 1;
    e8ea:	06 48 a8    	bset.b    0x806, #0x2

0000e8ec <.L55>:

      /* Wait for end of SPI sequence (handle within an interrupt) */
      while (MCHP_I2C21_Request != 0) ;/* Wait until end of SPI sequence. */
    e8ec:	30 1d 82    	mov.w     0x43a6, w0
    e8ee:	00 00 e0    	cp0.w     w0
    e8f0:	fd ff 3a    	bra       NZ, 0xe8ec <.L55>
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[0] = I2C21_Buff8[0];
    e8f2:	00 3c 24    	mov.w     #0x43c0, w0
    e8f4:	10 47 78    	mov.b     [w0], w14
    e8f6:	80 aa 21    	mov.w     #0x1aa8, w0
    e8f8:	0e 48 78    	mov.b     w14, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[1] = I2C21_Buff8[1];
    e8fa:	10 3c 24    	mov.w     #0x43c1, w0
    e8fc:	10 46 78    	mov.b     [w0], w12
    e8fe:	90 aa 21    	mov.w     #0x1aa9, w0
    e900:	0c 48 78    	mov.b     w12, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[2] = I2C21_Buff8[2];
    e902:	20 3c 24    	mov.w     #0x43c2, w0
    e904:	90 45 78    	mov.b     [w0], w11
    e906:	a0 aa 21    	mov.w     #0x1aaa, w0
    e908:	0b 48 78    	mov.b     w11, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[3] = I2C21_Buff8[3];
    e90a:	30 3c 24    	mov.w     #0x43c3, w0
    e90c:	90 44 78    	mov.b     [w0], w9
    e90e:	b0 aa 21    	mov.w     #0x1aab, w0
    e910:	09 48 78    	mov.b     w9, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[4] = I2C21_Buff8[4];
    e912:	40 3c 24    	mov.w     #0x43c4, w0
    e914:	10 45 78    	mov.b     [w0], w10
    e916:	c0 aa 21    	mov.w     #0x1aac, w0
    e918:	0a 48 78    	mov.b     w10, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[5] = I2C21_Buff8[5];
    e91a:	50 3c 24    	mov.w     #0x43c5, w0
    e91c:	10 44 78    	mov.b     [w0], w8
    e91e:	d0 aa 21    	mov.w     #0x1aad, w0
    e920:	08 48 78    	mov.b     w8, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[6] = I2C21_Buff8[6];
    e922:	60 3c 24    	mov.w     #0x43c6, w0
    e924:	10 40 78    	mov.b     [w0], w0
    e926:	a0 e7 9f    	mov.b     w0, [w15-30]
    e928:	e0 aa 21    	mov.w     #0x1aae, w0
    e92a:	af e0 97    	mov.b     [w15-30], w1
    e92c:	01 48 78    	mov.b     w1, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[7] = I2C21_Buff8[7];
    e92e:	70 3c 24    	mov.w     #0x43c7, w0
    e930:	10 40 78    	mov.b     [w0], w0
    e932:	80 e7 9f    	mov.b     w0, [w15-32]
    e934:	f0 aa 21    	mov.w     #0x1aaf, w0
    e936:	0f e1 97    	mov.b     [w15-32], w2
    e938:	02 48 78    	mov.b     w2, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[8] = I2C21_Buff8[8];
    e93a:	80 3c 24    	mov.w     #0x43c8, w0
    e93c:	10 40 78    	mov.b     [w0], w0
    e93e:	e0 df 9f    	mov.b     w0, [w15-34]
    e940:	00 ab 21    	mov.w     #0x1ab0, w0
    e942:	ef d9 97    	mov.b     [w15-34], w3
    e944:	03 48 78    	mov.b     w3, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[9] = I2C21_Buff8[9];
    e946:	90 3c 24    	mov.w     #0x43c9, w0
    e948:	10 40 78    	mov.b     [w0], w0
    e94a:	c0 df 9f    	mov.b     w0, [w15-36]
    e94c:	10 ab 21    	mov.w     #0x1ab1, w0
    e94e:	4f da 97    	mov.b     [w15-36], w4
    e950:	04 48 78    	mov.b     w4, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[10] = I2C21_Buff8[10];
    e952:	a0 3c 24    	mov.w     #0x43ca, w0
    e954:	10 40 78    	mov.b     [w0], w0
    e956:	a0 df 9f    	mov.b     w0, [w15-38]
    e958:	20 ab 21    	mov.w     #0x1ab2, w0
    e95a:	af d8 97    	mov.b     [w15-38], w1
    e95c:	01 48 78    	mov.b     w1, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[11] = I2C21_Buff8[11];
    e95e:	b0 3c 24    	mov.w     #0x43cb, w0
    e960:	10 40 78    	mov.b     [w0], w0
    e962:	80 df 9f    	mov.b     w0, [w15-40]
    e964:	30 ab 21    	mov.w     #0x1ab3, w0
    e966:	0f d9 97    	mov.b     [w15-40], w2
    e968:	02 48 78    	mov.b     w2, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[12] = I2C21_Buff8[12];
    e96a:	c0 3c 24    	mov.w     #0x43cc, w0
    e96c:	90 43 78    	mov.b     [w0], w7
    e96e:	40 ab 21    	mov.w     #0x1ab4, w0
    e970:	07 48 78    	mov.b     w7, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[13] = I2C21_Buff8[13];
    e972:	d0 3c 24    	mov.w     #0x43cd, w0
    e974:	10 43 78    	mov.b     [w0], w6
    e976:	50 ab 21    	mov.w     #0x1ab5, w0
    e978:	06 48 78    	mov.b     w6, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[14] = I2C21_Buff8[14];
    e97a:	e0 3c 24    	mov.w     #0x43ce, w0
    e97c:	90 42 78    	mov.b     [w0], w5
    e97e:	60 ab 21    	mov.w     #0x1ab6, w0
    e980:	05 48 78    	mov.b     w5, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[15] = I2C21_Buff8[15];
    e982:	f0 3c 24    	mov.w     #0x43cf, w0
    e984:	10 42 78    	mov.b     [w0], w4
    e986:	70 ab 21    	mov.w     #0x1ab7, w0
    e988:	04 48 78    	mov.b     w4, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[16] = I2C21_Buff8[16];
    e98a:	00 00 e8    	inc.w     w0, w0
    e98c:	01 3d 24    	mov.w     #0x43d0, w1
    e98e:	11 48 78    	mov.b     [w1], [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[17] = I2C21_Buff8[17];
    e990:	00 00 e8    	inc.w     w0, w0
    e992:	81 00 e8    	inc.w     w1, w1
    e994:	11 48 78    	mov.b     [w1], [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[18] = I2C21_Buff8[18];
    e996:	01 00 e8    	inc.w     w1, w0
    e998:	90 41 78    	mov.b     [w0], w3
    e99a:	a0 ab 21    	mov.w     #0x1aba, w0
    e99c:	03 48 78    	mov.b     w3, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[19] = I2C21_Buff8[19];
    e99e:	01 80 e8    	inc2.w    w1, w0
    e9a0:	10 41 78    	mov.b     [w0], w2
    e9a2:	b0 ab 21    	mov.w     #0x1abb, w0
    e9a4:	02 48 78    	mov.b     w2, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[20] = I2C21_Buff8[20];
    e9a6:	63 80 40    	add.w     w1, #0x3, w0
    e9a8:	90 40 78    	mov.b     [w0], w1
    e9aa:	c0 ab 21    	mov.w     #0x1abc, w0
    e9ac:	01 48 78    	mov.b     w1, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[21] = I2C21_Buff8[21];
    e9ae:	50 3d 24    	mov.w     #0x43d5, w0
    e9b0:	10 40 78    	mov.b     [w0], w0
    e9b2:	dd ab 21    	mov.w     #0x1abd, w13
    e9b4:	80 4e 78    	mov.b     w0, [w13]
    }

    /* DataTypeConversion: '<S31>/Data Type Conversion1' incorporates:
     *  DataTypeConversion: '<S48>/Data Type Conversion1'
     *  DataTypeConversion: '<S48>/Data Type Conversion3'
     *  Gain: '<S48>/Gain'
     *  S-Function (sfix_bitop): '<S48>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition3 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[2] << 8 |
    e9b6:	c8 5e dd    	sl.w      w11, #0x8, w13
    e9b8:	89 85 fb    	ze        w9, w11
    e9ba:	49 9b 21    	mov.w     #0x19b4, w9
    e9bc:	8b 8c 76    	ior.w     w13, w11, [w9]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[3]);

    /* DataTypeConversion: '<S31>/Data Type Conversion2' incorporates:
     *  DataTypeConversion: '<S47>/Data Type Conversion1'
     *  DataTypeConversion: '<S47>/Data Type Conversion3'
     *  Gain: '<S47>/Gain'
     *  S-Function (sfix_bitop): '<S47>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition2 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[0] << 8 |
    e9be:	8e 04 78    	mov.w     w14, w9
    e9c0:	48 4f dd    	sl.w      w9, #0x8, w14
    e9c2:	0c 86 fb    	ze        w12, w12
    e9c4:	29 9b 21    	mov.w     #0x19b2, w9
    e9c6:	8c 0c 77    	ior.w     w14, w12, [w9]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[1]);

    /* DataTypeConversion: '<S31>/Data Type Conversion3' incorporates:
     *  DataTypeConversion: '<S49>/Data Type Conversion1'
     *  DataTypeConversion: '<S49>/Data Type Conversion3'
     *  Gain: '<S49>/Gain'
     *  S-Function (sfix_bitop): '<S49>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition4 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[4] << 8 |
    e9c8:	48 55 dd    	sl.w      w10, #0x8, w10
    e9ca:	08 84 fb    	ze        w8, w8
    e9cc:	e4 84 44    	add.w     w9, #0x4, w9
    e9ce:	88 0c 75    	ior.w     w10, w8, [w9]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[5]);

    /* DataTypeConversion: '<S31>/Data Type Conversion4' incorporates:
     *  DataTypeConversion: '<S53>/Data Type Conversion1'
     *  DataTypeConversion: '<S53>/Data Type Conversion3'
     *  Gain: '<S53>/Gain'
     *  S-Function (sfix_bitop): '<S53>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition8 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[12] << 8 |
    e9d0:	c8 3b dd    	sl.w      w7, #0x8, w7
    e9d2:	06 83 fb    	ze        w6, w6
    e9d4:	09 84 e8    	inc2.w    w9, w8
    e9d6:	06 8c 73    	ior.w     w7, w6, [w8]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[13]);

    /* DataTypeConversion: '<S31>/Data Type Conversion5' incorporates:
     *  DataTypeConversion: '<S54>/Data Type Conversion1'
     *  DataTypeConversion: '<S54>/Data Type Conversion3'
     *  Gain: '<S54>/Gain'
     *  S-Function (sfix_bitop): '<S54>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition9 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[14] << 8 |
    e9d8:	c8 2a dd    	sl.w      w5, #0x8, w5
    e9da:	04 82 fb    	ze        w4, w4
    e9dc:	08 83 e8    	inc2.w    w8, w6
    e9de:	04 8b 72    	ior.w     w5, w4, [w6]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[15]);

    /* DataTypeConversion: '<S31>/Data Type Conversion7' incorporates:
     *  DataTypeConversion: '<S45>/Data Type Conversion1'
     *  DataTypeConversion: '<S45>/Data Type Conversion3'
     *  Gain: '<S45>/Gain'
     *  S-Function (sfix_bitop): '<S45>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition11 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[18] << 8 |
    e9e0:	c8 19 dd    	sl.w      w3, #0x8, w3
    e9e2:	02 81 fb    	ze        w2, w2
    e9e4:	6c 02 53    	sub.w     w6, #0xc, w4
    e9e6:	02 8a 71    	ior.w     w3, w2, [w4]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[19]);

    /* DataTypeConversion: '<S31>/Data Type Conversion8' incorporates:
     *  DataTypeConversion: '<S46>/Data Type Conversion1'
     *  DataTypeConversion: '<S46>/Data Type Conversion3'
     *  Gain: '<S46>/Gain'
     *  S-Function (sfix_bitop): '<S46>/Bitwise Operator'
     */
    AUAV_V3_TestSensors_B.RateTransition12 = (int16_T)((uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[20] << 8 |
    e9e8:	c8 08 dd    	sl.w      w1, #0x8, w1
    e9ea:	00 80 fb    	ze        w0, w0
    e9ec:	04 81 e8    	inc2.w    w4, w2
    e9ee:	00 89 70    	ior.w     w1, w0, [w2]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[21]);

    /* S-Function (sfix_bitop): '<S50>/Bitwise Operator' incorporates:
     *  DataTypeConversion: '<S50>/Data Type Conversion1'
     *  DataTypeConversion: '<S50>/Data Type Conversion3'
     *  Gain: '<S50>/Gain'
     */
    AUAV_V3_TestSensors_B.RateTransition5 = (uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[6] << 8 |
    e9f0:	2f e0 97    	mov.b     [w15-30], w0
    e9f2:	48 01 dd    	sl.w      w0, #0x8, w2
    e9f4:	8f e1 97    	mov.b     [w15-32], w3
    e9f6:	83 80 fb    	ze        w3, w1
    e9f8:	40 06 20    	mov.w     #0x64, w0
    e9fa:	04 00 40    	add.w     w0, w4, w0
    e9fc:	01 08 71    	ior.w     w2, w1, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[7];

    /* S-Function (sfix_bitop): '<S51>/Bitwise Operator' incorporates:
     *  DataTypeConversion: '<S51>/Data Type Conversion1'
     *  DataTypeConversion: '<S51>/Data Type Conversion3'
     *  Gain: '<S51>/Gain'
     */
    AUAV_V3_TestSensors_B.RateTransition6 = (uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[8] << 8 |
    e9fe:	6f da 97    	mov.b     [w15-34], w4
    ea00:	48 21 dd    	sl.w      w4, #0x8, w2
    ea02:	cf dc 97    	mov.b     [w15-36], w9
    ea04:	89 80 fb    	ze        w9, w1
    ea06:	00 80 e8    	inc2.w    w0, w0
    ea08:	01 08 71    	ior.w     w2, w1, [w0]
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[9];

    /* S-Function (sfix_bitop): '<S52>/Bitwise Operator' incorporates:
     *  DataTypeConversion: '<S52>/Data Type Conversion1'
     *  DataTypeConversion: '<S52>/Data Type Conversion3'
     *  Gain: '<S52>/Gain'
     */
    AUAV_V3_TestSensors_B.RateTransition7 = (uint16_T)
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[10] << 8 |
    ea0a:	2f d8 97    	mov.b     [w15-38], w0
    ea0c:	48 01 dd    	sl.w      w0, #0x8, w2
    ea0e:	8f d9 97    	mov.b     [w15-40], w3
    ea10:	83 80 fb    	ze        w3, w1
    ea12:	c0 05 20    	mov.w     #0x5c, w0
    ea14:	06 00 40    	add.w     w0, w6, w0
    ea16:	01 08 71    	ior.w     w2, w1, [w0]

0000ea18 <.L22>:
      AUAV_V3_TestSensors_B.BUSI2CInitializeBMP180readCalib[11];
  }

  /* End of Delay: '<S1>/Delay' */
  /* End of Outputs for SubSystem: '<S1>/I2C Initialisation Read EEPROM Calibration data Once (Blocking Function)' */

  /* Sum: '<S27>/Sum' */
  rtb_Sum1_n -= AUAV_V3_TestSensors_B.RateTransition7;
    ea18:	60 a1 21    	mov.w     #0x1a16, w0
    ea1a:	4f b2 97    	mov.w     [w15-24], w4
    ea1c:	10 00 52    	sub.w     w4, [w0], w0

  /* Product: '<S27>/Product' */
  rtb_Sum6 = (uint32_T)rtb_Sum1_n * AUAV_V3_TestSensors_B.RateTransition6;
    ea1e:	41 a1 21    	mov.w     #0x1a14, w1
    ea20:	11 00 b8    	mul.uu    w0, [w1], w0
  rtb_Sum1_n = (uint16_T)(((uint16_T)((int16_T)rtb_Sum6 & 16384) != 0U) +
    ea22:	08 00 24    	mov.w     #0x4000, w8
    ea24:	00 04 64    	and.w     w8, w0, w8
    ea26:	08 04 ea    	neg.w     w8, w8
    ea28:	4f 44 de    	lsr.w     w8, #0xf, w8
    (rtb_Sum6 >> 15));
    ea2a:	c1 0c dd    	sl.w      w1, #0x1, w9
    ea2c:	4f 00 de    	lsr.w     w0, #0xf, w0
    ea2e:	00 80 74    	ior.w     w9, w0, w0
    ea30:	cf 08 de    	lsr.w     w1, #0xf, w1
    ea32:	00 04 44    	add.w     w8, w0, w8

  /* Sum: '<S27>/Sum2' incorporates:
   *  Bias: '<S27>/Bias'
   *  Bias: '<S27>/Bias1'
   *  Product: '<S27>/Product1'
   *  Sum: '<S27>/Sum1'
   */
  rtb_B6 = (div_s16s32_round((int32_T)AUAV_V3_TestSensors_B.RateTransition11 <<
             11, rtb_Sum1_n + AUAV_V3_TestSensors_B.RateTransition12) + (int16_T)
    ea34:	00 9b 21    	mov.w     #0x19b0, w0
    ea36:	10 01 44    	add.w     w8, [w0], w2

0000ea38 <.L0>:
    ea38:	80 01 eb    	clr.w     w3
    ea3a:	74 cd 80    	mov.w     0x19ae, w4
    ea3c:	cf a2 de    	asr.w     w4, #0xf, w5
    ea3e:	4b 28 dd    	sl.w      w5, #0xb, w0
    ea40:	c5 20 de    	lsr.w     w4, #0x5, w1
    ea42:	81 00 70    	ior.w     w0, w1, w1
    ea44:	4b 20 dd    	sl.w      w4, #0xb, w0
    ea46:	04 4c 02    	call      0x4c04 <_div_s16s32_round>
    ea48:	00 00 00 

0000ea4a <.L0>:
    ea4a:	0e 06 2f    	mov.w     #0xf060, w14
    ea4c:	0e 04 44    	add.w     w8, w14, w8
    ea4e:	00 07 44    	add.w     w8, w0, w14

0000ea50 <.L0>:
            rtb_Sum1_n) - 4000;

  /* MATLAB Function: '<S28>/Enables//Disables the Computation of  initial Baro Bias' */
  EnablesDisablestheComputat
    (&AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputatio,
    ea50:	61 1d 22    	mov.w     #0x21d6, w1
    ea52:	40 d5 21    	mov.w     #0x1d54, w0
    ea54:	4e 11 02    	call      0x1114e <_EnablesDisablestheComputat>
    ea56:	01 00 00 

0000ea58 <.L0>:
     &AUAV_V3_TestSensors_DWork.sf_EnablesDisablestheComputatio);

  /* Outputs for Enabled SubSystem: '<S28>/Zero Out Height' incorporates:
   *  EnablePort: '<S41>/Enable'
   */
  if (AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputatio.tOut > 0.0) {
    ea58:	60 11 b8    	mul.uu    w2, #0x0, w2
    ea5a:	a0 ea 80    	mov.w     0x1d54, w0
    ea5c:	b1 ea 80    	mov.w     0x1d56, w1
    ea5e:	90 18 02    	call      0x1890 <___gesf2>
    ea60:	00 00 00 
    ea62:	00 00 e0    	cp0.w     w0
    ea64:	07 00 34    	bra       LE, 0xea74 <.L0> <.L27>

0000ea66 <.L0>:
    /* Sum: '<S41>/Sum' incorporates:
     *  Constant: '<S28>/Constant5'
     *  Delay: '<S41>/Integer Delay'
     */
    AUAV_V3_TestSensors_B.Sum_k = 0.0F -
    ea66:	62 fd 80    	mov.w     0x1fac, w2
    ea68:	73 fd 80    	mov.w     0x1fae, w3
    ea6a:	60 00 b8    	mul.uu    w0, #0x0, w0
    ea6c:	90 14 02    	call      0x1490 <___subsf3>
    ea6e:	00 00 00 
    ea70:	10 c8 88    	mov.w     w0, 0x1902
    ea72:	21 c8 88    	mov.w     w1, 0x1904

0000ea74 <.L0>:
      AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_jh;
  }

  /* End of Outputs for SubSystem: '<S28>/Zero Out Height' */

  /* Math: '<S27>/Math Function' */
  rtb_Bias5 = (int32_T)rtb_B6 * rtb_B6;
    ea74:	0e f4 b9    	mul.ss    w14, w14, w8

  /* Sum: '<S27>/Sum6' incorporates:
   *  Bias: '<S27>/Bias2'
   *  Product: '<S27>/Product2'
   *  Product: '<S27>/Product3'
   *  Sum: '<S27>/Sum3'
   *  Sum: '<S27>/Sum4'
   */
  rtb_Sum6 = (uint32_T)rtb_SumB21 - (((((int16_T)((int32_T)rtb_B6 *
    ea76:	aa cd 80    	mov.w     0x19b4, w10
    ea78:	0a f5 b9    	mul.ss    w14, w10, w10
    AUAV_V3_TestSensors_B.RateTransition3 >> 11) + (int16_T)mul_s32_s32_s32_sr23
    ea7a:	c5 58 dd    	sl.w      w11, #0x5, w1
    ea7c:	4b 55 de    	lsr.w     w10, #0xb, w10
    ea7e:	0a 85 70    	ior.w     w1, w10, w10
    ea80:	cb dd de    	asr.w     w11, #0xb, w11

0000ea82 <.L0>:
    (AUAV_V3_TestSensors_B.RateTransition9, rtb_Bias5)) + ((int32_T)
    ea82:	d0 cd 80    	mov.w     0x19ba, w0
    ea84:	cf 80 de    	asr.w     w0, #0xf, w1
    ea86:	08 01 be    	mov.d     w8, w2
    ea88:	e0 4b 02    	call      0x4be0 <_mul_s32_s32_s32_sr23>
    ea8a:	00 00 00 

0000ea8c <.L0>:
    ea8c:	2f b2 97    	mov.w     [w15-28], w4
    ea8e:	61 21 b8    	mul.uu    w4, #0x1, w2
    ea90:	94 cd 80    	mov.w     0x19b2, w4
    ea92:	cf a2 de    	asr.w     w4, #0xf, w5
    AUAV_V3_TestSensors_B.RateTransition2 << 2)) + 2L) >> 2);
    ea94:	42 2e dd    	sl.w      w5, #0x2, w12
    ea96:	ce 26 de    	lsr.w     w4, #0xe, w13
    ea98:	8d 06 76    	ior.w     w12, w13, w13
    ea9a:	42 26 dd    	sl.w      w4, #0x2, w12
    ea9c:	62 06 46    	add.w     w12, #0x2, w12
    ea9e:	e0 86 4e    	addc.w    w13, #0x0, w13
    eaa0:	00 00 45    	add.w     w10, w0, w0
    eaa2:	4f 82 de    	asr.w     w0, #0xf, w4
    eaa4:	0c 00 40    	add.w     w0, w12, w0
    eaa6:	8d 00 4a    	addc.w    w4, w13, w1
    eaa8:	4e 0a dd    	sl.w      w1, #0xe, w4
    eaaa:	42 00 de    	lsr.w     w0, #0x2, w0
    eaac:	00 00 72    	ior.w     w4, w0, w0
    eaae:	c2 88 de    	asr.w     w1, #0x2, w1
    eab0:	00 06 51    	sub.w     w2, w0, w12
    eab2:	81 86 59    	subb.w    w3, w1, w13

  /* Product: '<S27>/Product6' incorporates:
   *  Bias: '<S27>/Bias3'
   *  Bias: '<S27>/Bias4'
   *  Gain: '<S27>/Gain1'
   *  Product: '<S27>/Product4'
   *  Product: '<S27>/Product5'
   *  Sum: '<S27>/Sum9'
   */
  rtb_B4 = mul_u32_s32_u32_sr15(((((int16_T)((int32_T)rtb_B6 *
    eab4:	9a d0 80    	mov.w     0x1a12, w10
    eab6:	80 05 eb    	clr.w     w11
    eab8:	b0 cd 80    	mov.w     0x19b6, w0
    eaba:	00 f0 b9    	mul.ss    w14, w0, w0
    AUAV_V3_TestSensors_B.RateTransition4 >> 13) + (int16_T)mul_s32_s32_s32_sr28
    eabc:	c3 09 dd    	sl.w      w1, #0x3, w3
    eabe:	4d 00 de    	lsr.w     w0, #0xd, w0
    eac0:	00 80 71    	ior.w     w3, w0, w0
    eac2:	cd 88 de    	asr.w     w1, #0xd, w1
    eac4:	00 02 78    	mov.w     w0, w4
    eac6:	c4 b7 9f    	mov.w     w4, [w15-24]

0000eac8 <.L0>:
    (rtb_Bias5, AUAV_V3_TestSensors_B.RateTransition8)) + 2) >> 2) + 32768L,
    eac8:	c2 cd 80    	mov.w     0x19b8, w2
    eaca:	cf 91 de    	asr.w     w2, #0xf, w3
    eacc:	08 00 be    	mov.d     w8, w0
    eace:	bc 4b 02    	call      0x4bbc <_mul_s32_s32_s32_sr28>
    ead0:	00 00 00 

0000ead2 <.L0>:
    ead2:	cf b4 97    	mov.w     [w15-24], w9
    ead4:	09 81 e8    	inc2.w    w9, w2
    ead6:	00 00 41    	add.w     w2, w0, w0
    ead8:	42 80 de    	asr.w     w0, #0x2, w0

0000eada <.L0>:
    eada:	02 00 28    	mov.w     #0x8000, w2
    eadc:	03 00 20    	mov.w     #0x0, w3
    eade:	4f 82 de    	asr.w     w0, #0xf, w4
    eae0:	02 00 40    	add.w     w0, w2, w0
    eae2:	83 00 4a    	addc.w    w4, w3, w1
    eae4:	0a 01 be    	mov.d     w10, w2
    eae6:	98 4b 02    	call      0x4b98 <_mul_u32_s32_u32_sr15>
    eae8:	00 00 00 
    eaea:	00 04 be    	mov.d     w0, w8

0000eaec <.L0>:
    AUAV_V3_TestSensors_B.RateTransition5);

  /* Switch: '<S27>/Switch' incorporates:
   *  Gain: '<S27>/Gain15'
   *  Gain: '<S27>/Gain22'
   *  Product: '<S27>/Product7'
   *  Product: '<S27>/Product8'
   */
  if (rtb_Sum6 > 2147483647UL) {
    eaec:	e0 0f 56    	sub.w     w12, #0x0, [w15]
    eaee:	e0 8f 5e    	subb.w    w13, #0x0, [w15]
    eaf0:	0c 00 3d    	bra       GE, 0xeb0a <.L0> <.L0> <.L29>

0000eaf2 <.L0>:
    rtb_Sum6 = mul_u32_u32_u32_sr11_round(div_repeat_u32_round(rtb_Sum6, rtb_B4,
    eaf2:	f4 00 20    	mov.w     #0xf, w4
    eaf4:	00 01 be    	mov.d     w0, w2
    eaf6:	0c 00 be    	mov.d     w12, w0
    eaf8:	28 4b 02    	call      0x4b28 <_div_repeat_u32_round>
    eafa:	00 00 00 
    eafc:	52 c3 20    	mov.w     #0xc35, w2
    eafe:	03 00 20    	mov.w     #0x0, w3
    eb00:	f8 4a 02    	call      0x4af8 <_mul_u32_u32_u32_sr11_round>
    eb02:	00 00 00 
    eb04:	00 04 40    	add.w     w0, w0, w8
    eb06:	81 84 48    	addc.w    w1, w1, w9
    eb08:	0a 00 37    	bra       0xeb1e <.L0> <.L30>

0000eb0a <.L0>:
      15U), 3125UL) << 1;
  } else {
    rtb_Sum6 = div_u32_round(mul_u32_u32_u32_sr11_round(rtb_Sum6 << 16, 3125UL),
    eb0a:	c0 60 dd    	sl.w      w12, #0x0, w1
    eb0c:	00 00 20    	mov.w     #0x0, w0
    eb0e:	52 c3 20    	mov.w     #0xc35, w2
    eb10:	03 00 20    	mov.w     #0x0, w3
    eb12:	f8 4a 02    	call      0x4af8 <_mul_u32_u32_u32_sr11_round>
    eb14:	00 00 00 
    eb16:	08 01 be    	mov.d     w8, w2
    eb18:	b2 4a 02    	call      0x4ab2 <_div_u32_round>
    eb1a:	00 00 00 
    eb1c:	00 04 be    	mov.d     w0, w8

0000eb1e <.L0>:
      rtb_B4);
  }

  /* End of Switch: '<S27>/Switch' */

  /* Gain: '<S27>/Gain16' */
  rtb_Bias5 = (int32_T)(((uint16_T)((int16_T)rtb_Sum6 & 128) != 0U) + (rtb_Sum6 >>
    eb1e:	08 00 78    	mov.w     w8, w0
    eb20:	00 08 b2    	and.w     #0x80, w0
    eb22:	00 00 ea    	neg.w     w0, w0
    eb24:	4f 00 de    	lsr.w     w0, #0xf, w0
    eb26:	c8 48 dd    	sl.w      w9, #0x8, w1
    eb28:	48 41 de    	lsr.w     w8, #0x8, w2
    eb2a:	02 81 70    	ior.w     w1, w2, w2
    eb2c:	c8 49 de    	lsr.w     w9, #0x8, w3
    eb2e:	4f 82 de    	asr.w     w0, #0xf, w4
    eb30:	02 00 40    	add.w     w0, w2, w0
    eb32:	83 00 4a    	addc.w    w4, w3, w1

0000eb34 <.L0>:
    8));

  /* Sum: '<S27>/Sum8' incorporates:
   *  Bias: '<S27>/Bias5'
   *  Gain: '<S27>/Gain17'
   *  Gain: '<S27>/Gain19'
   *  Gain: '<S27>/Gain21'
   *  Math: '<S27>/Math Function2'
   *  Sum: '<S27>/Sum7'
   */
  rtb_Bias5 = ((((int32_T)mul_u32_u32_u32_sr15(1519UL, mul_u32_s32_s32_sat
    eb34:	00 01 be    	mov.d     w0, w2
    eb36:	70 49 02    	call      0x4970 <_mul_u32_s32_s32_sat>
    eb38:	00 00 00 
    eb3a:	00 01 be    	mov.d     w0, w2
    eb3c:	f0 5e 20    	mov.w     #0x5ef, w0
    eb3e:	01 00 20    	mov.w     #0x0, w1
    eb40:	36 48 02    	call      0x4836 <_mul_u32_u32_u32_sr15>
    eb42:	00 00 00 
    eb44:	00 05 be    	mov.d     w0, w10

0000eb46 <.L0>:
    (rtb_Bias5, rtb_Bias5)) + mul_s32_s32_u32_sr16(-7357L, rtb_Sum6)) + 3791L) >>
    eb46:	08 01 be    	mov.d     w8, w2
    eb48:	30 34 2e    	mov.w     #0xe343, w0
    eb4a:	f1 ff 2f    	mov.w     #0xffff, w1
    eb4c:	92 4a 02    	call      0x4a92 <_mul_s32_s32_u32_sr16>
    eb4e:	00 00 00 
    eb50:	f2 ec 20    	mov.w     #0xecf, w2
    eb52:	03 00 20    	mov.w     #0x0, w3
    eb54:	00 00 41    	add.w     w2, w0, w0
    eb56:	81 80 49    	addc.w    w3, w1, w1
    eb58:	00 05 45    	add.w     w10, w0, w10
    eb5a:	81 85 4d    	addc.w    w11, w1, w11
    eb5c:	4c 58 dd    	sl.w      w11, #0xc, w0
    eb5e:	44 55 de    	lsr.w     w10, #0x4, w10
    eb60:	0a 05 70    	ior.w     w0, w10, w10
    eb62:	c4 dd de    	asr.w     w11, #0x4, w11

0000eb64 <.L0>:
    eb64:	0a 05 44    	add.w     w8, w10, w10
    eb66:	8b 85 4c    	addc.w    w9, w11, w11

0000eb68 <.L0>:
               4) + (int32_T)rtb_Sum6;

  /* Outputs for Enabled SubSystem: '<S28>/Initial Baro Bias' incorporates:
   *  EnablePort: '<S40>/Enable'
   */
  if (AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputatio.tOut > 0.0) {
    eb68:	60 11 b8    	mul.uu    w2, #0x0, w2
    eb6a:	a0 ea 80    	mov.w     0x1d54, w0
    eb6c:	b1 ea 80    	mov.w     0x1d56, w1
    eb6e:	90 18 02    	call      0x1890 <___gesf2>
    eb70:	00 00 00 
    eb72:	00 00 e0    	cp0.w     w0
    eb74:	36 00 34    	bra       LE, 0xebe2 <.L0> <.L31>

0000eb76 <.L0>:
    /* DataTypeConversion: '<S40>/Data Type Conversion' */
    rtb_DataTypeConversion = rtb_Bias5;
    eb76:	0a 00 be    	mov.d     w10, w0
    eb78:	0c 19 02    	call      0x190c <___floatsisf>
    eb7a:	00 00 00 
    eb7c:	00 06 be    	mov.d     w0, w12

0000eb7e <.L0>:

    /* DiscreteZeroPole: '<S43>/Discrete Zero-Pole' */
    {
      rtb_DiscreteZeroPole = 0.014778325123152709*rtb_DataTypeConversion;
    eb7e:	a2 0c 22    	mov.w     #0x20ca, w2
    eb80:	23 c7 23    	mov.w     #0x3c72, w3
    eb82:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    eb84:	00 00 00 
    eb86:	00 04 be    	mov.d     w0, w8

0000eb88 <.L0>:
      rtb_DiscreteZeroPole += 0.029119852459414206*
    eb88:	22 cc 28    	mov.w     #0x8cc2, w2
    eb8a:	e3 ce 23    	mov.w     #0x3cee, w3
    eb8c:	20 ec 80    	mov.w     0x1d84, w0
    eb8e:	31 ec 80    	mov.w     0x1d86, w1
    eb90:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    eb92:	00 00 00 
    eb94:	08 01 be    	mov.d     w8, w2
    eb96:	92 14 02    	call      0x1492 <___addsf3>
    eb98:	00 00 00 
    eb9a:	00 04 be    	mov.d     w0, w8

0000eb9c <.L0>:
        AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_nk;
    }

    /* Saturate: '<S40>/[80k - 120k]' incorporates:
     *  DataTypeConversion: '<S40>/Data Type Conversion1'
     */
    if ((real32_T)rtb_DiscreteZeroPole > 120000.0F) {
    eb9c:	02 00 26    	mov.w     #0x6000, w2
    eb9e:	a3 7e 24    	mov.w     #0x47ea, w3
    eba0:	90 18 02    	call      0x1890 <___gesf2>
    eba2:	00 00 00 
    eba4:	00 00 e0    	cp0.w     w0
    eba6:	05 00 34    	bra       LE, 0xebb2 <.L0> <.L57>

0000eba8 <.L0>:
      AUAV_V3_TestSensors_B.u0k120k_i = 120000.0F;
    eba8:	00 00 26    	mov.w     #0x6000, w0
    ebaa:	a1 7e 24    	mov.w     #0x47ea, w1
    ebac:	30 c8 88    	mov.w     w0, 0x1906
    ebae:	41 c8 88    	mov.w     w1, 0x1908
    ebb0:	0e 00 37    	bra       0xebce <.L35>

0000ebb2 <.L0>:
    } else if ((real32_T)rtb_DiscreteZeroPole < 80000.0F) {
    ebb2:	02 00 24    	mov.w     #0x4000, w2
    ebb4:	c3 79 24    	mov.w     #0x479c, w3
    ebb6:	08 00 be    	mov.d     w8, w0
    ebb8:	8c 18 02    	call      0x188c <___eqsf2>
    ebba:	00 00 00 
    ebbc:	00 00 e0    	cp0.w     w0
    ebbe:	05 00 3d    	bra       GE, 0xebca <.L58>

0000ebc0 <.L0>:
      AUAV_V3_TestSensors_B.u0k120k_i = 80000.0F;
    ebc0:	00 00 24    	mov.w     #0x4000, w0
    ebc2:	c1 79 24    	mov.w     #0x479c, w1
    ebc4:	30 c8 88    	mov.w     w0, 0x1906
    ebc6:	41 c8 88    	mov.w     w1, 0x1908
    ebc8:	02 00 37    	bra       0xebce <.L35>

0000ebca <.L58>:
    } else {
      AUAV_V3_TestSensors_B.u0k120k_i = (real32_T)rtb_DiscreteZeroPole;
    ebca:	38 c8 88    	mov.w     w8, 0x1906
    ebcc:	49 c8 88    	mov.w     w9, 0x1908

0000ebce <.L35>:
    }

    /* End of Saturate: '<S40>/[80k - 120k]' */
    /* Update for DiscreteZeroPole: '<S43>/Discrete Zero-Pole' */
    {
      AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_nk =
    ebce:	48 d8 21    	mov.w     #0x1d84, w8

0000ebd0 <.L0>:
        rtb_DataTypeConversion + 0.97044334975369462*
    ebd0:	a2 ef 26    	mov.w     #0x6efa, w2
    ebd2:	83 f7 23    	mov.w     #0x3f78, w3
    ebd4:	18 00 be    	mov.d     [w8], w0
    ebd6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ebd8:	00 00 00 
    ebda:	0c 01 be    	mov.d     w12, w2
    ebdc:	92 14 02    	call      0x1492 <___addsf3>
    ebde:	00 00 00 

0000ebe0 <.L0>:
    ebe0:	00 8c be    	mov.d     w0, [w8]

0000ebe2 <.L0>:
        AUAV_V3_TestSensors_DWork.DiscreteZeroPole_DSTATE_nk;
    }
  }

  /* End of Outputs for SubSystem: '<S28>/Initial Baro Bias' */

  /* Product: '<S37>/Divide' incorporates:
   *  Sum: '<S37>/Sum2'
   */
  rtb_x = ((real32_T)rtb_Bias5 - AUAV_V3_TestSensors_B.u0k120k_i) /
    ebe2:	38 c8 80    	mov.w     0x1906, w8
    ebe4:	49 c8 80    	mov.w     0x1908, w9
    ebe6:	0a 00 be    	mov.d     w10, w0
    ebe8:	0c 19 02    	call      0x190c <___floatsisf>
    ebea:	00 00 00 
    ebec:	08 01 be    	mov.d     w8, w2
    ebee:	90 14 02    	call      0x1490 <___subsf3>
    ebf0:	00 00 00 
    ebf2:	08 01 be    	mov.d     w8, w2
    ebf4:	26 17 02    	call      0x1726 <___divsf3>
    ebf6:	00 00 00 
    ebf8:	00 04 be    	mov.d     w0, w8

0000ebfa <.L0>:
    AUAV_V3_TestSensors_B.u0k120k_i;

  /* Sum: '<S37>/Sum1' incorporates:
   *  Constant: '<S37>/Constant2'
   *  Constant: '<S37>/Constant3'
   *  Constant: '<S37>/Constant4'
   *  Constant: '<S37>/Constant5'
   *  Gain: '<S42>/Unit Conversion'
   *  Product: '<S37>/Divide1'
   *  Product: '<S37>/Divide2'
   *  Product: '<S37>/Divide3'
   *  Product: '<S37>/Divide4'
   *  Sum: '<S37>/Sum3'
   */
  rtb_x = ((rtb_x * rtb_x * 0.093502529F + rtb_x * -0.188893303F) +
    ebfa:	00 01 be    	mov.d     w0, w2
    ebfc:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ebfe:	00 00 00 
    ec00:	12 e4 27    	mov.w     #0x7e41, w2
    ec02:	f3 db 23    	mov.w     #0x3dbf, w3
    ec04:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ec06:	00 00 00 
    ec08:	00 05 be    	mov.d     w0, w10
    ec0a:	f2 d3 26    	mov.w     #0x6d3f, w2
    ec0c:	13 e4 2b    	mov.w     #0xbe41, w3
    ec0e:	08 00 be    	mov.d     w8, w0
    ec10:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ec12:	00 00 00 
    ec14:	00 01 be    	mov.d     w0, w2
    ec16:	0a 00 be    	mov.d     w10, w0
    ec18:	92 14 02    	call      0x1492 <___addsf3>
    ec1a:	00 00 00 
    ec1c:	d2 5d 2e    	mov.w     #0xe5dd, w2
    ec1e:	63 7b 23    	mov.w     #0x37b6, w3
    ec20:	92 14 02    	call      0x1492 <___addsf3>
    ec22:	00 00 00 

0000ec24 <.L0>:
           2.18031291E-5F) * 145473.5F * 0.3048F;
    ec24:	02 06 21    	mov.w     #0x1060, w2
    ec26:	e3 80 24    	mov.w     #0x480e, w3
    ec28:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ec2a:	00 00 00 

0000ec2c <.L0>:
    ec2c:	f2 eb 20    	mov.w     #0xebf, w2
    ec2e:	c3 e9 23    	mov.w     #0x3e9c, w3
    ec30:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ec32:	00 00 00 
    ec34:	00 04 be    	mov.d     w0, w8

0000ec36 <.L0>:

  /* Outputs for Enabled SubSystem: '<S28>/Enabled Subsystem' */

  /* Logic: '<S28>/Logical Operator' incorporates:
   *  Sum: '<S28>/Sum1'
   */
  AUAV_V3_T_EnabledSubsystem
    (!(AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputatio.tOut != 0.0),
    ec36:	12 c8 80    	mov.w     0x1902, w2
    ec38:	23 c8 80    	mov.w     0x1904, w3
    ec3a:	92 14 02    	call      0x1492 <___addsf3>
    ec3c:	00 00 00 
    ec3e:	00 05 be    	mov.d     w0, w10
    ec40:	1c c0 b3    	mov.b     #0x1, w12
    ec42:	60 11 b8    	mul.uu    w2, #0x0, w2
    ec44:	a0 ea 80    	mov.w     0x1d54, w0
    ec46:	b1 ea 80    	mov.w     0x1d56, w1
    ec48:	c8 19 02    	call      0x19c8 <___nesf2>
    ec4a:	00 00 00 
    ec4c:	00 00 e0    	cp0.w     w0
    ec4e:	01 00 3a    	bra       NZ, 0xec52 <.L38>
    ec50:	00 46 eb    	clr.b     w12

0000ec52 <.L38>:
    ec52:	0c 04 a2    	btg.b     w12, #0x0
    ec54:	0c 80 fb    	ze        w12, w0
    ec56:	81 d5 21    	mov.w     #0x1d58, w1
    ec58:	0a 01 be    	mov.d     w10, w2
    ec5a:	7e 12 02    	call      0x1127e <_AUAV_V3_T_EnabledSubsystem>
    ec5c:	01 00 00 

0000ec5e <.L0>:
     AUAV_V3_TestSensors_B.Sum_k + rtb_x,
     &AUAV_V3_TestSensors_B.EnabledSubsystem);

  /* End of Outputs for SubSystem: '<S28>/Enabled Subsystem' */

  /* Outputs for Enabled SubSystem: '<S1>/Disable path through in HIL Subsystem1' incorporates:
   *  EnablePort: '<S30>/Enable'
   */
  if (rtb_LogicalOperator) {
    ec5e:	ef e0 97    	mov.b     [w15-26], w1
    ec60:	01 04 e0    	cp0.b     w1
    ec62:	0e 00 32    	bra       Z, 0xec80 <.L39>
    /* DataStoreWrite: '<S30>/Update ScaledPressure' incorporates:
     *  Bias: '<S27>/Bias'
     *  Bias: '<S27>/Bias1'
     *  Gain: '<S1>/Gain21'
     */
    mlAirData.temperature = (int16_T)((rtb_B6 + 4008) * 5L >> 3);
    ec64:	65 71 b9    	mul.su    w14, #0x5, w2
    ec66:	80 e4 24    	mov.w     #0x4e48, w0
    ec68:	01 00 20    	mov.w     #0x0, w1
    ec6a:	02 00 40    	add.w     w0, w2, w0
    ec6c:	83 80 48    	addc.w    w1, w3, w1
    ec6e:	4d 09 dd    	sl.w      w1, #0xd, w2
    ec70:	43 00 de    	lsr.w     w0, #0x3, w0
    ec72:	00 00 71    	ior.w     w2, w0, w0
    ec74:	c3 88 de    	asr.w     w1, #0x3, w1
    ec76:	20 84 88    	mov.w     w0, 0x1084
    mlAirData.press_abs = AUAV_V3_TestSensors_B.EnabledSubsystem.In1;
    ec78:	c0 ea 80    	mov.w     0x1d58, w0
    ec7a:	d1 ea 80    	mov.w     0x1d5a, w1
    ec7c:	e0 83 88    	mov.w     w0, 0x107c
    ec7e:	f1 83 88    	mov.w     w1, 0x107e

0000ec80 <.L39>:
  }

  /* End of Outputs for SubSystem: '<S1>/Disable path through in HIL Subsystem1' */

  /* Update for Delay: '<S32>/Delay11' incorporates:
   *  Sum: '<S32>/SumA21'
   */
  AUAV_V3_TestSensors_DWork.Delay11_DSTATE = qY_0;
    ec80:	7f b1 97    	mov.w     [w15-18], w2
    ec82:	8f b9 97    	mov.w     [w15-16], w3
    ec84:	a2 fd 88    	mov.w     w2, 0x1fb4
    ec86:	b3 fd 88    	mov.w     w3, 0x1fb6

  /* Update for Delay: '<S33>/Delay11' incorporates:
   *  Sum: '<S33>/SumA21'
   */
  AUAV_V3_TestSensors_DWork.Delay11_DSTATE_j = qY;
    ec88:	5f b0 97    	mov.w     [w15-22], w0
    ec8a:	ef b0 97    	mov.w     [w15-20], w1
    ec8c:	c0 fd 88    	mov.w     w0, 0x1fb8
    ec8e:	d1 fd 88    	mov.w     w1, 0x1fba

  /* Update for Delay: '<S1>/Delay' incorporates:
   *  Constant: '<S1>/Constant'
   */
  AUAV_V3_TestSensors_DWork.Delay_DSTATE = 0U;
    ec90:	40 ff 21    	mov.w     #0x1ff4, w0
    ec92:	00 08 eb    	clr.w     [w0]

0000ec94 <.L0>:

  /* Update for Enabled SubSystem: '<S28>/Zero Out Height' incorporates:
   *  Update for EnablePort: '<S41>/Enable'
   */
  if (AUAV_V3_TestSensors_B.sf_EnablesDisablestheComputatio.tOut > 0.0) {
    ec94:	60 11 b8    	mul.uu    w2, #0x0, w2
    ec96:	a0 ea 80    	mov.w     0x1d54, w0
    ec98:	b1 ea 80    	mov.w     0x1d56, w1
    ec9a:	90 18 02    	call      0x1890 <___gesf2>
    ec9c:	00 00 00 
    ec9e:	00 00 e0    	cp0.w     w0
    eca0:	02 00 34    	bra       LE, 0xeca6 <.L3>

0000eca2 <.L0>:
    /* Update for Delay: '<S41>/Integer Delay' */
    AUAV_V3_TestSensors_DWork.IntegerDelay_DSTATE_jh = rtb_x;
    eca2:	68 fd 88    	mov.w     w8, 0x1fac
    eca4:	79 fd 88    	mov.w     w9, 0x1fae

0000eca6 <.L3>:
  }

  /* End of Update for SubSystem: '<S28>/Zero Out Height' */
}
    eca6:	4f 07 78    	mov.w     [--w15], w14
    eca8:	4f 06 be    	mov.d     [--w15], w12
    ecaa:	4f 05 be    	mov.d     [--w15], w10
    ecac:	4f 04 be    	mov.d     [--w15], w8
    ecae:	cf 01 b1    	sub.w     #0x1c, w15
    ecb0:	00 00 06    	return    

0000ecb2 <_msg_B3>:
}

static void msg_B3(uint8_t gpschar)
{
	if (gpschar == 0xB5)
    ecb2:	51 cb b3    	mov.b     #0xb5, w1
    ecb4:	81 4f 50    	sub.b     w0, w1, [w15]
    ecb6:	02 00 3a    	bra       NZ, 0xecbc <.L1>
	{
		//bin_out(0x01);
		msg_parse = &msg_SYNC1;
    ecb8:	e0 cb 2e    	mov.w     #0xecbe, w0
    ecba:	70 20 8a    	mov.w     w0, 0x440e

0000ecbc <.L1>:
	}
	//else if (dcm_flags._.nmea_passthrough && gpschar == '$' && udb_gps_check_rate(19200))
	//{
	//	nmea_passthru_countdown = 128; // this limits the number of characters we will passthrough. (Most lines are 60-80 chars long.)
	//	msg_parse = &nmea_passthru;
	//	nmea_passthru (gpschar);
	//}
	else
	{
		// error condition
	}
}
    ecbc:	00 00 06    	return    

0000ecbe <_msg_SYNC1>:

static void msg_SYNC1(uint8_t gpschar)
{
	if (gpschar == 0x62)
    ecbe:	21 c6 b3    	mov.b     #0x62, w1
    ecc0:	81 4f 50    	sub.b     w0, w1, [w15]
    ecc2:	05 00 3a    	bra       NZ, 0xecce <.L4>
	{
		//bin_out(0x02);
		store_index = 0;
    ecc4:	00 00 eb    	clr.w     w0
    ecc6:	90 19 8a    	mov.w     w0, 0x4332
		msg_parse = &msg_SYNC2;
    ecc8:	40 cd 2e    	mov.w     #0xecd4, w0
    ecca:	70 20 8a    	mov.w     w0, 0x440e
    eccc:	02 00 37    	bra       0xecd2 <.L3>

0000ecce <.L4>:
	}
	else
	{
		msg_parse = &msg_B3;        // error condition
    ecce:	20 cb 2e    	mov.w     #0xecb2, w0
    ecd0:	70 20 8a    	mov.w     w0, 0x440e

0000ecd2 <.L3>:
	}
}
    ecd2:	00 00 06    	return    

0000ecd4 <_msg_SYNC2>:

static void msg_SYNC2(uint8_t gpschar)
{
	//bin_out(0x03);
	msg_class = gpschar;
    ecd4:	80 80 fb    	ze        w0, w1
    ecd6:	a1 19 8a    	mov.w     w1, 0x4334
	CK_A = 0;
	CK_B = 0;
	CK_A += gpschar;
    ecd8:	61 33 24    	mov.w     #0x4336, w1
    ecda:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    ecdc:	71 33 24    	mov.w     #0x4337, w1
    ecde:	80 48 78    	mov.b     w0, [w1]
	msg_parse = &msg_CLASS;
    ece0:	60 ce 2e    	mov.w     #0xece6, w0
    ece2:	70 20 8a    	mov.w     w0, 0x440e
}
    ece4:	00 00 06    	return    

0000ece6 <_msg_CLASS>:

static void msg_CLASS(uint8_t gpschar)
{
	//bin_out(0x04);
	msg_id = gpschar;
    ece6:	80 80 fb    	ze        w0, w1
    ece8:	c1 19 8a    	mov.w     w1, 0x4338
	CK_A += gpschar;
    ecea:	61 33 24    	mov.w     #0x4336, w1
    ecec:	11 40 40    	add.b     w0, [w1], w0
    ecee:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    ecf0:	71 33 24    	mov.w     #0x4337, w1
    ecf2:	91 48 40    	add.b     w0, [w1], [w1]
	msg_parse = &msg_ID;
    ecf4:	a0 cf 2e    	mov.w     #0xecfa, w0
    ecf6:	70 20 8a    	mov.w     w0, 0x440e
}
    ecf8:	00 00 06    	return    

0000ecfa <_msg_ID>:

static void msg_ID(uint8_t gpschar)
{
	//bin_out(0x05);
	payloadlength._.B0 = gpschar;   // UBX stored payload length in little endian order
    ecfa:	a1 33 24    	mov.w     #0x433a, w1
    ecfc:	80 48 78    	mov.b     w0, [w1]
	CK_A += gpschar;
    ecfe:	61 33 24    	mov.w     #0x4336, w1
    ed00:	11 40 40    	add.b     w0, [w1], w0
    ed02:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    ed04:	71 33 24    	mov.w     #0x4337, w1
    ed06:	91 48 40    	add.b     w0, [w1], [w1]
	msg_parse = &msg_PL1;
    ed08:	e0 d0 2e    	mov.w     #0xed0e, w0
    ed0a:	70 20 8a    	mov.w     w0, 0x440e
}
    ed0c:	00 00 06    	return    

0000ed0e <_msg_PL1>:
#define NUM_POINTERS_IN(x)      (sizeof(x)/sizeof(char*))

static void msg_PL1(uint8_t gpschar)
{
	//bin_out(0x06);
	payloadlength._.B1 = gpschar;   // UBX stored payload length in little endian order
    ed0e:	b1 33 24    	mov.w     #0x433b, w1
    ed10:	80 48 78    	mov.b     w0, [w1]
	CK_A += gpschar;
    ed12:	61 33 24    	mov.w     #0x4336, w1
    ed14:	11 40 40    	add.b     w0, [w1], w0
    ed16:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    ed18:	71 33 24    	mov.w     #0x4337, w1
    ed1a:	91 48 40    	add.b     w0, [w1], [w1]

	switch (msg_class) {
    ed1c:	a0 19 82    	mov.w     0x4334, w0
    ed1e:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    ed20:	03 00 32    	bra       Z, 0xed28 <.L11>
    ed22:	e5 0f 50    	sub.w     w0, #0x5, [w15]
    ed24:	4e 00 3a    	bra       NZ, 0xedc2 <.L28>
    ed26:	3a 00 37    	bra       0xed9c <.L30>

0000ed28 <.L11>:
		case 0x01 : {
			switch (msg_id) {
    ed28:	c0 19 82    	mov.w     0x4338, w0
    ed2a:	e6 0f 50    	sub.w     w0, #0x6, [w15]
    ed2c:	1e 00 32    	bra       Z, 0xed6a <.L16>
    ed2e:	05 00 3e    	bra       GTU, 0xed3a <.L19>
    ed30:	e2 0f 50    	sub.w     w0, #0x2, [w15]
    ed32:	09 00 32    	bra       Z, 0xed46 <.L14>
    ed34:	e4 0f 50    	sub.w     w0, #0x4, [w15]
    ed36:	2f 00 3a    	bra       NZ, 0xed96 <.L13>
    ed38:	0f 00 37    	bra       0xed58 <.L31>

0000ed3a <.L19>:
    ed3a:	f2 0f 50    	sub.w     w0, #0x12, [w15]
    ed3c:	20 00 32    	bra       Z, 0xed7e <.L17>
    ed3e:	b1 0a 20    	mov.w     #0xab, w1
    ed40:	81 0f 50    	sub.w     w0, w1, [w15]
    ed42:	29 00 3a    	bra       NZ, 0xed96 <.L13>
    ed44:	1f 00 37    	bra       0xed84 <.L32>

0000ed46 <.L14>:
				case 0x02 : { // NAV-POSLLH message
					if (payloadlength.BB  == NUM_POINTERS_IN(msg_POSLLH_parse))
    ed46:	d0 19 82    	mov.w     0x433a, w0
    ed48:	fc 0f 50    	sub.w     w0, #0x1c, [w15]
    ed4a:	03 00 3a    	bra       NZ, 0xed52 <.L20>
					{
						msg_parse = &msg_POSLLH;
    ed4c:	80 dc 2e    	mov.w     #0xedc8, w0
    ed4e:	70 20 8a    	mov.w     w0, 0x440e
    ed50:	3a 00 37    	bra       0xedc6 <.L9>

0000ed52 <.L20>:
					}
					else
					{
						msg_parse = &msg_B3;    // error condition
    ed52:	20 cb 2e    	mov.w     #0xecb2, w0
    ed54:	70 20 8a    	mov.w     w0, 0x440e
    ed56:	37 00 37    	bra       0xedc6 <.L9>

0000ed58 <.L31>:
					}
					break;
				}
				case 0x04 : { // NAV-DOP message
					if (payloadlength.BB  == NUM_POINTERS_IN(msg_DOP_parse))
    ed58:	d0 19 82    	mov.w     0x433a, w0
    ed5a:	f2 0f 50    	sub.w     w0, #0x12, [w15]
    ed5c:	03 00 3a    	bra       NZ, 0xed64 <.L22>
					{
						msg_parse = &msg_DOP;
    ed5e:	80 df 2e    	mov.w     #0xedf8, w0
    ed60:	70 20 8a    	mov.w     w0, 0x440e
    ed62:	31 00 37    	bra       0xedc6 <.L9>

0000ed64 <.L22>:
					}
					else
					{
						msg_parse = &msg_B3;    // error condition
    ed64:	20 cb 2e    	mov.w     #0xecb2, w0
    ed66:	70 20 8a    	mov.w     w0, 0x440e
    ed68:	2e 00 37    	bra       0xedc6 <.L9>

0000ed6a <.L16>:
					}
					break;
				}
				case 0x06 : { // NAV-SOL message
					if (payloadlength.BB  == NUM_POINTERS_IN(msg_SOL_parse))
    ed6a:	40 03 20    	mov.w     #0x34, w0
    ed6c:	d1 19 82    	mov.w     0x433a, w1
    ed6e:	80 8f 50    	sub.w     w1, w0, [w15]
    ed70:	03 00 3a    	bra       NZ, 0xed78 <.L23>
					{
						msg_parse = &msg_SOL;
    ed72:	80 e2 2e    	mov.w     #0xee28, w0
    ed74:	70 20 8a    	mov.w     w0, 0x440e
    ed76:	27 00 37    	bra       0xedc6 <.L9>

0000ed78 <.L23>:
					}
					else
					{
						msg_parse = &msg_B3;    // error condition
    ed78:	20 cb 2e    	mov.w     #0xecb2, w0
    ed7a:	70 20 8a    	mov.w     w0, 0x440e
    ed7c:	24 00 37    	bra       0xedc6 <.L9>

0000ed7e <.L17>:
					}
					break;
				}
				case 0x12 : { // NAV-VELNED message
					if (payloadlength.BB  == NUM_POINTERS_IN(msg_VELNED_parse))
					{
						msg_parse = &msg_VELNED;
					}
					else
					{
						msg_parse = &msg_B3;    // error condition
					}
					msg_parse = &msg_VELNED;    // TODO: this does not look right (wipes out error setting above) - RobD
    ed7e:	80 e5 2e    	mov.w     #0xee58, w0
    ed80:	70 20 8a    	mov.w     w0, 0x440e
					break;
    ed82:	21 00 37    	bra       0xedc6 <.L9>

0000ed84 <.L32>:
				}
//#if (HILSIM == 1)
				case 0xAB : { // NAV-BODYRATES message - THIS IS NOT AN OFFICIAL UBX MESSAGE
					// WE ARE FAKING THIS FOR HIL SIMULATION
					if (payloadlength.BB  == NUM_POINTERS_IN(msg_BODYRATES_parse))
    ed84:	d0 19 82    	mov.w     0x433a, w0
    ed86:	ec 0f 50    	sub.w     w0, #0xc, [w15]
    ed88:	03 00 3a    	bra       NZ, 0xed90 <.L24>
					{
						msg_parse = &msg_BODYRATES;
    ed8a:	80 e8 2e    	mov.w     #0xee88, w0
    ed8c:	70 20 8a    	mov.w     w0, 0x440e
    ed8e:	1b 00 37    	bra       0xedc6 <.L9>

0000ed90 <.L24>:
					}
					else
					{
						msg_parse = &msg_B3;    // error condition
    ed90:	20 cb 2e    	mov.w     #0xecb2, w0
    ed92:	70 20 8a    	mov.w     w0, 0x440e
    ed94:	18 00 37    	bra       0xedc6 <.L9>

0000ed96 <.L13>:
					}
					break;
				}
//#endif
				default : {     // some other NAV class message
					msg_parse = &msg_MSGU;
    ed96:	00 ee 2e    	mov.w     #0xeee0, w0
    ed98:	70 20 8a    	mov.w     w0, 0x440e
					break;
    ed9a:	15 00 37    	bra       0xedc6 <.L9>

0000ed9c <.L30>:
				}
			}
			break;
		}
		case 0x05 : {
			switch (msg_id) {
    ed9c:	c0 19 82    	mov.w     0x4338, w0
    ed9e:	00 00 e0    	cp0.w     w0
    eda0:	03 00 32    	bra       Z, 0xeda8 <.L26>
    eda2:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    eda4:	0b 00 3a    	bra       NZ, 0xedbc <.L29>
    eda6:	05 00 37    	bra       0xedb2 <.L33>

0000eda8 <.L26>:
				case 0x00 : {   // NACK message
					ack_type = 0;
    eda8:	00 00 eb    	clr.w     w0
    edaa:	e0 19 8a    	mov.w     w0, 0x433c
					msg_parse = &msg_ACK_CLASS;
    edac:	80 eb 2e    	mov.w     #0xeeb8, w0
    edae:	70 20 8a    	mov.w     w0, 0x440e
					break;
    edb0:	0a 00 37    	bra       0xedc6 <.L9>

0000edb2 <.L33>:
				}
				case 0x01 : {   // ACK message
					ack_type = 1;
    edb2:	10 00 20    	mov.w     #0x1, w0
    edb4:	e0 19 8a    	mov.w     w0, 0x433c
					msg_parse = &msg_ACK_CLASS;
    edb6:	80 eb 2e    	mov.w     #0xeeb8, w0
    edb8:	70 20 8a    	mov.w     w0, 0x440e
					break;
    edba:	05 00 37    	bra       0xedc6 <.L9>

0000edbc <.L29>:
				}
				default : {     // There are no other messages in this class, so this is an error
					msg_parse = &msg_B3;
    edbc:	20 cb 2e    	mov.w     #0xecb2, w0
    edbe:	70 20 8a    	mov.w     w0, 0x440e
					break;
    edc0:	02 00 37    	bra       0xedc6 <.L9>

0000edc2 <.L28>:
				}
			}
			break;
		}
		default : {             // a non NAV class message
			msg_parse = &msg_MSGU;
    edc2:	00 ee 2e    	mov.w     #0xeee0, w0
    edc4:	70 20 8a    	mov.w     w0, 0x440e

0000edc6 <.L9>:
			break;
		}
	}
}
    edc6:	00 00 06    	return    

0000edc8 <_msg_POSLLH>:

static void msg_POSLLH(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    edc8:	d1 19 82    	mov.w     0x433a, w1
    edca:	01 00 e0    	cp0.w     w1
    edcc:	10 00 34    	bra       LE, 0xedee <.L35>
	{
		*msg_POSLLH_parse[store_index++] = gpschar;
    edce:	92 19 82    	mov.w     0x4332, w2
    edd0:	82 01 41    	add.w     w2, w2, w3
    edd2:	84 0a 2c    	mov.w     #0xc0a8, w4
    edd4:	83 01 42    	add.w     w4, w3, w3
    edd6:	93 01 78    	mov.w     [w3], w3
    edd8:	80 49 78    	mov.b     w0, [w3]
    edda:	02 01 e8    	inc.w     w2, w2
    eddc:	92 19 8a    	mov.w     w2, 0x4332
		CK_A += gpschar;
    edde:	62 33 24    	mov.w     #0x4336, w2
    ede0:	12 40 40    	add.b     w0, [w2], w0
    ede2:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    ede4:	72 33 24    	mov.w     #0x4337, w2
    ede6:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    ede8:	81 00 e9    	dec.w     w1, w1
    edea:	d1 19 8a    	mov.w     w1, 0x433a
    edec:	04 00 37    	bra       0xedf6 <.L34>

0000edee <.L35>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		//gpsoutchar2(0x08);
		checksum._.B1 = gpschar;
    edee:	31 34 24    	mov.w     #0x4343, w1
    edf0:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    edf2:	60 fd 2e    	mov.w     #0xefd6, w0
    edf4:	70 20 8a    	mov.w     w0, 0x440e

0000edf6 <.L34>:
	}
}
    edf6:	00 00 06    	return    

0000edf8 <_msg_DOP>:

static void msg_DOP(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    edf8:	d1 19 82    	mov.w     0x433a, w1
    edfa:	01 00 e0    	cp0.w     w1
    edfc:	10 00 34    	bra       LE, 0xee1e <.L38>
	{
		*msg_DOP_parse[store_index++] = gpschar;
    edfe:	92 19 82    	mov.w     0x4332, w2
    ee00:	82 01 41    	add.w     w2, w2, w3
    ee02:	44 08 2c    	mov.w     #0xc084, w4
    ee04:	83 01 42    	add.w     w4, w3, w3
    ee06:	93 01 78    	mov.w     [w3], w3
    ee08:	80 49 78    	mov.b     w0, [w3]
    ee0a:	02 01 e8    	inc.w     w2, w2
    ee0c:	92 19 8a    	mov.w     w2, 0x4332
		CK_A += gpschar;
    ee0e:	62 33 24    	mov.w     #0x4336, w2
    ee10:	12 40 40    	add.b     w0, [w2], w0
    ee12:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    ee14:	72 33 24    	mov.w     #0x4337, w2
    ee16:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    ee18:	81 00 e9    	dec.w     w1, w1
    ee1a:	d1 19 8a    	mov.w     w1, 0x433a
    ee1c:	04 00 37    	bra       0xee26 <.L37>

0000ee1e <.L38>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		//gpsoutchar2(0x09);
		checksum._.B1 = gpschar;
    ee1e:	31 34 24    	mov.w     #0x4343, w1
    ee20:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    ee22:	60 fd 2e    	mov.w     #0xefd6, w0
    ee24:	70 20 8a    	mov.w     w0, 0x440e

0000ee26 <.L37>:
	}
}
    ee26:	00 00 06    	return    

0000ee28 <_msg_SOL>:

static void msg_SOL(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    ee28:	d1 19 82    	mov.w     0x433a, w1
    ee2a:	01 00 e0    	cp0.w     w1
    ee2c:	10 00 34    	bra       LE, 0xee4e <.L41>
	{
		*msg_SOL_parse[store_index++] = gpschar;
    ee2e:	92 19 82    	mov.w     0x4332, w2
    ee30:	82 01 41    	add.w     w2, w2, w3
    ee32:	c4 01 2c    	mov.w     #0xc01c, w4
    ee34:	83 01 42    	add.w     w4, w3, w3
    ee36:	93 01 78    	mov.w     [w3], w3
    ee38:	80 49 78    	mov.b     w0, [w3]
    ee3a:	02 01 e8    	inc.w     w2, w2
    ee3c:	92 19 8a    	mov.w     w2, 0x4332
		CK_A += gpschar;
    ee3e:	62 33 24    	mov.w     #0x4336, w2
    ee40:	12 40 40    	add.b     w0, [w2], w0
    ee42:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    ee44:	72 33 24    	mov.w     #0x4337, w2
    ee46:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    ee48:	81 00 e9    	dec.w     w1, w1
    ee4a:	d1 19 8a    	mov.w     w1, 0x433a
    ee4c:	04 00 37    	bra       0xee56 <.L40>

0000ee4e <.L41>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		//gpsoutchar2(0x0A);
		checksum._.B1 = gpschar;
    ee4e:	31 34 24    	mov.w     #0x4343, w1
    ee50:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    ee52:	60 fd 2e    	mov.w     #0xefd6, w0
    ee54:	70 20 8a    	mov.w     w0, 0x440e

0000ee56 <.L40>:
	}
}
    ee56:	00 00 06    	return    

0000ee58 <_msg_VELNED>:

static void msg_VELNED(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    ee58:	d1 19 82    	mov.w     0x433a, w1
    ee5a:	01 00 e0    	cp0.w     w1
    ee5c:	10 00 34    	bra       LE, 0xee7e <.L44>
	{
		*msg_VELNED_parse[store_index++] = gpschar;
    ee5e:	92 19 82    	mov.w     0x4332, w2
    ee60:	82 01 41    	add.w     w2, w2, w3
    ee62:	04 0e 2c    	mov.w     #0xc0e0, w4
    ee64:	83 01 42    	add.w     w4, w3, w3
    ee66:	93 01 78    	mov.w     [w3], w3
    ee68:	80 49 78    	mov.b     w0, [w3]
    ee6a:	02 01 e8    	inc.w     w2, w2
    ee6c:	92 19 8a    	mov.w     w2, 0x4332
		CK_A += gpschar;
    ee6e:	62 33 24    	mov.w     #0x4336, w2
    ee70:	12 40 40    	add.b     w0, [w2], w0
    ee72:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    ee74:	72 33 24    	mov.w     #0x4337, w2
    ee76:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    ee78:	81 00 e9    	dec.w     w1, w1
    ee7a:	d1 19 8a    	mov.w     w1, 0x433a
    ee7c:	04 00 37    	bra       0xee86 <.L43>

0000ee7e <.L44>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		//gpsoutchar2(0x0B);
		checksum._.B1 = gpschar;
    ee7e:	31 34 24    	mov.w     #0x4343, w1
    ee80:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    ee82:	60 fd 2e    	mov.w     #0xefd6, w0
    ee84:	70 20 8a    	mov.w     w0, 0x440e

0000ee86 <.L43>:
	}
}
    ee86:	00 00 06    	return    

0000ee88 <_msg_BODYRATES>:

//#if (HILSIM == 1)
static void msg_BODYRATES(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    ee88:	d1 19 82    	mov.w     0x433a, w1
    ee8a:	01 00 e0    	cp0.w     w1
    ee8c:	10 00 34    	bra       LE, 0xeeae <.L47>
	{
		*msg_BODYRATES_parse[store_index++] = gpschar;
    ee8e:	92 19 82    	mov.w     0x4332, w2
    ee90:	82 01 41    	add.w     w2, w2, w3
    ee92:	84 12 2c    	mov.w     #0xc128, w4
    ee94:	83 01 42    	add.w     w4, w3, w3
    ee96:	93 01 78    	mov.w     [w3], w3
    ee98:	80 49 78    	mov.b     w0, [w3]
    ee9a:	02 01 e8    	inc.w     w2, w2
    ee9c:	92 19 8a    	mov.w     w2, 0x4332
		CK_A += gpschar;
    ee9e:	62 33 24    	mov.w     #0x4336, w2
    eea0:	12 40 40    	add.b     w0, [w2], w0
    eea2:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    eea4:	72 33 24    	mov.w     #0x4337, w2
    eea6:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    eea8:	81 00 e9    	dec.w     w1, w1
    eeaa:	d1 19 8a    	mov.w     w1, 0x433a
    eeac:	04 00 37    	bra       0xeeb6 <.L46>

0000eeae <.L47>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		checksum._.B1 = gpschar;
    eeae:	31 34 24    	mov.w     #0x4343, w1
    eeb0:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    eeb2:	60 fd 2e    	mov.w     #0xefd6, w0
    eeb4:	70 20 8a    	mov.w     w0, 0x440e

0000eeb6 <.L46>:
	}
}
    eeb6:	00 00 06    	return    

0000eeb8 <_msg_ACK_CLASS>:
//#endif // HILSIM

static void msg_ACK_CLASS(uint8_t gpschar)
{
	//bin_out(0xAA);
	ack_class = gpschar;
    eeb8:	80 80 fb    	ze        w0, w1
    eeba:	f1 19 8a    	mov.w     w1, 0x433e
	CK_A += gpschar;
    eebc:	61 33 24    	mov.w     #0x4336, w1
    eebe:	11 40 40    	add.b     w0, [w1], w0
    eec0:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    eec2:	71 33 24    	mov.w     #0x4337, w1
    eec4:	91 48 40    	add.b     w0, [w1], [w1]
	msg_parse = &msg_ACK_ID;
    eec6:	c0 ec 2e    	mov.w     #0xeecc, w0
    eec8:	70 20 8a    	mov.w     w0, 0x440e
}
    eeca:	00 00 06    	return    

0000eecc <_msg_ACK_ID>:

static void msg_ACK_ID(uint8_t gpschar)
{
	//bin_out(0xBB);
	ack_id = gpschar;
    eecc:	80 80 fb    	ze        w0, w1
    eece:	01 1a 8a    	mov.w     w1, 0x4340
	CK_A += gpschar;
    eed0:	61 33 24    	mov.w     #0x4336, w1
    eed2:	11 40 40    	add.b     w0, [w1], w0
    eed4:	80 48 78    	mov.b     w0, [w1]
	CK_B += CK_A;
    eed6:	71 33 24    	mov.w     #0x4337, w1
    eed8:	91 48 40    	add.b     w0, [w1], [w1]
	msg_parse = &msg_CS1;
    eeda:	60 fd 2e    	mov.w     #0xefd6, w0
    eedc:	70 20 8a    	mov.w     w0, 0x440e
}
    eede:	00 00 06    	return    

0000eee0 <_msg_MSGU>:

static void msg_MSGU(uint8_t gpschar)
{
	if (payloadlength.BB > 0)
    eee0:	d1 19 82    	mov.w     0x433a, w1
    eee2:	01 00 e0    	cp0.w     w1
    eee4:	08 00 34    	bra       LE, 0xeef6 <.L52>
	{
		CK_A += gpschar;
    eee6:	62 33 24    	mov.w     #0x4336, w2
    eee8:	12 40 40    	add.b     w0, [w2], w0
    eeea:	00 49 78    	mov.b     w0, [w2]
		CK_B += CK_A;
    eeec:	72 33 24    	mov.w     #0x4337, w2
    eeee:	12 49 40    	add.b     w0, [w2], [w2]
		payloadlength.BB--;
    eef0:	81 00 e9    	dec.w     w1, w1
    eef2:	d1 19 8a    	mov.w     w1, 0x433a
    eef4:	04 00 37    	bra       0xeefe <.L51>

0000eef6 <.L52>:
	}
	else
	{
		// If the payload length is zero, we have received the entire payload, or the payload length
		// was zero to start with. either way, the byte we just received is the first checksum byte.
		//gpsoutchar2(0x08);
		checksum._.B1 = gpschar;
    eef6:	31 34 24    	mov.w     #0x4343, w1
    eef8:	80 48 78    	mov.b     w0, [w1]
		msg_parse = &msg_CS1;
    eefa:	60 fd 2e    	mov.w     #0xefd6, w0
    eefc:	70 20 8a    	mov.w     w0, 0x440e

0000eefe <.L51>:
	}
}
    eefe:	00 00 06    	return    

0000ef00 <_gps_startup_sequence>:
    ef00:	00 00 06    	return    

0000ef02 <_gps_nav_valid>:
    ef02:	40 31 24    	mov.w     #0x4314, w0
    ef04:	10 40 78    	mov.b     [w0], w0
    ef06:	63 40 68    	xor.b     w0, #0x3, w0
    ef08:	00 80 fb    	ze        w0, w0
    ef0a:	00 00 e9    	dec.w     w0, w0
    ef0c:	4f 00 de    	lsr.w     w0, #0xf, w0
    ef0e:	00 00 06    	return    

0000ef10 <_udb_background_trigger>:
// If GPS data has not been received for this many state machine cycles, consider the GPS lock to be lost.
#define GPS_DATA_MAX_AGE    9
void udb_background_trigger(background_callback callback)
{
	if (callback) callback();
    ef10:	00 00 e0    	cp0.w     w0
    ef12:	01 00 32    	bra       Z, 0xef16 <.L56>
    ef14:	00 00 01    	call      w0

0000ef16 <.L56>:
}
    ef16:	00 00 06    	return    

0000ef18 <_gps_update_basic_data>:

static void msg_CS1(uint8_t gpschar)
{
	checksum._.B0 = gpschar;
	if ((checksum._.B1 == CK_A) && (checksum._.B0 == CK_B))
	{
		if (msg_id == 0x12)
		{
			// correct checksum for VELNED message
			//gps_parse_common(); // parsing is complete, schedule navigation
			udb_background_trigger(&udb_background_callback_triggered);
		}
//#if (HILSIM == 1)
		else if (msg_id == 0xAB)
		{
			// If we got the correct checksum for bodyrates, commit that data immediately
			commit_bodyrate_data();
		}
//#endif
	}
	else
	{
		gps_data_age = GPS_DATA_MAX_AGE+1;  // if the checksum is wrong then the data from this packet is invalid. 
		                                    // setting this ensures the nav routine does not try to use this data.
	}
	msg_parse = &msg_B3;
}

void gps_update_basic_data(void)
{
	week_no         = week_no_;
    ef18:	90 18 82    	mov.w     0x4312, w0
    ef1a:	20 17 8a    	mov.w     w0, 0x42e4
	svs             = svs_;
    ef1c:	51 31 24    	mov.w     #0x4315, w1
    ef1e:	30 2f 24    	mov.w     #0x42f3, w0
    ef20:	11 48 78    	mov.b     [w1], [w0]
}
    ef22:	00 00 06    	return    

0000ef24 <_gps_commit_data>:

void gps_commit_data(void)
{
	//bin_out(0xFF);
	week_no         = week_no_;
    ef24:	90 18 82    	mov.w     0x4312, w0
    ef26:	20 17 8a    	mov.w     w0, 0x42e4
	tow             = tow_;
    ef28:	10 18 82    	mov.w     0x4302, w0
    ef2a:	21 18 82    	mov.w     0x4304, w1
    ef2c:	70 17 8a    	mov.w     w0, 0x42ee
    ef2e:	81 17 8a    	mov.w     w1, 0x42f0
	mlGpsData.time_usec = tow.WW;
    ef30:	4f 89 de    	asr.w     w1, #0xf, w2
    ef32:	82 01 78    	mov.w     w2, w3
    ef34:	a4 05 21    	mov.w     #0x105a, w4
    ef36:	00 9a be    	mov.d     w0, [w4++]
    ef38:	02 92 be    	mov.d     w2, [w4--]
	lat_gps         = lat_gps_;
    ef3a:	b0 17 82    	mov.w     0x42f6, w0
    ef3c:	c1 17 82    	mov.w     0x42f8, w1
    ef3e:	c0 16 8a    	mov.w     w0, 0x42d8
    ef40:	d1 16 8a    	mov.w     w1, 0x42da
	mlGpsData.lat = lat_gps.WW;
    ef42:	10 83 88    	mov.w     w0, 0x1062
    ef44:	21 83 88    	mov.w     w1, 0x1064
	lon_gps         = lon_gps_;
    ef46:	d0 17 82    	mov.w     0x42fa, w0
    ef48:	e1 17 82    	mov.w     0x42fc, w1
    ef4a:	e0 16 8a    	mov.w     w0, 0x42dc
    ef4c:	f1 16 8a    	mov.w     w1, 0x42de
	mlGpsData.lon = lon_gps_.WW;
    ef4e:	30 83 88    	mov.w     w0, 0x1066
    ef50:	41 83 88    	mov.w     w1, 0x1068
	alt_sl_gps.WW   = alt_sl_gps_.WW;          // SIRF provides altMSL in cm, UBX provides it in mm
    ef52:	f0 17 82    	mov.w     0x42fe, w0
    ef54:	01 18 82    	mov.w     0x4300, w1
    ef56:	00 17 8a    	mov.w     w0, 0x42e0
    ef58:	11 17 8a    	mov.w     w1, 0x42e2
	mlGpsData.alt = alt_sl_gps.WW;
    ef5a:	50 83 88    	mov.w     w0, 0x106a
    ef5c:	61 83 88    	mov.w     w1, 0x106c
	sog_gps.BB      = sog_gps_._.W0;                // SIRF uses 2 byte SOG, UBX provides 4 bytes
    ef5e:	f0 18 82    	mov.w     0x431e, w0
    ef60:	30 17 8a    	mov.w     w0, 0x42e6
	mlGpsData.vel = sog_gps.BB;
    ef62:	90 83 88    	mov.w     w0, 0x1072
//#if (HILSIM == 1)
	hilsim_airspeed.BB       = as_sim_._.W0;                 // provided by HILSIM, simulated airspeed
    ef64:	d1 18 82    	mov.w     0x431a, w1
    ef66:	61 17 8a    	mov.w     w1, 0x42ec

0000ef68 <.L0>:
	
//#endif
	cog_gps.BB      = (uint16_t)(cog_gps_.WW / 1000);// SIRF uses 2 byte COG, 10^-2 deg, UBX provides 4 bytes, 10^-5 deg
    ef68:	82 3e 20    	mov.w     #0x3e8, w2
    ef6a:	03 00 20    	mov.w     #0x0, w3
    ef6c:	10 19 82    	mov.w     0x4322, w0
    ef6e:	21 19 82    	mov.w     0x4324, w1
    ef70:	aa 17 02    	call      0x17aa <___divsi3>
    ef72:	00 00 00 
    ef74:	40 17 8a    	mov.w     w0, 0x42e8

0000ef76 <.L0>:
	mlGpsData.cog = cog_gps.BB;
    ef76:	a0 83 88    	mov.w     w0, 0x1074
	climb_gps.BB    = - climb_gps_._.W0;            // SIRF uses 2 byte climb rate, UBX provides 4 bytes
    ef78:	60 31 24    	mov.w     #0x4316, w0
    ef7a:	10 00 ea    	neg.w     [w0], w0
    ef7c:	50 17 8a    	mov.w     w0, 0x42ea
	hdop            = (uint8_t)(hdop_.BB / 20);     // SIRF scales HDOP by 5, UBX by 10^-2
    ef7e:	30 18 82    	mov.w     0x4306, w0
    ef80:	42 01 20    	mov.w     #0x14, w2
    ef82:	11 00 09    	.pword 0x090011
    ef84:	02 00 d8    	div.sw    w0, w2
    ef86:	21 2f 24    	mov.w     #0x42f2, w1
    ef88:	80 48 78    	mov.b     w0, [w1]
	mlGpsData.eph = hdop;
    ef8a:	00 80 fb    	ze        w0, w0
    ef8c:	70 83 88    	mov.w     w0, 0x106e
	mlGpsData.epv = 65535;
    ef8e:	00 80 eb    	setm.w    w0
    ef90:	80 83 88    	mov.w     w0, 0x1070
	// SIRF provides position in m, UBX provides cm
//	xpg.WW          = xpg_.WW / 100;
//	ypg.WW          = ypg_.WW / 100;
//	zpg.WW          = zpg_.WW / 100;
	// SIRF provides 2 byte velocity in m scaled by 8,
	// UBX provides 4 bytes in cm
//	xvg.BB          = (int16_t)(xvg_.WW / 100 * 8);
//	yvg.BB          = (int16_t)(yvg_.WW / 100 * 8);
//	zvg.BB          = (int16_t)(zvg_.WW / 100 * 8);
//	mode1           = mode1_;
//	mode2           = mode2_;
	svs             = svs_;
    ef92:	50 31 24    	mov.w     #0x4315, w0
    ef94:	10 40 78    	mov.b     [w0], w0
    ef96:	31 2f 24    	mov.w     #0x42f3, w1
    ef98:	80 48 78    	mov.b     w0, [w1]
	mlGpsData.satellites_visible = svs;
    ef9a:	71 07 21    	mov.w     #0x1077, w1
    ef9c:	80 48 78    	mov.b     w0, [w1]
	mlGpsData.fix_type = nav_valid_;
    ef9e:	41 31 24    	mov.w     #0x4314, w1
    efa0:	60 07 21    	mov.w     #0x1076, w0
    efa2:	11 48 78    	mov.b     [w1], [w0]

0000efa4 <.L0>:

//#if (HILSIM == 1 && MAG_YAW_DRIFT == 1)
//	HILSIM_MagData(udb_magnetometer_callback); // run the magnetometer computations
//#endif // HILSIM
}

//#if (HILSIM == 1)
void commit_bodyrate_data(void)
{
	g_a_x_sim = g_a_x_sim_;
	g_a_y_sim = g_a_y_sim_;
	g_a_z_sim = g_a_z_sim_;
	p_sim = p_sim_;
	q_sim = q_sim_;
	r_sim = r_sim_;
	



}
#define RMAX                    16384//0b0100000000000000       // 1.0 in 2.14 fractional format

void HILSIM_saturate( uint16_t size , int16_t vector[3] )
{
	// hardware 16 bit signed integer gyro and accelerometer data and offsets
	// are divided by 2 prior to subtracting offsets from values.
	// This is done to prevent overflow.
	// However, it limits range to approximately +- RMAX.
	// Data coming in from Xplane is in 16 bit signed integer format with range +-2*RMAX,
	// so it needs to be passed through a saturation computation that limits to +-RMAX.
	uint16_t index ;
	for ( index = 0 ; index < size ; index ++ )
	{
		if ( vector[index ] > RMAX )
		{
			vector[index] = RMAX ;
		}
		if ( vector[index] < -RMAX )
		{
			vector[index] = -RMAX ;
		}
	}	
}
// gravity, as measured in plane coordinate system


void HILSIM_set_gplane(void)
{
	gplane[0] = g_a_y_sim.BB;
	gplane[1] = g_a_x_sim.BB;
	gplane[2] = g_a_z_sim.BB;
	HILSIM_saturate( 3, gplane ) ;
	aero_force[0] = - gplane[0] ;
	aero_force[1] = - gplane[1] ;
	aero_force[2] = - gplane[2] ;
	//from X-Plane interface adapter:
	// Accelerations are in m/s^2
	// Divide by 9.8 to get g's
	// Multiply by 5280 (constant from UDB code)
	// Divide by SCALEACCEL (2.64 for red board)
	// 1 / 9.8 * 5280 / 2.64 = 204.8
	mlRawImuData.xacc = gplane[1]  / 204.8 * 16384 / 9.815;//[1] is 'drg_axil' from  X-PLane
	mlRawImuData.yacc = -gplane[0] / 204.8 * 16384 / 9.815;//[0] is 'drg_side' from  X-PLane
	mlRawImuData.zacc = gplane[2]  / 204.8 * 16384 / 9.815;//[2] is 'drg_nrml' from  X-PLane

}
#define RADPERSEC ((int64_t)5632.0/SCALEGYRO)
// one radian per second, in AtoD/2 units
#ifdef WIN
extern fractional omegagyro[];

#else
fractional omegagyro[] = { 0, 0, 0 };

#endif

void HILSIM_set_omegagyro(void)
{
	omegagyro[0] = p_sim.BB;
	omegagyro[1] = q_sim.BB;
	omegagyro[2] = r_sim.BB;
	HILSIM_saturate( 3, omegagyro ) ;
	//I converted back to deg/sec since we have convertor inside the model to rad/sec
	//also converting to the sensor scale 
	// Angular rate
	// multiply by 5632 (constant from UDB code)
	// Divide by SCALEGYRO(3.0 for red board)
	// 1 * 5632 / 3.0 = 1877.33
	mlRawImuData.xgyro = -omegagyro[0] / 1877.33 * 65.5 / PI * 180 ;
	mlRawImuData.ygyro = -omegagyro[1] / 1877.33 * 65.5 / PI * 180 ;// I put the negative sign since HILSIM interface to X-PLane convert from NED to UDB
	mlRawImuData.zgyro = -omegagyro[2] / 1877.33 * 65.5 / PI * 180 ;
	

}
//#endif // HILSIM

void init_gps_ubx(void)
{
}

//#endif // (GPS_TYPE == GPS_UBX_2HZ || GPS_TYPE == GPS_UBX_4HZ || GPS_TYPE == GPS_ALL)

void gpsoutbin(int16_t length, const uint8_t msg[]) // output a binary message to the GPS
{
    uint8_t i;
	gps_out_buffer = 0; // clear the buffer pointer first, for safety, in case we're interrupted
	gps_out_index = 0;
	gps_out_buffer_length = length;
	gps_out_buffer = (uint8_t*)msg;

#ifdef WIN
    	udb_gps_start_sending_data();
#else
         for (i = 0U; i < length; i++) {
             Uart4OutBuff[i] = msg[i];
	}
        
#endif
}

void gpsoutline(const char *message) // output one NMEA line to the GPS
{
	gpsoutbin(strlen(message), (const uint8_t*)message);
}

int16_t udb_gps_callback_get_byte_to_send(void)
{
	if (gps_out_buffer != 0 && gps_out_index < gps_out_buffer_length)
	{
		// We have a byte to send
		return (uint8_t)(gps_out_buffer[gps_out_index++]);
	}
	else
	{
		// No byte to send, so clear the link to the buffer
		gps_out_buffer = 0;
	}
	return -1;
}

// Got a character from the GPS
void udb_gps_callback_received_byte(uint8_t rxchar)
{
	//bin_out(rxchar);      // binary out to the debugging USART
	(*msg_parse)(rxchar);   // parse the input byte
}


boolean gps_nav_capable_check_set(void)
{
	boolean tmp ;
	if (gps_data_age < GPS_DATA_MAX_AGE) gps_data_age++;
	tmp = (gps_data_age < GPS_DATA_MAX_AGE);
	//	return (gps_data_age < GPS_DATA_MAX_AGE);
	return (tmp);// dcm_flags._.nav_capable;
}



// Received a full set of GPS messages
//void gps_parse_common(void)
//{
//	udb_background_trigger(&udb_background_callback_triggered);
//}

static void udb_background_callback_triggered(void)
{
//	union longbbbb accum;
//	union longww accum_velocity;
//	union longww longaccum;
//	int8_t cog_circular;
//	int8_t cog_delta;
//	int16_t sog_delta;
//	int16_t climb_rate_delta;
//#ifdef USE_EXTENDED_NAV
//	int32_t location[3];
//#else
//	int16_t location[3];
//	union longbbbb accum_nav;
//#endif // USE_EXTENDED_NAV
	/*int16_t location_deltaZ;
	struct relative2D location_deltaXY;
	struct relative2D velocity_thru_air;
	int16_t velocity_thru_airz;*/

#ifdef SLUGS2
	fractional rmat[] = { RMAX, 0, 0, 0, RMAX, 0, 0, 0, RMAX };
#endif
	// compute horizontal projection of air velocity,
	// taking into account the angle of attack.
	/*longaccum.WW = (__builtin_mulss(rmat[2], angleOfAttack)) << 2;
	dirOverGndHrmat[0] = rmat[1] + longaccum._.W1;
	longaccum.WW = (__builtin_mulss(rmat[5], angleOfAttack)) << 2;
	dirOverGndHrmat[1] = rmat[4] + longaccum._.W1;
	dirOverGndHrmat[2] = 0;*/

	if (gps_nav_valid())
    efa4:	00 00 06    	return    

0000efa6 <_udb_background_callback_triggered>:
	{
		gps_commit_data();
    efa6:	ad ff 07    	rcall     0xef02 <_gps_nav_valid> <L0> <.LFB1466> <.LFE1465>
    efa8:	00 04 e0    	cp0.b     w0

0000efaa <.L0>:
    efaa:	04 00 32    	bra       Z, 0xefb4 <.L0> <.L61>
    efac:	bb ff 07    	rcall     0xef24 <_gps_commit_data> <L0> <.LFB1485> <.LFE1484>


		gps_data_age = 0;
    efae:	00 00 eb    	clr.w     w0
    efb0:	a0 17 8a    	mov.w     w0, 0x42f4
    efb2:	03 00 37    	bra       0xefba <.L60>

0000efb4 <.L0>:
//#ifndef SLUGS2
//		dcm_callback_gps_location_updated();
//#endif

//#ifdef USE_EXTENDED_NAV
//		location[1] = ((lat_gps.WW - lat_origin.WW) / 90); // in meters, range is about 20 miles
//		location[0] = long_scale((lon_gps.WW - lon_origin.WW) / 90, cos_lat);
//		location[2] = (alt_sl_gps.WW - alt_origin.WW) / 100; // height in meters
//#else // USE_EXTENDED_NAV
//		accum_nav.WW = ((lat_gps.WW - lat_origin.WW) / 90); // in meters, range is about 20 miles
//		location[1] = accum_nav._.W0;
//		accum_nav.WW = long_scale((lon_gps.WW - lon_origin.WW) / 90, cos_lat);
//
//		location[0] = accum_nav._.W0;
//#ifdef USE_PRESSURE_ALT
//		#warning "using pressure altitude instead of GPS altitude"
//			// division by 100 implies alt_origin is in centimeters; not documented elsewhere
//			// longword result = (longword/10 - longword)/100 : range
//			accum_nav.WW = ((get_barometer_altitude() / 10) - alt_origin.WW) / 100; // height in meters
//#else
//		accum_nav.WW = (alt_sl_gps.WW - alt_origin.WW) / 100; // height in meters
//#endif // USE_PRESSURE_ALT
//		location[2] = accum_nav._.W0;
//#endif // USE_EXTENDED_NAV
//
//		// convert GPS course of 360 degrees to a binary model with 256
//		accum.WW = __builtin_muluu(COURSEDEG_2_BYTECIR, cog_gps.BB) + 0x00008000;
//		// re-orientate from compass (clockwise) to maths (anti-clockwise) with 0 degrees in East
//		cog_circular = -accum.__.B2 + 64;
//
		// compensate for GPS reporting latency.
		// The dynamic model of the EM406 and uBlox is not well known.
		// However, it seems likely much of it is simply reporting latency.
		// This section of the code compensates for reporting latency.
		// markw: what is the latency? It doesn't appear numerically or as a comment
		// in the following code. Since this method is called at the GPS reporting rate
		// it must be assumed to be one reporting interval?

//		if (dcm_flags._.gps_history_valid)
//		{
//			cog_delta = cog_circular - cog_previous;
//			sog_delta = sog_gps.BB - sog_previous;
//			climb_rate_delta = climb_gps.BB - climb_rate_previous;
//
//			location_deltaXY.x = location[0] - location_previous[0];
//			location_deltaXY.y = location[1] - location_previous[1];
//			location_deltaZ = location[2] - location_previous[2];
//		}
//		else
//		{
//			cog_delta = sog_delta = climb_rate_delta = 0;
//			location_deltaXY.x = location_deltaXY.y = location_deltaZ = 0;
//		}
//		dcm_flags._.gps_history_valid = 1;
//		actual_dir = cog_circular + cog_delta;
//		cog_previous = cog_circular;
//
//		// Note that all these velocities are in centimeters / second
//
//		ground_velocity_magnitudeXY = sog_gps.BB + sog_delta;
//		sog_previous = sog_gps.BB;
//
//		GPSvelocity.z = climb_gps.BB + climb_rate_delta;
//		climb_rate_previous = climb_gps.BB;
//		accum_velocity.WW = (__builtin_mulss(cosine(actual_dir), ground_velocity_magnitudeXY) << 2) + 0x00008000;
//		GPSvelocity.x = accum_velocity._.W1;
//		accum_velocity.WW = (__builtin_mulss(sine(actual_dir), ground_velocity_magnitudeXY) << 2) + 0x00008000;
//
//		GPSvelocity.y = accum_velocity._.W1;
//		rotate_2D(&location_deltaXY, cog_delta); // this is a key step to account for rotation effects!!
//
//		GPSlocation.x = location[0] + location_deltaXY.x;
//		GPSlocation.y = location[1] + location_deltaXY.y;
//		GPSlocation.z = location[2] + location_deltaZ;
//
//		location_previous[0] = location[0];
//		location_previous[1] = location[1];
//		location_previous[2] = location[2];
//
//#ifndef SLUGS2
//		velocity_thru_air.y = GPSvelocity.y - estimatedWind[1];
//		velocity_thru_air.x = GPSvelocity.x - estimatedWind[0];
//		velocity_thru_airz = GPSvelocity.z - estimatedWind[2];
//#else
//		velocity_thru_air.y = GPSvelocity.y;
//		velocity_thru_air.x = GPSvelocity.x;
//		velocity_thru_airz = GPSvelocity.z;
//#endif

//#if (HILSIM == 1)
//		air_speed_3DGPS = hilsim_airspeed.BB; // use Xplane as a pitot
//#else
//		air_speed_3DGPS = vector3_mag(velocity_thru_air.x, velocity_thru_air.y, velocity_thru_airz);
//#endif
//
//		calculated_heading = rect_to_polar(&velocity_thru_air);
//
//		// veclocity_thru_air.x becomes XY air speed as a by product of CORDIC routine in rect_to_polar()
//		air_speed_magnitudeXY = velocity_thru_air.x; // in cm / sec
//
//#if (GPS_RATE == 4)
//		forward_acceleration = (air_speed_3DGPS - velocity_previous) << 2; // Ublox enters code 4 times per second
//#elif (GPS_RATE == 2)
//		forward_acceleration = (air_speed_3DGPS - velocity_previous) << 1; // Ublox enters code 2 times per second
//#else
//		forward_acceleration = (air_speed_3DGPS - velocity_previous);      // EM406 standard GPS enters code once per second
//#endif
//
//		velocity_previous = air_speed_3DGPS;
//#ifndef SLUGS2
//
//		estimateWind();
//		estAltitude();
//		estYawDrift();
//#endif
//		dcm_flags._.yaw_req = 1;       // request yaw drift correction
//		dcm_flags._.reckon_req = 1;    // request dead reckoning correction
//		dcm_flags._.rollpitch_req = 1;
//#if (DEADRECKONING == 0)
//		process_flightplan();
//#endif
	}
	else
	{
		gps_data_age = GPS_DATA_MAX_AGE + 1;
    efb4:	a0 00 20    	mov.w     #0xa, w0

0000efb6 <.L0>:
		//dirOverGndHGPS[0] = dirOverGndHrmat[0];
		//dirOverGndHGPS[1] = dirOverGndHrmat[1];
		//dirOverGndHGPS[2] = 0;
		//dcm_flags._.yaw_req = 1;            // request yaw drift correction
		//dcm_flags._.gps_history_valid = 0;  // gps history has to be restarted
		gps_update_basic_data();            // update svs
    efb6:	a0 17 8a    	mov.w     w0, 0x42f4
    efb8:	af ff 07    	rcall     0xef18 <_gps_update_basic_data> <L0> <.LFB1484> <.LFE1482>

0000efba <.L60>:
	}
}
    efba:	00 00 06    	return    

0000efbc <_commit_bodyrate_data>:
    efbc:	60 19 82    	mov.w     0x432c, w0
    efbe:	60 1a 8a    	mov.w     w0, 0x434c
    efc0:	70 19 82    	mov.w     0x432e, w0
    efc2:	50 1a 8a    	mov.w     w0, 0x434a
    efc4:	80 19 82    	mov.w     0x4330, w0
    efc6:	70 1a 8a    	mov.w     w0, 0x434e
    efc8:	30 19 82    	mov.w     0x4326, w0
    efca:	20 1a 8a    	mov.w     w0, 0x4344
    efcc:	40 19 82    	mov.w     0x4328, w0
    efce:	30 1a 8a    	mov.w     w0, 0x4346
    efd0:	50 19 82    	mov.w     0x432a, w0
    efd2:	40 1a 8a    	mov.w     w0, 0x4348
    efd4:	00 00 06    	return    

0000efd6 <_msg_CS1>:
    efd6:	21 34 24    	mov.w     #0x4342, w1
    efd8:	80 48 78    	mov.b     w0, [w1]
    efda:	61 33 24    	mov.w     #0x4336, w1
    efdc:	32 34 24    	mov.w     #0x4343, w2
    efde:	12 41 78    	mov.b     [w2], w2
    efe0:	91 4f 51    	sub.b     w2, [w1], [w15]
    efe2:	0e 00 3a    	bra       NZ, 0xf000 <.L65>
    efe4:	71 33 24    	mov.w     #0x4337, w1
    efe6:	91 4f 50    	sub.b     w0, [w1], [w15]
    efe8:	0b 00 3a    	bra       NZ, 0xf000 <.L65>
    efea:	c0 19 82    	mov.w     0x4338, w0
    efec:	f2 0f 50    	sub.w     w0, #0x12, [w15]
    efee:	03 00 3a    	bra       NZ, 0xeff6 <.L0> <.L0> <.L66>

0000eff0 <.L0>:
    eff0:	60 fa 2e    	mov.w     #0xefa6, w0
    eff2:	8e ff 07    	rcall     0xef10 <_udb_background_trigger> <L0> <.LFB1482> <.LFE1466>
    eff4:	07 00 37    	bra       0xf004 <.L67>

0000eff6 <.L0>:
    eff6:	b1 0a 20    	mov.w     #0xab, w1
    eff8:	81 0f 50    	sub.w     w0, w1, [w15]

0000effa <.L0>:
    effa:	04 00 3a    	bra       NZ, 0xf004 <.L67>
    effc:	df ff 07    	rcall     0xefbc <_commit_bodyrate_data> <L0> <.LFB1486> <.LFE1496>
    effe:	02 00 37    	bra       0xf004 <.L67>

0000f000 <.L65>:
    f000:	a0 00 20    	mov.w     #0xa, w0
    f002:	a0 17 8a    	mov.w     w0, 0x42f4

0000f004 <.L67>:
    f004:	20 cb 2e    	mov.w     #0xecb2, w0
    f006:	70 20 8a    	mov.w     w0, 0x440e
    f008:	00 00 06    	return    

0000f00a <_HILSIM_saturate>:
    f00a:	00 00 e0    	cp0.w     w0
    f00c:	10 00 32    	bra       Z, 0xf02e <.L68>
    f00e:	81 80 e9    	dec2.w    w1, w1
    f010:	00 01 eb    	clr.w     w2
    f012:	05 00 24    	mov.w     #0x4000, w5
    f014:	06 00 2c    	mov.w     #0xc000, w6

0000f016 <.L72>:
    f016:	81 80 e8    	inc2.w    w1, w1
    f018:	91 01 78    	mov.w     [w1], w3
    f01a:	85 8f 51    	sub.w     w3, w5, [w15]
    f01c:	02 00 34    	bra       LE, 0xf022 <.L70>
    f01e:	85 08 78    	mov.w     w5, [w1]
    f020:	03 00 37    	bra       0xf028 <.L71>

0000f022 <.L70>:
    f022:	86 8f 51    	sub.w     w3, w6, [w15]
    f024:	01 00 3d    	bra       GE, 0xf028 <.L71>
    f026:	86 08 78    	mov.w     w6, [w1]

0000f028 <.L71>:
    f028:	02 01 e8    	inc.w     w2, w2
    f02a:	82 0f 50    	sub.w     w0, w2, [w15]
    f02c:	f4 ff 3e    	bra       GTU, 0xf016 <.L72>

0000f02e <.L68>:
    f02e:	00 00 06    	return    

0000f030 <_HILSIM_set_gplane>:
    f030:	88 9f be    	mov.d     w8, [w15++]
    f032:	8a 9f be    	mov.d     w10, [w15++]
    f034:	28 40 24    	mov.w     #0x4402, w8
    f036:	50 1a 82    	mov.w     0x434a, w0
    f038:	00 0c 78    	mov.w     w0, [w8]
    f03a:	88 84 e8    	inc2.w    w8, w9
    f03c:	60 1a 82    	mov.w     0x434c, w0
    f03e:	80 0c 78    	mov.w     w0, [w9]
    f040:	64 05 44    	add.w     w8, #0x4, w10
    f042:	70 1a 82    	mov.w     0x434e, w0
    f044:	00 0d 78    	mov.w     w0, [w10]

0000f046 <.L0>:
    f046:	88 00 78    	mov.w     w8, w1
    f048:	30 00 20    	mov.w     #0x3, w0
    f04a:	df ff 07    	rcall     0xf00a <_HILSIM_saturate> <L0> <.LFB1487> <.LFE1483>

0000f04c <.L0>:
    f04c:	98 05 ea    	neg.w     [w8], w11
    f04e:	4b 20 8a    	mov.w     w11, 0x4408
    f050:	99 00 78    	mov.w     [w9], w1
    f052:	a0 40 24    	mov.w     #0x440a, w0
    f054:	01 08 ea    	neg.w     w1, [w0]
    f056:	1a 04 78    	mov.w     [w10], w8
    f058:	00 80 e8    	inc2.w    w0, w0
    f05a:	08 08 ea    	neg.w     w8, [w0]

0000f05c <.L0>:
    f05c:	61 08 b9    	mul.su    w1, #0x1, w0
    f05e:	0c 19 02    	call      0x190c <___floatsisf>
    f060:	00 00 00 
    f062:	d2 cc 2c    	mov.w     #0xcccd, w2
    f064:	c3 34 24    	mov.w     #0x434c, w3
    f066:	26 17 02    	call      0x1726 <___divsf3>
    f068:	00 00 00 
    f06a:	02 00 20    	mov.w     #0x0, w2
    f06c:	03 68 24    	mov.w     #0x4680, w3
    f06e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f070:	00 00 00 
    f072:	d2 a3 20    	mov.w     #0xa3d, w2
    f074:	d3 11 24    	mov.w     #0x411d, w3
    f076:	26 17 02    	call      0x1726 <___divsf3>
    f078:	00 00 00 
    f07a:	94 18 02    	call      0x1894 <___fixsfsi>
    f07c:	00 00 00 
    f07e:	20 85 88    	mov.w     w0, 0x10a4

0000f080 <.L0>:
    f080:	61 58 b9    	mul.su    w11, #0x1, w0
    f082:	0c 19 02    	call      0x190c <___floatsisf>
    f084:	00 00 00 
    f086:	d2 cc 2c    	mov.w     #0xcccd, w2
    f088:	c3 34 24    	mov.w     #0x434c, w3
    f08a:	26 17 02    	call      0x1726 <___divsf3>
    f08c:	00 00 00 
    f08e:	02 00 20    	mov.w     #0x0, w2
    f090:	03 68 24    	mov.w     #0x4680, w3
    f092:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f094:	00 00 00 
    f096:	d2 a3 20    	mov.w     #0xa3d, w2
    f098:	d3 11 24    	mov.w     #0x411d, w3
    f09a:	26 17 02    	call      0x1726 <___divsf3>
    f09c:	00 00 00 
    f09e:	94 18 02    	call      0x1894 <___fixsfsi>
    f0a0:	00 00 00 
    f0a2:	30 85 88    	mov.w     w0, 0x10a6

0000f0a4 <.L0>:
    f0a4:	61 40 b9    	mul.su    w8, #0x1, w0
    f0a6:	0c 19 02    	call      0x190c <___floatsisf>
    f0a8:	00 00 00 
    f0aa:	d2 cc 2c    	mov.w     #0xcccd, w2
    f0ac:	c3 34 24    	mov.w     #0x434c, w3
    f0ae:	26 17 02    	call      0x1726 <___divsf3>
    f0b0:	00 00 00 
    f0b2:	02 00 20    	mov.w     #0x0, w2
    f0b4:	03 68 24    	mov.w     #0x4680, w3
    f0b6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f0b8:	00 00 00 
    f0ba:	d2 a3 20    	mov.w     #0xa3d, w2
    f0bc:	d3 11 24    	mov.w     #0x411d, w3
    f0be:	26 17 02    	call      0x1726 <___divsf3>
    f0c0:	00 00 00 
    f0c2:	94 18 02    	call      0x1894 <___fixsfsi>
    f0c4:	00 00 00 
    f0c6:	40 85 88    	mov.w     w0, 0x10a8

0000f0c8 <.L0>:
    f0c8:	4f 05 be    	mov.d     [--w15], w10
    f0ca:	4f 04 be    	mov.d     [--w15], w8
    f0cc:	00 00 06    	return    

0000f0ce <_HILSIM_set_omegagyro>:
    f0ce:	88 9f be    	mov.d     w8, [w15++]
    f0d0:	8a 1f 78    	mov.w     w10, [w15++]
    f0d2:	68 2c 24    	mov.w     #0x42c6, w8
    f0d4:	20 1a 82    	mov.w     0x4344, w0
    f0d6:	00 0c 78    	mov.w     w0, [w8]
    f0d8:	88 84 e8    	inc2.w    w8, w9
    f0da:	30 1a 82    	mov.w     0x4346, w0
    f0dc:	80 0c 78    	mov.w     w0, [w9]
    f0de:	64 05 44    	add.w     w8, #0x4, w10
    f0e0:	40 1a 82    	mov.w     0x4348, w0
    f0e2:	00 0d 78    	mov.w     w0, [w10]

0000f0e4 <.L0>:
    f0e4:	88 00 78    	mov.w     w8, w1
    f0e6:	30 00 20    	mov.w     #0x3, w0
    f0e8:	90 ff 07    	rcall     0xf00a <_HILSIM_saturate> <L0> <.LFB1487> <.LFE1483>

0000f0ea <.L0>:
    f0ea:	18 00 ea    	neg.w     [w8], w0
    f0ec:	cf 80 de    	asr.w     w0, #0xf, w1
    f0ee:	0c 19 02    	call      0x190c <___floatsisf>
    f0f0:	00 00 00 
    f0f2:	f2 a8 2a    	mov.w     #0xaa8f, w2
    f0f4:	a3 4e 24    	mov.w     #0x44ea, w3
    f0f6:	26 17 02    	call      0x1726 <___divsf3>
    f0f8:	00 00 00 
    f0fa:	02 00 20    	mov.w     #0x0, w2
    f0fc:	33 28 24    	mov.w     #0x4283, w3
    f0fe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f100:	00 00 00 
    f102:	b2 fd 20    	mov.w     #0xfdb, w2
    f104:	93 04 24    	mov.w     #0x4049, w3
    f106:	26 17 02    	call      0x1726 <___divsf3>
    f108:	00 00 00 
    f10a:	02 00 20    	mov.w     #0x0, w2
    f10c:	43 33 24    	mov.w     #0x4334, w3
    f10e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f110:	00 00 00 
    f112:	94 18 02    	call      0x1894 <___fixsfsi>
    f114:	00 00 00 
    f116:	50 85 88    	mov.w     w0, 0x10aa

0000f118 <.L0>:
    f118:	19 00 ea    	neg.w     [w9], w0
    f11a:	cf 80 de    	asr.w     w0, #0xf, w1
    f11c:	0c 19 02    	call      0x190c <___floatsisf>
    f11e:	00 00 00 
    f120:	f2 a8 2a    	mov.w     #0xaa8f, w2
    f122:	a3 4e 24    	mov.w     #0x44ea, w3
    f124:	26 17 02    	call      0x1726 <___divsf3>
    f126:	00 00 00 
    f128:	02 00 20    	mov.w     #0x0, w2
    f12a:	33 28 24    	mov.w     #0x4283, w3
    f12c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f12e:	00 00 00 
    f130:	b2 fd 20    	mov.w     #0xfdb, w2
    f132:	93 04 24    	mov.w     #0x4049, w3
    f134:	26 17 02    	call      0x1726 <___divsf3>
    f136:	00 00 00 
    f138:	02 00 20    	mov.w     #0x0, w2
    f13a:	43 33 24    	mov.w     #0x4334, w3
    f13c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f13e:	00 00 00 
    f140:	94 18 02    	call      0x1894 <___fixsfsi>
    f142:	00 00 00 
    f144:	60 85 88    	mov.w     w0, 0x10ac

0000f146 <.L0>:
    f146:	1a 00 ea    	neg.w     [w10], w0
    f148:	cf 80 de    	asr.w     w0, #0xf, w1
    f14a:	0c 19 02    	call      0x190c <___floatsisf>
    f14c:	00 00 00 
    f14e:	f2 a8 2a    	mov.w     #0xaa8f, w2
    f150:	a3 4e 24    	mov.w     #0x44ea, w3
    f152:	26 17 02    	call      0x1726 <___divsf3>
    f154:	00 00 00 
    f156:	02 00 20    	mov.w     #0x0, w2
    f158:	33 28 24    	mov.w     #0x4283, w3
    f15a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f15c:	00 00 00 
    f15e:	b2 fd 20    	mov.w     #0xfdb, w2
    f160:	93 04 24    	mov.w     #0x4049, w3
    f162:	26 17 02    	call      0x1726 <___divsf3>
    f164:	00 00 00 
    f166:	02 00 20    	mov.w     #0x0, w2
    f168:	43 33 24    	mov.w     #0x4334, w3
    f16a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f16c:	00 00 00 
    f16e:	94 18 02    	call      0x1894 <___fixsfsi>
    f170:	00 00 00 
    f172:	70 85 88    	mov.w     w0, 0x10ae

0000f174 <.L0>:
    f174:	4f 05 78    	mov.w     [--w15], w10
    f176:	4f 04 be    	mov.d     [--w15], w8
    f178:	00 00 06    	return    

0000f17a <_init_gps_ubx>:
    f17a:	00 00 06    	return    

0000f17c <_gpsoutbin>:
    f17c:	00 01 eb    	clr.w     w2
    f17e:	d2 15 8a    	mov.w     w2, 0x42ba
    f180:	c0 15 8a    	mov.w     w0, 0x42b8
    f182:	b1 15 8a    	mov.w     w1, 0x42b6
    f184:	00 00 e0    	cp0.w     w0
    f186:	0a 00 34    	bra       LE, 0xf19c <.L77>
    f188:	80 01 eb    	clr.w     w3
    f18a:	55 63 22    	mov.w     #0x2635, w5

0000f18c <.L79>:
    f18c:	83 81 42    	add.w     w5, w3, w3
    f18e:	02 82 fb    	ze        w2, w4
    f190:	04 82 40    	add.w     w1, w4, w4
    f192:	94 49 78    	mov.b     [w4], [w3]
    f194:	02 41 e8    	inc.b     w2, w2
    f196:	82 81 fb    	ze        w2, w3
    f198:	83 0f 50    	sub.w     w0, w3, [w15]
    f19a:	f8 ff 3c    	bra       GT, 0xf18c <.L79>

0000f19c <.L77>:
    f19c:	00 00 06    	return    

0000f19e <_nmea_passthru>:
    f19e:	88 1f 78    	mov.w     w8, [w15++]
    f1a0:	00 44 78    	mov.b     w0, w8
    f1a2:	01 35 24    	mov.w     #0x4350, w1
    f1a4:	88 48 78    	mov.b     w8, [w1]

0000f1a6 <.L0>:
    f1a6:	10 00 20    	mov.w     #0x1, w0
    f1a8:	e9 ff 07    	rcall     0xf17c <_gpsoutbin> <L0> <.LFB1491> <.LFE1490>

0000f1aa <.L0>:
    f1aa:	90 1a 82    	mov.w     0x4352, w0
    f1ac:	00 00 e9    	dec.w     w0, w0
    f1ae:	90 1a 8a    	mov.w     w0, 0x4352
    f1b0:	ea 4f 54    	sub.b     w8, #0xa, [w15]
    f1b2:	03 00 3a    	bra       NZ, 0xf1ba <.L82>
    f1b4:	20 cb 2e    	mov.w     #0xecb2, w0
    f1b6:	70 20 8a    	mov.w     w0, 0x440e
    f1b8:	04 00 37    	bra       0xf1c2 <.L81>

0000f1ba <.L82>:
    f1ba:	00 00 e0    	cp0.w     w0
    f1bc:	02 00 3a    	bra       NZ, 0xf1c2 <.L81>
    f1be:	20 cb 2e    	mov.w     #0xecb2, w0
    f1c0:	70 20 8a    	mov.w     w0, 0x440e

0000f1c2 <.L81>:
    f1c2:	4f 04 78    	mov.w     [--w15], w8
    f1c4:	00 00 06    	return    

0000f1c6 <_gpsoutline>:
    f1c6:	88 1f 78    	mov.w     w8, [w15++]
    f1c8:	00 04 78    	mov.w     w0, w8

0000f1ca <.L0>:
    f1ca:	08 00 78    	mov.w     w8, w0
    f1cc:	f8 23 02    	call      0x23f8 <_strlen>
    f1ce:	00 00 00 
    f1d0:	88 00 78    	mov.w     w8, w1
    f1d2:	d4 ff 07    	rcall     0xf17c <_gpsoutbin> <L0> <.LFB1491> <.LFE1490>

0000f1d4 <.L0>:
    f1d4:	4f 04 78    	mov.w     [--w15], w8
    f1d6:	00 00 06    	return    

0000f1d8 <_udb_gps_callback_get_byte_to_send>:
    f1d8:	b0 15 82    	mov.w     0x42b6, w0
    f1da:	00 00 e0    	cp0.w     w0
    f1dc:	09 00 32    	bra       Z, 0xf1f0 <.L86>
    f1de:	d1 15 82    	mov.w     0x42ba, w1
    f1e0:	c2 15 82    	mov.w     0x42b8, w2
    f1e2:	82 8f 50    	sub.w     w1, w2, [w15]
    f1e4:	05 00 3d    	bra       GE, 0xf1f0 <.L86>
    f1e6:	01 00 40    	add.w     w0, w1, w0
    f1e8:	10 80 fb    	ze        [w0], w0
    f1ea:	81 00 e8    	inc.w     w1, w1
    f1ec:	d1 15 8a    	mov.w     w1, 0x42ba
    f1ee:	03 00 37    	bra       0xf1f6 <.L87>

0000f1f0 <.L86>:
    f1f0:	00 00 eb    	clr.w     w0
    f1f2:	b0 15 8a    	mov.w     w0, 0x42b6
    f1f4:	00 80 eb    	setm.w    w0

0000f1f6 <.L87>:
    f1f6:	00 00 06    	return    

0000f1f8 <_udb_gps_callback_received_byte>:
    f1f8:	71 20 82    	mov.w     0x440e, w1
    f1fa:	01 00 01    	call      w1
    f1fc:	00 00 06    	return    

0000f1fe <_gps_nav_capable_check_set>:
    f1fe:	a0 17 82    	mov.w     0x42f4, w0
    f200:	e8 0f 50    	sub.w     w0, #0x8, [w15]
    f202:	02 00 3c    	bra       GT, 0xf208 <.L90>
    f204:	00 00 e8    	inc.w     w0, w0
    f206:	a0 17 8a    	mov.w     w0, 0x42f4

0000f208 <.L90>:
    f208:	10 c0 b3    	mov.b     #0x1, w0
    f20a:	a1 17 82    	mov.w     0x42f4, w1
    f20c:	e8 8f 50    	sub.w     w1, #0x8, [w15]
    f20e:	01 00 34    	bra       LE, 0xf212 <.L91>
    f210:	00 40 eb    	clr.b     w0

0000f212 <.L91>:
    f212:	00 00 06    	return    

0000f214 <_send_HILSIM_outputs>:
#define CHANNEL_1               1
#define CHANNEL_2               2
#define CHANNEL_3               3
#define CHANNEL_4               4
#define CHANNEL_5               5
#define THROTTLE_OUTPUT_CHANNEL             CHANNEL_3
#define AILERON_OUTPUT_CHANNEL              CHANNEL_1
#define ELEVATOR_OUTPUT_CHANNEL             CHANNEL_2
#define RUDDER_OUTPUT_CHANNEL               CHANNEL_4
#define NUM_OUTPUTS                         4
#define HILSIM_NUM_SERVOS 8
#define MAX_OUTPUTS     8
uint8_t SIMservoOutputs[] = {
	0xFF, 0xEE, //sync
	0x03, 0x04, //S1
	0x05, 0x06, //S2
	0x07, 0x08, //S3
	0x09, 0x0A, //S4
	0x0B, 0x0C, //S5
	0x0D, 0x0E, //S6
	0x0F, 0x10, //S7
	0x11, 0x12, //S8
	0x13, 0x14  //checksum
};
uint16_t send_HILSIM_outputs(void)
{
    f214:	f2 87 47    	add.w     w15, #0x12, w15
    f216:	8e 1f 78    	mov.w     w14, [w15++]
	// Setup outputs for HILSIM
	int16_t i;
	uint8_t CK_A = 0;
	uint8_t CK_B = 0;
	union intbb TempBB;
    
    int16_t udb_pwOut[MAX_OUTPUTS]; // pulse widths for servo outputs

	udb_pwOut[AILERON_OUTPUT_CHANNEL] = mlPwmCommands.servo2_raw *10 ;//
    f218:	80 88 80    	mov.w     0x1110, w0
    f21a:	ea 00 b9    	.pword 0xb900ea
    f21c:	80 bf 9f    	mov.w     w0, [w15-16]
	udb_pwOut[THROTTLE_OUTPUT_CHANNEL] = mlPwmCommands.servo1_raw * 10;//
    f21e:	70 88 80    	mov.w     0x110e, w0
    f220:	ea 00 b9    	.pword 0xb900ea
    f222:	a0 bf 9f    	mov.w     w0, [w15-12]
	udb_pwOut[RUDDER_OUTPUT_CHANNEL] = mlPwmCommands.servo3_raw * 10;//
    f224:	90 88 80    	mov.w     0x1112, w0
    f226:	ea 00 b9    	.pword 0xb900ea
    f228:	b0 bf 9f    	mov.w     w0, [w15-10]
	udb_pwOut[ELEVATOR_OUTPUT_CHANNEL] = mlPwmCommands.servo4_raw * 10 ;//
    f22a:	a0 88 80    	mov.w     0x1114, w0
    f22c:	ea 00 b9    	.pword 0xb900ea
    f22e:	90 bf 9f    	mov.w     w0, [w15-14]
    f230:	72 87 57    	sub.w     w15, #0x12, w14
    f232:	30 41 24    	mov.w     #0x4413, w0
    f234:	ea 81 57    	sub.w     w15, #0xa, w3

0000f236 <.L93>:
	for (i = 1; i <= NUM_OUTPUTS; i++)
	{
		
		TempBB.BB = udb_pwOut[i];
    f236:	de 00 78    	mov.w     [++w14], w1
		SIMservoOutputs[2 * i] = TempBB._.B1;
    f238:	48 09 de    	lsr.w     w1, #0x8, w2
    f23a:	02 48 78    	mov.b     w2, [w0]
		SIMservoOutputs[(2 * i) + 1] = TempBB._.B0;
    f23c:	11 40 98    	mov.b     w1, [w0+1]
    f23e:	00 80 e8    	inc2.w    w0, w0
    f240:	83 0f 57    	sub.w     w14, w3, [w15]
    f242:	f9 ff 3a    	bra       NZ, 0xf236 <.L93>
    f244:	21 41 24    	mov.w     #0x4412, w1
    f246:	f0 81 40    	add.w     w1, #0x10, w3
    f248:	00 41 eb    	clr.b     w2
    f24a:	02 40 78    	mov.b     w2, w0

0000f24c <.L94>:
	}

	for (i = 2; i < HILSIM_NUM_SERVOS * 2 + 2; i++)
	{
		CK_A += SIMservoOutputs[i];
    f24c:	51 40 40    	add.b     w0, [++w1], w0
		CK_B += CK_A;
    f24e:	00 41 41    	add.b     w2, w0, w2
    f250:	83 8f 50    	sub.w     w1, w3, [w15]
    f252:	fc ff 3a    	bra       NZ, 0xf24c <.L94>
	}
	SIMservoOutputs[i] = CK_A;
    f254:	31 42 24    	mov.w     #0x4423, w1
    f256:	80 48 78    	mov.b     w0, [w1]
	SIMservoOutputs[i + 1] = CK_B;
    f258:	01 00 e8    	inc.w     w1, w0
    f25a:	02 48 78    	mov.b     w2, [w0]

0000f25c <.L0>:

	// Send HILSIM outputs
	gpsoutbin(HILSIM_NUM_SERVOS * 2 + 4, SIMservoOutputs);
    f25c:	f2 80 50    	sub.w     w1, #0x12, w1
    f25e:	40 01 20    	mov.w     #0x14, w0
    f260:	8d ff 07    	rcall     0xf17c <_gpsoutbin> <L0> <.LFB1491> <.LFE1490>

0000f262 <.L0>:

    return HILSIM_NUM_SERVOS * 2 + 4;
}    f262:	40 01 20    	mov.w     #0x14, w0
    f264:	4f 07 78    	mov.w     [--w15], w14
    f266:	2f 01 b1    	sub.w     #0x12, w15
    f268:	00 00 06    	return    

0000f26a <_getMidLevelCommands>:
    f26a:	72 89 80    	mov.w     0x112e, w2
    f26c:	83 89 80    	mov.w     0x1130, w3
    f26e:	02 88 be    	mov.d     w2, [w0]
    f270:	52 89 80    	mov.w     0x112a, w2
 */

void getMidLevelCommands(float* commands) {
    commands[0] = mlMidLevelCommands.uCommand;
    commands[1] = mlMidLevelCommands.hCommand;
    f272:	63 89 80    	mov.w     0x112c, w3
    f274:	22 00 98    	mov.w     w2, [w0+4]
    f276:	33 00 98    	mov.w     w3, [w0+6]
    commands[2] = mlMidLevelCommands.rCommand;
    f278:	92 89 80    	mov.w     0x1132, w2
    f27a:	a3 89 80    	mov.w     0x1134, w3
    f27c:	42 00 98    	mov.w     w2, [w0+8]
    f27e:	53 00 98    	mov.w     w3, [w0+10]
}
    f280:	00 00 06    	return    

0000f282 <_isApManual>:

unsigned char isApManual(uint16_t failsafe) {
    // Disable and toggle manual/guided mode depending on failsafe
    if (failsafe < (uint16_t)600U) {
    f282:	71 25 20    	mov.w     #0x257, w1
    f284:	81 0f 50    	sub.w     w0, w1, [w15]
    f286:	06 00 3e    	bra       GTU, 0xf294 <.L3>
        mlHeartbeatLocal.base_mode &= ~MAV_MODE_FLAG_AUTO_ENABLED;
        mlHeartbeatLocal.base_mode |= MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
    f288:	60 12 21    	mov.w     #0x1126, w0
    f28a:	90 40 78    	mov.b     [w0], w1
    f28c:	01 24 a1    	bclr.b    w1, #0x2
    f28e:	01 64 a0    	bset.b    w1, #0x6
    f290:	01 48 78    	mov.b     w1, [w0]
    f292:	05 00 37    	bra       0xf29e <.L0> <.L4>

0000f294 <.L3>:
    }
    else {
        mlHeartbeatLocal.base_mode &= ~MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
        mlHeartbeatLocal.base_mode |= MAV_MODE_FLAG_AUTO_ENABLED;
    f294:	60 12 21    	mov.w     #0x1126, w0
    f296:	90 40 78    	mov.b     [w0], w1
    f298:	01 64 a1    	bclr.b    w1, #0x6
    f29a:	01 24 a0    	bset.b    w1, #0x2
    f29c:	01 48 78    	mov.b     w1, [w0]

0000f29e <.L0>:
    }

    return hasMode(mlHeartbeatLocal.base_mode, MAV_MODE_FLAG_MANUAL_INPUT_ENABLED);
    f29e:	01 c4 b3    	mov.b     #0x40, w1
    f2a0:	60 12 21    	mov.w     #0x1126, w0
    f2a2:	10 40 78    	mov.b     [w0], w0
    f2a4:	6e 10 02    	call      0x1106e <_hasMode>
    f2a6:	01 00 00 

0000f2a8 <.L0>:
}
    f2a8:	00 00 06    	return    

0000f2aa <_getParamIdx>:

float getParamIdx(unsigned char idx) {

    return mlParamInterface.param[idx];
    f2aa:	00 80 fb    	ze        w0, w0
    f2ac:	42 00 dd    	sl.w      w0, #0x2, w0
    f2ae:	a1 25 21    	mov.w     #0x125a, w1
    f2b0:	00 80 40    	add.w     w1, w0, w0
    f2b2:	10 00 be    	mov.d     [w0], w0
}
    f2b4:	00 00 06    	return    

0000f2b6 <_getRangeOfParams>:

void getRangeOfParams(uint8_t startIdx, uint8_t endIdx, float* parameters) {
    uint8_t i;

    for (i = startIdx; i <= endIdx; i++) {
    f2b6:	81 4f 50    	sub.b     w0, w1, [w15]
    f2b8:	0e 00 3e    	bra       GTU, 0xf2d6 <.L6>
    f2ba:	80 41 78    	mov.b     w0, w3
        parameters[i - startIdx] = mlParamInterface.param[i];
    f2bc:	00 80 fb    	ze        w0, w0
    f2be:	a6 25 21    	mov.w     #0x125a, w6

0000f2c0 <.L8>:
    f2c0:	03 82 fb    	ze        w3, w4
    f2c2:	80 02 52    	sub.w     w4, w0, w5
    f2c4:	c2 2a dd    	sl.w      w5, #0x2, w5
    f2c6:	85 02 41    	add.w     w2, w5, w5
    f2c8:	42 22 dd    	sl.w      w4, #0x2, w4
    f2ca:	04 02 43    	add.w     w6, w4, w4
    f2cc:	b4 1a 78    	mov.w     [w4++], [w5++]
    f2ce:	a4 12 78    	mov.w     [w4--], [w5--]
    f2d0:	83 41 e8    	inc.b     w3, w3
    f2d2:	83 cf 50    	sub.b     w1, w3, [w15]
    f2d4:	f5 ff 31    	bra       C, 0xf2c0 <.L8>

0000f2d6 <.L6>:
    }
}
    f2d6:	00 00 06    	return    

0000f2d8 <_getDynamic>:

float getDynamic(void) {
    // hectopascals to pascals
    return mlAirData.press_diff;
}
    f2d8:	00 84 80    	mov.w     0x1080, w0
    f2da:	11 84 80    	mov.w     0x1082, w1
    f2dc:	00 00 06    	return    

0000f2de <_getAttitude>:

void getAttitude(float* attitude) {

    // Return the values to the control algorithm
    attitude[0] = mlAttitudeData.roll;
    f2de:	52 86 80    	mov.w     0x10ca, w2
    f2e0:	63 86 80    	mov.w     0x10cc, w3
    f2e2:	02 88 be    	mov.d     w2, [w0]
    attitude[1] = mlAttitudeData.pitch;
    f2e4:	72 86 80    	mov.w     0x10ce, w2
    f2e6:	83 86 80    	mov.w     0x10d0, w3
    f2e8:	22 00 98    	mov.w     w2, [w0+4]
    f2ea:	33 00 98    	mov.w     w3, [w0+6]
    attitude[2] = mlAttitudeData.yaw;
    f2ec:	92 86 80    	mov.w     0x10d2, w2
    f2ee:	a3 86 80    	mov.w     0x10d4, w3
    f2f0:	42 00 98    	mov.w     w2, [w0+8]
    f2f2:	53 00 98    	mov.w     w3, [w0+10]
    attitude[3] = mlAttitudeData.rollspeed;
    f2f4:	b2 86 80    	mov.w     0x10d6, w2
    f2f6:	c3 86 80    	mov.w     0x10d8, w3
    f2f8:	62 00 98    	mov.w     w2, [w0+12]
    f2fa:	73 00 98    	mov.w     w3, [w0+14]
    attitude[4] = mlAttitudeData.pitchspeed;
    f2fc:	d2 86 80    	mov.w     0x10da, w2
    f2fe:	e3 86 80    	mov.w     0x10dc, w3
    f300:	02 08 98    	mov.w     w2, [w0+16]
    f302:	13 08 98    	mov.w     w3, [w0+18]
    attitude[5] = mlAttitudeData.yawspeed;
    f304:	f2 86 80    	mov.w     0x10de, w2
    f306:	03 87 80    	mov.w     0x10e0, w3
    f308:	22 08 98    	mov.w     w2, [w0+20]
    f30a:	33 08 98    	mov.w     w3, [w0+22]

}
    f30c:	00 00 06    	return    

0000f30e <_getXYZ>:

void getXYZ(float* xyz) {
    xyz[0] = mlLocalPositionData.x;
    f30e:	32 87 80    	mov.w     0x10e6, w2
    f310:	43 87 80    	mov.w     0x10e8, w3
    f312:	02 88 be    	mov.d     w2, [w0]
    xyz[1] = mlLocalPositionData.y;
    f314:	52 87 80    	mov.w     0x10ea, w2
    f316:	63 87 80    	mov.w     0x10ec, w3
    f318:	22 00 98    	mov.w     w2, [w0+4]
    f31a:	33 00 98    	mov.w     w3, [w0+6]
    xyz[2] = mlLocalPositionData.z;
    f31c:	72 87 80    	mov.w     0x10ee, w2
    f31e:	83 87 80    	mov.w     0x10f0, w3
    f320:	42 00 98    	mov.w     w2, [w0+8]
    f322:	53 00 98    	mov.w     w3, [w0+10]
}
    f324:	00 00 06    	return    

0000f326 <_getVned>:

void getVned(float* xyz) {
    xyz[0] = mlLocalPositionData.vx;
    f326:	92 87 80    	mov.w     0x10f2, w2
    f328:	a3 87 80    	mov.w     0x10f4, w3
    f32a:	02 88 be    	mov.d     w2, [w0]
    xyz[1] = mlLocalPositionData.vy;
    f32c:	b2 87 80    	mov.w     0x10f6, w2
    f32e:	c3 87 80    	mov.w     0x10f8, w3
    f330:	22 00 98    	mov.w     w2, [w0+4]
    f332:	33 00 98    	mov.w     w3, [w0+6]
    xyz[2] = mlLocalPositionData.vz;
    f334:	d2 87 80    	mov.w     0x10fa, w2
    f336:	e3 87 80    	mov.w     0x10fc, w3
    f338:	42 00 98    	mov.w     w2, [w0+8]
    f33a:	53 00 98    	mov.w     w3, [w0+10]
}
    f33c:	00 00 06    	return    

0000f33e <_getMaxWp>:

uint8_t getMaxWp(void) {
    return mlWpValues.wpCount;
    f33e:	80 23 21    	mov.w     #0x1238, w0
    f340:	10 40 78    	mov.b     [w0], w0
}
    f342:	00 00 06    	return    

0000f344 <_isWpFly>:

unsigned char isWpFly(void) {
    return ((mlHeartbeatLocal.custom_mode == SLUGS_MODE_WAYPOINT)
    f344:	02 89 80    	mov.w     0x1120, w2
    f346:	13 89 80    	mov.w     0x1122, w3
    f348:	10 00 20    	mov.w     #0x1, w0
    f34a:	e3 0f 51    	sub.w     w2, #0x3, [w15]
    f34c:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    f34e:	0a 00 32    	bra       Z, 0xf364 <.L16>
            || (mlHeartbeatLocal.custom_mode == SLUGS_MODE_ISR)
    f350:	e9 0f 51    	sub.w     w2, #0x9, [w15]
    f352:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    f354:	07 00 32    	bra       Z, 0xf364 <.L16>
    f356:	6a 01 69    	xor.w     w2, #0xa, w2
    f358:	02 81 71    	ior.w     w3, w2, w2
    f35a:	02 00 78    	mov.w     w2, w0
    f35c:	00 f0 a7    	btsc.w    w0, #0xf
    f35e:	00 00 ea    	neg.w     w0, w0
    f360:	00 00 e9    	dec.w     w0, w0
    f362:	4f 00 de    	lsr.w     w0, #0xf, w0

0000f364 <.L16>:
            || (mlHeartbeatLocal.custom_mode == SLUGS_MODE_LINE_PATROL));
    /*
    return ((mlSystemStatus.nav_mode == MAV_NAV_WAYPOINT) ||
                (mlSystemStatus.nav_mode == MAV_NAV_ISR) ||
                (mlSystemStatus.nav_mode == MAV_NAV_LINE_PATROL)
              );
     * */
}
    f364:	00 00 06    	return    

0000f366 <_isPassthrough>:

unsigned char isPassthrough(void) {
    return ((mlHeartbeatLocal.custom_mode == SLUGS_MODE_PASSTHROUGH)
    f366:	02 89 80    	mov.w     0x1120, w2
    f368:	13 89 80    	mov.w     0x1122, w3
    f36a:	10 00 20    	mov.w     #0x1, w0
    f36c:	e2 0f 51    	sub.w     w2, #0x2, [w15]
    f36e:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    f370:	0a 00 32    	bra       Z, 0xf386 <.L20>
            || (mlHeartbeatLocal.custom_mode == SLUGS_MODE_SELECTIVE_PASSTHROUGH)
    f372:	e8 0f 51    	sub.w     w2, #0x8, [w15]
    f374:	e0 8f 59    	subb.w    w3, #0x0, [w15]
    f376:	07 00 32    	bra       Z, 0xf386 <.L20>
    f378:	02 20 a2    	btg.w     w2, #0x2
    f37a:	02 81 71    	ior.w     w3, w2, w2
    f37c:	02 00 78    	mov.w     w2, w0
    f37e:	00 f0 a7    	btsc.w    w0, #0xf
    f380:	00 00 ea    	neg.w     w0, w0
    f382:	00 00 e9    	dec.w     w0, w0
    f384:	4f 00 de    	lsr.w     w0, #0xf, w0

0000f386 <.L20>:
            || (mlHeartbeatLocal.custom_mode == SLUGS_MODE_MID_LEVEL));
    /*
    return ( (mlSystemStatus.nav_mode == MAV_NAV_PASSTHROUGH) || 
                 (mlSystemStatus.nav_mode == MAV_NAV_SEL_PT) || 
                 (mlSystemStatus.nav_mode == MAV_NAV_MID_LEVEL));
     * */
}
    f386:	00 00 06    	return    

0000f388 <_setDiagnosticFloat>:

void setDiagnosticFloat(float * flValues) {
    mlDiagnosticData.diagFl1 = flValues[0];
    f388:	10 01 be    	mov.d     [w0], w2
    f38a:	c2 0b 8a    	mov.w     w2, 0x4178
    f38c:	d3 0b 8a    	mov.w     w3, 0x417a
    mlDiagnosticData.diagFl2 = flValues[1];
    f38e:	20 01 90    	mov.w     [w0+4], w2
    f390:	b0 01 90    	mov.w     [w0+6], w3
    f392:	e2 0b 8a    	mov.w     w2, 0x417c
    f394:	f3 0b 8a    	mov.w     w3, 0x417e
    mlDiagnosticData.diagFl3 = flValues[2];
    f396:	40 01 90    	mov.w     [w0+8], w2
    f398:	d0 01 90    	mov.w     [w0+10], w3
    f39a:	02 0c 8a    	mov.w     w2, 0x4180
    f39c:	13 0c 8a    	mov.w     w3, 0x4182
}
    f39e:	00 00 06    	return    

0000f3a0 <_setDiagnosticShort>:

void setDiagnosticShort(int16_t* shValues) {
    mlDiagnosticData.diagSh1 = shValues[0];
    f3a0:	90 00 78    	mov.w     [w0], w1
    f3a2:	21 0c 8a    	mov.w     w1, 0x4184
    mlDiagnosticData.diagSh2 = shValues[1];
    f3a4:	90 00 90    	mov.w     [w0+2], w1
    f3a6:	31 0c 8a    	mov.w     w1, 0x4186
    mlDiagnosticData.diagSh3 = shValues[2];
    f3a8:	20 00 90    	mov.w     [w0+4], w0
    f3aa:	40 0c 8a    	mov.w     w0, 0x4188
}
    f3ac:	00 00 06    	return    

0000f3ae <_getWP>:

void getWP(unsigned char idx, float* WPpos) {
    WPpos[0] = mlWpValues.lat[idx - 1];
    f3ae:	00 80 fb    	ze        w0, w0
    f3b0:	80 01 e9    	dec.w     w0, w3
    f3b2:	c2 19 dd    	sl.w      w3, #0x2, w3
    f3b4:	82 13 21    	mov.w     #0x1138, w2
    f3b6:	83 01 41    	add.w     w2, w3, w3
    f3b8:	b3 18 78    	mov.w     [w3++], [w1++]
    f3ba:	a3 10 78    	mov.w     [w3--], [w1--]
    WPpos[1] = mlWpValues.lon[idx - 1];
    f3bc:	f0 01 40    	add.w     w0, #0x10, w3
    f3be:	c2 19 dd    	sl.w      w3, #0x2, w3
    f3c0:	83 01 41    	add.w     w2, w3, w3
    f3c2:	13 02 be    	mov.d     [w3], w4
    f3c4:	a4 00 98    	mov.w     w4, [w1+4]
    f3c6:	b5 00 98    	mov.w     w5, [w1+6]
    WPpos[2] = mlWpValues.alt[idx - 1];
    f3c8:	10 02 b0    	add.w     #0x21, w0
    f3ca:	42 00 dd    	sl.w      w0, #0x2, w0
    f3cc:	00 01 41    	add.w     w2, w0, w2
    f3ce:	12 02 be    	mov.d     [w2], w4
    f3d0:	c4 00 98    	mov.w     w4, [w1+8]
    f3d2:	d5 00 98    	mov.w     w5, [w1+10]
}
    f3d4:	00 00 06    	return    

0000f3d6 <_setLogFloat1>:

void setLogFloat1(float * flValues) {
    mlDataLog.fl_1 = flValues[0];
    f3d6:	10 01 be    	mov.d     [w0], w2
    f3d8:	72 10 8a    	mov.w     w2, 0x420e
    f3da:	83 10 8a    	mov.w     w3, 0x4210
    mlDataLog.fl_2 = flValues[1];
    f3dc:	20 01 90    	mov.w     [w0+4], w2
    f3de:	b0 01 90    	mov.w     [w0+6], w3
    f3e0:	92 10 8a    	mov.w     w2, 0x4212
    f3e2:	a3 10 8a    	mov.w     w3, 0x4214
    mlDataLog.fl_3 = flValues[2];
    f3e4:	40 01 90    	mov.w     [w0+8], w2
    f3e6:	d0 01 90    	mov.w     [w0+10], w3
    f3e8:	b2 10 8a    	mov.w     w2, 0x4216
    f3ea:	c3 10 8a    	mov.w     w3, 0x4218
}
    f3ec:	00 00 06    	return    

0000f3ee <_setLogFloat2>:

void setLogFloat2(float * flValues) {
    mlDataLog.fl_4 = flValues[0];
    f3ee:	10 01 be    	mov.d     [w0], w2
    f3f0:	d2 10 8a    	mov.w     w2, 0x421a
    f3f2:	e3 10 8a    	mov.w     w3, 0x421c
    mlDataLog.fl_5 = flValues[1];
    f3f4:	20 01 90    	mov.w     [w0+4], w2
    f3f6:	b0 01 90    	mov.w     [w0+6], w3
    f3f8:	f2 10 8a    	mov.w     w2, 0x421e
    f3fa:	03 11 8a    	mov.w     w3, 0x4220
    mlDataLog.fl_6 = flValues[2];
    f3fc:	40 01 90    	mov.w     [w0+8], w2
    f3fe:	d0 01 90    	mov.w     [w0+10], w3
    f400:	12 11 8a    	mov.w     w2, 0x4222
    f402:	23 11 8a    	mov.w     w3, 0x4224
}
    f404:	00 00 06    	return    

0000f406 <_getApControlType>:

unsigned char getApControlType(void) {
    return mlHeartbeatLocal.custom_mode;
    f406:	00 89 80    	mov.w     0x1120, w0
}
    f408:	00 00 06    	return    

0000f40a <_getPassValues>:

unsigned char getPassValues(uint8_t* pasVals) {
    pasVals[0] = (uint8_t) (mlPassthrough.bitfieldPt & 128);
    f40a:	61 22 24    	mov.w     #0x4226, w1
    f40c:	02 c8 b3    	mov.b     #0x80, w2
    f40e:	11 48 61    	and.b     w2, [w1], [w0]
    pasVals[1] = (uint8_t) (mlPassthrough.bitfieldPt & 64);
    f410:	03 c4 b3    	mov.b     #0x40, w3
    f412:	11 c1 61    	and.b     w3, [w1], w2
    f414:	12 40 98    	mov.b     w2, [w0+1]
    pasVals[2] = (uint8_t) (mlPassthrough.bitfieldPt & 16);
    f416:	91 41 78    	mov.b     [w1], w3
    f418:	70 c1 61    	and.b     w3, #0x10, w2
    f41a:	22 40 98    	mov.b     w2, [w0+2]
    pasVals[3] = (uint8_t) (mlPassthrough.bitfieldPt & 8);
    f41c:	91 40 78    	mov.b     [w1], w1
    f41e:	e8 c0 60    	and.b     w1, #0x8, w1
    f420:	31 40 98    	mov.b     w1, [w0+3]
    return 1;
}
    f422:	10 c0 b3    	mov.b     #0x1, w0
    f424:	00 00 06    	return    

0000f426 <_setCurrentCommands>:

void setCurrentCommands(float airSpeed) {
    mlMidLevelCommands.uCommand = airSpeed;
    f426:	70 89 88    	mov.w     w0, 0x112e
    f428:	81 89 88    	mov.w     w1, 0x1130
    mlMidLevelCommands.hCommand = mlLocalPositionData.z;
    f42a:	70 87 80    	mov.w     0x10ee, w0
    f42c:	81 87 80    	mov.w     0x10f0, w1
    f42e:	50 89 88    	mov.w     w0, 0x112a
    f430:	61 89 88    	mov.w     w1, 0x112c
    mlMidLevelCommands.rCommand = 0.0;
    f432:	60 00 b8    	mul.uu    w0, #0x0, w0
    f434:	90 89 88    	mov.w     w0, 0x1132
    f436:	a1 89 88    	mov.w     w1, 0x1134

}
    f438:	00 00 06    	return    

0000f43a <_getCurrentGPSPos>:

// NOTE should this be double buffered or converted each time? (dagoodma)
void getCurrentGPSPos(float* latLonAlt) {
    f43a:	88 1f 78    	mov.w     w8, [w15++]
    f43c:	00 04 78    	mov.w     w0, w8

0000f43e <.L0>:
    latLonAlt[0] = INT32_1E7_TO_FLOAT(mlGpsData.lat);
    f43e:	10 83 80    	mov.w     0x1062, w0
    f440:	21 83 80    	mov.w     0x1064, w1
    f442:	0c 19 02    	call      0x190c <___floatsisf>
    f444:	00 00 00 
    f446:	52 f9 2b    	mov.w     #0xbf95, w2
    f448:	63 3d 23    	mov.w     #0x33d6, w3
    f44a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f44c:	00 00 00 
    f44e:	00 8c be    	mov.d     w0, [w8]

0000f450 <.L0>:
    latLonAlt[1] = INT32_1E7_TO_FLOAT(mlGpsData.lon);
    f450:	30 83 80    	mov.w     0x1066, w0
    f452:	41 83 80    	mov.w     0x1068, w1
    f454:	0c 19 02    	call      0x190c <___floatsisf>
    f456:	00 00 00 
    f458:	52 f9 2b    	mov.w     #0xbf95, w2
    f45a:	63 3d 23    	mov.w     #0x33d6, w3
    f45c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f45e:	00 00 00 
    f460:	20 04 98    	mov.w     w0, [w8+4]
    f462:	31 04 98    	mov.w     w1, [w8+6]

0000f464 <.L0>:
    latLonAlt[2] = INT32_1E3_TO_FLOAT(mlGpsData.alt);
    f464:	50 83 80    	mov.w     0x106a, w0
    f466:	61 83 80    	mov.w     0x106c, w1
    f468:	0c 19 02    	call      0x190c <___floatsisf>
    f46a:	00 00 00 
    f46c:	f2 26 21    	mov.w     #0x126f, w2
    f46e:	33 a8 23    	mov.w     #0x3a83, w3
    f470:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f472:	00 00 00 
    f474:	40 04 98    	mov.w     w0, [w8+8]
    f476:	51 04 98    	mov.w     w1, [w8+10]

0000f478 <.L0>:
}
    f478:	4f 04 78    	mov.w     [--w15], w8
    f47a:	00 00 06    	return    

0000f47c <_setNavLong>:

void setNavLong(float* values) {
    mlNavigation.u_m = values[0];
    f47c:	10 01 be    	mov.d     [w0], w2
    f47e:	d2 91 88    	mov.w     w2, 0x123a
    f480:	e3 91 88    	mov.w     w3, 0x123c
    mlNavigation.theta_c = values[1];
    f482:	20 01 90    	mov.w     [w0+4], w2
    f484:	b0 01 90    	mov.w     [w0+6], w3
    f486:	12 92 88    	mov.w     w2, 0x1242
    f488:	23 92 88    	mov.w     w3, 0x1244

0000f48a <.L0>:
    mlNavigation.h_c = (uint16_t)( floorf(values[2]*10.0));
    f48a:	02 00 20    	mov.w     #0x0, w2
    f48c:	03 12 24    	mov.w     #0x4120, w3
    f48e:	d0 00 90    	mov.w     [w0+10], w1
    f490:	40 00 90    	mov.w     [w0+8], w0
    f492:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f494:	00 00 00 
    f496:	16 19 02    	call      0x1916 <_floorf>
    f498:	00 00 00 
    f49a:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f49c:	00 00 00 
    f49e:	b0 92 88    	mov.w     w0, 0x1256

0000f4a0 <.L0>:
}
    f4a0:	00 00 06    	return    

0000f4a2 <_setNavLat>:

void setNavLat(float* values) {
    mlNavigation.psiDot_c = values[0];
    f4a2:	10 01 be    	mov.d     [w0], w2
    f4a4:	32 92 88    	mov.w     w2, 0x1246
    f4a6:	43 92 88    	mov.w     w3, 0x1248
    mlNavigation.phi_c = values[1];
    f4a8:	20 01 90    	mov.w     [w0+4], w2
    f4aa:	b0 01 90    	mov.w     [w0+6], w3
    f4ac:	f2 91 88    	mov.w     w2, 0x123e
    f4ae:	03 92 88    	mov.w     w3, 0x1240
    mlNavigation.ay_body = values[2];
    f4b0:	40 01 90    	mov.w     [w0+8], w2
    f4b2:	d0 01 90    	mov.w     [w0+10], w3
    f4b4:	52 92 88    	mov.w     w2, 0x124a
    f4b6:	63 92 88    	mov.w     w3, 0x124c
}
    f4b8:	00 00 06    	return    

0000f4ba <_setNavNav>:

void setNavNav(float* values) {
    f4ba:	88 1f 78    	mov.w     w8, [w15++]
    f4bc:	00 04 78    	mov.w     w0, w8
    mlNavigation.totalDist = values[0];
    f4be:	18 00 be    	mov.d     [w8], w0
    f4c0:	70 92 88    	mov.w     w0, 0x124e
    f4c2:	81 92 88    	mov.w     w1, 0x1250
    mlNavigation.dist2Go = values[1];
    f4c4:	28 00 90    	mov.w     [w8+4], w0
    f4c6:	b8 00 90    	mov.w     [w8+6], w1
    f4c8:	90 92 88    	mov.w     w0, 0x1252
    f4ca:	a1 92 88    	mov.w     w1, 0x1254

0000f4cc <.L0>:
    mlNavigation.fromWP = (uint8_t) values[2];
    f4cc:	48 00 90    	mov.w     [w8+8], w0
    f4ce:	d8 00 90    	mov.w     [w8+10], w1
    f4d0:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f4d2:	00 00 00 
    f4d4:	00 01 be    	mov.d     w0, w2
    f4d6:	81 25 21    	mov.w     #0x1258, w1
    f4d8:	82 48 78    	mov.b     w2, [w1]

0000f4da <.L0>:

    if (mlNavigation.toWP != (uint8_t)values[3]) mlPending.wpSendCurrent = TRUE;
    f4da:	6c 04 44    	add.w     w8, #0xc, w8
    f4dc:	18 00 be    	mov.d     [w8], w0
    f4de:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f4e0:	00 00 00 
    f4e2:	92 25 21    	mov.w     #0x1259, w2
    f4e4:	92 4f 10    	subr.b    w0, [w2], [w15]
    f4e6:	03 00 32    	bra       Z, 0xf4ee <.L0> <.L0> <.L35>
    f4e8:	11 c0 b3    	mov.b     #0x1, w1
    f4ea:	30 4a 22    	mov.w     #0x24a3, w0
    f4ec:	01 48 78    	mov.b     w1, [w0]

0000f4ee <.L0>:
    mlNavigation.toWP = (uint8_t) values[3];
    f4ee:	18 00 be    	mov.d     [w8], w0
    f4f0:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f4f2:	00 00 00 
    f4f4:	00 01 be    	mov.d     w0, w2
    f4f6:	91 25 21    	mov.w     #0x1259, w1
    f4f8:	82 48 78    	mov.b     w2, [w1]

0000f4fa <.L0>:
}
    f4fa:	4f 04 78    	mov.w     [--w15], w8
    f4fc:	00 00 06    	return    

0000f4fe <_getAccels>:

void getAccels(float * accels) {
    f4fe:	88 1f 78    	mov.w     w8, [w15++]
    f500:	00 04 78    	mov.w     w0, w8

0000f502 <.L0>:
    accels[0] = (float) (mlFilteredData.xacc * MG_TO_MPS);
    f502:	70 0c 82    	mov.w     0x418e, w0
    f504:	cf 80 de    	asr.w     w0, #0xf, w1
    f506:	0c 19 02    	call      0x190c <___floatsisf>
    f508:	00 00 00 
    f50a:	82 f1 2c    	mov.w     #0xcf18, w2
    f50c:	03 c2 23    	mov.w     #0x3c20, w3
    f50e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f510:	00 00 00 
    f512:	00 8c be    	mov.d     w0, [w8]

0000f514 <.L0>:
    accels[1] = (float) (mlFilteredData.yacc * MG_TO_MPS);
    f514:	80 0c 82    	mov.w     0x4190, w0
    f516:	cf 80 de    	asr.w     w0, #0xf, w1
    f518:	0c 19 02    	call      0x190c <___floatsisf>
    f51a:	00 00 00 
    f51c:	82 f1 2c    	mov.w     #0xcf18, w2
    f51e:	03 c2 23    	mov.w     #0x3c20, w3
    f520:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f522:	00 00 00 
    f524:	20 04 98    	mov.w     w0, [w8+4]
    f526:	31 04 98    	mov.w     w1, [w8+6]

0000f528 <.L0>:
    accels[2] = (float) (mlFilteredData.zacc * MG_TO_MPS);
    f528:	90 0c 82    	mov.w     0x4192, w0
    f52a:	cf 80 de    	asr.w     w0, #0xf, w1
    f52c:	0c 19 02    	call      0x190c <___floatsisf>
    f52e:	00 00 00 
    f530:	82 f1 2c    	mov.w     #0xcf18, w2
    f532:	03 c2 23    	mov.w     #0x3c20, w3
    f534:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f536:	00 00 00 
    f538:	40 04 98    	mov.w     w0, [w8+8]
    f53a:	51 04 98    	mov.w     w1, [w8+10]

0000f53c <.L0>:
}
    f53c:	4f 04 78    	mov.w     [--w15], w8
    f53e:	00 00 06    	return    

0000f540 <_getAccBias>:

void getAccBias(float * bias) {
    bias[0] = mlSensorBiasData.axBias;
    f540:	02 0b 82    	mov.w     0x4160, w2
    f542:	13 0b 82    	mov.w     0x4162, w3
    f544:	02 88 be    	mov.d     w2, [w0]
    bias[1] = mlSensorBiasData.ayBias;
    f546:	22 0b 82    	mov.w     0x4164, w2
    f548:	33 0b 82    	mov.w     0x4166, w3
    f54a:	22 00 98    	mov.w     w2, [w0+4]
    f54c:	33 00 98    	mov.w     w3, [w0+6]
    bias[2] = mlSensorBiasData.azBias;
    f54e:	42 0b 82    	mov.w     0x4168, w2
    f550:	53 0b 82    	mov.w     0x416a, w3
    f552:	42 00 98    	mov.w     w2, [w0+8]
    f554:	53 00 98    	mov.w     w3, [w0+10]
}
    f556:	00 00 06    	return    

0000f558 <_getRTB>:

void getRTB(uint8_t* rtb) {
    f558:	88 1f 78    	mov.w     w8, [w15++]
    f55a:	00 04 78    	mov.w     w0, w8
    rtb[0] = (mlRTB.rtb || (mlPending.heartbeatAge > HEARTBEAT_LIMIT));
    f55c:	10 00 20    	mov.w     #0x1, w0
    f55e:	c1 29 24    	mov.w     #0x429c, w1
    f560:	11 04 e0    	cp0.b     [w1]
    f562:	05 00 3a    	bra       NZ, 0xf56e <.L39>
    f564:	02 29 81    	mov.w     0x2520, w2
    f566:	01 77 21    	mov.w     #0x1770, w1
    f568:	81 0f 51    	sub.w     w2, w1, [w15]
    f56a:	01 00 3e    	bra       GTU, 0xf56e <.L39>
    f56c:	00 00 eb    	clr.w     w0

0000f56e <.L39>:
    f56e:	00 4c 78    	mov.b     w0, [w8]
    rtb[1] = mlRTB.track_mobile; 
    f570:	d0 29 24    	mov.w     #0x429d, w0
    f572:	10 40 78    	mov.b     [w0], w0
    f574:	10 44 98    	mov.b     w0, [w8+1]

0000f576 <.L0>:

    // No RTB in HIL simulation
    if (hasMode(mlHeartbeatLocal.base_mode,MAV_MODE_FLAG_HIL_ENABLED)) {
    f576:	01 c2 b3    	mov.b     #0x20, w1
    f578:	60 12 21    	mov.w     #0x1126, w0
    f57a:	10 40 78    	mov.b     [w0], w0
    f57c:	6e 10 02    	call      0x1106e <_hasMode>
    f57e:	01 00 00 
    f580:	00 04 e0    	cp0.b     w0
    f582:	17 00 3a    	bra       NZ, 0xf5b2 <.L38>

0000f584 <.L0>:
        return;
    }
    
    if (rtb[0]) {
    f584:	18 04 e0    	cp0.b     [w8]
    f586:	15 00 32    	bra       Z, 0xf5b2 <.L38>
        if (mlHeartbeatLocal.custom_mode != SLUGS_MODE_RETURNING) {
    f588:	00 89 80    	mov.w     0x1120, w0
    f58a:	11 89 80    	mov.w     0x1122, w1
    f58c:	e5 0f 50    	sub.w     w0, #0x5, [w15]
    f58e:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    f590:	0c 00 32    	bra       Z, 0xf5aa <.L42>
            lastNavigationMode = mlHeartbeatLocal.custom_mode;
    f592:	50 15 8a    	mov.w     w0, 0x42aa
    f594:	61 15 8a    	mov.w     w1, 0x42ac

            mlPending.statustext++;
    f596:	c0 49 22    	mov.w     #0x249c, w0
    f598:	10 48 e8    	inc.b     [w0], [w0]

            mlStatustext.severity = MAV_SEVERITY_INFO;
    f59a:	61 c0 b3    	mov.b     #0x6, w1
    f59c:	a0 1d 24    	mov.w     #0x41da, w0
    f59e:	01 48 78    	mov.b     w1, [w0]
            strncpy(mlStatustext.text, "Lost groundstation heartbeat. Returning to base.", 49);
    f5a0:	40 76 2c    	mov.w     #0xc764, w0
    f5a2:	b1 1d 24    	mov.w     #0x41db, w1
    f5a4:	30 00 09    	.pword 0x090030
    f5a6:	b0 58 78    	mov.b     [w0++], [w1++]
    f5a8:	10 03 b1    	sub.w     #0x31, w0

0000f5aa <.L42>:
        }

        mlHeartbeatLocal.custom_mode = SLUGS_MODE_RETURNING; //MAV_STATE_RETURNING;
    f5aa:	50 00 20    	mov.w     #0x5, w0
    f5ac:	01 00 20    	mov.w     #0x0, w1
    f5ae:	00 89 88    	mov.w     w0, 0x1120
    f5b0:	11 89 88    	mov.w     w1, 0x1122

0000f5b2 <.L38>:
    } else {
        //if (mlHeartbeatLocal.custom_mode == SLUGS_MODE_RETURNING)
        //    mlHeartbeatLocal.custom_mode = lastNavigationMode;
    }
}
    f5b2:	4f 04 78    	mov.w     [--w15], w8
    f5b4:	00 00 06    	return    

0000f5b6 <_getMobileLocation>:

void getMobileLocation (float* loc){
    loc[0] = mlMobileLocation.latitude;
    f5b6:	32 a6 80    	mov.w     0x14c6, w2
    f5b8:	43 a6 80    	mov.w     0x14c8, w3
    f5ba:	02 88 be    	mov.d     w2, [w0]
    loc[1] = mlMobileLocation.longitude;
    f5bc:	52 a6 80    	mov.w     0x14ca, w2
    f5be:	63 a6 80    	mov.w     0x14cc, w3
    f5c0:	22 00 98    	mov.w     w2, [w0+4]
    f5c2:	33 00 98    	mov.w     w3, [w0+6]
}
    f5c4:	00 00 06    	return    

0000f5c6 <_getNavMode>:

uint8_t getNavMode (void){
    return mlHeartbeatLocal.custom_mode;
    f5c6:	00 89 80    	mov.w     0x1120, w0
}
    f5c8:	00 00 06    	return    

0000f5ca <_getISRLocation>:

void getISRLocation (float* loc){
    loc[0] =  mlISR.latitude;
    f5ca:	82 a6 80    	mov.w     0x14d0, w2
    f5cc:	93 a6 80    	mov.w     0x14d2, w3
    f5ce:	02 88 be    	mov.d     w2, [w0]
    loc[1] =  mlISR.longitude;
    f5d0:	a2 a6 80    	mov.w     0x14d4, w2
    f5d2:	b3 a6 80    	mov.w     0x14d6, w3
    f5d4:	22 00 98    	mov.w     w2, [w0+4]
    f5d6:	33 00 98    	mov.w     w3, [w0+6]
    loc[2] =  mlISR.height;
    f5d8:	c2 a6 80    	mov.w     0x14d8, w2
    f5da:	d3 a6 80    	mov.w     0x14da, w3
    f5dc:	42 00 98    	mov.w     w2, [w0+8]
    f5de:	53 00 98    	mov.w     w3, [w0+10]
}
    f5e0:	00 00 06    	return    

0000f5e2 <_getISRCameraOption1>:


uint8_t getISRCameraOption1(void){
    return mlISR.option1;
    f5e2:	d0 4d 21    	mov.w     #0x14dd, w0
    f5e4:	10 40 78    	mov.b     [w0], w0
}
    f5e6:	00 00 06    	return    

0000f5e8 <_justEnabled>:
unsigned short meanFilter5(unsigned short * values) {
    quickSort(values, 7);
    return values[3];
}

uint8_t justEnabled(uint8_t enableValue, uint8_t index){
    f5e8:	00 41 78    	mov.b     w0, w2
    /*
     * The indexes used are as follows:
     * 
     * 0    Just switched to WP
     * 1    DidReachIP
     * 2    Trim Conditions
     */
    
    static uint8_t enableValues [NUM_JUST_ENAB] ;
    static uint8_t firstRun = 1;
    uint8_t retVal;
      
    if (firstRun){
    f5ea:	40 4a 24    	mov.w     #0x44a4, w0
    f5ec:	10 04 e0    	cp0.b     [w0]
    f5ee:	05 00 32    	bra       Z, 0xf5fa <.L49>
        memset(enableValues, 0, NUM_JUST_ENAB);
    f5f0:	c0 49 24    	mov.w     #0x449c, w0
    f5f2:	02 00 09    	.pword 0x090002
    f5f4:	00 58 eb    	clr.b     [w0++]
        firstRun = 0;
    f5f6:	40 4a 24    	mov.w     #0x44a4, w0
    f5f8:	00 48 eb    	clr.b     [w0]

0000f5fa <.L49>:
    }
    
    retVal = (enableValues[index] == 0 && enableValue == 1);
    f5fa:	81 80 fb    	ze        w1, w1
    f5fc:	c3 49 24    	mov.w     #0x449c, w3
    f5fe:	81 81 41    	add.w     w3, w1, w3
    f600:	00 00 eb    	clr.w     w0
    f602:	13 04 e0    	cp0.b     [w3]
    f604:	05 00 3a    	bra       NZ, 0xf610 <.L50>
    f606:	02 40 78    	mov.b     w2, w0
    f608:	00 04 a2    	btg.b     w0, #0x0
    f60a:	00 80 fb    	ze        w0, w0
    f60c:	00 00 e9    	dec.w     w0, w0
    f60e:	4f 00 de    	lsr.w     w0, #0xf, w0

0000f610 <.L50>:
    
    enableValues[index] = enableValue;
    f610:	c3 49 24    	mov.w     #0x449c, w3
    f612:	81 80 41    	add.w     w3, w1, w1
    f614:	82 48 78    	mov.b     w2, [w1]
    
    return retVal;
}
    f616:	00 00 06    	return    

0000f618 <_quickSort>:

//  quickSort
//
//  This public-domain C implementation by Darel Rex Finley.
//
//  * Returns YES if sort was successful, or NO if the nested
//    pivots went too deep, in which case your array will have
//    been re-ordered, but probably not sorted correctly.
//
//  * This function assumes it is called with valid parameters.
//
//  * Example calls:
//    quickSort(&myArray[0],5); // sorts elements 0, 1, 2, 3, and 4
//    quickSort(&myArray[3],5); // sorts elements 3, 4, 5, 6, and 7
//
// 	source: http://alienryderflex.com/quicksort/

unsigned char quickSort(unsigned short *arr, char elements) {
    f618:	20 00 fa    	lnk       #0x20
    f61a:	88 1f 78    	mov.w     w8, [w15++]

#define  MAX_LEVELS  8

    short i = 0, L, R;
    unsigned short piv, beg[MAX_LEVELS], end[MAX_LEVELS];

    beg[0] = 0;
    f61c:	00 01 eb    	clr.w     w2
    f61e:	f2 af 9f    	mov.w     w2, [w15-34]
    end[0] = elements;
    f620:	81 00 fb    	se        w1, w1
    f622:	f1 b7 9f    	mov.w     w1, [w15-18]
    f624:	80 03 eb    	clr.w     w7

0000f626 <.L66>:
    while (i >= 0) {
        L = beg[i];
    f626:	07 81 43    	add.w     w7, w7, w2
    f628:	e4 fd 2f    	mov.w     #0xffde, w4
    f62a:	02 02 42    	add.w     w4, w2, w4
    f62c:	ef 01 7a    	mov.w     [w15+w4], w3
    f62e:	83 00 78    	mov.w     w3, w1
        R = end[i] - 1;
    f630:	72 01 51    	sub.w     w2, #0x12, w2
    f632:	6f 04 79    	mov.w     [w15+w2], w8
    f634:	08 01 e9    	dec.w     w8, w2
        if (L < R) {
    f636:	82 8f 51    	sub.w     w3, w2, [w15]
    f638:	49 00 3d    	bra       GE, 0xf6cc <.L53>
            piv = arr[L];
    f63a:	83 81 41    	add.w     w3, w3, w3
    f63c:	83 01 40    	add.w     w0, w3, w3
    f63e:	93 02 78    	mov.w     [w3], w5
            if (i == MAX_LEVELS - 1) return 0;
    f640:	e7 8f 53    	sub.w     w7, #0x7, [w15]
    f642:	26 00 3a    	bra       NZ, 0xf690 <.L71>
    f644:	48 00 37    	bra       0xf6d6 <.L72>

0000f646 <.L57>:
            while (L < R) {
                while (arr[R] >= piv && L < R) {
                    R--;
    f646:	02 01 e9    	dec.w     w2, w2
    f648:	03 03 78    	mov.w     w3, w6
    f64a:	23 02 78    	mov.w     [w3--], w4
    f64c:	84 8f 52    	sub.w     w5, w4, [w15]
    f64e:	03 00 3e    	bra       GTU, 0xf656 <.L56>
    f650:	81 0f 51    	sub.w     w2, w1, [w15]
    f652:	f9 ff 3c    	bra       GT, 0xf646 <.L57>
    f654:	06 00 37    	bra       0xf662 <.L59>

0000f656 <.L56>:
                }
                if (L < R) {
    f656:	82 8f 50    	sub.w     w1, w2, [w15]
    f658:	04 00 3d    	bra       GE, 0xf662 <.L59>
                    arr[L++] = arr[R];
    f65a:	81 81 40    	add.w     w1, w1, w3
    f65c:	83 01 40    	add.w     w0, w3, w3
    f65e:	84 09 78    	mov.w     w4, [w3]
    f660:	81 00 e8    	inc.w     w1, w1

0000f662 <.L59>:
                }
                while (arr[L] <= piv && L < R) {
    f662:	81 81 40    	add.w     w1, w1, w3
    f664:	83 01 40    	add.w     w0, w3, w3
    f666:	93 01 78    	mov.w     [w3], w3
    f668:	83 8f 52    	sub.w     w5, w3, [w15]
    f66a:	0c 00 39    	bra       NC, 0xf684 <.L60>
    f66c:	81 0f 51    	sub.w     w2, w1, [w15]
    f66e:	1b 00 34    	bra       LE, 0xf6a6 <.L64>
    f670:	01 02 e8    	inc.w     w1, w4
    f672:	04 02 42    	add.w     w4, w4, w4
    f674:	04 02 40    	add.w     w0, w4, w4

0000f676 <.L62>:
                    L++;
    f676:	81 00 e8    	inc.w     w1, w1
    f678:	b4 01 78    	mov.w     [w4++], w3
    f67a:	83 8f 52    	sub.w     w5, w3, [w15]
    f67c:	03 00 39    	bra       NC, 0xf684 <.L60>
    f67e:	82 8f 50    	sub.w     w1, w2, [w15]
    f680:	fa ff 35    	bra       LT, 0xf676 <.L62>
    f682:	11 00 37    	bra       0xf6a6 <.L64>

0000f684 <.L60>:
                }
                if (L < R) {
    f684:	81 0f 51    	sub.w     w2, w1, [w15]
    f686:	0f 00 34    	bra       LE, 0xf6a6 <.L64>
                    arr[R--] = arr[L];
    f688:	03 0b 78    	mov.w     w3, [w6]
    f68a:	02 01 e9    	dec.w     w2, w2
    f68c:	81 0f 51    	sub.w     w2, w1, [w15]
    f68e:	0b 00 34    	bra       LE, 0xf6a6 <.L64>

0000f690 <.L71>:
    f690:	02 03 41    	add.w     w2, w2, w6
    f692:	06 03 40    	add.w     w0, w6, w6
    f694:	16 02 78    	mov.w     [w6], w4
    f696:	84 8f 52    	sub.w     w5, w4, [w15]
    f698:	de ff 3e    	bra       GTU, 0xf656 <.L56>
    f69a:	82 8f 50    	sub.w     w1, w2, [w15]
    f69c:	e2 ff 3d    	bra       GE, 0xf662 <.L59>
    f69e:	82 01 e9    	dec.w     w2, w3
    f6a0:	83 81 41    	add.w     w3, w3, w3
    f6a2:	83 01 40    	add.w     w0, w3, w3
    f6a4:	d0 ff 37    	bra       0xf646 <.L57>

0000f6a6 <.L64>:
                }
            }
            arr[L] = piv;
    f6a6:	01 81 40    	add.w     w1, w1, w2
    f6a8:	02 01 40    	add.w     w0, w2, w2
    f6aa:	05 09 78    	mov.w     w5, [w2]
            beg[i + 1] = L + 1;
    f6ac:	07 01 e8    	inc.w     w7, w2
    f6ae:	82 01 41    	add.w     w2, w2, w3
    f6b0:	01 02 e8    	inc.w     w1, w4
    f6b2:	04 03 78    	mov.w     w4, w6
    f6b4:	e5 fd 2f    	mov.w     #0xffde, w5
    f6b6:	83 82 42    	add.w     w5, w3, w5
    f6b8:	86 b7 7a    	mov.w     w6, [w15+w5]
            end[i + 1] = end[i];
    f6ba:	08 02 78    	mov.w     w8, w4
    f6bc:	f2 81 51    	sub.w     w3, #0x12, w3
    f6be:	84 b7 79    	mov.w     w4, [w15+w3]
            end[i++] = L;
    f6c0:	87 83 43    	add.w     w7, w7, w7
    f6c2:	81 02 78    	mov.w     w1, w5
    f6c4:	f2 81 53    	sub.w     w7, #0x12, w3
    f6c6:	85 b7 79    	mov.w     w5, [w15+w3]
    f6c8:	82 03 78    	mov.w     w2, w7
    f6ca:	01 00 37    	bra       0xf6ce <.L65>

0000f6cc <.L53>:
        } else {
            i--;
    f6cc:	87 03 e9    	dec.w     w7, w7

0000f6ce <.L65>:
    f6ce:	07 00 e0    	cp0.w     w7
    f6d0:	aa ff 3d    	bra       GE, 0xf626 <.L66>
        }
    }
    return 1;
    f6d2:	10 c0 b3    	mov.b     #0x1, w0
    f6d4:	01 00 37    	bra       0xf6d8 <.L54>

0000f6d6 <.L72>:
    f6d6:	00 40 eb    	clr.b     w0

0000f6d8 <.L54>:
}
    f6d8:	4f 04 78    	mov.w     [--w15], w8
    f6da:	00 80 fa    	ulnk      
    f6dc:	00 00 06    	return    

0000f6de <_meanFilter5>:
    f6de:	88 1f 78    	mov.w     w8, [w15++]
    f6e0:	00 04 78    	mov.w     w0, w8

0000f6e2 <.L0>:
    f6e2:	71 c0 b3    	mov.b     #0x7, w1
    f6e4:	08 00 78    	mov.w     w8, w0
    f6e6:	98 ff 07    	rcall     0xf618 <_quickSort> <L0> <.LFB1495> <.LFE1494>
    f6e8:	38 00 90    	mov.w     [w8+6], w0

0000f6ea <.L0>:
    f6ea:	4f 04 78    	mov.w     [--w15], w8
    f6ec:	00 00 06    	return    

0000f6ee <_gpsInit>:
    memset(&mlNovatelStatus, 0, sizeof (mavlink_novatel_diag_t));

#else
    
    uartBufferInit();
    f6ee:	98 11 02    	call      0x11198 <_uartBufferInit>
    f6f0:	01 00 00 
#endif
}
    f6f2:	00 00 06    	return    

0000f6f4 <_updateStatus>:

void gpsParse(uint8_t* dataStream) {

    DECODER_STATUS static currentStatus = DECO_START;

    uint16_t static payloadLen = 0;
    uint16_t static bytesRead = 0;
    uint8_t static completeMessage [MSIZE];
    uint16_t static totalBytes = 0;
    uint32_t static currentChecksum = 0;

    uint8_t ii = 1;
    uint8_t bytesReceived = dataStream[0];
    tUnsignedShortToChar shTemp;

    while (bytesReceived) {
        switch (currentStatus) {

            case DECO_START:
                payloadLen = 0;
                bytesRead = 0;
                totalBytes = 0;
                currentChecksum = 0;

                while (dataStream[ii] != HEAD1) {
                    ii++;
                    bytesReceived--;

                    if (bytesReceived == 0) {
                        return;
                    }
                }
                completeMessage[bytesRead++] = HEAD1;
                ii++;
                bytesReceived--;
                currentStatus = DECO_RECEIVING_HEADER2;
                break;

            case DECO_RECEIVING_HEADER2:
                if (dataStream[ii] != HEAD2) {
                    currentStatus = DECO_START;

                } else {
                    ii++;
                    bytesReceived--;
                    completeMessage[bytesRead++] = HEAD2;
                    currentStatus = DECO_RECEIVING_HEADER3;
                }

                break;

            case DECO_RECEIVING_HEADER3:
                if (dataStream[ii] != HEAD3) {
                    currentStatus = DECO_START;
                    bytesRead = 0;
                } else {
                    ii++;
                    bytesReceived--;
                    completeMessage[bytesRead++] = HEAD3;
                    currentStatus = DECO_RECEIVING_HEADER;
                }
                break;

            case DECO_RECEIVING_HEADER:
                while ((bytesReceived > 0) && (bytesRead < HEAD_LEN)) {
                    completeMessage[bytesRead++] = dataStream[ii++];
                    bytesReceived--;
                }

                if (bytesRead == HEAD_LEN) {
                    currentStatus = DECO_RECEIVING_PAYLOAD;

                    payloadLen = charsToUint16(&(completeMessage[8]));

                    totalBytes = payloadLen + HEAD_LEN + 4; // this includes the 4 CRC bytes
                }
                break;


            case DECO_RECEIVING_PAYLOAD:
                while ((bytesReceived > 0) && (bytesRead < totalBytes)) {
                    completeMessage[bytesRead++] = dataStream[ii++];
                    bytesReceived--;
                }

                if (bytesRead == totalBytes) {
                    currentStatus = DECO_COMPUTING_CRC;

                    currentChecksum = charsToUint32(&(completeMessage[bytesRead - 4]));
                }
                break;

            case DECO_COMPUTING_CRC:
                if (CalculateBlockCRC32(bytesRead - 4, completeMessage) == currentChecksum) {
                    currentStatus = DECO_DECODING;
                } else {
                    mlNovatelStatus.csFails++;
                    currentStatus = DECO_START;
                }
                break;

            case DECO_DECODING:
                shTemp.chData[0] = completeMessage[4];
                shTemp.chData[1] = completeMessage[5];

                updateStatus(completeMessage);

                switch (shTemp.usData) {
                    case BEST_POS_ID:
                        updatePositionData(completeMessage);
                        break;

                    case BEST_VEL_ID:
                        updateVelocityData(completeMessage);
                        break;

                    case TIME_ID:
                        updateTimeData(completeMessage);
                        break;

                    default:

                        break;
                }

                currentStatus = DECO_START;
                break;
        } // switch

    }// while bytes received

}

void updateStatus(uint8_t* completeMessage) {
    mlGpsDateTime.percentUsed = completeMessage[12];
    f6f4:	f1 1a 24    	mov.w     #0x41af, w1
    f6f6:	40 49 90    	mov.b     [w0+12], w2
    f6f8:	82 48 78    	mov.b     w2, [w1]
    mlNovatelStatus.timeStatus = completeMessage[13];
    f6fa:	61 1c 24    	mov.w     #0x41c6, w1
    f6fc:	50 49 90    	mov.b     [w0+13], w2
    f6fe:	82 48 78    	mov.b     w2, [w1]
    mlNovatelStatus.receiverStatus = (uint32_t) completeMessage[20];
    f700:	40 50 90    	mov.b     [w0+20], w0
    f702:	00 80 fb    	ze        w0, w0
    f704:	80 00 eb    	clr.w     w1
    f706:	e0 0d 8a    	mov.w     w0, 0x41bc
    f708:	f1 0d 8a    	mov.w     w1, 0x41be
};
    f70a:	00 00 06    	return    

0000f70c <_getGpsMainData>:

void updatePositionData(uint8_t* completeMessage) {
    t64IntToChar temp;
    temp.liData = mlGpsData.time_usec;
    temp.shData[0]++;
    mlGpsData.time_usec = temp.liData;

    mlNovatelStatus.solStatus = (uint8_t) charsToUint32(&(completeMessage[28]));
    mlNovatelStatus.posType = (uint8_t) charsToUint32(&(completeMessage[32]));

    mlGpsData.fix_type = ((mlNovatelStatus.posType>15) && (mlNovatelStatus.solStatus == 0))?
        GPS_FIX_3D : GPS_FIX_NONE;
    
    mlGpsData.lat = FLOAT_TO_INT32_1E7((float) charsToDouble(&(completeMessage[36])));
    mlGpsData.lon = FLOAT_TO_INT32_1E7((float) charsToDouble(&(completeMessage[44])));
    mlGpsData.alt = FLOAT_TO_INT32_1E3((float) charsToDouble(&(completeMessage[52])));

    mlNovatelStatus.posSolAge = charsToFloat(&(completeMessage[88]));

    mlGpsDateTime.visSat = completeMessage[92];
    mlGpsDateTime.useSat = completeMessage[93];
    mlGpsDateTime.GppGl = completeMessage[94];

    mlGpsDateTime.sigUsedMask = completeMessage[99];

};

void updateVelocityData(uint8_t* completeMessage) {
    t64IntToChar temp;
    temp.liData = mlGpsData.time_usec;
    temp.shData[1]++;
    mlGpsData.time_usec = temp.liData;

    mlNovatelStatus.velType = (uint8_t) charsToUint32(&(completeMessage[32]));
    mlGpsData.vel = FLOAT_TO_UINT16_1E2((float) charsToDouble(&(completeMessage[44])));
    mlGpsData.cog = FLOAT_TO_UINT16_1E2((float) charsToDouble(&(completeMessage[52])));
};

void updateTimeData(uint8_t* completeMessage) {
     t64IntToChar temp;
    temp.liData = mlGpsData.time_usec;
    temp.shData[2]++;
    mlGpsData.time_usec = temp.liData;
    
    mlGpsDateTime.clockStat = (uint8_t) charsToUint32(&(completeMessage[28]));
    mlGpsDateTime.year = (uint8_t) (charsToUint32(&(completeMessage[56])) - 2000);
    mlGpsDateTime.month = completeMessage[60];
    mlGpsDateTime.day = completeMessage[61];
    mlGpsDateTime.hour = completeMessage[62];
    mlGpsDateTime.min = completeMessage[63];
    mlGpsDateTime.sec = (uint8_t) (charsToUint32(&(completeMessage[64])) / 1000);
};

void getGpsMainData(float* data) {
    f70c:	88 1f 78    	mov.w     w8, [w15++]
    f70e:	00 04 78    	mov.w     w0, w8

0000f710 <.L0>:
    data[0] = INT32_1E7_TO_FLOAT(mlGpsData.lat);
    f710:	10 83 80    	mov.w     0x1062, w0
    f712:	21 83 80    	mov.w     0x1064, w1
    f714:	0c 19 02    	call      0x190c <___floatsisf>
    f716:	00 00 00 
    f718:	52 f9 2b    	mov.w     #0xbf95, w2
    f71a:	63 3d 23    	mov.w     #0x33d6, w3
    f71c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f71e:	00 00 00 
    f720:	00 8c be    	mov.d     w0, [w8]

0000f722 <.L0>:
    data[1] = INT32_1E7_TO_FLOAT(mlGpsData.lon);
    f722:	30 83 80    	mov.w     0x1066, w0
    f724:	41 83 80    	mov.w     0x1068, w1
    f726:	0c 19 02    	call      0x190c <___floatsisf>
    f728:	00 00 00 
    f72a:	52 f9 2b    	mov.w     #0xbf95, w2
    f72c:	63 3d 23    	mov.w     #0x33d6, w3
    f72e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f730:	00 00 00 
    f732:	20 04 98    	mov.w     w0, [w8+4]
    f734:	31 04 98    	mov.w     w1, [w8+6]

0000f736 <.L0>:
    data[2] = INT32_1E3_TO_FLOAT(mlGpsData.alt);
    f736:	50 83 80    	mov.w     0x106a, w0
    f738:	61 83 80    	mov.w     0x106c, w1
    f73a:	0c 19 02    	call      0x190c <___floatsisf>
    f73c:	00 00 00 
    f73e:	f2 26 21    	mov.w     #0x126f, w2
    f740:	33 a8 23    	mov.w     #0x3a83, w3
    f742:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f744:	00 00 00 
    f746:	40 04 98    	mov.w     w0, [w8+8]
    f748:	51 04 98    	mov.w     w1, [w8+10]

0000f74a <.L0>:
    data[3] = UINT16_1E2_TO_FLOAT(mlGpsData.cog);
    f74a:	a0 83 80    	mov.w     0x1074, w0
    f74c:	80 00 eb    	clr.w     w1
    f74e:	12 19 02    	call      0x1912 <___floatunsisf>
    f750:	00 00 00 
    f752:	a2 70 2d    	mov.w     #0xd70a, w2
    f754:	33 c2 23    	mov.w     #0x3c23, w3
    f756:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f758:	00 00 00 
    f75a:	60 04 98    	mov.w     w0, [w8+12]
    f75c:	71 04 98    	mov.w     w1, [w8+14]

0000f75e <.L0>:
    data[4] = UINT16_1E2_TO_FLOAT(mlGpsData.vel);
    f75e:	90 83 80    	mov.w     0x1072, w0
    f760:	80 00 eb    	clr.w     w1
    f762:	12 19 02    	call      0x1912 <___floatunsisf>
    f764:	00 00 00 
    f766:	a2 70 2d    	mov.w     #0xd70a, w2
    f768:	33 c2 23    	mov.w     #0x3c23, w3
    f76a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f76c:	00 00 00 
    f76e:	00 0c 98    	mov.w     w0, [w8+16]
    f770:	11 0c 98    	mov.w     w1, [w8+18]

0000f772 <.L0>:
}
    f772:	4f 04 78    	mov.w     [--w15], w8
    f774:	00 00 06    	return    

0000f776 <_CRC32Value>:

// Functions provided by NOVATEL

/* --------------------------------------------------------------------------
Calculate a CRC value to be used by CRC calculation functions.
 -------------------------------------------------------------------------- */
uint32_t CRC32Value(int32_t i) {
    int32_t j;
    uint32_t ulCRC;
    ulCRC = i;
    for (j = 8; j > 0; j--) {
    f776:	82 00 20    	mov.w     #0x8, w2
    f778:	03 00 20    	mov.w     #0x0, w3
        if (ulCRC & 1) {
            ulCRC = (ulCRC >> 1) ^ CRC32_POLYNOMIAL;
    f77a:	04 32 28    	mov.w     #0x8320, w4
    f77c:	85 db 2e    	mov.w     #0xedb8, w5

0000f77e <.L7>:
    f77e:	00 08 a3    	btst.z    w0, #0x0
    f780:	05 00 32    	bra       Z, 0xf78c <.L5>
    f782:	81 00 d1    	lsr.w     w1, w1
    f784:	00 80 d3    	rrc.w     w0, w0
    f786:	04 00 68    	xor.w     w0, w4, w0
    f788:	85 80 68    	xor.w     w1, w5, w1
    f78a:	02 00 37    	bra       0xf790 <.L6>

0000f78c <.L5>:
        } else {
            ulCRC >>= 1;
    f78c:	81 00 d1    	lsr.w     w1, w1
    f78e:	00 80 d3    	rrc.w     w0, w0

0000f790 <.L6>:
    f790:	61 01 51    	sub.w     w2, #0x1, w2
    f792:	e0 81 59    	subb.w    w3, #0x0, w3
    f794:	f4 ff 3a    	bra       NZ, 0xf77e <.L7>
        } // if
    } // for
    return ulCRC;
}
    f796:	00 00 06    	return    

0000f798 <_CalculateBlockCRC32>:

/* --------------------------------------------------------------------------
Calculates the CRC-32 of a block of data all at once
-------------------------------------------------------------------------- */
uint32_t CalculateBlockCRC32(
    uint32_t ulCount, /* Number of bytes in the data block */
    uint8_t *ucBuffer) { /* Data block */
    f798:	88 9f be    	mov.d     w8, [w15++]
    f79a:	8a 9f be    	mov.d     w10, [w15++]
    f79c:	8c 9f be    	mov.d     w12, [w15++]
    f79e:	00 04 be    	mov.d     w0, w8
    f7a0:	02 05 78    	mov.w     w2, w10

    uint32_t ulTemp1;
    uint32_t ulTemp2;
    uint32_t ulCRC = 0;
    f7a2:	60 00 b8    	mul.uu    w0, #0x0, w0
    while (ulCount-- != 0) {
    f7a4:	e0 0f 54    	sub.w     w8, #0x0, [w15]
    f7a6:	e0 8f 5c    	subb.w    w9, #0x0, [w15]
    f7a8:	10 00 32    	bra       Z, 0xf7ca <.L10>
        ulTemp1 = (ulCRC >> 8) & 0x00FFFFFFL;
        ulTemp2 = CRC32Value(((int32_t) ulCRC ^ *ucBuffer++) & 0xff);
    f7aa:	fb 0f 20    	mov.w     #0xff, w11

0000f7ac <.L11>:
    f7ac:	c8 0e de    	lsr.w     w1, #0x8, w13
    f7ae:	48 09 dd    	sl.w      w1, #0x8, w2
    f7b0:	48 06 de    	lsr.w     w0, #0x8, w12
    f7b2:	0c 06 71    	ior.w     w2, w12, w12

0000f7b4 <.L0>:
    f7b4:	3a 81 fb    	ze        [w10++], w2
    f7b6:	80 01 eb    	clr.w     w3
    f7b8:	02 00 68    	xor.w     w0, w2, w0
    f7ba:	0b 00 60    	and.w     w0, w11, w0
    f7bc:	80 00 eb    	clr.w     w1
    f7be:	db ff 07    	rcall     0xf776 <_CRC32Value> <L0> <.LFB1470> <.LFE1469>

0000f7c0 <.L0>:
        ulCRC = ulTemp1 ^ ulTemp2;
    f7c0:	00 00 6e    	xor.w     w12, w0, w0
    f7c2:	81 80 6e    	xor.w     w13, w1, w1
    f7c4:	61 04 54    	sub.w     w8, #0x1, w8
    f7c6:	e0 84 5c    	subb.w    w9, #0x0, w9
    f7c8:	f1 ff 3a    	bra       NZ, 0xf7ac <.L11>

0000f7ca <.L10>:
    }
    return ( ulCRC);
}
    f7ca:	4f 06 be    	mov.d     [--w15], w12
    f7cc:	4f 05 be    	mov.d     [--w15], w10
    f7ce:	4f 04 be    	mov.d     [--w15], w8
    f7d0:	00 00 06    	return    

0000f7d2 <_charsToUint16>:

uint16_t charsToUint16(uint8_t* data) {
    tUnsignedShortToChar shTemp;

    shTemp.chData[0] = data[0];
    shTemp.chData[1] = data[1];
    f7d2:	90 40 90    	mov.b     [w0+1], w1
    f7d4:	c8 08 dd    	sl.w      w1, #0x8, w1
    f7d6:	10 80 fb    	ze        [w0], w0
    f7d8:	00 80 70    	ior.w     w1, w0, w0

    return shTemp.usData;
}
    f7da:	00 00 06    	return    

0000f7dc <_charsToUint32>:

uint32_t charsToUint32(uint8_t* data) {
    f7dc:	00 01 78    	mov.w     w0, w2
    tUnsignedIntToChar inTemp;

    inTemp.chData[0] = data[0];
    f7de:	60 00 b8    	mul.uu    w0, #0x0, w0
    f7e0:	92 81 fb    	ze        [w2], w3
    inTemp.chData[1] = data[1];
    f7e2:	12 42 90    	mov.b     [w2+1], w4
    f7e4:	48 22 dd    	sl.w      w4, #0x8, w4
    f7e6:	03 00 72    	ior.w     w4, w3, w0
    inTemp.chData[2] = data[2];
    f7e8:	22 42 90    	mov.b     [w2+2], w4
    f7ea:	04 82 fb    	ze        w4, w4
    f7ec:	03 f0 2f    	mov.w     #0xff00, w3
    f7ee:	81 81 61    	and.w     w3, w1, w3
    f7f0:	83 01 72    	ior.w     w4, w3, w3
    inTemp.chData[3] = data[3];
    f7f2:	32 41 90    	mov.b     [w2+3], w2
    f7f4:	48 11 dd    	sl.w      w2, #0x8, w2
    f7f6:	83 81 fb    	ze        w3, w3
    f7f8:	83 00 71    	ior.w     w2, w3, w1

    return inTemp.uiData;
}
    f7fa:	00 00 06    	return    

0000f7fc <_updateTimeData>:
    f7fc:	88 1f 78    	mov.w     w8, [w15++]
    f7fe:	00 04 78    	mov.w     w0, w8
    f800:	a4 05 21    	mov.w     #0x105a, w4
    f802:	34 00 be    	mov.d     [w4++], w0
    f804:	24 01 be    	mov.d     [w4--], w2
    f806:	02 01 e8    	inc.w     w2, w2
    f808:	00 9a be    	mov.d     w0, [w4++]
    f80a:	02 92 be    	mov.d     w2, [w4--]

0000f80c <.L0>:
    f80c:	7c 00 44    	add.w     w8, #0x1c, w0
    f80e:	e6 ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f810:	00 01 be    	mov.d     w0, w2
    f812:	a1 1a 24    	mov.w     #0x41aa, w1
    f814:	82 48 78    	mov.b     w2, [w1]

0000f816 <.L0>:
    f816:	80 03 20    	mov.w     #0x38, w0
    f818:	08 00 40    	add.w     w0, w8, w0
    f81a:	e0 ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f81c:	00 01 be    	mov.d     w0, w2
    f81e:	41 1a 24    	mov.w     #0x41a4, w1
    f820:	00 c3 b3    	mov.b     #0x30, w0
    f822:	80 48 41    	add.b     w2, w0, [w1]

0000f824 <.L0>:
    f824:	01 00 e8    	inc.w     w1, w0
    f826:	c8 78 90    	mov.b     [w8+60], w1
    f828:	01 48 78    	mov.b     w1, [w0]
    f82a:	00 00 e8    	inc.w     w0, w0
    f82c:	d8 78 90    	mov.b     [w8+61], w1
    f82e:	01 48 78    	mov.b     w1, [w0]
    f830:	00 00 e8    	inc.w     w0, w0
    f832:	e8 78 90    	mov.b     [w8+62], w1
    f834:	01 48 78    	mov.b     w1, [w0]
    f836:	00 00 e8    	inc.w     w0, w0
    f838:	f8 78 90    	mov.b     [w8+63], w1
    f83a:	01 48 78    	mov.b     w1, [w0]

0000f83c <.L0>:
    f83c:	00 04 20    	mov.w     #0x40, w0
    f83e:	08 00 40    	add.w     w0, w8, w0
    f840:	cd ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f842:	82 3e 20    	mov.w     #0x3e8, w2
    f844:	03 00 20    	mov.w     #0x0, w3
    f846:	34 1f 02    	call      0x1f34 <___udivsi3>
    f848:	00 00 00 
    f84a:	00 01 be    	mov.d     w0, w2
    f84c:	91 1a 24    	mov.w     #0x41a9, w1
    f84e:	82 48 78    	mov.b     w2, [w1]

0000f850 <.L0>:
    f850:	4f 04 78    	mov.w     [--w15], w8
    f852:	00 00 06    	return    

0000f854 <_charsToFloat>:

float charsToFloat(uint8_t* data) {
    f854:	00 01 78    	mov.w     w0, w2
    tFloatToChar flTemp;

    flTemp.chData[0] = data[0];
    f856:	60 00 b8    	mul.uu    w0, #0x0, w0
    f858:	92 81 fb    	ze        [w2], w3
    flTemp.chData[1] = data[1];
    f85a:	12 42 90    	mov.b     [w2+1], w4
    f85c:	48 22 dd    	sl.w      w4, #0x8, w4
    f85e:	03 00 72    	ior.w     w4, w3, w0
    flTemp.chData[2] = data[2];
    f860:	22 42 90    	mov.b     [w2+2], w4
    f862:	04 82 fb    	ze        w4, w4
    f864:	03 f0 2f    	mov.w     #0xff00, w3
    f866:	81 81 61    	and.w     w3, w1, w3
    f868:	83 01 72    	ior.w     w4, w3, w3
    flTemp.chData[3] = data[3];
    f86a:	32 41 90    	mov.b     [w2+3], w2
    f86c:	48 11 dd    	sl.w      w2, #0x8, w2
    f86e:	83 81 fb    	ze        w3, w3
    f870:	83 00 71    	ior.w     w2, w3, w1

    return flTemp.flData;
}
    f872:	00 00 06    	return    

0000f874 <_charsToDouble>:

#if _TESTING_

double charsToDouble(uint8_t* data) {
#else

long double charsToDouble(uint8_t* data) {
    f874:	88 1f 78    	mov.w     w8, [w15++]
    f876:	00 02 78    	mov.w     w0, w4
#endif
    tDoubleToChar doTemp;

    doTemp.chData[0] = data[0];
    f878:	06 f0 2f    	mov.w     #0xff00, w6
    f87a:	60 00 b8    	mul.uu    w0, #0x0, w0
    f87c:	60 11 b8    	mul.uu    w2, #0x0, w2
    f87e:	94 83 fb    	ze        [w4], w7
    doTemp.chData[1] = data[1];
    f880:	14 44 90    	mov.b     [w4+1], w8
    f882:	48 44 dd    	sl.w      w8, #0x8, w8
    f884:	f5 0f 20    	mov.w     #0xff, w5
    f886:	07 00 74    	ior.w     w8, w7, w0
    doTemp.chData[2] = data[2];
    f888:	a4 43 90    	mov.b     [w4+2], w7
    f88a:	87 83 fb    	ze        w7, w7
    f88c:	01 04 63    	and.w     w6, w1, w8
    f88e:	88 83 73    	ior.w     w7, w8, w7
    doTemp.chData[3] = data[3];
    f890:	34 44 90    	mov.b     [w4+3], w8
    f892:	48 44 dd    	sl.w      w8, #0x8, w8
    f894:	85 83 63    	and.w     w7, w5, w7
    f896:	87 00 74    	ior.w     w8, w7, w1
    doTemp.chData[4] = data[4];
    f898:	c4 43 90    	mov.b     [w4+4], w7
    f89a:	87 83 fb    	ze        w7, w7
    f89c:	02 04 63    	and.w     w6, w2, w8
    f89e:	88 83 73    	ior.w     w7, w8, w7
    doTemp.chData[5] = data[5];
    f8a0:	54 44 90    	mov.b     [w4+5], w8
    f8a2:	48 44 dd    	sl.w      w8, #0x8, w8
    f8a4:	85 83 63    	and.w     w7, w5, w7
    f8a6:	07 01 74    	ior.w     w8, w7, w2
    doTemp.chData[6] = data[6];
    f8a8:	e4 43 90    	mov.b     [w4+6], w7
    f8aa:	87 83 fb    	ze        w7, w7
    f8ac:	03 03 63    	and.w     w6, w3, w6
    f8ae:	06 83 73    	ior.w     w7, w6, w6
    doTemp.chData[7] = data[7];
    f8b0:	74 42 90    	mov.b     [w4+7], w4
    f8b2:	48 22 dd    	sl.w      w4, #0x8, w4
    f8b4:	85 02 63    	and.w     w6, w5, w5
    f8b6:	85 01 72    	ior.w     w4, w5, w3

    return doTemp.doData;

}
    f8b8:	4f 04 78    	mov.w     [--w15], w8
    f8ba:	00 00 06    	return    

0000f8bc <_updateVelocityData>:
    f8bc:	88 1f 78    	mov.w     w8, [w15++]
    f8be:	00 04 78    	mov.w     w0, w8
    f8c0:	a4 05 21    	mov.w     #0x105a, w4
    f8c2:	34 00 be    	mov.d     [w4++], w0
    f8c4:	24 01 be    	mov.d     [w4--], w2
    f8c6:	81 00 e8    	inc.w     w1, w1
    f8c8:	00 9a be    	mov.d     w0, [w4++]
    f8ca:	02 92 be    	mov.d     w2, [w4--]

0000f8cc <.L0>:
    f8cc:	00 02 20    	mov.w     #0x20, w0
    f8ce:	08 00 40    	add.w     w0, w8, w0
    f8d0:	85 ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f8d2:	00 01 be    	mov.d     w0, w2
    f8d4:	91 1c 24    	mov.w     #0x41c9, w1
    f8d6:	82 48 78    	mov.b     w2, [w1]

0000f8d8 <.L0>:
    f8d8:	c0 02 20    	mov.w     #0x2c, w0
    f8da:	08 00 40    	add.w     w0, w8, w0
    f8dc:	cb ff 07    	rcall     0xf874 <_charsToDouble> <L0> <.LFB1475> <.LFE1474>
    f8de:	de 1e 02    	call      0x1ede <___truncdfsf2>
    f8e0:	00 00 00 
    f8e2:	02 00 20    	mov.w     #0x0, w2
    f8e4:	83 2c 24    	mov.w     #0x42c8, w3
    f8e6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f8e8:	00 00 00 
    f8ea:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f8ec:	00 00 00 
    f8ee:	90 83 88    	mov.w     w0, 0x1072

0000f8f0 <.L0>:
    f8f0:	40 03 20    	mov.w     #0x34, w0
    f8f2:	08 00 40    	add.w     w0, w8, w0
    f8f4:	bf ff 07    	rcall     0xf874 <_charsToDouble> <L0> <.LFB1475> <.LFE1474>
    f8f6:	de 1e 02    	call      0x1ede <___truncdfsf2>
    f8f8:	00 00 00 
    f8fa:	02 00 20    	mov.w     #0x0, w2
    f8fc:	83 2c 24    	mov.w     #0x42c8, w3
    f8fe:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f900:	00 00 00 
    f902:	d6 18 02    	call      0x18d6 <___fixunssfsi>
    f904:	00 00 00 
    f906:	a0 83 88    	mov.w     w0, 0x1074

0000f908 <.L0>:
    f908:	4f 04 78    	mov.w     [--w15], w8
    f90a:	00 00 06    	return    

0000f90c <_updatePositionData>:
    f90c:	88 9f be    	mov.d     w8, [w15++]
    f90e:	00 04 78    	mov.w     w0, w8
    f910:	a4 05 21    	mov.w     #0x105a, w4
    f912:	34 00 be    	mov.d     [w4++], w0
    f914:	24 01 be    	mov.d     [w4--], w2
    f916:	00 00 e8    	inc.w     w0, w0
    f918:	00 9a be    	mov.d     w0, [w4++]
    f91a:	02 92 be    	mov.d     w2, [w4--]

0000f91c <.L0>:
    f91c:	7c 00 44    	add.w     w8, #0x1c, w0
    f91e:	5e ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f920:	80 44 78    	mov.b     w0, w9
    f922:	72 1c 24    	mov.w     #0x41c7, w2
    f924:	00 49 78    	mov.b     w0, [w2]

0000f926 <.L0>:
    f926:	00 02 20    	mov.w     #0x20, w0
    f928:	08 00 40    	add.w     w0, w8, w0
    f92a:	58 ff 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    f92c:	82 1c 24    	mov.w     #0x41c8, w2
    f92e:	00 49 78    	mov.b     w0, [w2]

0000f930 <.L0>:
    f930:	00 41 eb    	clr.b     w2
    f932:	ef 4f 50    	sub.b     w0, #0xf, [w15]
    f934:	04 00 36    	bra       LEU, 0xf93e <.L21>
    f936:	32 c0 b3    	mov.b     #0x3, w2
    f938:	09 04 e0    	cp0.b     w9
    f93a:	01 00 32    	bra       Z, 0xf93e <.L21>
    f93c:	00 41 eb    	clr.b     w2

0000f93e <.L21>:
    f93e:	60 07 21    	mov.w     #0x1076, w0
    f940:	02 48 78    	mov.b     w2, [w0]

0000f942 <.L0>:
    f942:	40 02 20    	mov.w     #0x24, w0
    f944:	08 00 40    	add.w     w0, w8, w0
    f946:	96 ff 07    	rcall     0xf874 <_charsToDouble> <L0> <.LFB1475> <.LFE1474>
    f948:	de 1e 02    	call      0x1ede <___truncdfsf2>
    f94a:	00 00 00 
    f94c:	02 68 29    	mov.w     #0x9680, w2
    f94e:	83 b1 24    	mov.w     #0x4b18, w3
    f950:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f952:	00 00 00 
    f954:	94 18 02    	call      0x1894 <___fixsfsi>
    f956:	00 00 00 
    f958:	10 83 88    	mov.w     w0, 0x1062
    f95a:	21 83 88    	mov.w     w1, 0x1064

0000f95c <.L0>:
    f95c:	c0 02 20    	mov.w     #0x2c, w0
    f95e:	08 00 40    	add.w     w0, w8, w0
    f960:	89 ff 07    	rcall     0xf874 <_charsToDouble> <L0> <.LFB1475> <.LFE1474>
    f962:	de 1e 02    	call      0x1ede <___truncdfsf2>
    f964:	00 00 00 
    f966:	02 68 29    	mov.w     #0x9680, w2
    f968:	83 b1 24    	mov.w     #0x4b18, w3
    f96a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f96c:	00 00 00 
    f96e:	94 18 02    	call      0x1894 <___fixsfsi>
    f970:	00 00 00 
    f972:	30 83 88    	mov.w     w0, 0x1066
    f974:	41 83 88    	mov.w     w1, 0x1068

0000f976 <.L0>:
    f976:	40 03 20    	mov.w     #0x34, w0
    f978:	08 00 40    	add.w     w0, w8, w0
    f97a:	7c ff 07    	rcall     0xf874 <_charsToDouble> <L0> <.LFB1475> <.LFE1474>
    f97c:	de 1e 02    	call      0x1ede <___truncdfsf2>
    f97e:	00 00 00 
    f980:	02 00 20    	mov.w     #0x0, w2
    f982:	a3 47 24    	mov.w     #0x447a, w3
    f984:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    f986:	00 00 00 
    f988:	94 18 02    	call      0x1894 <___fixsfsi>
    f98a:	00 00 00 
    f98c:	50 83 88    	mov.w     w0, 0x106a
    f98e:	61 83 88    	mov.w     w1, 0x106c

0000f990 <.L0>:
    f990:	80 05 20    	mov.w     #0x58, w0
    f992:	08 00 40    	add.w     w0, w8, w0
    f994:	5f ff 07    	rcall     0xf854 <_charsToFloat> <L0> <.LFB1474> <.LFE1468>
    f996:	00 0e 8a    	mov.w     w0, 0x41c0
    f998:	11 0e 8a    	mov.w     w1, 0x41c2

0000f99a <.L0>:
    f99a:	b0 1a 24    	mov.w     #0x41ab, w0
    f99c:	c8 d8 90    	mov.b     [w8+92], w1
    f99e:	01 48 78    	mov.b     w1, [w0]

0000f9a0 <.L0>:
    f9a0:	00 00 e8    	inc.w     w0, w0
    f9a2:	d8 d8 90    	mov.b     [w8+93], w1
    f9a4:	01 48 78    	mov.b     w1, [w0]

0000f9a6 <.L0>:
    f9a6:	00 00 e8    	inc.w     w0, w0
    f9a8:	e8 d8 90    	mov.b     [w8+94], w1
    f9aa:	01 48 78    	mov.b     w1, [w0]
    f9ac:	00 00 e8    	inc.w     w0, w0
    f9ae:	38 e4 90    	mov.b     [w8+99], w8
    f9b0:	08 48 78    	mov.b     w8, [w0]
    f9b2:	4f 04 be    	mov.d     [--w15], w8
    f9b4:	00 00 06    	return    

0000f9b6 <_gpsParse>:
    f9b6:	88 9f be    	mov.d     w8, [w15++]
    f9b8:	8a 9f be    	mov.d     w10, [w15++]
    f9ba:	8c 9f be    	mov.d     w12, [w15++]
    f9bc:	8e 1f 78    	mov.w     w14, [w15++]
    f9be:	00 05 78    	mov.w     w0, w10
    f9c0:	1a 44 78    	mov.b     [w10], w8
    f9c2:	19 c0 b3    	mov.b     #0x1, w9
    f9c4:	2c 0a 24    	mov.w     #0x40a2, w12
    f9c6:	4e 1c 24    	mov.w     #0x41c4, w14
    f9c8:	ab ca b3    	mov.b     #0xaa, w11
    f9ca:	b2 00 37    	bra       0xfb30 <.L58>

0000f9cc <.L26>:
    f9cc:	e3 0f 50    	sub.w     w0, #0x3, [w15]
    f9ce:	10 00 32    	bra       Z, 0xf9f0 <.L30>
    f9d0:	04 00 3e    	bra       GTU, 0xf9da <.L34>
    f9d2:	e1 0f 50    	sub.w     w0, #0x1, [w15]
    f9d4:	27 00 32    	bra       Z, 0xfa24 <.L28>
    f9d6:	39 00 3e    	bra       GTU, 0xfa4a <.L29>
    f9d8:	0f 00 37    	bra       0xf9f8 <.L60>

0000f9da <.L34>:
    f9da:	e5 0f 50    	sub.w     w0, #0x5, [w15]
    f9dc:	7d 00 32    	bra       Z, 0xfad8 <.L0> <.L0> <.L32>
    f9de:	03 00 39    	bra       NC, 0xf9e6 <.L31>
    f9e0:	e6 0f 50    	sub.w     w0, #0x6, [w15]
    f9e2:	f4 ff 3a    	bra       NZ, 0xf9cc <.L26>
    f9e4:	8a 00 37    	bra       0xfafa <.L61>

0000f9e6 <.L31>:
    f9e6:	b0 0a 82    	mov.w     0x4156, w0
    f9e8:	03 05 82    	mov.w     0x40a0, w3
    f9ea:	83 0f 50    	sub.w     w0, w3, [w15]
    f9ec:	5b 00 39    	bra       NC, 0xfaa4 <.L35>
    f9ee:	68 00 37    	bra       0xfac0 <.L36>

0000f9f0 <.L30>:
    f9f0:	b0 0a 82    	mov.w     0x4156, w0
    f9f2:	fb 0f 50    	sub.w     w0, #0x1b, [w15]
    f9f4:	3e 00 36    	bra       LEU, 0xfa72 <.L37>
    f9f6:	4b 00 37    	bra       0xfa8e <.L38>

0000f9f8 <.L60>:
    f9f8:	00 00 eb    	clr.w     w0
    f9fa:	c0 0a 8a    	mov.w     w0, 0x4158
    f9fc:	b0 0a 8a    	mov.w     w0, 0x4156
    f9fe:	00 05 8a    	mov.w     w0, 0x40a0
    fa00:	60 00 b8    	mul.uu    w0, #0x0, w0
    fa02:	e0 04 8a    	mov.w     w0, 0x409c
    fa04:	f1 04 8a    	mov.w     w1, 0x409e
    fa06:	03 00 37    	bra       0xfa0e <.L39>

0000fa08 <.L41>:
    fa08:	08 44 e9    	dec.b     w8, w8
    fa0a:	96 00 32    	bra       Z, 0xfb38 <.L24>
    fa0c:	89 44 e8    	inc.b     w9, w9

0000fa0e <.L39>:
    fa0e:	09 80 fb    	ze        w9, w0
    fa10:	00 00 45    	add.w     w10, w0, w0
    fa12:	90 cf 15    	subr.b    w11, [w0], [w15]
    fa14:	f9 ff 3a    	bra       NZ, 0xfa08 <.L41>
    fa16:	0b 4e 78    	mov.b     w11, [w12]
    fa18:	10 00 20    	mov.w     #0x1, w0
    fa1a:	b0 0a 8a    	mov.w     w0, 0x4156
    fa1c:	89 44 e8    	inc.b     w9, w9
    fa1e:	08 44 e9    	dec.b     w8, w8
    fa20:	d0 0a 8a    	mov.w     w0, 0x415a
    fa22:	86 00 37    	bra       0xfb30 <.L58>

0000fa24 <.L28>:
    fa24:	89 80 fb    	ze        w9, w1
    fa26:	81 00 45    	add.w     w10, w1, w1
    fa28:	40 c4 b3    	mov.b     #0x44, w0
    fa2a:	91 4f 10    	subr.b    w0, [w1], [w15]
    fa2c:	03 00 32    	bra       Z, 0xfa34 <.L43>
    fa2e:	00 00 eb    	clr.w     w0
    fa30:	d0 0a 8a    	mov.w     w0, 0x415a
    fa32:	7e 00 37    	bra       0xfb30 <.L58>

0000fa34 <.L43>:
    fa34:	89 44 e8    	inc.b     w9, w9
    fa36:	08 44 e9    	dec.b     w8, w8
    fa38:	b0 0a 82    	mov.w     0x4156, w0
    fa3a:	80 00 46    	add.w     w12, w0, w1
    fa3c:	42 c4 b3    	mov.b     #0x44, w2
    fa3e:	82 48 78    	mov.b     w2, [w1]
    fa40:	00 00 e8    	inc.w     w0, w0
    fa42:	b0 0a 8a    	mov.w     w0, 0x4156
    fa44:	20 00 20    	mov.w     #0x2, w0
    fa46:	d0 0a 8a    	mov.w     w0, 0x415a
    fa48:	73 00 37    	bra       0xfb30 <.L58>

0000fa4a <.L29>:
    fa4a:	09 80 fb    	ze        w9, w0
    fa4c:	00 00 45    	add.w     w10, w0, w0
    fa4e:	21 c1 b3    	mov.b     #0x12, w1
    fa50:	90 cf 10    	subr.b    w1, [w0], [w15]
    fa52:	04 00 32    	bra       Z, 0xfa5c <.L44>
    fa54:	00 00 eb    	clr.w     w0
    fa56:	d0 0a 8a    	mov.w     w0, 0x415a
    fa58:	b0 0a 8a    	mov.w     w0, 0x4156
    fa5a:	6a 00 37    	bra       0xfb30 <.L58>

0000fa5c <.L44>:
    fa5c:	89 44 e8    	inc.b     w9, w9
    fa5e:	08 44 e9    	dec.b     w8, w8
    fa60:	b0 0a 82    	mov.w     0x4156, w0
    fa62:	80 00 46    	add.w     w12, w0, w1
    fa64:	22 c1 b3    	mov.b     #0x12, w2
    fa66:	82 48 78    	mov.b     w2, [w1]
    fa68:	00 00 e8    	inc.w     w0, w0
    fa6a:	b0 0a 8a    	mov.w     w0, 0x4156
    fa6c:	30 00 20    	mov.w     #0x3, w0
    fa6e:	d0 0a 8a    	mov.w     w0, 0x415a
    fa70:	5f 00 37    	bra       0xfb30 <.L58>

0000fa72 <.L37>:
    fa72:	80 00 e9    	dec.w     w0, w1
    fa74:	8c 80 40    	add.w     w1, w12, w1

0000fa76 <.L46>:
    fa76:	09 81 fb    	ze        w9, w2
    fa78:	02 01 45    	add.w     w10, w2, w2
    fa7a:	92 68 78    	mov.b     [w2], [++w1]
    fa7c:	00 00 e8    	inc.w     w0, w0
    fa7e:	89 44 e8    	inc.b     w9, w9
    fa80:	08 44 e9    	dec.b     w8, w8
    fa82:	02 00 3a    	bra       NZ, 0xfa88 <.L45>
    fa84:	b0 0a 8a    	mov.w     w0, 0x4156
    fa86:	03 00 37    	bra       0xfa8e <.L38>

0000fa88 <.L45>:
    fa88:	fb 0f 50    	sub.w     w0, #0x1b, [w15]
    fa8a:	f5 ff 36    	bra       LEU, 0xfa76 <.L46>
    fa8c:	b0 0a 8a    	mov.w     w0, 0x4156

0000fa8e <.L38>:
    fa8e:	b0 0a 82    	mov.w     0x4156, w0
    fa90:	fc 0f 50    	sub.w     w0, #0x1c, [w15]
    fa92:	4e 00 3a    	bra       NZ, 0xfb30 <.L58>
    fa94:	40 00 20    	mov.w     #0x4, w0
    fa96:	d0 0a 8a    	mov.w     w0, 0x415a

0000fa98 <.L0>:
    fa98:	a0 0a 24    	mov.w     #0x40aa, w0
    fa9a:	9b fe 07    	rcall     0xf7d2 <_charsToUint16> <L0> <.LFB1472> <.LFE1471>
    fa9c:	c0 0a 8a    	mov.w     w0, 0x4158

0000fa9e <.L0>:
    fa9e:	00 02 b0    	add.w     #0x20, w0
    faa0:	00 05 8a    	mov.w     w0, 0x40a0
    faa2:	46 00 37    	bra       0xfb30 <.L58>

0000faa4 <.L35>:
    faa4:	80 00 e9    	dec.w     w0, w1
    faa6:	8c 80 40    	add.w     w1, w12, w1

0000faa8 <.L48>:
    faa8:	09 81 fb    	ze        w9, w2
    faaa:	02 01 45    	add.w     w10, w2, w2
    faac:	92 68 78    	mov.b     [w2], [++w1]
    faae:	00 00 e8    	inc.w     w0, w0
    fab0:	89 44 e8    	inc.b     w9, w9
    fab2:	08 44 e9    	dec.b     w8, w8
    fab4:	02 00 3a    	bra       NZ, 0xfaba <.L47>
    fab6:	b0 0a 8a    	mov.w     w0, 0x4156
    fab8:	03 00 37    	bra       0xfac0 <.L36>

0000faba <.L47>:
    faba:	83 0f 50    	sub.w     w0, w3, [w15]
    fabc:	f5 ff 39    	bra       NC, 0xfaa8 <.L48>
    fabe:	b0 0a 8a    	mov.w     w0, 0x4156

0000fac0 <.L36>:
    fac0:	b0 0a 82    	mov.w     0x4156, w0
    fac2:	01 05 82    	mov.w     0x40a0, w1
    fac4:	81 0f 50    	sub.w     w0, w1, [w15]
    fac6:	34 00 3a    	bra       NZ, 0xfb30 <.L58>
    fac8:	51 00 20    	mov.w     #0x5, w1
    faca:	d1 0a 8a    	mov.w     w1, 0x415a

0000facc <.L0>:
    facc:	64 00 50    	sub.w     w0, #0x4, w0
    face:	0c 00 40    	add.w     w0, w12, w0
    fad0:	85 fe 07    	rcall     0xf7dc <_charsToUint32> <L0> <.LFB1473> <.LFE1472>
    fad2:	e0 04 8a    	mov.w     w0, 0x409c
    fad4:	f1 04 8a    	mov.w     w1, 0x409e
    fad6:	2c 00 37    	bra       0xfb30 <.L58>

0000fad8 <.L0>:
    fad8:	b0 0a 82    	mov.w     0x4156, w0
    fada:	64 00 50    	sub.w     w0, #0x4, w0
    fadc:	80 00 eb    	clr.w     w1
    fade:	0c 01 78    	mov.w     w12, w2
    fae0:	5b fe 07    	rcall     0xf798 <_CalculateBlockCRC32> <L0> <.LFB1471> <.LFE1470>
    fae2:	e2 04 82    	mov.w     0x409c, w2
    fae4:	f3 04 82    	mov.w     0x409e, w3
    fae6:	82 0f 50    	sub.w     w0, w2, [w15]
    fae8:	83 8f 58    	subb.w    w1, w3, [w15]
    faea:	03 00 3a    	bra       NZ, 0xfaf2 <.L49>

0000faec <.L0>:
    faec:	60 00 20    	mov.w     #0x6, w0
    faee:	d0 0a 8a    	mov.w     w0, 0x415a
    faf0:	1f 00 37    	bra       0xfb30 <.L58>

0000faf2 <.L49>:
    faf2:	1e 0f e8    	inc.w     [w14], [w14]
    faf4:	00 00 eb    	clr.w     w0
    faf6:	d0 0a 8a    	mov.w     w0, 0x415a
    faf8:	1b 00 37    	bra       0xfb30 <.L58>

0000fafa <.L61>:
    fafa:	70 0a 24    	mov.w     #0x40a7, w0
    fafc:	90 86 fb    	ze        [w0], w13
    fafe:	c8 6e dd    	sl.w      w13, #0x8, w13
    fb00:	80 00 e9    	dec.w     w0, w1
    fb02:	11 80 fb    	ze        [w1], w0
    fb04:	80 86 76    	ior.w     w13, w0, w13

0000fb06 <.L0>:
    fb06:	0c 00 78    	mov.w     w12, w0
    fb08:	f5 fd 07    	rcall     0xf6f4 <_updateStatus> <L0> <.LFB1465> <.LFE1463>

0000fb0a <.L0>:
    fb0a:	30 06 20    	mov.w     #0x63, w0
    fb0c:	80 8f 56    	sub.w     w13, w0, [w15]
    fb0e:	09 00 32    	bra       Z, 0xfb22 <.L0> <.L52>
    fb10:	00 80 e8    	inc2.w    w0, w0
    fb12:	80 8f 56    	sub.w     w13, w0, [w15]
    fb14:	09 00 32    	bra       Z, 0xfb28 <.L0> <.L53>
    fb16:	a0 02 20    	mov.w     #0x2a, w0
    fb18:	80 8f 56    	sub.w     w13, w0, [w15]
    fb1a:	08 00 3a    	bra       NZ, 0xfb2c <.L0> <.L50>

0000fb1c <.L0>:
    fb1c:	0c 00 78    	mov.w     w12, w0
    fb1e:	f6 fe 07    	rcall     0xf90c <_updatePositionData> <L0> <.LFB1466> <.LFE1467>

0000fb20 <.L0>:
    fb20:	05 00 37    	bra       0xfb2c <.L0> <.L50>

0000fb22 <.L0>:
    fb22:	0c 00 78    	mov.w     w12, w0
    fb24:	cb fe 07    	rcall     0xf8bc <_updateVelocityData> <L0> <.LFB1467> <.LFE1475>

0000fb26 <.L0>:
    fb26:	02 00 37    	bra       0xfb2c <.L0> <.L50>

0000fb28 <.L0>:
    fb28:	0c 00 78    	mov.w     w12, w0
    fb2a:	68 fe 07    	rcall     0xf7fc <_updateTimeData> <L0> <.LFB1468> <.LFE1473>

0000fb2c <.L0>:
    fb2c:	00 00 eb    	clr.w     w0
    fb2e:	d0 0a 8a    	mov.w     w0, 0x415a

0000fb30 <.L58>:
    fb30:	08 04 e0    	cp0.b     w8
    fb32:	02 00 32    	bra       Z, 0xfb38 <.L24>
    fb34:	d0 0a 82    	mov.w     0x415a, w0
    fb36:	4a ff 37    	bra       0xf9cc <.L26>

0000fb38 <.L24>:
    fb38:	4f 07 78    	mov.w     [--w15], w14
    fb3a:	4f 06 be    	mov.d     [--w15], w12
    fb3c:	4f 05 be    	mov.d     [--w15], w10
    fb3e:	4f 04 be    	mov.d     [--w15], w8
    fb40:	00 00 06    	return    

0000fb42 <_updateRawADCData>:

#include "updateSensorMcuState.h"
extern float myPow(float x, float toTheN);

void updateRawADCData(int16_t* adcData) {
    fb42:	ea 87 47    	add.w     w15, #0xa, w15
    fb44:	88 9f be    	mov.d     w8, [w15++]
    fb46:	8a 9f be    	mov.d     w10, [w15++]
    fb48:	8c 9f be    	mov.d     w12, [w15++]
    fb4a:	8e 1f 78    	mov.w     w14, [w15++]
	float T, p, r, h,v;

    //mlRawPressureData.time_usec = mlAttitudeData.time_boot_ms; // set by updateTimestamp()
    mlRawPressureData.press_abs = (int16_t) adcData[0]; // Baro
    fb4c:	ee 0b 21    	mov.w     #0x10be, w14
    fb4e:	10 0f 78    	mov.w     [w0], [w14]
    mlRawPressureData.press_diff1 = (int16_t) adcData[1]; // Pito
    fb50:	10 01 90    	mov.w     [w0+2], w2
    fb52:	8e 80 e8    	inc2.w    w14, w1
    fb54:	82 08 78    	mov.w     w2, [w1]
    mlRawPressureData.press_diff2 = (int16_t) adcData[2]; // Power
    fb56:	a0 01 90    	mov.w     [w0+4], w3
    fb58:	13 86 88    	mov.w     w3, 0x10c2
    mlRawPressureData.temperature = (int16_t) adcData[3]; // Temp
    fb5a:	30 00 90    	mov.w     [w0+6], w0
    fb5c:	e4 80 40    	add.w     w1, #0x4, w1
    fb5e:	80 08 78    	mov.w     w0, [w1]

0000fb60 <.L0>:
	//SLUGS2
	h = (float)((float)(mlGpsData.alt) / 1000.0f);
    fb60:	50 83 80    	mov.w     0x106a, w0
    fb62:	61 83 80    	mov.w     0x106c, w1
    fb64:	0c 19 02    	call      0x190c <___floatsisf>
    fb66:	00 00 00 
    fb68:	02 00 20    	mov.w     #0x0, w2
    fb6a:	a3 47 24    	mov.w     #0x447a, w3
    fb6c:	26 17 02    	call      0x1726 <___divsf3>
    fb6e:	00 00 00 

0000fb70 <.L0>:
	T = (float)(15.04f - .00649f * h);
    fb70:	12 a1 2a    	mov.w     #0xaa11, w2
    fb72:	43 bd 23    	mov.w     #0x3bd4, w3
    fb74:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fb76:	00 00 00 
    fb78:	00 01 be    	mov.d     w0, w2
    fb7a:	70 3d 2a    	mov.w     #0xa3d7, w0
    fb7c:	01 17 24    	mov.w     #0x4170, w1
    fb7e:	90 14 02    	call      0x1490 <___subsf3>
    fb80:	00 00 00 
    fb82:	00 04 be    	mov.d     w0, w8

0000fb84 <.L0>:
	p = (float)(101.29f *myPow((T + 273.1f) / 288.08f, 5.256f) * 1000.0f); //pascal
    fb84:	d2 cc 28    	mov.w     #0x8ccd, w2
    fb86:	83 38 24    	mov.w     #0x4388, w3
    fb88:	92 14 02    	call      0x1492 <___addsf3>
    fb8a:	00 00 00 
    fb8c:	00 06 be    	mov.d     w0, w12
    fb8e:	d2 a3 20    	mov.w     #0xa3d, w2
    fb90:	03 39 24    	mov.w     #0x4390, w3
    fb92:	26 17 02    	call      0x1726 <___divsf3>
    fb94:	00 00 00 
    fb96:	72 12 23    	mov.w     #0x3127, w2
    fb98:	83 0a 24    	mov.w     #0x40a8, w3
    fb9a:	10 10 02    	call      0x11010 <_myPow>
    fb9c:	01 00 00 
    fb9e:	b2 47 29    	mov.w     #0x947b, w2
    fba0:	a3 2c 24    	mov.w     #0x42ca, w3
    fba2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fba4:	00 00 00 
    fba6:	02 00 20    	mov.w     #0x0, w2
    fba8:	a3 47 24    	mov.w     #0x447a, w3
    fbaa:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fbac:	00 00 00 
    fbae:	00 05 be    	mov.d     w0, w10

0000fbb0 <.L0>:
	r = (float)(p / (.2869f * (T + 273.1f)));
    fbb0:	f2 48 2e    	mov.w     #0xe48f, w2
    fbb2:	23 e9 23    	mov.w     #0x3e92, w3
    fbb4:	0c 00 be    	mov.d     w12, w0
    fbb6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fbb8:	00 00 00 
    fbba:	00 01 be    	mov.d     w0, w2
    fbbc:	0a 00 be    	mov.d     w10, w0
    fbbe:	26 17 02    	call      0x1726 <___divsf3>
    fbc0:	00 00 00 
    fbc2:	f0 b7 9f    	mov.w     w0, [w15-18]
    fbc4:	81 bf 9f    	mov.w     w1, [w15-16]

0000fbc6 <.L0>:
	v = (float)((float)(mlGpsData.vel) / 100.0f);
    fbc6:	90 83 80    	mov.w     0x1072, w0
    fbc8:	80 00 eb    	clr.w     w1
    fbca:	12 19 02    	call      0x1912 <___floatunsisf>
    fbcc:	00 00 00 
    fbce:	02 00 20    	mov.w     #0x0, w2
    fbd0:	83 2c 24    	mov.w     #0x42c8, w3
    fbd2:	26 17 02    	call      0x1726 <___divsf3>
    fbd4:	00 00 00 
    fbd6:	00 06 be    	mov.d     w0, w12

0000fbd8 <.L0>:

	mlRawPressureData.press_abs = (p - 9444.4) / 27.1270; //convert to static pressure in Pascal / baroScale
    fbd8:	a2 19 29    	mov.w     #0x919a, w2
    fbda:	33 61 24    	mov.w     #0x4613, w3
    fbdc:	0a 00 be    	mov.d     w10, w0
    fbde:	90 14 02    	call      0x1490 <___subsf3>
    fbe0:	00 00 00 
    fbe2:	92 41 20    	mov.w     #0x419, w2
    fbe4:	93 1d 24    	mov.w     #0x41d9, w3
    fbe6:	26 17 02    	call      0x1726 <___divsf3>
    fbe8:	00 00 00 
    fbea:	94 18 02    	call      0x1894 <___fixsfsi>
    fbec:	00 00 00 
    fbee:	00 0f 78    	mov.w     w0, [w14]

0000fbf0 <.L0>:
	mlRawPressureData.press_diff1 = (1 / 2 * r * myPow(v, 2) + 1005.9) / 1.0514;//pitotScale
    fbf0:	02 00 20    	mov.w     #0x0, w2
    fbf2:	03 00 24    	mov.w     #0x4000, w3
    fbf4:	0c 00 be    	mov.d     w12, w0
    fbf6:	10 10 02    	call      0x11010 <_myPow>
    fbf8:	01 00 00 
    fbfa:	d0 b7 9f    	mov.w     w0, [w15-22]
    fbfc:	e1 b7 9f    	mov.w     w1, [w15-20]
    fbfe:	60 11 b8    	mul.uu    w2, #0x0, w2
    fc00:	7f b0 97    	mov.w     [w15-18], w0
    fc02:	8f b8 97    	mov.w     [w15-16], w1
    fc04:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fc06:	00 00 00 
    fc08:	5f b1 97    	mov.w     [w15-22], w2
    fc0a:	ef b1 97    	mov.w     [w15-20], w3
    fc0c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fc0e:	00 00 00 
    fc10:	a2 99 27    	mov.w     #0x799a, w2
    fc12:	b3 47 24    	mov.w     #0x447b, w3
    fc14:	92 14 02    	call      0x1492 <___addsf3>
    fc16:	00 00 00 
    fc18:	62 44 29    	mov.w     #0x9446, w2
    fc1a:	63 f8 23    	mov.w     #0x3f86, w3
    fc1c:	26 17 02    	call      0x1726 <___divsf3>
    fc1e:	00 00 00 
    fc20:	94 18 02    	call      0x1894 <___fixsfsi>
    fc22:	00 00 00 
    fc24:	8e 81 e8    	inc2.w    w14, w3
    fc26:	80 09 78    	mov.w     w0, [w3]

0000fc28 <.L0>:
	mlRawPressureData.temperature = (T + 1605.3) / 1.5113;
    fc28:	a2 99 2a    	mov.w     #0xa99a, w2
    fc2a:	83 4c 24    	mov.w     #0x44c8, w3
    fc2c:	08 00 be    	mov.d     w8, w0
    fc2e:	92 14 02    	call      0x1492 <___addsf3>
    fc30:	00 00 00 
    fc32:	72 24 27    	mov.w     #0x7247, w2
    fc34:	13 fc 23    	mov.w     #0x3fc1, w3
    fc36:	26 17 02    	call      0x1726 <___divsf3>
    fc38:	00 00 00 
    fc3a:	94 18 02    	call      0x1894 <___fixsfsi>
    fc3c:	00 00 00 
    fc3e:	66 01 47    	add.w     w14, #0x6, w2
    fc40:	00 09 78    	mov.w     w0, [w2]

0000fc42 <.L0>:
	
	mlAirData.press_diff = (float)((r * myPow(v, 2)) / 2.0f / 100.0f);//hectopascal (1 hPa = 100 Pa)
    fc42:	02 00 20    	mov.w     #0x0, w2
    fc44:	03 00 24    	mov.w     #0x4000, w3
    fc46:	0c 00 be    	mov.d     w12, w0
    fc48:	10 10 02    	call      0x11010 <_myPow>
    fc4a:	01 00 00 
    fc4c:	7f b1 97    	mov.w     [w15-18], w2
    fc4e:	8f b9 97    	mov.w     [w15-16], w3
    fc50:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fc52:	00 00 00 
    fc54:	02 00 20    	mov.w     #0x0, w2
    fc56:	03 f0 23    	mov.w     #0x3f00, w3
    fc58:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fc5a:	00 00 00 
    fc5c:	02 00 20    	mov.w     #0x0, w2
    fc5e:	83 2c 24    	mov.w     #0x42c8, w3
    fc60:	26 17 02    	call      0x1726 <___divsf3>
    fc62:	00 00 00 
    fc64:	00 84 88    	mov.w     w0, 0x1080
    fc66:	11 84 88    	mov.w     w1, 0x1082

0000fc68 <.L0>:
	mlAirData.press_abs = (float)((p) / 100.0f);//hectopascal (1 hPa = 100 Pa)
    fc68:	02 00 20    	mov.w     #0x0, w2
    fc6a:	83 2c 24    	mov.w     #0x42c8, w3
    fc6c:	0a 00 be    	mov.d     w10, w0
    fc6e:	26 17 02    	call      0x1726 <___divsf3>
    fc70:	00 00 00 
    fc72:	e0 83 88    	mov.w     w0, 0x107c
    fc74:	f1 83 88    	mov.w     w1, 0x107e

0000fc76 <.L0>:
	mlAirData.temperature = (int16_t)(T * 100.0f);//0.01 degrees celsius
    fc76:	02 00 20    	mov.w     #0x0, w2
    fc78:	83 2c 24    	mov.w     #0x42c8, w3
    fc7a:	08 00 be    	mov.d     w8, w0
    fc7c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fc7e:	00 00 00 
    fc80:	94 18 02    	call      0x1894 <___fixsfsi>
    fc82:	00 00 00 
    fc84:	20 84 88    	mov.w     w0, 0x1084

0000fc86 <.L0>:
}
    fc86:	4f 07 78    	mov.w     [--w15], w14
    fc88:	4f 06 be    	mov.d     [--w15], w12
    fc8a:	4f 05 be    	mov.d     [--w15], w10
    fc8c:	4f 04 be    	mov.d     [--w15], w8
    fc8e:	af 00 b1    	sub.w     #0xa, w15
    fc90:	00 00 06    	return    

0000fc92 <_updateAirData>:

void updateAirData(float* airData) {
    fc92:	e6 87 47    	add.w     w15, #0x6, w15
    fc94:	88 9f be    	mov.d     w8, [w15++]
    fc96:	8a 9f be    	mov.d     w10, [w15++]
    fc98:	8c 9f be    	mov.d     w12, [w15++]
    fc9a:	8e 1f 78    	mov.w     w14, [w15++]
    fc9c:	00 07 78    	mov.w     w0, w14

0000fc9e <.L0>:
	//SLUGS2
	float T, p, r, h,v;

	h = (float)((float)(mlGpsData.alt) / 1000.0f);
    fc9e:	50 83 80    	mov.w     0x106a, w0
    fca0:	61 83 80    	mov.w     0x106c, w1
    fca2:	0c 19 02    	call      0x190c <___floatsisf>
    fca4:	00 00 00 
    fca6:	02 00 20    	mov.w     #0x0, w2
    fca8:	a3 47 24    	mov.w     #0x447a, w3
    fcaa:	26 17 02    	call      0x1726 <___divsf3>
    fcac:	00 00 00 

0000fcae <.L0>:
	T = (float)(15.04f - .00649f * h);
    fcae:	12 a1 2a    	mov.w     #0xaa11, w2
    fcb0:	43 bd 23    	mov.w     #0x3bd4, w3
    fcb2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fcb4:	00 00 00 
    fcb6:	00 01 be    	mov.d     w0, w2
    fcb8:	70 3d 2a    	mov.w     #0xa3d7, w0
    fcba:	01 17 24    	mov.w     #0x4170, w1
    fcbc:	90 14 02    	call      0x1490 <___subsf3>
    fcbe:	00 00 00 
    fcc0:	00 05 be    	mov.d     w0, w10

0000fcc2 <.L0>:
	p = (float)(101.29f *myPow((T + 273.1f) / 288.08f, 5.256f) * 1000.0f); //pascal
    fcc2:	d2 cc 28    	mov.w     #0x8ccd, w2
    fcc4:	83 38 24    	mov.w     #0x4388, w3
    fcc6:	92 14 02    	call      0x1492 <___addsf3>
    fcc8:	00 00 00 
    fcca:	00 04 be    	mov.d     w0, w8
    fccc:	d2 a3 20    	mov.w     #0xa3d, w2
    fcce:	03 39 24    	mov.w     #0x4390, w3
    fcd0:	26 17 02    	call      0x1726 <___divsf3>
    fcd2:	00 00 00 
    fcd4:	72 12 23    	mov.w     #0x3127, w2
    fcd6:	83 0a 24    	mov.w     #0x40a8, w3
    fcd8:	10 10 02    	call      0x11010 <_myPow>
    fcda:	01 00 00 
    fcdc:	b2 47 29    	mov.w     #0x947b, w2
    fcde:	a3 2c 24    	mov.w     #0x42ca, w3
    fce0:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fce2:	00 00 00 
    fce4:	02 00 20    	mov.w     #0x0, w2
    fce6:	a3 47 24    	mov.w     #0x447a, w3
    fce8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fcea:	00 00 00 
    fcec:	00 06 be    	mov.d     w0, w12

0000fcee <.L0>:
	r = (float)(p / (.2869f * (T + 273.1f)));
	v = (float)((float)(mlGpsData.vel) / 100.0f);
    fcee:	90 83 80    	mov.w     0x1072, w0
    fcf0:	80 00 eb    	clr.w     w1
    fcf2:	12 19 02    	call      0x1912 <___floatunsisf>
    fcf4:	00 00 00 
    fcf6:	02 00 20    	mov.w     #0x0, w2
    fcf8:	83 2c 24    	mov.w     #0x42c8, w3
    fcfa:	26 17 02    	call      0x1726 <___divsf3>
    fcfc:	00 00 00 
    fcfe:	f0 b7 9f    	mov.w     w0, [w15-18]
    fd00:	81 bf 9f    	mov.w     w1, [w15-16]

0000fd02 <.L0>:

	

    //mlAirData.time_boot_ms = mlAttitudeData.time_boot_ms; // set by updateTimestamp()
    mlAirData.press_diff = airData[0]; //dynamic
    fd02:	03 08 21    	mov.w     #0x1080, w3
    fd04:	be 19 78    	mov.w     [w14++], [w3++]
    fd06:	ae 11 78    	mov.w     [w14--], [w3--]
    mlAirData.press_abs = airData[1]; //static
    fd08:	2e 00 90    	mov.w     [w14+4], w0
    fd0a:	be 00 90    	mov.w     [w14+6], w1
    fd0c:	64 81 51    	sub.w     w3, #0x4, w2
    fd0e:	00 89 be    	mov.d     w0, [w2]

0000fd10 <.L0>:
    mlAirData.temperature = (int16_t) (airData[2]*10.0); // temp 0.01
    fd10:	02 00 20    	mov.w     #0x0, w2
    fd12:	03 12 24    	mov.w     #0x4120, w3
    fd14:	4e 00 90    	mov.w     [w14+8], w0
    fd16:	de 00 90    	mov.w     [w14+10], w1
    fd18:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fd1a:	00 00 00 
    fd1c:	94 18 02    	call      0x1894 <___fixsfsi>
    fd1e:	00 00 00 
    fd20:	43 08 21    	mov.w     #0x1084, w3
    fd22:	80 09 78    	mov.w     w0, [w3]

0000fd24 <.L0>:

	//SLUGS2
	mlAirData.press_diff = (float)((r * myPow(v, 2)) / 2.0f / 100.0f);//hectopascal (1 hPa = 100 Pa)
    fd24:	02 00 20    	mov.w     #0x0, w2
    fd26:	03 00 24    	mov.w     #0x4000, w3
    fd28:	7f b0 97    	mov.w     [w15-18], w0
    fd2a:	8f b8 97    	mov.w     [w15-16], w1
    fd2c:	10 10 02    	call      0x11010 <_myPow>
    fd2e:	01 00 00 
    fd30:	f0 b7 9f    	mov.w     w0, [w15-18]
    fd32:	81 bf 9f    	mov.w     w1, [w15-16]

0000fd34 <.L0>:
    fd34:	f2 48 2e    	mov.w     #0xe48f, w2
    fd36:	23 e9 23    	mov.w     #0x3e92, w3
    fd38:	08 00 be    	mov.d     w8, w0
    fd3a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fd3c:	00 00 00 
    fd3e:	00 01 be    	mov.d     w0, w2
    fd40:	0c 00 be    	mov.d     w12, w0
    fd42:	26 17 02    	call      0x1726 <___divsf3>
    fd44:	00 00 00 
    fd46:	00 01 be    	mov.d     w0, w2

0000fd48 <.L0>:
    fd48:	7f b0 97    	mov.w     [w15-18], w0
    fd4a:	8f b8 97    	mov.w     [w15-16], w1
    fd4c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fd4e:	00 00 00 
    fd50:	02 00 20    	mov.w     #0x0, w2
    fd52:	03 f0 23    	mov.w     #0x3f00, w3
    fd54:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fd56:	00 00 00 
    fd58:	02 00 20    	mov.w     #0x0, w2
    fd5a:	83 2c 24    	mov.w     #0x42c8, w3
    fd5c:	26 17 02    	call      0x1726 <___divsf3>
    fd5e:	00 00 00 
    fd60:	03 08 21    	mov.w     #0x1080, w3
    fd62:	80 89 be    	mov.d     w0, [w3]

0000fd64 <.L0>:
	mlAirData.press_abs = (float)((p) / 100.0f);//hectopascal (1 hPa = 100 Pa)
    fd64:	02 00 20    	mov.w     #0x0, w2
    fd66:	83 2c 24    	mov.w     #0x42c8, w3
    fd68:	0c 00 be    	mov.d     w12, w0
    fd6a:	26 17 02    	call      0x1726 <___divsf3>
    fd6c:	00 00 00 
    fd6e:	c2 07 21    	mov.w     #0x107c, w2
    fd70:	00 89 be    	mov.d     w0, [w2]

0000fd72 <.L0>:
	mlAirData.temperature = (int16_t)(T * 100.0f);//0.01 degrees celsius
    fd72:	02 00 20    	mov.w     #0x0, w2
    fd74:	83 2c 24    	mov.w     #0x42c8, w3
    fd76:	0a 00 be    	mov.d     w10, w0
    fd78:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fd7a:	00 00 00 
    fd7c:	94 18 02    	call      0x1894 <___fixsfsi>
    fd7e:	00 00 00 
    fd80:	43 08 21    	mov.w     #0x1084, w3
    fd82:	80 09 78    	mov.w     w0, [w3]

0000fd84 <.L0>:
}
    fd84:	4f 07 78    	mov.w     [--w15], w14
    fd86:	4f 06 be    	mov.d     [--w15], w12
    fd88:	4f 05 be    	mov.d     [--w15], w10
    fd8a:	4f 04 be    	mov.d     [--w15], w8
    fd8c:	6f 00 b1    	sub.w     #0x6, w15
    fd8e:	00 00 06    	return    

0000fd90 <_updateLoadData>:



void updateLoadData(uint8_t load, uint16_t mvPower) {
    mlCpuLoadData.sensLoad = load;
    fd90:	e2 15 24    	mov.w     #0x415e, w2
    fd92:	00 49 78    	mov.b     w0, [w2]
    mlCpuLoadData.batVolt = mvPower;
    fd94:	e1 0a 8a    	mov.w     w1, 0x415c
}
    fd96:	00 00 06    	return    

0000fd98 <_updateAttitude>:

void updateAttitude(float * attitudeData) {

    mlAttitudeData.roll = attitudeData[0];
    fd98:	10 01 be    	mov.d     [w0], w2
    fd9a:	52 86 88    	mov.w     w2, 0x10ca
    fd9c:	63 86 88    	mov.w     w3, 0x10cc
    mlAttitudeData.pitch = attitudeData[1];
    fd9e:	20 01 90    	mov.w     [w0+4], w2
    fda0:	b0 01 90    	mov.w     [w0+6], w3
    fda2:	72 86 88    	mov.w     w2, 0x10ce
    fda4:	83 86 88    	mov.w     w3, 0x10d0
    mlAttitudeData.yaw = attitudeData[2];
    fda6:	40 01 90    	mov.w     [w0+8], w2
    fda8:	d0 01 90    	mov.w     [w0+10], w3
    fdaa:	92 86 88    	mov.w     w2, 0x10d2
    fdac:	a3 86 88    	mov.w     w3, 0x10d4
    mlAttitudeData.rollspeed = attitudeData[3];
    fdae:	60 01 90    	mov.w     [w0+12], w2
    fdb0:	f0 01 90    	mov.w     [w0+14], w3
    fdb2:	b2 86 88    	mov.w     w2, 0x10d6
    fdb4:	c3 86 88    	mov.w     w3, 0x10d8
    mlAttitudeData.pitchspeed = attitudeData[4];
    fdb6:	00 09 90    	mov.w     [w0+16], w2
    fdb8:	90 09 90    	mov.w     [w0+18], w3
    fdba:	d2 86 88    	mov.w     w2, 0x10da
    fdbc:	e3 86 88    	mov.w     w3, 0x10dc
    mlAttitudeData.yawspeed = attitudeData[5];
    fdbe:	20 09 90    	mov.w     [w0+20], w2
    fdc0:	b0 09 90    	mov.w     [w0+22], w3
    fdc2:	f2 86 88    	mov.w     w2, 0x10de
    fdc4:	03 87 88    	mov.w     w3, 0x10e0

}
    fdc6:	00 00 06    	return    

0000fdc8 <_getGSLocation>:

void getGSLocation(float* altLatLon) {
    fdc8:	88 1f 78    	mov.w     w8, [w15++]
    fdca:	00 04 78    	mov.w     w0, w8

0000fdcc <.L0>:

    altLatLon[0] = mlGSLocationFloat.alt * 0.001;
    fdcc:	f2 26 21    	mov.w     #0x126f, w2
    fdce:	33 a8 23    	mov.w     #0x3a83, w3
    fdd0:	30 88 80    	mov.w     0x1106, w0
    fdd2:	41 88 80    	mov.w     0x1108, w1
    fdd4:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fdd6:	00 00 00 
    fdd8:	00 8c be    	mov.d     w0, [w8]

0000fdda <.L0>:
    altLatLon[1] = mlGSLocationFloat.lat * 0.0000001;
    fdda:	52 f9 2b    	mov.w     #0xbf95, w2
    fddc:	63 3d 23    	mov.w     #0x33d6, w3
    fdde:	f0 87 80    	mov.w     0x10fe, w0
    fde0:	01 88 80    	mov.w     0x1100, w1
    fde2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fde4:	00 00 00 
    fde6:	20 04 98    	mov.w     w0, [w8+4]
    fde8:	31 04 98    	mov.w     w1, [w8+6]

0000fdea <.L0>:
    altLatLon[2] = mlGSLocationFloat.lon * 0.0000001;
    fdea:	52 f9 2b    	mov.w     #0xbf95, w2
    fdec:	63 3d 23    	mov.w     #0x33d6, w3
    fdee:	10 88 80    	mov.w     0x1102, w0
    fdf0:	21 88 80    	mov.w     0x1104, w1
    fdf2:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fdf4:	00 00 00 
    fdf6:	40 04 98    	mov.w     w0, [w8+8]
    fdf8:	51 04 98    	mov.w     w1, [w8+10]

0000fdfa <.L0>:
}
    fdfa:	4f 04 78    	mov.w     [--w15], w8
    fdfc:	00 00 06    	return    

0000fdfe <_updateTimeStamp>:

/* Simulink sends 10's of milliseconds since boot. */
void updateTimeStamp(uint32_t timeSt) {

    // Todo fix units later
    mlAirData.time_boot_ms = timeSt;
    fdfe:	c0 83 88    	mov.w     w0, 0x1078
    fe00:	d1 83 88    	mov.w     w1, 0x107a
    mlAttitudeData.time_boot_ms = timeSt;
    fe02:	30 86 88    	mov.w     w0, 0x10c6
    fe04:	41 86 88    	mov.w     w1, 0x10c8
    mlRawPressureData.time_usec = timeSt;
    fe06:	60 11 b8    	mul.uu    w2, #0x0, w2
    fe08:	64 0b 21    	mov.w     #0x10b6, w4
    fe0a:	00 9a be    	mov.d     w0, [w4++]
    fe0c:	02 92 be    	mov.d     w2, [w4--]

    /* Doesn't work:
    // Messages with time stamps in milliseconds
    uint32_t timeMs = timeSt*10;
    mlAirData.time_boot_ms = (uint64_t) timeMs;
    mlAttitudeData.time_boot_ms = timeMs;
    mlFilteredData.time_boot_ms = timeMs;
    mlLocalPositionData.time_boot_ms = timeMs;
    mlPilotConsoleData.time_boot_ms = timeMs;

    // Messages with time stamps in microseconds
    uint64_t timeUsec = timeSt*10000;
    mlGpsData.time_usec = timeUsec;
    mlRawImuData.time_usec = timeUsec;
    mlRawPressureData.time_usec = timeUsec;
    //mlPwmCommands.time_usec = timeSt; // this one is handled by control dsc
     * */
}
    fe0e:	00 00 06    	return    

0000fe10 <_updatePosition>:

void updatePosition(float * posData) {

    mlLocalPositionData.x = posData[0];
    fe10:	10 01 be    	mov.d     [w0], w2
    fe12:	32 87 88    	mov.w     w2, 0x10e6
    fe14:	43 87 88    	mov.w     w3, 0x10e8
    mlLocalPositionData.y = posData[1];
    fe16:	20 01 90    	mov.w     [w0+4], w2
    fe18:	b0 01 90    	mov.w     [w0+6], w3
    fe1a:	52 87 88    	mov.w     w2, 0x10ea
    fe1c:	63 87 88    	mov.w     w3, 0x10ec
    mlLocalPositionData.z = posData[2];
    fe1e:	40 01 90    	mov.w     [w0+8], w2
    fe20:	d0 01 90    	mov.w     [w0+10], w3
    fe22:	72 87 88    	mov.w     w2, 0x10ee
    fe24:	83 87 88    	mov.w     w3, 0x10f0
    mlLocalPositionData.vx = posData[3];
    fe26:	60 01 90    	mov.w     [w0+12], w2
    fe28:	f0 01 90    	mov.w     [w0+14], w3
    fe2a:	92 87 88    	mov.w     w2, 0x10f2
    fe2c:	a3 87 88    	mov.w     w3, 0x10f4
    mlLocalPositionData.vy = posData[4];
    fe2e:	00 09 90    	mov.w     [w0+16], w2
    fe30:	90 09 90    	mov.w     [w0+18], w3
    fe32:	b2 87 88    	mov.w     w2, 0x10f6
    fe34:	c3 87 88    	mov.w     w3, 0x10f8
    mlLocalPositionData.vz = posData[5];
    fe36:	20 09 90    	mov.w     [w0+20], w2
    fe38:	b0 09 90    	mov.w     [w0+22], w3
    fe3a:	d2 87 88    	mov.w     w2, 0x10fa
    fe3c:	e3 87 88    	mov.w     w3, 0x10fc
}
    fe3e:	00 00 06    	return    

0000fe40 <_updatePilotConsole>:

void updatePilotConsole(uint16_t * pilData) {
    // dT dA dR dE dFail

    mlPilotConsoleData.chan1_raw = pilData[0];
    fe40:	90 00 78    	mov.w     [w0], w1
    fe42:	51 84 88    	mov.w     w1, 0x108a
    mlPilotConsoleData.chan2_raw = pilData[1];
    fe44:	90 00 90    	mov.w     [w0+2], w1
    fe46:	61 84 88    	mov.w     w1, 0x108c
    mlPilotConsoleData.chan3_raw = pilData[2];
    fe48:	a0 00 90    	mov.w     [w0+4], w1
    fe4a:	71 84 88    	mov.w     w1, 0x108e
    mlPilotConsoleData.chan4_raw = pilData[3];
    fe4c:	b0 00 90    	mov.w     [w0+6], w1
    fe4e:	81 84 88    	mov.w     w1, 0x1090
    mlPilotConsoleData.chan5_raw = pilData[4];
    fe50:	40 00 90    	mov.w     [w0+8], w0
    fe52:	90 84 88    	mov.w     w0, 0x1092
}
    fe54:	00 00 06    	return    

0000fe56 <_updateDiagnosticFl>:

void updateDiagnosticFl(float* diagFl) {
    mlDiagnosticData.diagFl1 = diagFl[0];
    fe56:	10 01 be    	mov.d     [w0], w2
    fe58:	c2 0b 8a    	mov.w     w2, 0x4178
    fe5a:	d3 0b 8a    	mov.w     w3, 0x417a
    mlDiagnosticData.diagFl2 = diagFl[1];
    fe5c:	20 01 90    	mov.w     [w0+4], w2
    fe5e:	b0 01 90    	mov.w     [w0+6], w3
    fe60:	e2 0b 8a    	mov.w     w2, 0x417c
    fe62:	f3 0b 8a    	mov.w     w3, 0x417e
    mlDiagnosticData.diagFl3 = diagFl[2];
    fe64:	40 01 90    	mov.w     [w0+8], w2
    fe66:	d0 01 90    	mov.w     [w0+10], w3
    fe68:	02 0c 8a    	mov.w     w2, 0x4180
    fe6a:	13 0c 8a    	mov.w     w3, 0x4182
}
    fe6c:	00 00 06    	return    

0000fe6e <_updateDiagnosticSh>:

void updateDiagnosticSh(int16_t* diagSh) {
    mlDiagnosticData.diagSh1 = diagSh[0];
    fe6e:	90 00 78    	mov.w     [w0], w1
    fe70:	21 0c 8a    	mov.w     w1, 0x4184
    mlDiagnosticData.diagSh2 = diagSh[1];
    fe72:	90 00 90    	mov.w     [w0+2], w1
    fe74:	31 0c 8a    	mov.w     w1, 0x4186
    mlDiagnosticData.diagSh3 = diagSh[2];
    fe76:	20 00 90    	mov.w     [w0+4], w0
    fe78:	40 0c 8a    	mov.w     w0, 0x4188
}
    fe7a:	00 00 06    	return    

0000fe7c <_updateBias>:

void updateBias(float * biasData) {
    mlSensorBiasData.axBias = biasData[0];
    fe7c:	10 01 be    	mov.d     [w0], w2
    fe7e:	02 0b 8a    	mov.w     w2, 0x4160
    fe80:	13 0b 8a    	mov.w     w3, 0x4162
    mlSensorBiasData.ayBias = biasData[1];
    fe82:	20 01 90    	mov.w     [w0+4], w2
    fe84:	b0 01 90    	mov.w     [w0+6], w3
    fe86:	22 0b 8a    	mov.w     w2, 0x4164
    fe88:	33 0b 8a    	mov.w     w3, 0x4166
    mlSensorBiasData.azBias = biasData[2];
    fe8a:	40 01 90    	mov.w     [w0+8], w2
    fe8c:	d0 01 90    	mov.w     [w0+10], w3
    fe8e:	42 0b 8a    	mov.w     w2, 0x4168
    fe90:	53 0b 8a    	mov.w     w3, 0x416a
    mlSensorBiasData.gxBias = biasData[3];
    fe92:	60 01 90    	mov.w     [w0+12], w2
    fe94:	f0 01 90    	mov.w     [w0+14], w3
    fe96:	62 0b 8a    	mov.w     w2, 0x416c
    fe98:	73 0b 8a    	mov.w     w3, 0x416e
    mlSensorBiasData.gyBias = biasData[4];
    fe9a:	00 09 90    	mov.w     [w0+16], w2
    fe9c:	90 09 90    	mov.w     [w0+18], w3
    fe9e:	82 0b 8a    	mov.w     w2, 0x4170
    fea0:	93 0b 8a    	mov.w     w3, 0x4172
    mlSensorBiasData.gzBias = biasData[5];
    fea2:	20 09 90    	mov.w     [w0+20], w2
    fea4:	b0 09 90    	mov.w     [w0+22], w3
    fea6:	a2 0b 8a    	mov.w     w2, 0x4174
    fea8:	b3 0b 8a    	mov.w     w3, 0x4176
}
    feaa:	00 00 06    	return    

0000feac <_updateSensorData>:

void updateSensorData(float* sens) {
    feac:	88 1f 78    	mov.w     w8, [w15++]
    feae:	00 04 78    	mov.w     w0, w8

0000feb0 <.L0>:
    mlFilteredData.xacc = (int16_t) (sens[0] * MPS_TO_MG);
    feb0:	22 51 2c    	mov.w     #0xc512, w2
    feb2:	b3 2c 24    	mov.w     #0x42cb, w3
    feb4:	18 00 be    	mov.d     [w8], w0
    feb6:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    feb8:	00 00 00 
    feba:	94 18 02    	call      0x1894 <___fixsfsi>
    febc:	00 00 00 
    febe:	70 0c 8a    	mov.w     w0, 0x418e

0000fec0 <.L0>:
    mlFilteredData.yacc = (int16_t) (sens[1] * MPS_TO_MG);
    fec0:	22 51 2c    	mov.w     #0xc512, w2
    fec2:	b3 2c 24    	mov.w     #0x42cb, w3
    fec4:	28 00 90    	mov.w     [w8+4], w0
    fec6:	b8 00 90    	mov.w     [w8+6], w1
    fec8:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    feca:	00 00 00 
    fecc:	94 18 02    	call      0x1894 <___fixsfsi>
    fece:	00 00 00 
    fed0:	80 0c 8a    	mov.w     w0, 0x4190

0000fed2 <.L0>:
    mlFilteredData.zacc = (int16_t) (sens[2] * MPS_TO_MG);
    fed2:	22 51 2c    	mov.w     #0xc512, w2
    fed4:	b3 2c 24    	mov.w     #0x42cb, w3
    fed6:	48 00 90    	mov.w     [w8+8], w0
    fed8:	d8 00 90    	mov.w     [w8+10], w1
    feda:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    fedc:	00 00 00 
    fede:	94 18 02    	call      0x1894 <___fixsfsi>
    fee0:	00 00 00 
    fee2:	90 0c 8a    	mov.w     w0, 0x4192

0000fee4 <.L0>:
    mlFilteredData.xmag = (int16_t) (sens[3]); // assuming milligaus
    fee4:	68 00 90    	mov.w     [w8+12], w0
    fee6:	f8 00 90    	mov.w     [w8+14], w1
    fee8:	94 18 02    	call      0x1894 <___fixsfsi>
    feea:	00 00 00 
    feec:	d0 0c 8a    	mov.w     w0, 0x419a

0000feee <.L0>:
    mlFilteredData.ymag = (int16_t) (sens[4]);
    feee:	08 08 90    	mov.w     [w8+16], w0
    fef0:	98 08 90    	mov.w     [w8+18], w1
    fef2:	94 18 02    	call      0x1894 <___fixsfsi>
    fef4:	00 00 00 
    fef6:	e0 0c 8a    	mov.w     w0, 0x419c

0000fef8 <.L0>:
    mlFilteredData.zmag = (int16_t) (sens[5]);
    fef8:	28 08 90    	mov.w     [w8+20], w0
    fefa:	b8 08 90    	mov.w     [w8+22], w1
    fefc:	94 18 02    	call      0x1894 <___fixsfsi>
    fefe:	00 00 00 
    ff00:	f0 0c 8a    	mov.w     w0, 0x419e

0000ff02 <.L0>:
    mlFilteredData.xgyro = (int16_t) (sens[6]*1000.0);
    ff02:	02 00 20    	mov.w     #0x0, w2
    ff04:	a3 47 24    	mov.w     #0x447a, w3
    ff06:	48 08 90    	mov.w     [w8+24], w0
    ff08:	d8 08 90    	mov.w     [w8+26], w1
    ff0a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ff0c:	00 00 00 
    ff0e:	94 18 02    	call      0x1894 <___fixsfsi>
    ff10:	00 00 00 
    ff12:	a0 0c 8a    	mov.w     w0, 0x4194

0000ff14 <.L0>:
    mlFilteredData.ygyro = (int16_t) (sens[7]*1000.0);
    ff14:	02 00 20    	mov.w     #0x0, w2
    ff16:	a3 47 24    	mov.w     #0x447a, w3
    ff18:	68 08 90    	mov.w     [w8+28], w0
    ff1a:	f8 08 90    	mov.w     [w8+30], w1
    ff1c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ff1e:	00 00 00 
    ff20:	94 18 02    	call      0x1894 <___fixsfsi>
    ff22:	00 00 00 
    ff24:	b0 0c 8a    	mov.w     w0, 0x4196

0000ff26 <.L0>:
    mlFilteredData.zgyro = (int16_t) (sens[8]*1000.0);
    ff26:	02 00 20    	mov.w     #0x0, w2
    ff28:	a3 47 24    	mov.w     #0x447a, w3
    ff2a:	08 10 90    	mov.w     [w8+32], w0
    ff2c:	98 10 90    	mov.w     [w8+34], w1
    ff2e:	b6 1a 02    	call      0x1ab6 <___mulsf3>
    ff30:	00 00 00 
    ff32:	94 18 02    	call      0x1894 <___fixsfsi>
    ff34:	00 00 00 
    ff36:	c0 0c 8a    	mov.w     w0, 0x4198

0000ff38 <.L0>:
}
    ff38:	4f 04 78    	mov.w     [--w15], w8
    ff3a:	00 00 06    	return    

0000ff3c <_isFixValid>:

uint8_t isFixValid (void){
    return (mlGpsData.fix_type == GPS_FIX_3D);
    ff3c:	60 07 21    	mov.w     #0x1076, w0
    ff3e:	10 40 78    	mov.b     [w0], w0
    ff40:	63 40 68    	xor.b     w0, #0x3, w0
    ff42:	00 80 fb    	ze        w0, w0
    ff44:	00 00 e9    	dec.w     w0, w0
    ff46:	4f 00 de    	lsr.w     w0, #0xf, w0
}
    ff48:	00 00 06    	return    

0000ff4a <_updateSensorDiag>:

void updateSensorDiag (float* diag){
    ff4a:	88 1f 78    	mov.w     w8, [w15++]
    ff4c:	00 04 78    	mov.w     w0, w8
    mlSensorDiag.float1 = diag[0];
    ff4e:	18 00 be    	mov.d     [w8], w0
    ff50:	50 0e 8a    	mov.w     w0, 0x41ca
    ff52:	61 0e 8a    	mov.w     w1, 0x41cc
    mlSensorDiag.float2 = diag[1];
    ff54:	28 00 90    	mov.w     [w8+4], w0
    ff56:	b8 00 90    	mov.w     [w8+6], w1
    ff58:	70 0e 8a    	mov.w     w0, 0x41ce
    ff5a:	81 0e 8a    	mov.w     w1, 0x41d0

0000ff5c <.L0>:
    mlSensorDiag.int1 = (int16_t) diag[2];
    ff5c:	48 00 90    	mov.w     [w8+8], w0
    ff5e:	d8 00 90    	mov.w     [w8+10], w1
    ff60:	94 18 02    	call      0x1894 <___fixsfsi>
    ff62:	00 00 00 
    ff64:	90 0e 8a    	mov.w     w0, 0x41d2

0000ff66 <.L0>:
    mlSensorDiag.char1 = (int8_t) diag[3];
    ff66:	68 00 90    	mov.w     [w8+12], w0
    ff68:	f8 00 90    	mov.w     [w8+14], w1
    ff6a:	94 18 02    	call      0x1894 <___fixsfsi>
    ff6c:	00 00 00 
    ff6e:	00 01 be    	mov.d     w0, w2
    ff70:	41 1d 24    	mov.w     #0x41d4, w1
    ff72:	82 48 78    	mov.b     w2, [w1]

0000ff74 <.L0>:
}
    ff74:	4f 04 78    	mov.w     [--w15], w8
    ff76:	00 00 06    	return    

0000ff78 <_crc_accumulate>:
    ff78:	11 01 78    	mov.w     [w1], w2
    ff7a:	02 40 68    	xor.b     w0, w2, w0
    ff7c:	80 81 fb    	ze        w0, w3
    ff7e:	c4 19 dd    	sl.w      w3, #0x4, w3
    ff80:	03 40 68    	xor.b     w0, w3, w0
        uint8_t tmp;

        tmp = data ^ (uint8_t)(*crcAccum &0xff);
        tmp ^= (tmp<<4);
        *crcAccum = (*crcAccum>>8) ^ (tmp<<8) ^ (tmp <<3) ^ (tmp>>4);
    ff82:	00 80 fb    	ze        w0, w0
    ff84:	c4 01 de    	lsr.w     w0, #0x4, w3
    ff86:	48 11 de    	lsr.w     w2, #0x8, w2
    ff88:	02 81 69    	xor.w     w3, w2, w2
    ff8a:	c8 01 dd    	sl.w      w0, #0x8, w3
    ff8c:	03 01 69    	xor.w     w2, w3, w2
    ff8e:	43 00 dd    	sl.w      w0, #0x3, w0
    ff90:	80 08 69    	xor.w     w2, w0, [w1]
}
    ff92:	00 00 06    	return    

0000ff94 <_crc_init>:
#endif

/**
 * @brief Initiliaze the buffer for the X.25 CRC
 *
 * @param crcAccum the 16 bit X.25 CRC
 */
static inline void crc_init(uint16_t* crcAccum)
{
        *crcAccum = X25_INIT_CRC;
    ff94:	00 88 eb    	setm.w    [w0]
}
    ff96:	00 00 06    	return    

0000ff98 <_mavlink_get_channel_status>:
	// has to be defined externally
#else
	static mavlink_status_t m_mavlink_status[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_status[chan];
    ff98:	e2 c0 b3    	mov.b     #0xe, w2
    ff9a:	04 40 bc    	mul.b     0x4
    ff9c:	01 62 23    	mov.w     #0x3620, w1
    ff9e:	01 00 41    	add.w     w2, w1, w0
}
    ffa0:	00 00 06    	return    

0000ffa2 <_mavlink_get_channel_buffer>:
#endif

/*
 * Internal function to give access to the channel buffer for each channel
 */
#ifndef MAVLINK_GET_CHANNEL_BUFFER
MAVLINK_HELPER mavlink_message_t* mavlink_get_channel_buffer(uint8_t chan)
{
	
#if MAVLINK_EXTERNAL_RX_BUFFER
	// No m_mavlink_buffer array defined in function,
	// has to be defined externally
#else
	static mavlink_message_t m_mavlink_buffer[MAVLINK_COMM_NUM_BUFFERS];
#endif
	return &m_mavlink_buffer[chan];
    ffa2:	00 80 fb    	ze        w0, w0
    ffa4:	01 11 20    	mov.w     #0x110, w1
    ffa6:	81 80 b9    	.pword 0xb98081
    ffa8:	01 1e 23    	mov.w     #0x31e0, w1
    ffaa:	01 00 40    	add.w     w0, w1, w0

0000ffac <.L0>:
}
#endif

/**
 * @brief Reset the status of a channel.
 */
MAVLINK_HELPER void mavlink_reset_channel_status(uint8_t chan)
{
	mavlink_status_t *status = mavlink_get_channel_status(chan);
	status->parse_state = MAVLINK_PARSE_STATE_IDLE;
}

/**
 * @brief Finalize a MAVLink message with channel assignment
 *
 * This function calculates the checksum and sets length and aircraft id correctly.
 * It assumes that the message id and the payload are already correctly set. This function
 * can also be used if the message header has already been written before (as in mavlink_msg_xxx_pack
 * instead of mavlink_msg_xxx_pack_headerless), it just introduces little extra overhead.
 *
 * @param msg Message to finalize
 * @param system_id Id of the sending (this) system, 1-127
 * @param length Message length
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length, uint8_t crc_extra)
#else
MAVLINK_HELPER uint16_t mavlink_finalize_message_chan(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						      uint8_t chan, uint8_t length)
#endif
{
	// This code part is the same for all messages;
	uint16_t checksum;
	msg->magic = MAVLINK_STX;
	msg->len = length;
	msg->sysid = system_id;
	msg->compid = component_id;
	// One sequence number per component
	msg->seq = mavlink_get_channel_status(chan)->current_tx_seq;
	mavlink_get_channel_status(chan)->current_tx_seq = mavlink_get_channel_status(chan)->current_tx_seq+1;
	checksum = crc_calculate((uint8_t*)&msg->len, length + MAVLINK_CORE_HEADER_LEN);
#if MAVLINK_CRC_EXTRA
	crc_accumulate(crc_extra, &checksum);
#endif
	mavlink_ck_a(msg) = (uint8_t)(checksum & 0xFF);
	mavlink_ck_b(msg) = (uint8_t)(checksum >> 8);

	return length + MAVLINK_NUM_NON_PAYLOAD_BYTES;
}


/**
 * @brief Finalize a MAVLink message with MAVLINK_COMM_0 as default channel
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER uint16_t mavlink_finalize_message(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						 uint8_t length, uint8_t crc_extra)
{
	return mavlink_finalize_message_chan(msg, system_id, component_id, MAVLINK_COMM_0, length, crc_extra);
}
#else
MAVLINK_HELPER uint16_t mavlink_finalize_message(mavlink_message_t* msg, uint8_t system_id, uint8_t component_id, 
						 uint8_t length)
{
	return mavlink_finalize_message_chan(msg, system_id, component_id, MAVLINK_COMM_0, length);
}
#endif

#ifdef MAVLINK_USE_CONVENIENCE_FUNCTIONS
MAVLINK_HELPER void _mavlink_send_uart(mavlink_channel_t chan, const char *buf, uint16_t len);

/**
 * @brief Finalize a MAVLink message with channel assignment and send
 */
#if MAVLINK_CRC_EXTRA
MAVLINK_HELPER void _mav_finalize_message_chan_send(mavlink_channel_t chan, uint8_t msgid, const char *packet, 
						    uint8_t length, uint8_t crc_extra)
#else
MAVLINK_HELPER void _mav_finalize_message_chan_send(mavlink_channel_t chan, uint8_t msgid, const char *packet, uint8_t length)
#endif
{
	uint16_t checksum;
	uint8_t buf[MAVLINK_NUM_HEADER_BYTES];
	uint8_t ck[2];
	mavlink_status_t *status = mavlink_get_channel_status(chan);
	buf[0] = MAVLINK_STX;
	buf[1] = length;
	buf[2] = status->current_tx_seq;
	buf[3] = mavlink_system.sysid;
	buf[4] = mavlink_system.compid;
	buf[5] = msgid;
	status->current_tx_seq++;
	checksum = crc_calculate((uint8_t*)&buf[1], MAVLINK_CORE_HEADER_LEN);
	crc_accumulate_buffer(&checksum, packet, length);
#if MAVLINK_CRC_EXTRA
	crc_accumulate(crc_extra, &checksum);
#endif
	ck[0] = (uint8_t)(checksum & 0xFF);
	ck[1] = (uint8_t)(checksum >> 8);

	MAVLINK_START_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)length);
	_mavlink_send_uart(chan, (const char *)buf, MAVLINK_NUM_HEADER_BYTES);
	_mavlink_send_uart(chan, packet, length);
	_mavlink_send_uart(chan, (const char *)ck, 2);
	MAVLINK_END_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)length);
}

/**
 * @brief re-send a message over a uart channel
 * this is more stack efficient than re-marshalling the message
 */
MAVLINK_HELPER void _mavlink_resend_uart(mavlink_channel_t chan, const mavlink_message_t *msg)
{
	uint8_t ck[2];

	ck[0] = (uint8_t)(msg->checksum & 0xFF);
	ck[1] = (uint8_t)(msg->checksum >> 8);

	MAVLINK_START_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + msg->len);
	_mavlink_send_uart(chan, (const char *)&msg->magic, MAVLINK_NUM_HEADER_BYTES);
	_mavlink_send_uart(chan, _MAV_PAYLOAD(msg), msg->len);
	_mavlink_send_uart(chan, (const char *)ck, 2);
	MAVLINK_END_UART_SEND(chan, MAVLINK_NUM_NON_PAYLOAD_BYTES + msg->len);
}
#endif // MAVLINK_USE_CONVENIENCE_FUNCTIONS

/**
 * @brief Pack a message to send it over a serial byte stream
 */
MAVLINK_HELPER uint16_t mavlink_msg_to_send_buffer(uint8_t *buffer, const mavlink_message_t *msg)
{
	memcpy(buffer, (const uint8_t *)&msg->magic, MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len);
	return MAVLINK_NUM_NON_PAYLOAD_BYTES + (uint16_t)msg->len;
}

union __mavlink_bitfield {
	uint8_t uint8;
	int8_t int8;
	uint16_t uint16;
	int16_t int16;
	uint32_t uint32;
	int32_t int32;
};


MAVLINK_HELPER void mavlink_start_checksum(mavlink_message_t* msg)
{
	crc_init(&msg->checksum);
    ffac:	00 00 06    	return    

0000ffae <_mavlink_start_checksum>:
}
    ffae:	f2 ff 07    	rcall     0xff94 <_crc_init> <L0> <.LFB1> <.LFE0>
    ffb0:	00 00 06    	return    

0000ffb2 <_mavlink_update_checksum>:

MAVLINK_HELPER void mavlink_update_checksum(mavlink_message_t* msg, uint8_t c)
{
    ffb2:	00 01 78    	mov.w     w0, w2
    ffb4:	01 40 78    	mov.b     w1, w0

0000ffb6 <.L0>:
	crc_accumulate(c, &msg->checksum);
    ffb6:	82 00 78    	mov.w     w2, w1
    ffb8:	df ff 07    	rcall     0xff78 <_crc_accumulate> <L0> <.L0> <.LFB0> <.LFE1478> <.Letext0> <.Ltext0>

0000ffba <.L0>:
}
    ffba:	00 00 06    	return    

0000ffbc <_mavlink_parse_char>:

/**
 * This is a convenience function which handles the complete MAVLink parsing.
 * the function will parse one byte at a time and return the complete packet once
 * it could be successfully decoded. Checksum and other failures will be silently
 * ignored.
 *
 * @param chan     ID of the current channel. This allows to parse different channels with this function.
 *                 a channel is not a physical message channel like a serial port, but a logic partition of
 *                 the communication streams in this case. COMM_NB is the limit for the number of channels
 *                 on MCU (e.g. ARM7), while COMM_NB_HIGH is the limit for the number of channels in Linux/Windows
 * @param c        The char to barse
 *
 * @param returnMsg NULL if no message could be decoded, the message data else
 * @return 0 if no message could be decoded, 1 else
 *
 * A typical use scenario of this function call is:
 *
 * @code
 * #include <inttypes.h> // For fixed-width uint8_t type
 *
 * mavlink_message_t msg;
 * int chan = 0;
 *
 *
 * while(serial.bytesAvailable > 0)
 * {
 *   uint8_t byte = serial.getNextByte();
 *   if (mavlink_parse_char(chan, byte, &msg))
 *     {
 *     printf("Received message with ID %d, sequence: %d from component %d of system %d", msg.msgid, msg.seq, msg.compid, msg.sysid);
 *     }
 * }
 *
 *
 * @endcode
 */
MAVLINK_HELPER uint8_t mavlink_parse_char(uint8_t chan, uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status)
{
    ffbc:	88 9f be    	mov.d     w8, [w15++]
    ffbe:	8a 9f be    	mov.d     w10, [w15++]
    ffc0:	8c 1f 78    	mov.w     w12, [w15++]
    ffc2:	00 44 78    	mov.b     w0, w8
    ffc4:	81 45 78    	mov.b     w1, w11
    ffc6:	02 06 78    	mov.w     w2, w12
    ffc8:	83 04 78    	mov.w     w3, w9

0000ffca <.L0>:
        /*
	  default message crc function. You can override this per-system to
	  put this data in a different memory segment
	*/
#if MAVLINK_CRC_EXTRA
#ifndef MAVLINK_MESSAGE_CRC
	static const uint8_t mavlink_message_crcs[256] = MAVLINK_MESSAGE_CRCS;
#define MAVLINK_MESSAGE_CRC(msgid) mavlink_message_crcs[msgid]
#endif
#endif

/* Enable this option to check the length of each message.
 This allows invalid messages to be caught much sooner. Use if the transmission
 medium is prone to missing (or extra) characters (e.g. a radio that fades in
 and out). Only use if the channel will only contain messages types listed in
 the headers.
*/
#if MAVLINK_CHECK_MESSAGE_LENGTH
#ifndef MAVLINK_MESSAGE_LENGTH
	static const uint8_t mavlink_message_lengths[256] = MAVLINK_MESSAGE_LENGTHS;
#define MAVLINK_MESSAGE_LENGTH(msgid) mavlink_message_lengths[msgid]
#endif
#endif

	mavlink_message_t* rxmsg = mavlink_get_channel_buffer(chan); ///< The currently decoded message
    ffca:	08 40 78    	mov.b     w8, w0
    ffcc:	ea ff 07    	rcall     0xffa2 <_mavlink_get_channel_buffer> <L0> <.LFB10> <.LFE9>
    ffce:	00 05 78    	mov.w     w0, w10

0000ffd0 <.L0>:
	mavlink_status_t* status = mavlink_get_channel_status(chan); ///< The current decode status
    ffd0:	08 40 78    	mov.b     w8, w0
    ffd2:	e2 ff 07    	rcall     0xff98 <_mavlink_get_channel_status> <L0> <.LFB9> <.LFE1>
    ffd4:	00 04 78    	mov.w     w0, w8

0000ffd6 <.L0>:
	int bufferIndex = 0;

	status->msg_received = 0;
    ffd6:	00 4c eb    	clr.b     [w8]

	switch (status->parse_state)
    ffd8:	28 00 90    	mov.w     [w8+4], w0
    ffda:	80 00 eb    	clr.w     w1
    ffdc:	e9 0f 50    	sub.w     w0, #0x9, [w15]
    ffde:	e0 8f 58    	subb.w    w1, #0x0, [w15]
    ffe0:	91 00 3e    	bra       GTU, 0x10104 <.L8>
    ffe2:	00 06 01    	.pword 0x010600
    ffe4:	09 00 37    	bra       0xfff8 <.L9>
    ffe6:	08 00 37    	bra       0xfff8 <.L9>
    ffe8:	12 00 37    	bra       0x1000e <.L0> <.L10>
    ffea:	21 00 37    	bra       0x1002e <.L11>
    ffec:	19 00 37    	bra       0x10020 <.L12>
    ffee:	26 00 37    	bra       0x1003c <.L13>
    fff0:	2c 00 37    	bra       0x1004a <.L14>
    fff2:	38 00 37    	bra       0x10064 <.L15>
    fff4:	47 00 37    	bra       0x10084 <.L0> <.L16>
    fff6:	67 00 37    	bra       0x100c6 <.L17>

0000fff8 <.L9>:
	{
	case MAVLINK_PARSE_STATE_UNINIT:
	case MAVLINK_PARSE_STATE_IDLE:
		if (c == MAVLINK_STX)
    fff8:	e2 cf 45    	add.b     w11, #0x2, [w15]
    fffa:	90 00 3a    	bra       NZ, 0x1011c <.L19>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
    fffc:	20 00 20    	mov.w     #0x2, w0
    fffe:	20 04 98    	mov.w     w0, [w8+4]
			rxmsg->len = 0;
   10000:	00 40 eb    	clr.b     w0
   10002:	30 45 98    	mov.b     w0, [w10+3]
			rxmsg->magic = c;
   10004:	e0 cf b3    	mov.b     #0xfe, w0
   10006:	20 45 98    	mov.b     w0, [w10+2]

00010008 <.L0>:
			mavlink_start_checksum(rxmsg);
   10008:	0a 00 78    	mov.w     w10, w0
   1000a:	d1 ff 07    	rcall     0xffae <_mavlink_start_checksum> <L0> <.LFB15> <.LFE10>
   1000c:	7b 00 37    	bra       0x10104 <.L8>

0001000e <.L0>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_STX:
			if (status->msg_received 
/* Support shorter buffers than the
   default maximum packet size */
#if (MAVLINK_MAX_PAYLOAD_LEN < 255)
				|| c > MAVLINK_MAX_PAYLOAD_LEN
#endif
				)
		{
			status->buffer_overrun++;
			status->parse_error++;
			status->msg_received = 0;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
		}
		else
		{
			// NOT counting STX, LENGTH, SEQ, SYSID, COMPID, MSGID, CRC1 and CRC2
			rxmsg->len = c;
   1000e:	3b 45 98    	mov.b     w11, [w10+3]
			status->packet_idx = 0;
   10010:	00 40 eb    	clr.b     w0
   10012:	60 44 98    	mov.b     w0, [w8+6]

00010014 <.L0>:
			mavlink_update_checksum(rxmsg, c);
   10014:	8b 40 78    	mov.b     w11, w1
   10016:	0a 00 78    	mov.w     w10, w0
   10018:	cc ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

0001001a <.L0>:
			status->parse_state = MAVLINK_PARSE_STATE_GOT_LENGTH;
   1001a:	40 00 20    	mov.w     #0x4, w0
   1001c:	20 04 98    	mov.w     w0, [w8+4]
   1001e:	72 00 37    	bra       0x10104 <.L8>

00010020 <.L12>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_LENGTH:
		rxmsg->seq = c;
   10020:	4b 45 98    	mov.b     w11, [w10+4]

00010022 <.L0>:
		mavlink_update_checksum(rxmsg, c);
   10022:	8b 40 78    	mov.b     w11, w1
   10024:	0a 00 78    	mov.w     w10, w0
   10026:	c5 ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010028 <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_SEQ;
   10028:	30 00 20    	mov.w     #0x3, w0
   1002a:	20 04 98    	mov.w     w0, [w8+4]
		break;
   1002c:	6b 00 37    	bra       0x10104 <.L8>

0001002e <.L11>:

	case MAVLINK_PARSE_STATE_GOT_SEQ:
		rxmsg->sysid = c;
   1002e:	5b 45 98    	mov.b     w11, [w10+5]

00010030 <.L0>:
		mavlink_update_checksum(rxmsg, c);
   10030:	8b 40 78    	mov.b     w11, w1
   10032:	0a 00 78    	mov.w     w10, w0
   10034:	be ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010036 <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_SYSID;
   10036:	50 00 20    	mov.w     #0x5, w0
   10038:	20 04 98    	mov.w     w0, [w8+4]
		break;
   1003a:	64 00 37    	bra       0x10104 <.L8>

0001003c <.L13>:

	case MAVLINK_PARSE_STATE_GOT_SYSID:
		rxmsg->compid = c;
   1003c:	6b 45 98    	mov.b     w11, [w10+6]

0001003e <.L0>:
		mavlink_update_checksum(rxmsg, c);
   1003e:	8b 40 78    	mov.b     w11, w1
   10040:	0a 00 78    	mov.w     w10, w0
   10042:	b7 ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010044 <.L0>:
		status->parse_state = MAVLINK_PARSE_STATE_GOT_COMPID;
   10044:	60 00 20    	mov.w     #0x6, w0
   10046:	20 04 98    	mov.w     w0, [w8+4]
		break;
   10048:	5d 00 37    	bra       0x10104 <.L8>

0001004a <.L14>:

	case MAVLINK_PARSE_STATE_GOT_COMPID:
#if MAVLINK_CHECK_MESSAGE_LENGTH
	        if (rxmsg->len != MAVLINK_MESSAGE_LENGTH(c))
		{
			status->parse_error++;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
			break;
			if (c == MAVLINK_STX)
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
				mavlink_start_checksum(rxmsg);
			}
	        }
#endif
		rxmsg->msgid = c;
   1004a:	7b 45 98    	mov.b     w11, [w10+7]

0001004c <.L0>:
		mavlink_update_checksum(rxmsg, c);
   1004c:	8b 40 78    	mov.b     w11, w1
   1004e:	0a 00 78    	mov.w     w10, w0
   10050:	b0 ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010052 <.L0>:
		if (rxmsg->len == 0)
   10052:	3a 40 90    	mov.b     [w10+3], w0
   10054:	00 04 e0    	cp0.b     w0
   10056:	03 00 3a    	bra       NZ, 0x1005e <.L20>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
   10058:	80 00 20    	mov.w     #0x8, w0
   1005a:	20 04 98    	mov.w     w0, [w8+4]
   1005c:	53 00 37    	bra       0x10104 <.L8>

0001005e <.L20>:
		}
		else
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_MSGID;
   1005e:	70 00 20    	mov.w     #0x7, w0
   10060:	20 04 98    	mov.w     w0, [w8+4]
   10062:	50 00 37    	bra       0x10104 <.L8>

00010064 <.L15>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_MSGID:
		_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx++] = (char)c;
   10064:	68 40 90    	mov.b     [w8+6], w0
   10066:	80 80 fb    	ze        w0, w1
   10068:	81 00 45    	add.w     w10, w1, w1
   1006a:	8b 48 98    	mov.b     w11, [w1+8]
   1006c:	00 40 e8    	inc.b     w0, w0
   1006e:	60 44 98    	mov.b     w0, [w8+6]

00010070 <.L0>:
		mavlink_update_checksum(rxmsg, c);
   10070:	8b 40 78    	mov.b     w11, w1
   10072:	0a 00 78    	mov.w     w10, w0
   10074:	9e ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010076 <.L0>:
		if (status->packet_idx == rxmsg->len)
   10076:	e8 40 90    	mov.b     [w8+6], w1
   10078:	3a 40 90    	mov.b     [w10+3], w0
   1007a:	80 cf 50    	sub.b     w1, w0, [w15]
   1007c:	43 00 3a    	bra       NZ, 0x10104 <.L8>
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_PAYLOAD;
   1007e:	80 00 20    	mov.w     #0x8, w0
   10080:	20 04 98    	mov.w     w0, [w8+4]
   10082:	40 00 37    	bra       0x10104 <.L8>

00010084 <.L0>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_PAYLOAD:
#if MAVLINK_CRC_EXTRA
		mavlink_update_checksum(rxmsg, MAVLINK_MESSAGE_CRC(rxmsg->msgid));
   10084:	7a 40 90    	mov.b     [w10+7], w0
   10086:	00 80 fb    	ze        w0, w0
   10088:	21 56 2c    	mov.w     #0xc562, w1
   1008a:	00 80 40    	add.w     w1, w0, w0
   1008c:	90 40 78    	mov.b     [w0], w1
   1008e:	0a 00 78    	mov.w     w10, w0
   10090:	90 ff 07    	rcall     0xffb2 <_mavlink_update_checksum> <L0> <.LFB16> <.LFE15>

00010092 <.L0>:
#endif
		if (c != (rxmsg->checksum & 0xFF)) {
   10092:	8b 80 fb    	ze        w11, w1
   10094:	1a 80 fb    	ze        [w10], w0
   10096:	80 8f 50    	sub.w     w1, w0, [w15]
   10098:	0f 00 32    	bra       Z, 0x100b8 <.L0> <.L21>
			// Check first checksum byte
			status->parse_error++;
   1009a:	28 40 90    	mov.b     [w8+2], w0
   1009c:	00 40 e8    	inc.b     w0, w0
   1009e:	20 44 98    	mov.b     w0, [w8+2]
			status->msg_received = 0;
   100a0:	00 4c eb    	clr.b     [w8]
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
   100a2:	10 00 20    	mov.w     #0x1, w0
   100a4:	20 04 98    	mov.w     w0, [w8+4]
			if (c == MAVLINK_STX)
   100a6:	e2 cf 45    	add.b     w11, #0x2, [w15]
   100a8:	2d 00 3a    	bra       NZ, 0x10104 <.L8>
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
   100aa:	20 00 20    	mov.w     #0x2, w0
   100ac:	20 04 98    	mov.w     w0, [w8+4]
				rxmsg->len = 0;
   100ae:	00 40 eb    	clr.b     w0
   100b0:	30 45 98    	mov.b     w0, [w10+3]

000100b2 <.L0>:
				mavlink_start_checksum(rxmsg);
   100b2:	0a 00 78    	mov.w     w10, w0
   100b4:	7c ff 07    	rcall     0xffae <_mavlink_start_checksum> <L0> <.LFB15> <.LFE10>
   100b6:	26 00 37    	bra       0x10104 <.L8>

000100b8 <.L0>:
			}
		}
		else
		{
			status->parse_state = MAVLINK_PARSE_STATE_GOT_CRC1;
   100b8:	90 00 20    	mov.w     #0x9, w0
   100ba:	20 04 98    	mov.w     w0, [w8+4]
			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx] = (char)c;
   100bc:	68 40 90    	mov.b     [w8+6], w0
   100be:	00 80 fb    	ze        w0, w0
   100c0:	00 00 45    	add.w     w10, w0, w0
   100c2:	0b 48 98    	mov.b     w11, [w0+8]
   100c4:	1f 00 37    	bra       0x10104 <.L8>

000100c6 <.L17>:
		}
		break;

	case MAVLINK_PARSE_STATE_GOT_CRC1:
		if (c != (rxmsg->checksum >> 8)) {
   100c6:	8b 80 fb    	ze        w11, w1
   100c8:	1a 00 78    	mov.w     [w10], w0
   100ca:	48 00 de    	lsr.w     w0, #0x8, w0
   100cc:	80 8f 50    	sub.w     w1, w0, [w15]
   100ce:	0e 00 32    	bra       Z, 0x100ec <.L0> <.L22>
			// Check second checksum byte
			status->parse_error++;
   100d0:	28 40 90    	mov.b     [w8+2], w0
   100d2:	00 40 e8    	inc.b     w0, w0
   100d4:	20 44 98    	mov.b     w0, [w8+2]
			status->msg_received = 0;
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
   100d6:	10 00 20    	mov.w     #0x1, w0
   100d8:	20 04 98    	mov.w     w0, [w8+4]
			if (c == MAVLINK_STX)
   100da:	e2 cf 45    	add.b     w11, #0x2, [w15]
   100dc:	13 00 3a    	bra       NZ, 0x10104 <.L8>
			{
				status->parse_state = MAVLINK_PARSE_STATE_GOT_STX;
   100de:	20 00 20    	mov.w     #0x2, w0
   100e0:	20 04 98    	mov.w     w0, [w8+4]
				rxmsg->len = 0;
   100e2:	00 40 eb    	clr.b     w0
   100e4:	30 45 98    	mov.b     w0, [w10+3]

000100e6 <.L0>:
				mavlink_start_checksum(rxmsg);
   100e6:	0a 00 78    	mov.w     w10, w0
   100e8:	62 ff 07    	rcall     0xffae <_mavlink_start_checksum> <L0> <.LFB15> <.LFE10>
   100ea:	0c 00 37    	bra       0x10104 <.L8>

000100ec <.L0>:
			}
		}
		else
		{
			// Successfully got message
			status->msg_received = 1;
   100ec:	10 c0 b3    	mov.b     #0x1, w0
   100ee:	00 4c 78    	mov.b     w0, [w8]
			status->parse_state = MAVLINK_PARSE_STATE_IDLE;
   100f0:	10 00 20    	mov.w     #0x1, w0
   100f2:	20 04 98    	mov.w     w0, [w8+4]
			_MAV_PAYLOAD_NON_CONST(rxmsg)[status->packet_idx+1] = (char)c;
   100f4:	68 40 90    	mov.b     [w8+6], w0
   100f6:	00 80 fb    	ze        w0, w0
   100f8:	00 00 45    	add.w     w10, w0, w0
   100fa:	1b 48 98    	mov.b     w11, [w0+9]
			memcpy(r_message, rxmsg, sizeof(mavlink_message_t));
   100fc:	87 00 09    	.pword 0x090087
   100fe:	3a 1e 78    	mov.w     [w10++], [w12++]
   10100:	0c 11 b1    	sub.w     #0x110, w12
   10102:	0a 11 b1    	sub.w     #0x110, w10

00010104 <.L8>:
		}
		break;
	}

	bufferIndex++;
	// If a message has been sucessfully decoded, check index
	if (status->msg_received == 1)
   10104:	10 c0 b3    	mov.b     #0x1, w0
   10106:	98 4f 10    	subr.b    w0, [w8], [w15]
   10108:	09 00 3a    	bra       NZ, 0x1011c <.L19>
	{
		//while(status->current_seq != rxmsg->seq)
		//{
		//	status->packet_rx_drop_count++;
		//               status->current_seq++;
		//}
		status->current_rx_seq = rxmsg->seq;
   1010a:	4a 45 90    	mov.b     [w10+4], w10
   1010c:	7a 44 98    	mov.b     w10, [w8+7]
		// Initial condition: If no packet has been received so far, drop count is undefined
		if (status->packet_rx_success_count == 0) status->packet_rx_drop_count = 0;
   1010e:	58 00 90    	mov.w     [w8+10], w0
   10110:	00 00 e0    	cp0.w     w0
   10112:	02 00 3a    	bra       NZ, 0x10118 <.L23>
   10114:	80 00 eb    	clr.w     w1
   10116:	61 04 98    	mov.w     w1, [w8+12]

00010118 <.L23>:
		// Count this packet as received
		status->packet_rx_success_count++;
   10118:	00 00 e8    	inc.w     w0, w0
   1011a:	50 04 98    	mov.w     w0, [w8+10]

0001011c <.L19>:
	}

	r_mavlink_status->current_rx_seq = status->current_rx_seq+1;
   1011c:	78 40 90    	mov.b     [w8+7], w0
   1011e:	00 40 e8    	inc.b     w0, w0
   10120:	f0 44 98    	mov.b     w0, [w9+7]
	r_mavlink_status->packet_rx_success_count = status->packet_rx_success_count;
   10122:	58 00 90    	mov.w     [w8+10], w0
   10124:	d0 04 98    	mov.w     w0, [w9+10]
	r_mavlink_status->packet_rx_drop_count = status->parse_error;
   10126:	28 40 90    	mov.b     [w8+2], w0
   10128:	00 80 fb    	ze        w0, w0
   1012a:	e0 04 98    	mov.w     w0, [w9+12]
	status->parse_error = 0;
   1012c:	00 40 eb    	clr.b     w0
   1012e:	20 44 98    	mov.b     w0, [w8+2]
   10130:	18 40 78    	mov.b     [w8], w0
	return status->msg_received;
}
   10132:	4f 06 78    	mov.w     [--w15], w12
   10134:	4f 05 be    	mov.d     [--w15], w10
   10136:	4f 04 be    	mov.d     [--w15], w8
   10138:	00 00 06    	return    

0001013a <_mavlink_msg_gps_raw_int_decode>:
	gps_raw_int->cog = mavlink_msg_gps_raw_int_get_cog(msg);
	gps_raw_int->fix_type = mavlink_msg_gps_raw_int_get_fix_type(msg);
	gps_raw_int->satellites_visible = mavlink_msg_gps_raw_int_get_satellites_visible(msg);
#else
	memcpy(gps_raw_int, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_RAW_INT_LEN);
   1013a:	68 01 40    	add.w     w0, #0x8, w2
   1013c:	0e 00 09    	.pword 0x09000e
   1013e:	b2 18 78    	mov.w     [w2++], [w1++]
   10140:	e1 01 b1    	sub.w     #0x1e, w1
#endif
}
   10142:	00 00 06    	return    

00010144 <_mavlink_msg_cpu_load_decode>:
	cpu_load->batVolt = mavlink_msg_cpu_load_get_batVolt(msg);
	cpu_load->sensLoad = mavlink_msg_cpu_load_get_sensLoad(msg);
	cpu_load->ctrlLoad = mavlink_msg_cpu_load_get_ctrlLoad(msg);
#else
	memcpy(cpu_load, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_CPU_LOAD_LEN);
   10144:	40 01 90    	mov.w     [w0+8], w2
   10146:	d0 01 90    	mov.w     [w0+10], w3
   10148:	82 88 be    	mov.d     w2, [w1]
#endif
}
   1014a:	00 00 06    	return    

0001014c <_mavlink_msg_local_position_ned_decode>:
	local_position_ned->vx = mavlink_msg_local_position_ned_get_vx(msg);
	local_position_ned->vy = mavlink_msg_local_position_ned_get_vy(msg);
	local_position_ned->vz = mavlink_msg_local_position_ned_get_vz(msg);
#else
	memcpy(local_position_ned, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN);
   1014c:	68 01 40    	add.w     w0, #0x8, w2
   1014e:	0d 00 09    	.pword 0x09000d
   10150:	b2 18 78    	mov.w     [w2++], [w1++]
   10152:	c1 01 b1    	sub.w     #0x1c, w1
#endif
}
   10154:	00 00 06    	return    

00010156 <_mavlink_msg_scaled_pressure_decode>:
	scaled_pressure->press_abs = mavlink_msg_scaled_pressure_get_press_abs(msg);
	scaled_pressure->press_diff = mavlink_msg_scaled_pressure_get_press_diff(msg);
	scaled_pressure->temperature = mavlink_msg_scaled_pressure_get_temperature(msg);
#else
	memcpy(scaled_pressure, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_SCALED_PRESSURE_LEN);
   10156:	68 01 40    	add.w     w0, #0x8, w2
   10158:	06 00 09    	.pword 0x090006
   1015a:	b2 18 78    	mov.w     [w2++], [w1++]
   1015c:	e1 00 b1    	sub.w     #0xe, w1
#endif
}
   1015e:	00 00 06    	return    

00010160 <_mavlink_msg_attitude_decode>:
	attitude->rollspeed = mavlink_msg_attitude_get_rollspeed(msg);
	attitude->pitchspeed = mavlink_msg_attitude_get_pitchspeed(msg);
	attitude->yawspeed = mavlink_msg_attitude_get_yawspeed(msg);
#else
	memcpy(attitude, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_ATTITUDE_LEN);
   10160:	68 01 40    	add.w     w0, #0x8, w2
   10162:	0d 00 09    	.pword 0x09000d
   10164:	b2 18 78    	mov.w     [w2++], [w1++]
   10166:	c1 01 b1    	sub.w     #0x1c, w1
#endif
}
   10168:	00 00 06    	return    

0001016a <_mavlink_msg_raw_imu_decode>:
	raw_imu->xmag = mavlink_msg_raw_imu_get_xmag(msg);
	raw_imu->ymag = mavlink_msg_raw_imu_get_ymag(msg);
	raw_imu->zmag = mavlink_msg_raw_imu_get_zmag(msg);
#else
	memcpy(raw_imu, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RAW_IMU_LEN);
   1016a:	68 01 40    	add.w     w0, #0x8, w2
   1016c:	0c 00 09    	.pword 0x09000c
   1016e:	b2 18 78    	mov.w     [w2++], [w1++]
   10170:	a1 01 b1    	sub.w     #0x1a, w1
#endif
}
   10172:	00 00 06    	return    

00010174 <_mavlink_msg_raw_pressure_decode>:
	raw_pressure->press_diff1 = mavlink_msg_raw_pressure_get_press_diff1(msg);
	raw_pressure->press_diff2 = mavlink_msg_raw_pressure_get_press_diff2(msg);
	raw_pressure->temperature = mavlink_msg_raw_pressure_get_temperature(msg);
#else
	memcpy(raw_pressure, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_RAW_PRESSURE_LEN);
   10174:	68 01 40    	add.w     w0, #0x8, w2
   10176:	07 00 09    	.pword 0x090007
   10178:	b2 18 78    	mov.w     [w2++], [w1++]
   1017a:	01 01 b1    	sub.w     #0x10, w1
#endif
}
   1017c:	00 00 06    	return    

0001017e <_mavlink_msg_gps_date_time_decode>:
	gps_date_time->GppGl = mavlink_msg_gps_date_time_get_GppGl(msg);
	gps_date_time->sigUsedMask = mavlink_msg_gps_date_time_get_sigUsedMask(msg);
	gps_date_time->percentUsed = mavlink_msg_gps_date_time_get_percentUsed(msg);
#else
	memcpy(gps_date_time, _MAV_PAYLOAD(msg), MAVLINK_MSG_ID_GPS_DATE_TIME_LEN);
   1017e:	68 01 40    	add.w     w0, #0x8, w2
   10180:	0b 00 09    	.pword 0x09000b
   10182:	b2 58 78    	mov.b     [w2++], [w1++]
   10184:	c1 00 b1    	sub.w     #0xc, w1
#endif
}
   10186:	00 00 06    	return    

00010188 <_hilRead>:
#include "hil.h"
extern CBRef uartBuffer;

void hilRead(unsigned char* hilChunk) {
   10188:	88 9f be    	mov.d     w8, [w15++]
   1018a:	80 04 78    	mov.w     w0, w9

0001018c <.L0>:

    // fix the data length so if the interrupt adds data
    // during execution of this block, it will be read
    // until the next hilRead
     //unsigned char tmpLen = getLength(uartBufferIn), i = 0;
        unsigned char tmpLen = getLength(uartBuffer), i = 0;
   1018c:	c0 b2 81    	mov.w     0x3658, w0
   1018e:	c0 0a 02    	call      0x10ac0 <_getLength>
   10190:	01 00 00 

00010192 <.L0>:

    // if the buffer has more data than the max size, set it to max,
    // otherwise set it to the length
    hilChunk[0] = (tmpLen > MAXSEND - 1) ? MAXSEND - 1 : tmpLen;
   10192:	c1 c6 b3    	mov.b     #0x6c, w1
   10194:	81 4f 50    	sub.b     w0, w1, [w15]
   10196:	01 00 36    	bra       LEU, 0x1019a <.L33>
   10198:	01 40 78    	mov.b     w1, w0

0001019a <.L33>:
   1019a:	80 4c 78    	mov.b     w0, [w9]

    // read the data 
    for (i = 1; i <= hilChunk[0]; i += 1) {
   1019c:	00 04 e0    	cp0.b     w0
   1019e:	0a 00 32    	bra       Z, 0x101b4 <.L32>
   101a0:	18 c0 b3    	mov.b     #0x1, w8

000101a2 <.L0>:
//        hilChunk[i] = readFront(uartBufferIn);
        hilChunk[i] = readFront(uartBuffer);
   101a2:	c0 b2 81    	mov.w     0x3658, w0
   101a4:	14 0b 02    	call      0x10b14 <_readFront>
   101a6:	01 00 00 
   101a8:	88 80 fb    	ze        w8, w1
   101aa:	81 80 44    	add.w     w9, w1, w1
   101ac:	80 48 78    	mov.b     w0, [w1]

000101ae <.L0>:
   101ae:	08 44 e8    	inc.b     w8, w8
   101b0:	99 4f 14    	subr.b    w8, [w9], [w15]
   101b2:	f7 ff 31    	bra       C, 0x101a2 <.L0> <.L35>

000101b4 <.L32>:

    } 
}
   101b4:	4f 04 be    	mov.d     [--w15], w8
   101b6:	00 00 06    	return    

000101b8 <_hil_getRawRead>:

void hil_getRawRead(short * rawData) {
    rawData[0] = mlRawImuData.xgyro;
   101b8:	51 85 80    	mov.w     0x10aa, w1
   101ba:	01 08 78    	mov.w     w1, [w0]
    rawData[1] = mlRawImuData.ygyro;
   101bc:	61 85 80    	mov.w     0x10ac, w1
   101be:	11 00 98    	mov.w     w1, [w0+2]
    rawData[2] = mlRawImuData.zgyro;
   101c0:	71 85 80    	mov.w     0x10ae, w1
   101c2:	21 00 98    	mov.w     w1, [w0+4]
    rawData[3] = mlRawImuData.xacc;
   101c4:	21 85 80    	mov.w     0x10a4, w1
   101c6:	31 00 98    	mov.w     w1, [w0+6]
    rawData[4] = mlRawImuData.yacc;
   101c8:	31 85 80    	mov.w     0x10a6, w1
   101ca:	41 00 98    	mov.w     w1, [w0+8]
    rawData[5] = mlRawImuData.zacc;
   101cc:	41 85 80    	mov.w     0x10a8, w1
   101ce:	51 00 98    	mov.w     w1, [w0+10]
    rawData[6] = mlRawImuData.xmag;
   101d0:	81 85 80    	mov.w     0x10b0, w1
   101d2:	61 00 98    	mov.w     w1, [w0+12]
    rawData[7] = mlRawImuData.ymag;
   101d4:	91 85 80    	mov.w     0x10b2, w1
   101d6:	71 00 98    	mov.w     w1, [w0+14]
    rawData[8] = mlRawImuData.zmag;
   101d8:	a1 85 80    	mov.w     0x10b4, w1
   101da:	01 08 98    	mov.w     w1, [w0+16]
    rawData[9] = mlRawPressureData.press_abs;
   101dc:	f1 85 80    	mov.w     0x10be, w1
   101de:	11 08 98    	mov.w     w1, [w0+18]
    rawData[10] = mlRawPressureData.press_diff1;
   101e0:	01 86 80    	mov.w     0x10c0, w1
   101e2:	21 08 98    	mov.w     w1, [w0+20]
    rawData[11] = mlCpuLoadData.batVolt;
   101e4:	e1 0a 82    	mov.w     0x415c, w1
   101e6:	31 08 98    	mov.w     w1, [w0+22]
    rawData[12] = mlRawPressureData.temperature;
   101e8:	21 86 80    	mov.w     0x10c4, w1
   101ea:	41 08 98    	mov.w     w1, [w0+24]
}
   101ec:	00 00 06    	return    

000101ee <_hil_getVned>:

void hil_getVned(float* vned) {
    vned[0] = mlLocalPositionData.vx;
   101ee:	92 87 80    	mov.w     0x10f2, w2
   101f0:	a3 87 80    	mov.w     0x10f4, w3
   101f2:	02 88 be    	mov.d     w2, [w0]
    vned[1] = mlLocalPositionData.vy;
   101f4:	b2 87 80    	mov.w     0x10f6, w2
   101f6:	c3 87 80    	mov.w     0x10f8, w3
   101f8:	22 00 98    	mov.w     w2, [w0+4]
   101fa:	33 00 98    	mov.w     w3, [w0+6]
    vned[2] = mlLocalPositionData.vz;
   101fc:	d2 87 80    	mov.w     0x10fa, w2
   101fe:	e3 87 80    	mov.w     0x10fc, w3
   10200:	42 00 98    	mov.w     w2, [w0+8]
   10202:	53 00 98    	mov.w     w3, [w0+10]
}
   10204:	00 00 06    	return    

00010206 <_hil_getEuler>:

void hil_getEuler(float* euler) {
    euler[0] = mlAttitudeData.roll;
   10206:	52 86 80    	mov.w     0x10ca, w2
   10208:	63 86 80    	mov.w     0x10cc, w3
   1020a:	02 88 be    	mov.d     w2, [w0]
    euler[1] = mlAttitudeData.pitch;
   1020c:	72 86 80    	mov.w     0x10ce, w2
   1020e:	83 86 80    	mov.w     0x10d0, w3
   10210:	22 00 98    	mov.w     w2, [w0+4]
   10212:	33 00 98    	mov.w     w3, [w0+6]
    euler[2] = mlAttitudeData.yaw;
   10214:	92 86 80    	mov.w     0x10d2, w2
   10216:	a3 86 80    	mov.w     0x10d4, w3
   10218:	42 00 98    	mov.w     w2, [w0+8]
   1021a:	53 00 98    	mov.w     w3, [w0+10]
}
   1021c:	00 00 06    	return    

0001021e <_hil_getRates>:

void hil_getRates(float* pqr) {
    pqr[0] = mlAttitudeData.rollspeed;
   1021e:	b2 86 80    	mov.w     0x10d6, w2
   10220:	c3 86 80    	mov.w     0x10d8, w3
   10222:	02 88 be    	mov.d     w2, [w0]
    pqr[1] = mlAttitudeData.pitchspeed;
   10224:	d2 86 80    	mov.w     0x10da, w2
   10226:	e3 86 80    	mov.w     0x10dc, w3
   10228:	22 00 98    	mov.w     w2, [w0+4]
   1022a:	33 00 98    	mov.w     w3, [w0+6]
    pqr[2] = mlAttitudeData.yawspeed;
   1022c:	f2 86 80    	mov.w     0x10de, w2
   1022e:	03 87 80    	mov.w     0x10e0, w3
   10230:	42 00 98    	mov.w     w2, [w0+8]
   10232:	53 00 98    	mov.w     w3, [w0+10]
}
   10234:	00 00 06    	return    

00010236 <_hil_getXYZ>:

void hil_getXYZ(float* xyz) {
    xyz[0] = mlLocalPositionData.x;
   10236:	32 87 80    	mov.w     0x10e6, w2
   10238:	43 87 80    	mov.w     0x10e8, w3
   1023a:	02 88 be    	mov.d     w2, [w0]
    xyz[1] = mlLocalPositionData.y;
   1023c:	52 87 80    	mov.w     0x10ea, w2
   1023e:	63 87 80    	mov.w     0x10ec, w3
   10240:	22 00 98    	mov.w     w2, [w0+4]
   10242:	33 00 98    	mov.w     w3, [w0+6]
    xyz[2] = mlLocalPositionData.z;
   10244:	72 87 80    	mov.w     0x10ee, w2
   10246:	83 87 80    	mov.w     0x10f0, w3
   10248:	42 00 98    	mov.w     w2, [w0+8]
   1024a:	53 00 98    	mov.w     w3, [w0+10]
}
   1024c:	00 00 06    	return    

0001024e <_hil_getTs>:

unsigned int hil_getTs(void) {
    return mlAttitudeData.time_boot_ms;
}
   1024e:	30 86 80    	mov.w     0x10c6, w0
   10250:	00 00 06    	return    

00010252 <_protDecodeHil>:

void protDecodeHil(uint8_t* dataIn) {
   10252:	1e 01 fa    	lnk       #0x11e
   10254:	88 9f be    	mov.d     w8, [w15++]
   10256:	8a 1f 78    	mov.w     w10, [w15++]
   10258:	80 04 78    	mov.w     w0, w9

    uint8_t i/*, indx, writeSuccess*/;
    //uint16_t indexOffset;
    //tFloatToChar tempFloat;
    //uint32_t temp;


    mavlink_message_t msg;
    mavlink_status_t status;

    for (i = 1; i <= dataIn[0]; i++) {
   1025a:	19 04 e0    	cp0.b     [w9]
   1025c:	4d 00 32    	bra       Z, 0x102f8 <.L43>
   1025e:	18 c0 b3    	mov.b     #0x1, w8
        // Try to get a new message
        if (mavlink_parse_char(0, dataIn[i], &msg, &status)) {

            // Handle message
            switch (msg.msgid) {
   10260:	0a c2 b3    	mov.b     #0x20, w10

00010262 <.L0>:
   10262:	08 80 fb    	ze        w8, w0
   10264:	00 80 44    	add.w     w9, w0, w0
   10266:	f4 81 57    	sub.w     w15, #0x14, w3
   10268:	c2 ed 2f    	mov.w     #0xfedc, w2
   1026a:	0f 01 41    	add.w     w2, w15, w2
   1026c:	90 40 78    	mov.b     [w0], w1
   1026e:	00 40 eb    	clr.b     w0
   10270:	a5 fe 07    	rcall     0xffbc <_mavlink_parse_char> <L0> <.LFB17> <.LFE16>
   10272:	00 04 e0    	cp0.b     w0
   10274:	3e 00 32    	bra       Z, 0x102f2 <.L0> <.L45>

00010276 <.L0>:
   10276:	3f e0 95    	mov.b     [w15-285], w0
   10278:	fd 4f 50    	sub.b     w0, #0x1d, [w15]
   1027a:	23 00 32    	bra       Z, 0x102c2 <.L0> <.L49>
   1027c:	06 00 3e    	bra       GTU, 0x1028a <.L54>
   1027e:	fb 4f 50    	sub.b     w0, #0x1b, [w15]
   10280:	2a 00 32    	bra       Z, 0x102d6 <.L0> <.L47>
   10282:	2e 00 3e    	bra       GTU, 0x102e0 <.L0> <.L48>
   10284:	f8 4f 50    	sub.b     w0, #0x18, [w15]
   10286:	35 00 3a    	bra       NZ, 0x102f2 <.L0> <.L45>
   10288:	0d 00 37    	bra       0x102a4 <.L0> <.L58>

0001028a <.L54>:
   1028a:	8a 4f 50    	sub.b     w0, w10, [w15]
   1028c:	15 00 32    	bra       Z, 0x102b8 <.L0> <.L51>
   1028e:	03 00 3e    	bra       GTU, 0x10296 <.L55>
   10290:	fe 4f 50    	sub.b     w0, #0x1e, [w15]
   10292:	2f 00 3a    	bra       NZ, 0x102f2 <.L0> <.L45>
   10294:	1b 00 37    	bra       0x102cc <.L0> <.L59>

00010296 <.L55>:
   10296:	a1 ca b3    	mov.b     #0xaa, w1
   10298:	81 4f 50    	sub.b     w0, w1, [w15]
   1029a:	09 00 32    	bra       Z, 0x102ae <.L0> <.L52>
   1029c:	e9 c0 40    	add.b     w1, #0x9, w1
   1029e:	81 4f 50    	sub.b     w0, w1, [w15]
   102a0:	28 00 3a    	bra       NZ, 0x102f2 <.L0> <.L45>
   102a2:	23 00 37    	bra       0x102ea <.L0> <.L60>

000102a4 <.L0>:
                case MAVLINK_MSG_ID_GPS_RAW_INT:
                    mavlink_msg_gps_raw_int_decode(&msg, &mlGpsData);
   102a4:	a1 05 21    	mov.w     #0x105a, w1
   102a6:	c0 ed 2f    	mov.w     #0xfedc, w0
   102a8:	0f 00 40    	add.w     w0, w15, w0
   102aa:	47 ff 07    	rcall     0x1013a <_mavlink_msg_gps_raw_int_decode> <L0> <.LFB177> <.LFE17>

000102ac <.L0>:
                    break;
   102ac:	22 00 37    	bra       0x102f2 <.L0> <.L45>

000102ae <.L0>:

                case MAVLINK_MSG_ID_CPU_LOAD:
                    mavlink_msg_cpu_load_decode(&msg, &mlCpuLoadData);
   102ae:	c1 15 24    	mov.w     #0x415c, w1
   102b0:	c0 ed 2f    	mov.w     #0xfedc, w0
   102b2:	0f 00 40    	add.w     w0, w15, w0
   102b4:	47 ff 07    	rcall     0x10144 <_mavlink_msg_cpu_load_decode> <L0> <.LFB1268> <.LFE177>

000102b6 <.L0>:
                    break;
   102b6:	1d 00 37    	bra       0x102f2 <.L0> <.L45>

000102b8 <.L0>:

                case MAVLINK_MSG_ID_LOCAL_POSITION_NED:
                    mavlink_msg_local_position_ned_decode(&msg, &mlLocalPositionData);
   102b8:	21 0e 21    	mov.w     #0x10e2, w1
   102ba:	c0 ed 2f    	mov.w     #0xfedc, w0
   102bc:	0f 00 40    	add.w     w0, w15, w0
   102be:	46 ff 07    	rcall     0x1014c <_mavlink_msg_local_position_ned_decode> <L0> <.LFB274> <.LFE1268>

000102c0 <.L0>:
                    break;
   102c0:	18 00 37    	bra       0x102f2 <.L0> <.L45>

000102c2 <.L0>:

                case MAVLINK_MSG_ID_SCALED_PRESSURE:
                    mavlink_msg_scaled_pressure_decode(&msg, &mlAirData);
   102c2:	81 07 21    	mov.w     #0x1078, w1
   102c4:	c0 ed 2f    	mov.w     #0xfedc, w0
   102c6:	0f 00 40    	add.w     w0, w15, w0
   102c8:	46 ff 07    	rcall     0x10156 <_mavlink_msg_scaled_pressure_decode> <L0> <.LFB237> <.LFE274>

000102ca <.L0>:
                    break;
   102ca:	13 00 37    	bra       0x102f2 <.L0> <.L45>

000102cc <.L0>:

                case MAVLINK_MSG_ID_ATTITUDE:
                    mavlink_msg_attitude_decode(&msg, &mlAttitudeData);
   102cc:	61 0c 21    	mov.w     #0x10c6, w1
   102ce:	c0 ed 2f    	mov.w     #0xfedc, w0
   102d0:	0f 00 40    	add.w     w0, w15, w0
   102d2:	46 ff 07    	rcall     0x10160 <_mavlink_msg_attitude_decode> <L0> <.LFB249> <.LFE237>

000102d4 <.L0>:
                    break;
   102d4:	0e 00 37    	bra       0x102f2 <.L0> <.L45>

000102d6 <.L0>:

                case MAVLINK_MSG_ID_RAW_IMU:
                    mavlink_msg_raw_imu_decode(&msg, &mlRawImuData);
   102d6:	c1 09 21    	mov.w     #0x109c, w1
   102d8:	c0 ed 2f    	mov.w     #0xfedc, w0
   102da:	0f 00 40    	add.w     w0, w15, w0
   102dc:	46 ff 07    	rcall     0x1016a <_mavlink_msg_raw_imu_decode> <L0> <.LFB218> <.LFE249>

000102de <.L0>:
                    break;
   102de:	09 00 37    	bra       0x102f2 <.L0> <.L45>

000102e0 <.L0>:

                case MAVLINK_MSG_ID_RAW_PRESSURE:
                    mavlink_msg_raw_pressure_decode(&msg, &mlRawPressureData);
   102e0:	61 0b 21    	mov.w     #0x10b6, w1
   102e2:	c0 ed 2f    	mov.w     #0xfedc, w0
   102e4:	0f 00 40    	add.w     w0, w15, w0
   102e6:	46 ff 07    	rcall     0x10174 <_mavlink_msg_raw_pressure_decode> <L0> <.LFB228> <.LFE218>

000102e8 <.L0>:
                    break;
   102e8:	04 00 37    	bra       0x102f2 <.L0> <.L45>

000102ea <.L0>:

                case MAVLINK_MSG_ID_GPS_DATE_TIME:
                    mavlink_msg_gps_date_time_decode(&msg, &mlGpsDateTime);
   102ea:	41 1a 24    	mov.w     #0x41a4, w1
   102ec:	c0 ed 2f    	mov.w     #0xfedc, w0
   102ee:	0f 00 40    	add.w     w0, w15, w0
   102f0:	46 ff 07    	rcall     0x1017e <_mavlink_msg_gps_date_time_decode> <L0> <.LFB1333> <.LFE228>

000102f2 <.L0>:
   102f2:	08 44 e8    	inc.b     w8, w8
   102f4:	99 4f 14    	subr.b    w8, [w9], [w15]
   102f6:	b5 ff 31    	bra       C, 0x10262 <.L0> <.L56>

000102f8 <.L43>:
                    break;

            } // switch	
        } // if
    }// for  
}
   102f8:	4f 05 78    	mov.w     [--w15], w10
   102fa:	4f 04 be    	mov.d     [--w15], w8
   102fc:	00 80 fa    	ulnk      
   102fe:	00 00 06    	return    

00010300 <_AUAV_V3_Mavlink_TX_AdapterTID0>:
   10300:	88 9f be    	mov.d     w8, [w15++]
   10302:	d0 91 80    	mov.w     0x123a, w0
   10304:	e1 91 80    	mov.w     0x123c, w1
   10306:	d0 10 89    	mov.w     w0, 0x221a
   10308:	e1 10 89    	mov.w     w1, 0x221c

0001030a <.L0>:
   1030a:	70 3d 2a    	mov.w     #0xa3d7, w0
   1030c:	91 83 80    	mov.w     0x1072, w1
   *  DataTypeConversion: '<S8>/Data Type Conversion2'
   *  Gain: '<S8>/Gain'
   */
  mlVfr_hud.airspeed = mlNavigation.u_m;
  mlVfr_hud.groundspeed = (real32_T)(41943UL * mlGpsData.vel) * 2.38418579E-7F;
   1030e:	00 08 b8    	mul.uu    w1, w0, w0
   10310:	12 19 02    	call      0x1912 <___floatunsisf>
   10312:	00 00 00 
   10314:	02 00 20    	mov.w     #0x0, w2
   10316:	03 48 23    	mov.w     #0x3480, w3
   10318:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   1031a:	00 00 00 
   1031c:	f0 10 89    	mov.w     w0, 0x221e
   1031e:	01 11 89    	mov.w     w1, 0x2220

00010320 <.L0>:
  mlVfr_hud.alt = mlLocalPositionData.z;
   10320:	70 87 80    	mov.w     0x10ee, w0
   10322:	81 87 80    	mov.w     0x10f0, w1
   10324:	10 11 89    	mov.w     w0, 0x2222
   10326:	21 11 89    	mov.w     w1, 0x2224
  mlVfr_hud.climb = mlLocalPositionData.vz;
   10328:	d0 87 80    	mov.w     0x10fa, w0
   1032a:	e1 87 80    	mov.w     0x10fc, w1
   1032c:	30 11 89    	mov.w     w0, 0x2226
   1032e:	41 11 89    	mov.w     w1, 0x2228

00010330 <.L0>:

  /* DataTypeConversion: '<S8>/Data Type Conversion1' incorporates:
   *  DataStoreRead: '<S8>/Get VfrHud3'
   *  Gain: '<S8>/Gain1'
   */
  tmp_0 = (real32_T)floor(57.2957802F * mlAttitudeSol.yaw);
   10330:	12 ee 22    	mov.w     #0x2ee1, w2
   10332:	53 26 24    	mov.w     #0x4265, w3
   10334:	50 0f 81    	mov.w     0x21ea, w0
   10336:	61 0f 81    	mov.w     0x21ec, w1
   10338:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   1033a:	00 00 00 
   1033c:	16 19 02    	call      0x1916 <_floorf>
   1033e:	00 00 00 
   10340:	00 04 be    	mov.d     w0, w8

00010342 <.L0>:
  if (rtIsNaNF(tmp_0) || rtIsInfF(tmp_0)) {
   10342:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
   10344:	01 00 00 
   10346:	00 04 e0    	cp0.b     w0
   10348:	56 00 3a    	bra       NZ, 0x103f6 <.L2>
   1034a:	08 00 be    	mov.d     w8, w0
   1034c:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
   1034e:	01 00 00 
   10350:	00 04 e0    	cp0.b     w0
   10352:	51 00 3a    	bra       NZ, 0x103f6 <.L2>

00010354 <.L0>:
    tmp_0 = 0.0F;
  } else {
    tmp_0 = (real32_T)fmod(tmp_0, 65536.0F);
   10354:	02 00 20    	mov.w     #0x0, w2
   10356:	03 78 24    	mov.w     #0x4780, w3
   10358:	08 00 be    	mov.d     w8, w0
   1035a:	26 19 02    	call      0x1926 <_fmodf>
   1035c:	00 00 00 
   1035e:	00 04 be    	mov.d     w0, w8

00010360 <.L0>:
  }

  /* DataStoreWrite: '<S8>/Set VfrHud' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion1'
   */
  mlVfr_hud.heading = tmp_0 < 0.0F ? -(int16_T)(uint16_T)-tmp_0 : (int16_T)
   10360:	60 11 b8    	mul.uu    w2, #0x0, w2
   10362:	00 00 be    	mov.d     w0, w0
   10364:	8c 18 02    	call      0x188c <___eqsf2>
   10366:	00 00 00 
   10368:	00 00 e0    	cp0.w     w0
   1036a:	06 00 3d    	bra       GE, 0x10378 <.L0> <.L0> <.L3>
   1036c:	08 00 be    	mov.d     w8, w0
   1036e:	01 f0 a2    	btg.w     w1, #0xf
   10370:	d6 18 02    	call      0x18d6 <___fixunssfsi>
   10372:	00 00 00 
   10374:	00 00 ea    	neg.w     w0, w0
   10376:	03 00 37    	bra       0x1037e <.L0> <.L5>

00010378 <.L0>:
    (uint16_T)tmp_0;
   10378:	08 00 be    	mov.d     w8, w0
   1037a:	d6 18 02    	call      0x18d6 <___fixunssfsi>
   1037c:	00 00 00 

0001037e <.L0>:
   1037e:	50 11 89    	mov.w     w0, 0x222a

00010380 <.L0>:

  /* DataTypeConversion: '<S8>/Data Type Conversion5' incorporates:
   *  Constant: '<S8>/Constant1'
   *  DataStoreRead: '<S8>/Get VfrHud5'
   *  Gain: '<S8>/Gain2'
   *  Sum: '<S8>/Sum1'
   */
  tmp = (int16_T)floor(((real_T)mlPwmCommands.servo1_raw - 189.0) * 0.47);
   10380:	70 88 80    	mov.w     0x110e, w0
   10382:	80 00 eb    	clr.w     w1
   10384:	12 19 02    	call      0x1912 <___floatunsisf>
   10386:	00 00 00 
   10388:	02 00 20    	mov.w     #0x0, w2
   1038a:	d3 33 24    	mov.w     #0x433d, w3
   1038c:	90 14 02    	call      0x1490 <___subsf3>
   1038e:	00 00 00 
   10390:	72 3d 2a    	mov.w     #0xa3d7, w2
   10392:	03 ef 23    	mov.w     #0x3ef0, w3
   10394:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   10396:	00 00 00 
   10398:	16 19 02    	call      0x1916 <_floorf>
   1039a:	00 00 00 
   1039c:	94 18 02    	call      0x1894 <___fixsfsi>
   1039e:	00 00 00 

000103a0 <.L0>:
  tmp = (int16_T)fmod(tmp, 65536.0);
   103a0:	cf 80 de    	asr.w     w0, #0xf, w1
   103a2:	0c 19 02    	call      0x190c <___floatsisf>
   103a4:	00 00 00 
   103a6:	02 00 20    	mov.w     #0x0, w2
   103a8:	03 78 24    	mov.w     #0x4780, w3
   103aa:	26 19 02    	call      0x1926 <_fmodf>
   103ac:	00 00 00 
   103ae:	94 18 02    	call      0x1894 <___fixsfsi>
   103b0:	00 00 00 

000103b2 <.L0>:

  /* DataStoreWrite: '<S8>/Set VfrHud' incorporates:
   *  DataTypeConversion: '<S8>/Data Type Conversion5'
   */
  mlVfr_hud.throttle = tmp < 0 ? (uint16_T)-(int16_T)(uint16_T)-(real_T)tmp :
   103b2:	00 00 e0    	cp0.w     w0
   103b4:	07 00 3d    	bra       GE, 0x103c4 <.L7>
   103b6:	cf 80 de    	asr.w     w0, #0xf, w1
   103b8:	0c 19 02    	call      0x190c <___floatsisf>
   103ba:	00 00 00 
   103bc:	01 f0 a2    	btg.w     w1, #0xf
   103be:	d6 18 02    	call      0x18d6 <___fixunssfsi>
   103c0:	00 00 00 
   103c2:	00 00 ea    	neg.w     w0, w0

000103c4 <.L7>:
   103c4:	60 11 89    	mov.w     w0, 0x222c

000103c6 <.L0>:
    (uint16_T)tmp;

  /* RateTransition: '<S8>/RawIMU Rate Transition' incorporates:
   *  RateTransition: '<S8>/Attitude Rate Transition'
   *  RateTransition: '<S8>/Attitude Rate Transition1'
   */
  if (AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_2 == 1) {
   103c6:	b0 f3 85    	mov.w     0xbe76, w0
   103c8:	b0 58 90    	mov.b     [w0+27], w1
   103ca:	e1 cf 50    	sub.b     w1, #0x1, [w15]
   103cc:	0c 00 3a    	bra       NZ, 0x103e6 <.L8>
    AUAV_V3_TestSensors_B.RawIMURateTransition = mlRawImuData;
   103ce:	61 57 21    	mov.w     #0x1576, w1
   103d0:	c2 09 21    	mov.w     #0x109c, w2
   103d2:	0c 00 09    	.pword 0x09000c
   103d4:	b2 18 78    	mov.w     [w2++], [w1++]
    AUAV_V3_TestSensors_B.AttitudeRateTransition = mlAttitudeSol;
   103d6:	61 4e 21    	mov.w     #0x14e6, w1
   103d8:	e2 1d 22    	mov.w     #0x21de, w2
   103da:	0d 00 09    	.pword 0x09000d
   103dc:	b2 18 78    	mov.w     [w2++], [w1++]
    AUAV_V3_TestSensors_B.AttitudeRateTransition1 = mlNavigation;
   103de:	01 52 21    	mov.w     #0x1520, w1
   103e0:	a2 23 21    	mov.w     #0x123a, w2
   103e2:	0f 00 09    	.pword 0x09000f
   103e4:	b2 18 78    	mov.w     [w2++], [w1++]

000103e6 <.L8>:
  }

  /* End of RateTransition: '<S8>/RawIMU Rate Transition' */

  /* RateTransition: '<S8>/RC Rate Transition' */
  if (AUAV_V3_TestSensors_M->Timing.RateInteraction.TID0_3 == 1) {
   103e6:	40 58 90    	mov.b     [w0+28], w0
   103e8:	e1 4f 50    	sub.b     w0, #0x1, [w15]
   103ea:	07 00 3a    	bra       NZ, 0x103fa <.L1>
    AUAV_V3_TestSensors_B.RCRateTransition = mlPilotConsoleData;
   103ec:	00 56 21    	mov.w     #0x1560, w0
   103ee:	61 08 21    	mov.w     #0x1086, w1
   103f0:	0a 00 09    	.pword 0x09000a
   103f2:	31 18 78    	mov.w     [w1++], [w0++]
   103f4:	02 00 37    	bra       0x103fa <.L1>

000103f6 <.L2>:
   103f6:	60 44 b8    	mul.uu    w8, #0x0, w8
   103f8:	bf ff 37    	bra       0x10378 <.L0> <.L0> <.L3>

000103fa <.L1>:
  }

  /* End of RateTransition: '<S8>/RC Rate Transition' */
}
   103fa:	4f 04 be    	mov.d     [--w15], w8
   103fc:	00 00 06    	return    

000103fe <_AUAV_V3_Mavlink_TX_AdapterTID2>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID2(void)
{
   103fe:	00 00 fa    	lnk       #0x0
   10400:	88 1f 78    	mov.w     w8, [w15++]
  /* DataStoreRead: '<S8>/Get time' */
  AUAV_V3_TestSensors_B.Gettime = AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   10402:	08 ff 21    	mov.w     #0x1ff0, w8
   10404:	18 01 be    	mov.d     [w8], w2
   10406:	92 c8 88    	mov.w     w2, 0x1912
   10408:	a3 c8 88    	mov.w     w3, 0x1914

0001040a <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackRawIMU' */
  AUAV_V3_TestSensors_B.PackRawIMU = PackRawIMU(
   1040a:	fa 87 47    	add.w     w15, #0x1a, w15
   1040c:	7a 80 57    	sub.w     w15, #0x1a, w0
   1040e:	61 57 21    	mov.w     #0x1576, w1
   10410:	0c 00 09    	.pword 0x09000c
   10412:	31 18 78    	mov.w     [w1++], [w0++]
   10414:	11 c0 b3    	mov.b     #0x1, w1
   10416:	50 c6 b3    	mov.b     #0x65, w0
   10418:	b2 d0 02    	call      0xd0b2 <_PackRawIMU>
   1041a:	00 00 00 
   1041c:	60 cf 88    	mov.w     w0, 0x19ec

0001041e <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.RawIMURateTransition
    , AUAV_V3_TestSensors_B.Gettime
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data' */
  TxN_Data_OverU1(
   1041e:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10420:	00 00 00 
                  AUAV_V3_TestSensors_B.PackRawIMU
                  );

  /* DataStoreRead: '<S8>/Get time6' */
  AUAV_V3_TestSensors_B.Gettime6 =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   10422:	18 01 be    	mov.d     [w8], w2
   10424:	b2 c8 88    	mov.w     w2, 0x1916
   10426:	c3 c8 88    	mov.w     w3, 0x1918

00010428 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/Pack Attitude' */
  AUAV_V3_TestSensors_B.PackAttitude = PackRawAttitude(
   10428:	fc 87 47    	add.w     w15, #0x1c, w15
   1042a:	7c 80 57    	sub.w     w15, #0x1c, w0
   1042c:	61 4e 21    	mov.w     #0x14e6, w1
   1042e:	0d 00 09    	.pword 0x09000d
   10430:	31 18 78    	mov.w     [w1++], [w0++]
   10432:	11 c0 b3    	mov.b     #0x1, w1
   10434:	50 c6 b3    	mov.b     #0x65, w0
   10436:	f6 d0 02    	call      0xd0f6 <_PackRawAttitude>
   10438:	00 00 00 
   1043a:	80 cf 88    	mov.w     w0, 0x19f0

0001043c <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.AttitudeRateTransition
    , AUAV_V3_TestSensors_B.Gettime6
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data10' */
  TxN_Data_OverU1(
   1043c:	6f 03 b1    	sub.w     #0x36, w15
   1043e:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10440:	00 00 00 

00010442 <.L0>:
                  AUAV_V3_TestSensors_B.PackAttitude
                  );

  /* DataStoreRead: '<S8>/Get time7' */
  AUAV_V3_TestSensors_B.Gettime7 =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   10442:	18 01 be    	mov.d     [w8], w2
   10444:	d2 c8 88    	mov.w     w2, 0x191a
   10446:	e3 c8 88    	mov.w     w3, 0x191c

00010448 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/Pack Navigation' */
  AUAV_V3_TestSensors_B.PackNavigation = PackRawNavigation(
   10448:	0f 02 b0    	add.w     #0x20, w15
   1044a:	08 fe 2f    	mov.w     #0xffe0, w8
   1044c:	0f 04 44    	add.w     w8, w15, w8
   1044e:	00 52 21    	mov.w     #0x1520, w0
   10450:	0f 00 09    	.pword 0x09000f
   10452:	30 1c 78    	mov.w     [w0++], [w8++]
   10454:	08 02 b1    	sub.w     #0x20, w8
   10456:	11 c0 b3    	mov.b     #0x1, w1
   10458:	50 c6 b3    	mov.b     #0x65, w0
   1045a:	38 d1 02    	call      0xd138 <_PackRawNavigation>
   1045c:	00 00 00 
   1045e:	90 cf 88    	mov.w     w0, 0x19f2

00010460 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.AttitudeRateTransition1
    , AUAV_V3_TestSensors_B.Gettime7
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data11' */
  TxN_Data_OverU1(
   10460:	88 07 78    	mov.w     w8, w15
   10462:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10464:	00 00 00 

00010466 <.L0>:
                  AUAV_V3_TestSensors_B.PackNavigation
                  );
}
   10466:	4f 04 78    	mov.w     [--w15], w8
   10468:	00 80 fa    	ulnk      
   1046a:	00 00 06    	return    

0001046c <_AUAV_V3_Mavlink_TX_AdapterTID3>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID3(void)
{
   1046c:	00 00 fa    	lnk       #0x0
   1046e:	88 1f 78    	mov.w     w8, [w15++]
  /* DataStoreRead: '<S8>/Get time3' */
  AUAV_V3_TestSensors_B.Gettime3 =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   10470:	08 ff 21    	mov.w     #0x1ff0, w8
   10472:	18 01 be    	mov.d     [w8], w2
   10474:	32 c9 88    	mov.w     w2, 0x1926
   10476:	43 c9 88    	mov.w     w3, 0x1928

00010478 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackRawRC' */
  AUAV_V3_TestSensors_B.PackRawRC = PackRawRC(
   10478:	f6 87 47    	add.w     w15, #0x16, w15
   1047a:	76 80 57    	sub.w     w15, #0x16, w0
   1047c:	01 56 21    	mov.w     #0x1560, w1
   1047e:	0a 00 09    	.pword 0x09000a
   10480:	31 18 78    	mov.w     [w1++], [w0++]
   10482:	11 c0 b3    	mov.b     #0x1, w1
   10484:	50 c6 b3    	mov.b     #0x65, w0
   10486:	26 d3 02    	call      0xd326 <_PackRawRC>
   10488:	00 00 00 
   1048a:	f0 cf 88    	mov.w     w0, 0x19fe

0001048c <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.RCRateTransition
    , AUAV_V3_TestSensors_B.Gettime3
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data7' */
  TxN_Data_OverU1(
   1048c:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   1048e:	00 00 00 
                  AUAV_V3_TestSensors_B.PackRawRC
                  );

  /* DataStoreRead: '<S8>/Get VfrHud' */
  AUAV_V3_TestSensors_B.GetVfrHud = mlVfr_hud;
   10490:	c0 5b 21    	mov.w     #0x15bc, w0
   10492:	a1 21 22    	mov.w     #0x221a, w1
   10494:	09 00 09    	.pword 0x090009
   10496:	31 18 78    	mov.w     [w1++], [w0++]
   10498:	40 01 b1    	sub.w     #0x14, w0

  /* DataStoreRead: '<S8>/Get time4' */
  AUAV_V3_TestSensors_B.Gettime4_e =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   1049a:	18 01 be    	mov.d     [w8], w2
   1049c:	52 c9 88    	mov.w     w2, 0x192a
   1049e:	63 c9 88    	mov.w     w3, 0x192c

000104a0 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackHUD' */
  AUAV_V3_TestSensors_B.PackHUD = PackVFR_HUD(
   104a0:	f4 87 47    	add.w     w15, #0x14, w15
   104a2:	f4 80 57    	sub.w     w15, #0x14, w1
   104a4:	09 00 09    	.pword 0x090009
   104a6:	b0 18 78    	mov.w     [w0++], [w1++]
   104a8:	40 01 b1    	sub.w     #0x14, w0
   104aa:	11 c0 b3    	mov.b     #0x1, w1
   104ac:	50 c6 b3    	mov.b     #0x65, w0
   104ae:	68 d3 02    	call      0xd368 <_PackVFR_HUD>
   104b0:	00 00 00 
   104b2:	00 d0 88    	mov.w     w0, 0x1a00

000104b4 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.GetVfrHud
    , AUAV_V3_TestSensors_B.Gettime4_e
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data8' */
  TxN_Data_OverU1(
   104b4:	af 02 b1    	sub.w     #0x2a, w15
   104b6:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   104b8:	00 00 00 

000104ba <.L0>:
                  AUAV_V3_TestSensors_B.PackHUD
                  );

  /* DataStoreRead: '<S8>/Get Raw Commands' */
  AUAV_V3_TestSensors_B.GetRawCommands_p = mlPwmCommands;
   104ba:	60 5a 21    	mov.w     #0x15a6, w0
   104bc:	a1 10 21    	mov.w     #0x110a, w1
   104be:	0a 00 09    	.pword 0x09000a
   104c0:	31 18 78    	mov.w     [w1++], [w0++]
   104c2:	60 01 b1    	sub.w     #0x16, w0

  /* DataStoreRead: '<S8>/Get time5' */
  AUAV_V3_TestSensors_B.Gettime5_a =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   104c4:	18 01 be    	mov.d     [w8], w2
   104c6:	72 c9 88    	mov.w     w2, 0x192e
   104c8:	83 c9 88    	mov.w     w3, 0x1930

000104ca <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackRawServo' */
  AUAV_V3_TestSensors_B.PackRawServo_d = PackRawServo(
   104ca:	f6 87 47    	add.w     w15, #0x16, w15
   104cc:	76 84 57    	sub.w     w15, #0x16, w8
   104ce:	0a 00 09    	.pword 0x09000a
   104d0:	30 1c 78    	mov.w     [w0++], [w8++]
   104d2:	68 01 b1    	sub.w     #0x16, w8
   104d4:	60 01 b1    	sub.w     #0x16, w0
   104d6:	11 c0 b3    	mov.b     #0x1, w1
   104d8:	50 c6 b3    	mov.b     #0x65, w0
   104da:	aa d2 02    	call      0xd2aa <_PackRawServo>
   104dc:	00 00 00 
   104de:	10 d0 88    	mov.w     w0, 0x1a02

000104e0 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.GetRawCommands_p
    , AUAV_V3_TestSensors_B.Gettime5_a
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data9' */
  TxN_Data_OverU1(
   104e0:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   104e2:	00 00 00 
   104e4:	88 07 78    	mov.w     w8, w15
                  AUAV_V3_TestSensors_B.PackRawServo_d
                  );
}
   104e6:	4f 04 78    	mov.w     [--w15], w8
   104e8:	00 80 fa    	ulnk      
   104ea:	00 00 06    	return    

000104ec <_AUAV_V3_Mavlink_TX_AdapterTID4>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID4(void)
{
   104ec:	00 00 fa    	lnk       #0x0
   104ee:	88 1f 78    	mov.w     w8, [w15++]
  /* DataStoreRead: '<S8>/Get mlAirData' */
  AUAV_V3_TestSensors_B.GetmlAirData = mlAirData;
   104f0:	00 5d 21    	mov.w     #0x15d0, w0
   104f2:	81 07 21    	mov.w     #0x1078, w1
   104f4:	06 00 09    	.pword 0x090006
   104f6:	31 18 78    	mov.w     [w1++], [w0++]
   104f8:	e0 00 b1    	sub.w     #0xe, w0

  /* DataStoreRead: '<S8>/Get time2' */
  AUAV_V3_TestSensors_B.Gettime2 =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   104fa:	82 ff 80    	mov.w     0x1ff0, w2
   104fc:	93 ff 80    	mov.w     0x1ff2, w3
   104fe:	12 c9 88    	mov.w     w2, 0x1922
   10500:	23 c9 88    	mov.w     w3, 0x1924

00010502 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackScaledPressure' */
  AUAV_V3_TestSensors_B.PackScaledPressure = PackScaledPressure(
   10502:	ee 87 47    	add.w     w15, #0xe, w15
   10504:	6e 84 57    	sub.w     w15, #0xe, w8
   10506:	06 00 09    	.pword 0x090006
   10508:	30 1c 78    	mov.w     [w0++], [w8++]
   1050a:	e8 00 b1    	sub.w     #0xe, w8
   1050c:	e0 00 b1    	sub.w     #0xe, w0
   1050e:	11 c0 b3    	mov.b     #0x1, w1
   10510:	50 c6 b3    	mov.b     #0x65, w0
   10512:	16 d2 02    	call      0xd216 <_PackScaledPressure>
   10514:	00 00 00 
   10516:	b0 cf 88    	mov.w     w0, 0x19f6

00010518 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.GetmlAirData
    , AUAV_V3_TestSensors_B.Gettime2
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data3' */
  TxN_Data_OverU1(
   10518:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   1051a:	00 00 00 
   1051c:	88 07 78    	mov.w     w8, w15
                  AUAV_V3_TestSensors_B.PackScaledPressure
                  );
}
   1051e:	4f 04 78    	mov.w     [--w15], w8
   10520:	00 80 fa    	ulnk      
   10522:	00 00 06    	return    

00010524 <_AUAV_V3_Mavlink_TX_AdapterTID5>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID5(void)
{
   10524:	00 00 fa    	lnk       #0x0
   10526:	88 1f 78    	mov.w     w8, [w15++]
  /* DataStoreRead: '<S8>/Get mlSysStatus' */
  AUAV_V3_TestSensors_B.GetmlSysStatus = mlSysStatus;
   10528:	00 54 21    	mov.w     #0x1540, w0
   1052a:	a1 1f 22    	mov.w     #0x21fa, w1
   1052c:	0f 00 09    	.pword 0x09000f
   1052e:	31 18 78    	mov.w     [w1++], [w0++]
   10530:	00 02 b1    	sub.w     #0x20, w0

00010532 <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackSysStatus' */
  AUAV_V3_TestSensors_B.PackSysStatus = PackSysStatus(
   10532:	0f 02 b0    	add.w     #0x20, w15
   10534:	08 fe 2f    	mov.w     #0xffe0, w8
   10536:	0f 04 44    	add.w     w8, w15, w8
   10538:	0f 00 09    	.pword 0x09000f
   1053a:	30 1c 78    	mov.w     [w0++], [w8++]
   1053c:	08 02 b1    	sub.w     #0x20, w8
   1053e:	00 02 b1    	sub.w     #0x20, w0
   10540:	11 c0 b3    	mov.b     #0x1, w1
   10542:	50 c6 b3    	mov.b     #0x65, w0
   10544:	58 d2 02    	call      0xd258 <_PackSysStatus>
   10546:	00 00 00 
   10548:	c0 cf 88    	mov.w     w0, 0x19f8

0001054a <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.GetmlSysStatus
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data4' */
  TxN_Data_OverU1(
   1054a:	88 07 78    	mov.w     w8, w15
   1054c:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   1054e:	00 00 00 

00010550 <.L0>:
                  AUAV_V3_TestSensors_B.PackSysStatus
                  );
}
   10550:	4f 04 78    	mov.w     [--w15], w8
   10552:	00 80 fa    	ulnk      
   10554:	00 00 06    	return    

00010556 <_AUAV_V3_Mavlink_TX_AdapterTID6>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID6(void)
{
  /* S-Function (MCHP_C_function_Call): '<S8>/ParamInterfaceResponse' */
  AUAV_V3_TestSensors_B.ParamInterfaceResponse = ParameterInterfaceResponse(
   10556:	11 c0 b3    	mov.b     #0x1, w1
   10558:	50 c6 b3    	mov.b     #0x65, w0
   1055a:	42 cf 02    	call      0xcf42 <_ParameterInterfaceResponse>
   1055c:	00 00 00 
   1055e:	d0 cf 88    	mov.w     w0, 0x19fa

00010560 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data5' */
  TxN_Data_OverU1(
   10560:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10562:	00 00 00 
                  AUAV_V3_TestSensors_B.ParamInterfaceResponse
                  );
}
   10564:	00 00 06    	return    

00010566 <_AUAV_V3_Mavlink_TX_AdapterTID7>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID7(void)
{
  /* S-Function (MCHP_C_function_Call): '<S8>/MissionInterfaceResponse' */
  AUAV_V3_TestSensors_B.MissionInterfaceResponse = MissionInterfaceResponse(
   10566:	11 c0 b3    	mov.b     #0x1, w1
   10568:	50 c6 b3    	mov.b     #0x65, w0
   1056a:	bc d3 02    	call      0xd3bc <_MissionInterfaceResponse>
   1056c:	00 00 00 
   1056e:	e0 cf 88    	mov.w     w0, 0x19fc

00010570 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data6' */
  TxN_Data_OverU1(
   10570:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10572:	00 00 00 
                  AUAV_V3_TestSensors_B.MissionInterfaceResponse
                  );
}
   10574:	00 00 06    	return    

00010576 <_AUAV_V3_Mavlink_TX_AdapterTID9>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID9(void)
{
  /* S-Function (MCHP_C_function_Call): '<S8>/PackHeartBeat' */
  AUAV_V3_TestSensors_B.PackHeartBeat = PackHeartBeat(
   10576:	11 c0 b3    	mov.b     #0x1, w1
   10578:	50 c6 b3    	mov.b     #0x65, w0
   1057a:	42 d0 02    	call      0xd042 <_PackHeartBeat>
   1057c:	00 00 00 
   1057e:	70 cf 88    	mov.w     w0, 0x19ee

00010580 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data1' */
  TxN_Data_OverU1(
   10580:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   10582:	00 00 00 
                  AUAV_V3_TestSensors_B.PackHeartBeat
                  );
}
   10584:	00 00 06    	return    

00010586 <_AUAV_V3_Mavlink_TX_AdapterTID10>:

/* Output and update for atomic system: '<Root>/Mavlink_TX_Adapter' */
void AUAV_V3_Mavlink_TX_AdapterTID10(void)
{
   10586:	00 00 fa    	lnk       #0x0
   10588:	88 1f 78    	mov.w     w8, [w15++]

0001058a <.L0>:
  /* DataStoreRead: '<S8>/Get RawGpsInt' */
  AUAV_V3_TestSensors_B.GetRawGpsInt = mlGpsData;
   1058a:	20 50 21    	mov.w     #0x1502, w0
   1058c:	a1 05 21    	mov.w     #0x105a, w1
   1058e:	0e 00 09    	.pword 0x09000e
   10590:	31 18 78    	mov.w     [w1++], [w0++]
   10592:	e0 01 b1    	sub.w     #0x1e, w0

00010594 <.L0>:

  /* DataStoreRead: '<S8>/Get time1' */
  AUAV_V3_TestSensors_B.Gettime1 =
    AUAV_V3_TestSensors_DWork.time_since_boot_usec;
   10594:	82 ff 80    	mov.w     0x1ff0, w2
   10596:	93 ff 80    	mov.w     0x1ff2, w3
   10598:	f2 c8 88    	mov.w     w2, 0x191e
   1059a:	03 c9 88    	mov.w     w3, 0x1920

0001059c <.L0>:

  /* S-Function (MCHP_C_function_Call): '<S8>/PackGpsRawInt' */
  AUAV_V3_TestSensors_B.PackGpsRawInt = PackGpsRawInt(
   1059c:	fe 87 47    	add.w     w15, #0x1e, w15
   1059e:	7e 84 57    	sub.w     w15, #0x1e, w8
   105a0:	0e 00 09    	.pword 0x09000e
   105a2:	30 1c 78    	mov.w     [w0++], [w8++]
   105a4:	e8 01 b1    	sub.w     #0x1e, w8
   105a6:	e0 01 b1    	sub.w     #0x1e, w0
   105a8:	11 c0 b3    	mov.b     #0x1, w1
   105aa:	50 c6 b3    	mov.b     #0x65, w0
   105ac:	c8 d1 02    	call      0xd1c8 <_PackGpsRawInt>
   105ae:	00 00 00 
   105b0:	a0 cf 88    	mov.w     w0, 0x19f4

000105b2 <.L0>:
    ((uint8_T)101U)
    , ((uint8_T)1U)
    , AUAV_V3_TestSensors_B.GetRawGpsInt
    , AUAV_V3_TestSensors_B.Gettime1
    );

  /* S-Function (MCHP_C_function_Call): '<S8>/TX_N_Data2' */
  TxN_Data_OverU1(
   105b2:	d4 d5 02    	call      0xd5d4 <_TxN_Data_OverU1>
   105b4:	00 00 00 
   105b6:	88 07 78    	mov.w     w8, w15
                  AUAV_V3_TestSensors_B.PackGpsRawInt
                  );
}
   105b8:	4f 04 78    	mov.w     [--w15], w8
   105ba:	00 80 fa    	ulnk      
   105bc:	00 00 06    	return    
Disassembly of section .dinit:

000105be <.dinit>:
   105be:	5a 10 00    	nop       
   105c0:	f4 11 00    	nop       
   105c2:	80 00 00    	nop       
   105c4:	7a 44 00    	nop       
   105c6:	16 00 00    	nop       
   105c8:	82 00 00    	nop       
	...
   105ce:	00 00 12    	subr.w    w4, w0, w0
   105d0:	00 10 00    	nop       
   105d2:	0e 00 0c    	bra       OA, 0x105f0
	...
   105da:	90 44 00    	nop       
   105dc:	06 00 00    	nop       
   105de:	80 00 00    	nop       
   105e0:	50 10 00    	nop       
   105e2:	08 00 00    	nop       
   105e4:	80 00 00    	nop       
   105e6:	a0 43 00    	nop       
   105e8:	3c 00 00    	nop       
   105ea:	80 00 00    	nop       
   105ec:	26 44 00    	nop       
   105ee:	20 00 00    	nop       
   105f0:	80 00 00    	nop       
   105f2:	46 44 00    	nop       
   105f4:	1c 00 00    	nop       
   105f6:	80 00 00    	nop       
   105f8:	6a 3a 00    	nop       
   105fa:	04 02 00    	nop       
   105fc:	80 00 00    	nop       
   105fe:	6e 3c 00    	nop       
   10600:	04 02 00    	nop       
   10602:	80 00 00    	nop       
   10604:	4e 22 00    	nop       
   10606:	30 0a 00    	nop       
   10608:	80 00 00    	nop       
   1060a:	56 43 00    	nop       
   1060c:	4a 00 00    	nop       
   1060e:	80 00 00    	nop       
   10610:	58 36 00    	nop       
   10612:	0a 02 00    	nop       
   10614:	80 00 00    	nop       
   10616:	a0 44 00    	nop       
   10618:	02 00 00    	nop       
   1061a:	82 00 00    	nop       
   1061c:	01 00 00    	nop       
   1061e:	62 38 00    	nop       
   10620:	08 02 00    	nop       
   10622:	80 00 00    	nop       
   10624:	e0 31 00    	nop       
   10626:	78 04 00    	nop       
   10628:	80 00 00    	nop       
   1062a:	a2 44 00    	nop       
   1062c:	02 00 00    	nop       
   1062e:	82 00 00    	nop       
   10630:	01 00 00    	nop       
   10632:	7e 2c 00    	nop       
   10634:	62 05 00    	nop       
   10636:	80 00 00    	nop       
   10638:	0e 42 00    	nop       
   1063a:	a6 00 00    	nop       
   1063c:	80 00 00    	nop       
   1063e:	5c 41 00    	nop       
   10640:	b2 00 00    	nop       
   10642:	80 00 00    	nop       
   10644:	a4 44 00    	nop       
   10646:	02 00 00    	nop       
   10648:	82 00 00    	nop       
   1064a:	01 00 00    	nop       
   1064c:	9c 44 00    	nop       
   1064e:	04 00 00    	nop       
   10650:	80 00 00    	nop       
   10652:	9c 40 00    	nop       
   10654:	c0 00 00    	nop       
   10656:	80 00 00    	nop       
   10658:	62 44 00    	nop       
   1065a:	18 00 00    	nop       
   1065c:	80 00 00    	nop       
   1065e:	02 44 00    	nop       
   10660:	24 00 00    	nop       
   10662:	82 00 00    	nop       
   10664:	00 00 00    	nop       
   10666:	00 cf 07    	rcall     0xa468 <.L0> <.L0>
   10668:	00 00 00    	nop       
   1066a:	00 31 f8    	push      0x3100
   1066c:	b2 ec 18    	subbr.b   w1, [w2++], [++w9]
   1066e:	ff ee 03    	.pword 0x03eeff
   10670:	04 05 06    	.pword 0x060504
   10672:	07 08 09    	.pword 0x090807
   10674:	0a 0b 0c    	bra       OA, 0x11c8a
   10676:	0d 0e 0f    	bra       SB, 0x12292
   10678:	10 11 12    	subr.w    w4, [w0], [w2--]
   1067a:	13 14 00    	nop       
   1067c:	b4 42 00    	nop       
   1067e:	a2 00 00    	nop       
   10680:	80 00 00    	nop       
   10682:	58 10 00    	nop       
   10684:	02 00 00    	nop       
   10686:	80 00 00    	nop       
   10688:	d2 3f 00    	nop       
   1068a:	ca 00 00    	nop       
   1068c:	82 00 00    	nop       
   1068e:	30 31 32    	bra       Z, 0x168f0
   10690:	33 34 35    	bra       LT, 0x16ef8
   10692:	36 37 38    	bra       NOV, 0x17500
   10694:	39 41 42    	add.b     w4, [w9++], w2
   10696:	43 44 45    	add.b     w10, [--w3], w8
   10698:	46 00 30    	bra       OV, 0x10726
   1069a:	31 32 33    	bra       N, 0x16afe
   1069c:	34 35 36    	bra       LEU, 0x17106
   1069e:	37 38 39    	bra       NC, 0x1770e
   106a0:	61 62 63    	and.b     w6, #0x1, [--w4]
   106a2:	64 65 66    	and.b     w12, #0x4, [--w10]
   106a4:	00 28 6e    	xor.w     w12, w0, [++w0]
   106a6:	75 6c 6c    	xor.b     w8, #0x15, [++w8]
   106a8:	29 00 00    	nop       
   106aa:	01 00 00    	nop       
   106ac:	00 00 00    	nop       
   106ae:	00 00 0a    	.pword 0x0a0000
	...
   106b4:	00 64 00    	nop       
	...
   106ba:	e8 03 00    	nop       
   106bc:	00 00 00    	nop       
   106be:	00 00 10    	subr.w    w0, w0, w0
   106c0:	27 00 00    	nop       
   106c2:	00 00 00    	nop       
   106c4:	00 a0 86    	mov.w     0xd400, w0
   106c6:	01 00 00    	nop       
   106c8:	00 00 00    	nop       
   106ca:	40 42 0f    	bra       SB, 0x18b4c
   106cc:	00 00 00    	nop       
   106ce:	00 00 80    	mov.w     0x0, w0
   106d0:	96 98 00    	nop       
   106d2:	00 00 00    	nop       
   106d4:	00 00 e1    	cp.w      w0, w0
   106d6:	f5 05 00    	nop       
   106d8:	00 00 00    	nop       
   106da:	00 ca 9a    	mov.b     w0, [w4+328]
   106dc:	3b 00 00    	nop       
   106de:	00 00 00    	nop       
   106e0:	e4 0b 54    	sub.w     w8, #0x4, [w7]
   106e2:	02 00 00    	nop       
   106e4:	00 00 e8    	inc.w     w0, w0
   106e6:	76 48 17    	subr.b    w14, #0x16, [w0]
   106e8:	00 00 00    	nop       
   106ea:	00 10 a5    	btst.c    w0, w2
   106ec:	d4 e8 00    	nop       
   106ee:	00 00 00    	nop       
   106f0:	a0 72 4e    	.pword 0x4e72a0
   106f2:	18 09 00    	nop       
   106f4:	00 00 40    	add.w     w0, w0, w0
   106f6:	7a 10 f3    	.pword 0xf3107a
   106f8:	5a 00 00    	nop       
   106fa:	00 80 c6    	mac       w6 * w7, B, [w8], w4, [w10], w4, w13
   106fc:	a4 7e 8d    	mov.w     w4, 0xafd4
   106fe:	03 00 00    	nop       
   10700:	00 c1 6f    	xor.b     w15, w0, w2
   10702:	f2 86 23    	mov.w     #0x386f, w2
   10704:	00 00 00    	nop       
   10706:	8a 5d 78    	mov.b     w10, [w11++]
   10708:	45 63 01    	.pword 0x016345
   1070a:	00 00 64    	and.w     w8, w0, w0
   1070c:	a7 b3 b6    	xor.w     0x13a7
   1070e:	e0 0d 00    	nop       
   10710:	00 e8 89    	mov.w     w0, 0x3d00
   10712:	04 23 c7    	movsac    A, [w9+w12], w6, [w10]+=2, w4, w13
   10714:	8a 00 00    	nop       
   10716:	72 3e 00    	nop       
   10718:	60 01 00    	nop       
   1071a:	82 00 00    	nop       
	...
   10720:	f0 3f 00    	nop       
   10722:	00 00 00    	nop       
   10724:	00 00 24    	mov.w     #0x4000, w0
   10726:	40 00 00    	nop       
   10728:	00 00 00    	nop       
   1072a:	00 59 40    	add.b     w0, w0, [w2++]
   1072c:	00 00 00    	nop       
   1072e:	00 00 40    	add.w     w0, w0, w0
   10730:	8f 40 00    	nop       
   10732:	00 00 00    	nop       
   10734:	00 88 c3    	clr       B, [w8], w4, [w10], w6, w13
   10736:	40 00 00    	nop       
   10738:	00 00 00    	nop       
   1073a:	6a f8 40    	.pword 0x40f86a
   1073c:	00 00 00    	nop       
   1073e:	00 80 84    	mov.w     0x9000, w0
   10740:	2e 41 00    	nop       
   10742:	00 00 00    	nop       
   10744:	d0 12 63    	and.w     w6, [++w0], [w5--]
   10746:	41 00 00    	nop       
   10748:	00 00 84    	mov.w     0x8000, w0
   1074a:	d7 97 41    	add.w     w3, [++w7], [w15--]
   1074c:	00 00 00    	nop       
   1074e:	00 65 cd    	sac.r     A, #0xa, w0
   10750:	cd 41 00    	nop       
   10752:	00 00 20    	mov.w     #0x0, w0
   10754:	5f a0 02    	call      0x42a05f <L0+0x418dd9>
   10756:	42 00 00 
   10758:	00 80 1d    	subbr.w   w11, w0, w0
   1075a:	af 15 44    	add.w     w8, [w15--], [w11--]
   1075c:	00 00 00    	nop       
   1075e:	40 59 3e    	bra       GTU, 0x1b9e0
   10760:	29 46 00    	nop       
   10762:	00 00 00    	nop       
   10764:	00 00 f0    	mac       w4 * w4, A, [w8], w4, [w10], w4
   10766:	7f 00 00    	nop       
   10768:	00 00 00    	nop       
   1076a:	00 f0 7f    	mov.b     w0, [w0+w15]
	...
   10770:	f0 7f 00    	nop       
   10772:	00 00 00    	nop       
   10774:	00 00 f0    	mac       w4 * w4, A, [w8], w4, [w10], w4
   10776:	7f 00 00    	nop       
   10778:	00 00 00    	nop       
   1077a:	00 f0 7f    	mov.b     w0, [w0+w15]
	...
   10780:	f0 7f 00    	nop       
   10782:	00 00 00    	nop       
   10784:	00 00 f0    	mac       w4 * w4, A, [w8], w4, [w10], w4
   10786:	7f 00 00    	nop       
   10788:	00 00 00    	nop       
   1078a:	00 f0 7f    	mov.b     w0, [w0+w15]
	...
   10790:	f0 7f 00    	nop       
   10792:	00 00 00    	nop       
   10794:	00 00 f0    	mac       w4 * w4, A, [w8], w4, [w10], w4
   10796:	3f 00 00    	nop       
   10798:	00 a0 99    	mov.w     w0, [w0+448]
   1079a:	99 b9 3f    	bra       0x7ace
   1079c:	00 00 00    	nop       
   1079e:	40 e1 7a    	mov.b     [--w0], [--w2]
   107a0:	84 3f 00    	nop       
   107a2:	00 00 e0    	cp0.w     w0
   107a4:	4d 62 50    	sub.b     w0, [--w13], [--w4]
   107a6:	3f 00 00    	nop       
   107a8:	00 e0 e2    	.pword 0xe2e000
   107aa:	36 1a 3f    	bra       0x13c18
   107ac:	00 00 00    	nop       
   107ae:	80 b5 f8    	push      0xb580
   107b0:	e4 3e 00    	nop       
   107b2:	00 00 a0    	bset.w    w0, #0x0
   107b4:	f7 c6 b0    	addc.b    #0x6f, w7
   107b6:	3e 00 00    	nop       
   107b8:	00 a0 f2    	mac       w6 * w6, B, [w8], w6, [w10], w4
   107ba:	d7 7a 3e    	bra       GTU, 0x1fd6a
   107bc:	00 00 00    	nop       
   107be:	e0 8e 79    	mov.w     [w0+w3], [w13]
   107c0:	45 3e 00    	nop       
   107c2:	00 00 e0    	cp0.w     w0
   107c4:	0b 2e 11    	subr.w    w2, w11, [++w12]
   107c6:	3e 00 00    	nop       
   107c8:	00 e0 df    	fbcl      w0, w0
   107ca:	7c db 3d    	bra       GE, 0xbec4
   107cc:	00 00 00    	nop       
   107ce:	00 a1 9c    	mov.w     w0, [w2-832]
   107d0:	c7 3b 00    	nop       
   107d2:	00 00 00    	nop       
   107d4:	4c 48 b4    	add.b     0x84c, WREG
   107d6:	39 00 00    	nop       
   107d8:	00 00 20    	mov.w     #0x0, w0
   107da:	6c a1 37    	bra       0x4ab4
	...
   10808:	dc 43 00    	nop       
   1080a:	26 00 00    	nop       
   1080c:	82 00 00    	nop       
   1080e:	97 44 00    	nop       
   10810:	00 97 44    	add.w     w9, w0, [w14--]
   10812:	09 00 00    	nop       
   10814:	00 02 00    	nop       
   10816:	99 44 00    	nop       
   10818:	00 99 44    	add.w     w9, w0, [w2++]
   1081a:	0e 02 01    	.pword 0x01020e
	...
   10822:	06 02 02    	call      0x206 <__reset+0x6>
   10824:	00 00 00 
   10826:	dc 43 00    	nop       
   10828:	96 44 00    	nop       
   1082a:	06 00 00    	nop       
   1082c:	80 00 00    	nop       
   1082e:	a6 44 00    	nop       
   10830:	02 00 00    	nop       
   10832:	82 00 00    	nop       
   10834:	01 00 00    	nop       
   10836:	86 12 81    	mov.w     0x2250, w6
Disassembly of section .text:

00010838 <_populateParameterInterface>:

// TODO: Commented out for compilation, need to potentially initialize these PARAM values in the model.
void populateParameterInterface(void)
{
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_P], "PID_AIRSPD_P");
   10838:	20 3e 2c    	mov.w     #0xc3e2, w0
   1083a:	61 2d 21    	mov.w     #0x12d6, w1
   1083c:	0c 00 09    	.pword 0x09000c
   1083e:	b0 58 78    	mov.b     [w0++], [w1++]
   10840:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_I], "PID_AIRSPD_I");
   10842:	f0 3e 2c    	mov.w     #0xc3ef, w0
   10844:	61 2e 21    	mov.w     #0x12e6, w1
   10846:	0c 00 09    	.pword 0x09000c
   10848:	b0 58 78    	mov.b     [w0++], [w1++]
   1084a:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_AIRSPEED_D], "PID_AIRSPD_D");
   1084c:	c0 3f 2c    	mov.w     #0xc3fc, w0
   1084e:	61 2f 21    	mov.w     #0x12f6, w1
   10850:	0c 00 09    	.pword 0x09000c
   10852:	b0 58 78    	mov.b     [w0++], [w1++]
   10854:	d0 00 b1    	sub.w     #0xd, w0

    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_P], "PID_PIT_FO_P");
   10856:	90 40 2c    	mov.w     #0xc409, w0
   10858:	61 30 21    	mov.w     #0x1306, w1
   1085a:	0c 00 09    	.pword 0x09000c
   1085c:	b0 58 78    	mov.b     [w0++], [w1++]
   1085e:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_I], "PID_PIT_FO_I");
   10860:	60 41 2c    	mov.w     #0xc416, w0
   10862:	61 31 21    	mov.w     #0x1316, w1
   10864:	0c 00 09    	.pword 0x09000c
   10866:	b0 58 78    	mov.b     [w0++], [w1++]
   10868:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_PITCH_FO_D], "PID_PIT_FO_D");
   1086a:	30 42 2c    	mov.w     #0xc423, w0
   1086c:	61 32 21    	mov.w     #0x1326, w1
   1086e:	0c 00 09    	.pword 0x09000c
   10870:	b0 58 78    	mov.b     [w0++], [w1++]
   10872:	d0 00 b1    	sub.w     #0xd, w0

    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_P], "PID_ROLL_CO_P");
   10874:	00 43 2c    	mov.w     #0xc430, w0
   10876:	61 33 21    	mov.w     #0x1336, w1
   10878:	0d 00 09    	.pword 0x09000d
   1087a:	b0 58 78    	mov.b     [w0++], [w1++]
   1087c:	e0 00 b1    	sub.w     #0xe, w0
    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_I], "PID_ROLL_CO_I");
   1087e:	e0 43 2c    	mov.w     #0xc43e, w0
   10880:	61 34 21    	mov.w     #0x1346, w1
   10882:	0d 00 09    	.pword 0x09000d
   10884:	b0 58 78    	mov.b     [w0++], [w1++]
   10886:	e0 00 b1    	sub.w     #0xe, w0
    strcpy(mlParamInterface.param_name[PAR_PID_ROLL_CON_D], "PID_ROLL_CO_D");
   10888:	c0 44 2c    	mov.w     #0xc44c, w0
   1088a:	61 35 21    	mov.w     #0x1356, w1
   1088c:	0d 00 09    	.pword 0x09000d
   1088e:	b0 58 78    	mov.b     [w0++], [w1++]
   10890:	e0 00 b1    	sub.w     #0xe, w0

    strcpy(mlParamInterface.param_name[PAR_PID_HE_TO_PI_P], "PID_HE2PITC_P");
   10892:	a0 45 2c    	mov.w     #0xc45a, w0
   10894:	61 36 21    	mov.w     #0x1366, w1
   10896:	0d 00 09    	.pword 0x09000d
   10898:	b0 58 78    	mov.b     [w0++], [w1++]
   1089a:	e0 00 b1    	sub.w     #0xe, w0
    strcpy(mlParamInterface.param_name[PAR_PID_HE_TO_PI_I], "PID_HE2PITC_I");
   1089c:	80 46 2c    	mov.w     #0xc468, w0
   1089e:	61 37 21    	mov.w     #0x1376, w1
   108a0:	0d 00 09    	.pword 0x09000d
   108a2:	b0 58 78    	mov.b     [w0++], [w1++]
   108a4:	e0 00 b1    	sub.w     #0xe, w0

    strcpy(mlParamInterface.param_name[PAR_PID_HEI_ERR_FF], "PID_HERR_FF");
   108a6:	60 47 2c    	mov.w     #0xc476, w0
   108a8:	61 38 21    	mov.w     #0x1386, w1
   108aa:	0b 00 09    	.pword 0x09000b
   108ac:	b0 58 78    	mov.b     [w0++], [w1++]
   108ae:	c0 00 b1    	sub.w     #0xc, w0

    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_P], "PID_YAW_DA_P");
   108b0:	20 48 2c    	mov.w     #0xc482, w0
   108b2:	61 39 21    	mov.w     #0x1396, w1
   108b4:	0c 00 09    	.pword 0x09000c
   108b6:	b0 58 78    	mov.b     [w0++], [w1++]
   108b8:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_I], "PID_YAW_DA_I");
   108ba:	f0 48 2c    	mov.w     #0xc48f, w0
   108bc:	61 3a 21    	mov.w     #0x13a6, w1
   108be:	0c 00 09    	.pword 0x09000c
   108c0:	b0 58 78    	mov.b     [w0++], [w1++]
   108c2:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_YAW_DAMP_D], "PID_YAW_DA_D");
   108c4:	c0 49 2c    	mov.w     #0xc49c, w0
   108c6:	61 3b 21    	mov.w     #0x13b6, w1
   108c8:	0c 00 09    	.pword 0x09000c
   108ca:	b0 58 78    	mov.b     [w0++], [w1++]
   108cc:	d0 00 b1    	sub.w     #0xd, w0

    strcpy(mlParamInterface.param_name[PAR_PID_PITC_DT_FF], "PID_PIT_DT_FF");
   108ce:	90 4a 2c    	mov.w     #0xc4a9, w0
   108d0:	61 3c 21    	mov.w     #0x13c6, w1
   108d2:	0d 00 09    	.pword 0x09000d
   108d4:	b0 58 78    	mov.b     [w0++], [w1++]
   108d6:	e0 00 b1    	sub.w     #0xe, w0

    strcpy(mlParamInterface.param_name[PAR_CONFIG_ROLL_R ], "CONFIG_ROLL_R");
   108d8:	70 4b 2c    	mov.w     #0xc4b7, w0
   108da:	61 3d 21    	mov.w     #0x13d6, w1
   108dc:	0d 00 09    	.pword 0x09000d
   108de:	b0 58 78    	mov.b     [w0++], [w1++]
   108e0:	e0 00 b1    	sub.w     #0xe, w0
    strcpy(mlParamInterface.param_name[PAR_CONFIG_PITCH_R], "CONFIG_PITCH_R");
   108e2:	50 4c 2c    	mov.w     #0xc4c5, w0
   108e4:	61 3e 21    	mov.w     #0x13e6, w1
   108e6:	0e 00 09    	.pword 0x09000e
   108e8:	b0 58 78    	mov.b     [w0++], [w1++]
   108ea:	f0 00 b1    	sub.w     #0xf, w0
    strcpy(mlParamInterface.param_name[PAR_CONFIG_YAW_R ], "CONFIG_YAW_R");
   108ec:	40 4d 2c    	mov.w     #0xc4d4, w0
   108ee:	61 3f 21    	mov.w     #0x13f6, w1
   108f0:	0c 00 09    	.pword 0x09000c
   108f2:	b0 58 78    	mov.b     [w0++], [w1++]
   108f4:	d0 00 b1    	sub.w     #0xd, w0

    strcpy(mlParamInterface.param_name[PAR_NAV_L2_BASE ], "NAV_L2_BASE");
   108f6:	10 4e 2c    	mov.w     #0xc4e1, w0
   108f8:	61 40 21    	mov.w     #0x1406, w1
   108fa:	0b 00 09    	.pword 0x09000b
   108fc:	b0 58 78    	mov.b     [w0++], [w1++]
   108fe:	c0 00 b1    	sub.w     #0xc, w0
    strcpy(mlParamInterface.param_name[PAR_NAV_PRETURN_K], "NAV_PRETURN_K");
   10900:	d0 4e 2c    	mov.w     #0xc4ed, w0
   10902:	61 41 21    	mov.w     #0x1416, w1
   10904:	0d 00 09    	.pword 0x09000d
   10906:	b0 58 78    	mov.b     [w0++], [w1++]
   10908:	e0 00 b1    	sub.w     #0xe, w0
    strcpy(mlParamInterface.param_name[PAR_NAV_SSCOMP_ON], "NAV_SSCOMP_ON");
   1090a:	b0 4f 2c    	mov.w     #0xc4fb, w0
   1090c:	61 42 21    	mov.w     #0x1426, w1
   1090e:	0d 00 09    	.pword 0x09000d
   10910:	b0 58 78    	mov.b     [w0++], [w1++]
   10912:	e0 00 b1    	sub.w     #0xe, w0

    strcpy(mlParamInterface.param_name[PAR_L1_OMEGA ], "L1_OMEGA");
   10914:	90 50 2c    	mov.w     #0xc509, w0
   10916:	61 43 21    	mov.w     #0x1436, w1
   10918:	08 00 09    	.pword 0x090008
   1091a:	b0 58 78    	mov.b     [w0++], [w1++]
   1091c:	90 00 b1    	sub.w     #0x9, w0
    strcpy(mlParamInterface.param_name[PAR_L1_M ], "L1_M")  ;
   1091e:	20 51 2c    	mov.w     #0xc512, w0
   10920:	61 44 21    	mov.w     #0x1446, w1
   10922:	04 00 09    	.pword 0x090004
   10924:	b0 58 78    	mov.b     [w0++], [w1++]
   10926:	50 00 b1    	sub.w     #0x5, w0
    strcpy(mlParamInterface.param_name[PAR_L1_GAMMA ], "L1_GAMMA");
   10928:	70 51 2c    	mov.w     #0xc517, w0
   1092a:	61 45 21    	mov.w     #0x1456, w1
   1092c:	08 00 09    	.pword 0x090008
   1092e:	b0 58 78    	mov.b     [w0++], [w1++]
   10930:	90 00 b1    	sub.w     #0x9, w0
    strcpy(mlParamInterface.param_name[PAR_L1_ON_OFF], "L1_ON_OFF");
   10932:	00 52 2c    	mov.w     #0xc520, w0
   10934:	61 46 21    	mov.w     #0x1466, w1
   10936:	09 00 09    	.pword 0x090009
   10938:	b0 58 78    	mov.b     [w0++], [w1++]
   1093a:	a0 00 b1    	sub.w     #0xa, w0

    strcpy(mlParamInterface.param_name[PAR_NAV_ISR_FAC ], "NAV_ISR_FACT");
   1093c:	a0 52 2c    	mov.w     #0xc52a, w0
   1093e:	61 47 21    	mov.w     #0x1476, w1
   10940:	0c 00 09    	.pword 0x09000c
   10942:	b0 58 78    	mov.b     [w0++], [w1++]
   10944:	d0 00 b1    	sub.w     #0xd, w0
    strcpy(mlParamInterface.param_name[PAR_PID_RMIX_ON ], "PID_RMIX_ON");
   10946:	70 53 2c    	mov.w     #0xc537, w0
   10948:	61 48 21    	mov.w     #0x1486, w1
   1094a:	0b 00 09    	.pword 0x09000b
   1094c:	b0 58 78    	mov.b     [w0++], [w1++]
   1094e:	c0 00 b1    	sub.w     #0xc, w0
    strcpy(mlParamInterface.param_name[PAR_PID_RMIX_P], "PID_RMIX_P");
   10950:	30 54 2c    	mov.w     #0xc543, w0
   10952:	61 49 21    	mov.w     #0x1496, w1
   10954:	0a 00 09    	.pword 0x09000a
   10956:	b0 58 78    	mov.b     [w0++], [w1++]
   10958:	b0 00 b1    	sub.w     #0xb, w0
    
    strcpy(mlParamInterface.param_name[PAR_CAM_X], "CAM_LOC_X");
   1095a:	e0 54 2c    	mov.w     #0xc54e, w0
   1095c:	61 4a 21    	mov.w     #0x14a6, w1
   1095e:	09 00 09    	.pword 0x090009
   10960:	b0 58 78    	mov.b     [w0++], [w1++]
   10962:	a0 00 b1    	sub.w     #0xa, w0
    strcpy(mlParamInterface.param_name[PAR_CAM_Z], "CAM_LOC_Z");
   10964:	80 55 2c    	mov.w     #0xc558, w0
   10966:	61 4b 21    	mov.w     #0x14b6, w1
   10968:	09 00 09    	.pword 0x090009
   1096a:	b0 58 78    	mov.b     [w0++], [w1++]
   1096c:	a0 00 b1    	sub.w     #0xa, w0

    
    //strcpy(mlParamInterface.param_name[PAR_RATE_TELEMETRY], "RATE_TELEMETRY");
     


}
   1096e:	00 00 06    	return    

00010970 <_AUAV__IMU_Mag_Driver_Start>:
   10970:	40 47 20    	mov.w     #0x474, w0
   10972:	10 12 88    	mov.w     w0, 0x242
   10974:	10 00 20    	mov.w     #0x1, w0
   10976:	20 12 88    	mov.w     w0, 0x244
   10978:	40 01 28    	mov.w     #0x8014, w0
   1097a:	00 12 88    	mov.w     w0, 0x240
   1097c:	20 42 80    	mov.w     0x844, w0
   1097e:	00 80 a0    	bset.w    w0, #0x8
   10980:	00 90 a1    	bclr.w    w0, #0x9
   10982:	00 a0 a0    	bset.w    w0, #0xa
   10984:	20 42 88    	mov.w     w0, 0x844
   10986:	01 48 a9    	bclr.b    0x801, #0x2
   10988:	21 48 a8    	bset.b    0x821, #0x2
   1098a:	00 00 06    	return    

0001098c <_AUAV_V3_Tes_IMU_Mag_Driver>:
   1098c:	88 1f 78    	mov.w     w8, [w15++]
   1098e:	80 44 24    	mov.w     #0x4448, w0
   10990:	10 04 e0    	cp0.b     [w0]
   10992:	22 00 3a    	bra       NZ, 0x109d8 <.L3>
   10994:	a0 22 82    	mov.w     0x4454, w0
   10996:	20 d0 88    	mov.w     w0, 0x1a04
   10998:	b1 22 82    	mov.w     0x4456, w1
   1099a:	31 d0 88    	mov.w     w1, 0x1a06
   1099c:	c0 22 82    	mov.w     0x4458, w0
   1099e:	40 d0 88    	mov.w     w0, 0x1a08
   109a0:	d1 22 82    	mov.w     0x445a, w1
   109a2:	51 d0 88    	mov.w     w1, 0x1a0a
   109a4:	e0 22 82    	mov.w     0x445c, w0
   109a6:	60 d0 88    	mov.w     w0, 0x1a0c
   109a8:	f1 22 82    	mov.w     0x445e, w1
   109aa:	71 d0 88    	mov.w     w1, 0x1a0e
   109ac:	00 23 82    	mov.w     0x4460, w0
   109ae:	80 d0 88    	mov.w     w0, 0x1a10
   109b0:	11 c0 b3    	mov.b     #0x1, w1
   109b2:	80 44 24    	mov.w     #0x4448, w0
   109b4:	01 48 78    	mov.b     w1, [w0]
   109b6:	20 45 24    	mov.w     #0x4452, w0
   109b8:	90 00 78    	mov.w     [w0], w1
   109ba:	81 80 40    	add.w     w1, w1, w1
   109bc:	68 01 50    	sub.w     w0, #0x8, w2
   109be:	81 00 41    	add.w     w2, w1, w1
   109c0:	12 00 20    	mov.w     #0x1, w2
   109c2:	82 08 78    	mov.w     w2, [w1]
   109c4:	90 0f 11    	subr.w    w2, [w0], [w15]
   109c6:	02 00 36    	bra       LEU, 0x109cc <.L4>
   109c8:	00 08 eb    	clr.w     [w0]
   109ca:	02 00 37    	bra       0x109d0 <.L5>

000109cc <.L4>:
   109cc:	20 45 24    	mov.w     #0x4452, w0
   109ce:	10 08 e8    	inc.w     [w0], [w0]

000109d0 <.L5>:
   109d0:	30 22 82    	mov.w     0x4446, w0
   109d2:	00 00 e0    	cp0.w     w0
   109d4:	01 00 3a    	bra       NZ, 0x109d8 <.L3>
   109d6:	01 48 a8    	bset.b    0x801, #0x2

000109d8 <.L3>:
   109d8:	40 1d 82    	mov.w     0x43a8, w0
   109da:	00 00 e0    	cp0.w     w0
   109dc:	28 00 3a    	bra       NZ, 0x10a2e <.L6>
   109de:	e0 a9 21    	mov.w     #0x1a9e, w0
   109e0:	61 3d 24    	mov.w     #0x43d6, w1
   109e2:	11 48 78    	mov.b     [w1], [w0]
   109e4:	00 00 e8    	inc.w     w0, w0
   109e6:	81 00 e8    	inc.w     w1, w1
   109e8:	11 48 78    	mov.b     [w1], [w0]
   109ea:	00 00 e8    	inc.w     w0, w0
   109ec:	81 00 e8    	inc.w     w1, w1
   109ee:	11 48 78    	mov.b     [w1], [w0]
   109f0:	00 00 e8    	inc.w     w0, w0
   109f2:	81 00 e8    	inc.w     w1, w1
   109f4:	11 48 78    	mov.b     [w1], [w0]
   109f6:	00 00 e8    	inc.w     w0, w0
   109f8:	81 00 e8    	inc.w     w1, w1
   109fa:	11 48 78    	mov.b     [w1], [w0]
   109fc:	00 00 e8    	inc.w     w0, w0
   109fe:	81 00 e8    	inc.w     w1, w1
   10a00:	11 48 78    	mov.b     [w1], [w0]
   10a02:	40 1d 82    	mov.w     0x43a8, w0
   10a04:	00 00 e8    	inc.w     w0, w0
   10a06:	40 1d 8a    	mov.w     w0, 0x43a8
   10a08:	a0 3b 24    	mov.w     #0x43ba, w0
   10a0a:	90 00 78    	mov.w     [w0], w1
   10a0c:	81 80 40    	add.w     w1, w1, w1
   10a0e:	6e 01 50    	sub.w     w0, #0xe, w2
   10a10:	81 00 41    	add.w     w2, w1, w1
   10a12:	72 05 20    	mov.w     #0x57, w2
   10a14:	82 08 78    	mov.w     w2, [w1]
   10a16:	41 00 20    	mov.w     #0x4, w1
   10a18:	90 8f 10    	subr.w    w1, [w0], [w15]
   10a1a:	02 00 36    	bra       LEU, 0x10a20 <.L7>
   10a1c:	00 08 eb    	clr.w     [w0]
   10a1e:	02 00 37    	bra       0x10a24 <.L8>

00010a20 <.L7>:
   10a20:	a0 3b 24    	mov.w     #0x43ba, w0
   10a22:	10 08 e8    	inc.w     [w0], [w0]

00010a24 <.L8>:
   10a24:	00 1d 82    	mov.w     0x43a0, w0
   10a26:	00 00 e0    	cp0.w     w0
   10a28:	11 00 3a    	bra       NZ, 0x10a4c <.L0> <.L9>
   10a2a:	06 48 a8    	bset.b    0x806, #0x2
   10a2c:	0f 00 37    	bra       0x10a4c <.L0> <.L9>

00010a2e <.L6>:
   10a2e:	40 1d 82    	mov.w     0x43a8, w0
   10a30:	e3 0f 50    	sub.w     w0, #0x3, [w15]
   10a32:	09 00 36    	bra       LEU, 0x10a46 <.L10>
   10a34:	17 e2 a9    	bclr.b    0x217, #0x7
   10a36:	00 6e a9    	bclr.b    0xe00, #0x3
   10a38:	00 4e a9    	bclr.b    0xe00, #0x2
   10a3a:	00 00 eb    	clr.w     w0
   10a3c:	40 1d 8a    	mov.w     w0, 0x43a8
   10a3e:	10 00 20    	mov.w     #0x1, w0
   10a40:	00 1d 8a    	mov.w     w0, 0x43a0
   10a42:	06 48 a8    	bset.b    0x806, #0x2
   10a44:	03 00 37    	bra       0x10a4c <.L0> <.L9>

00010a46 <.L10>:
   10a46:	40 1d 82    	mov.w     0x43a8, w0
   10a48:	00 00 e8    	inc.w     w0, w0
   10a4a:	40 1d 8a    	mov.w     w0, 0x43a8

00010a4c <.L0>:
   10a4c:	18 c0 b3    	mov.b     #0x1, w8
   10a4e:	60 11 b8    	mul.uu    w2, #0x0, w2
   10a50:	f0 ae 80    	mov.w     0x15de, w0
   10a52:	01 af 80    	mov.w     0x15e0, w1
   10a54:	c8 19 02    	call      0x19c8 <___nesf2>
   10a56:	00 00 00 
   10a58:	00 00 e0    	cp0.w     w0
   10a5a:	01 00 3a    	bra       NZ, 0x10a5e <.L12>
   10a5c:	00 44 eb    	clr.b     w8

00010a5e <.L12>:
   10a5e:	08 04 e0    	cp0.b     w8
   10a60:	17 00 3a    	bra       NZ, 0x10a90 <.L2>

00010a62 <.L0>:
   10a62:	20 d0 80    	mov.w     0x1a04, w0
   10a64:	20 85 88    	mov.w     w0, 0x10a4
   10a66:	31 d0 80    	mov.w     0x1a06, w1
   10a68:	31 85 88    	mov.w     w1, 0x10a6
   10a6a:	40 d0 80    	mov.w     0x1a08, w0
   10a6c:	40 85 88    	mov.w     w0, 0x10a8
   10a6e:	61 d0 80    	mov.w     0x1a0c, w1
   10a70:	51 85 88    	mov.w     w1, 0x10aa
   10a72:	70 d0 80    	mov.w     0x1a0e, w0
   10a74:	60 85 88    	mov.w     w0, 0x10ac
   10a76:	81 d0 80    	mov.w     0x1a10, w1
   10a78:	71 85 88    	mov.w     w1, 0x10ae
   10a7a:	f0 a9 21    	mov.w     #0x1a9f, w0
   10a7c:	10 80 fb    	ze        [w0], w0
   10a7e:	80 85 88    	mov.w     w0, 0x10b0
   10a80:	10 aa 21    	mov.w     #0x1aa1, w0
   10a82:	10 80 fb    	ze        [w0], w0
   10a84:	90 85 88    	mov.w     w0, 0x10b2
   10a86:	30 aa 21    	mov.w     #0x1aa3, w0
   10a88:	10 80 fb    	ze        [w0], w0
   10a8a:	a0 85 88    	mov.w     w0, 0x10b4
   10a8c:	50 d0 80    	mov.w     0x1a0a, w0
   10a8e:	70 11 89    	mov.w     w0, 0x222e

00010a90 <.L2>:
   10a90:	4f 04 78    	mov.w     [--w15], w8
   10a92:	00 00 06    	return    

00010a94 <_newCircBuffer>:
   10a94:	00 01 78    	mov.w     w0, w2
   10a96:	80 00 eb    	clr.w     w1
   10a98:	00 42 eb    	clr.b     w4
   10a9a:	03 20 20    	mov.w     #0x200, w3

00010a9c <.L2>:
   10a9c:	04 59 78    	mov.b     w4, [w2++]
   10a9e:	81 00 e8    	inc.w     w1, w1
   10aa0:	83 8f 50    	sub.w     w1, w3, [w15]
   10aa2:	fc ff 3a    	bra       NZ, 0x10a9c <.L2>
   10aa4:	80 00 eb    	clr.w     w1
   10aa6:	01 00 9a    	mov.w     w1, [w0+512]
		}

		// initialize the data members
		cB->head = 0;
		cB->tail = 0;
   10aa8:	11 00 9a    	mov.w     w1, [w0+514]
		cB->size = BSIZE;
   10aaa:	02 20 20    	mov.w     #0x200, w2
   10aac:	22 00 9a    	mov.w     w2, [w0+516]
		cB->overflowCount = 0;
   10aae:	60 20 b0    	add.w     #0x206, w0
   10ab0:	01 48 78    	mov.b     w1, [w0]

	}
   10ab2:	00 00 06    	return    

00010ab4 <_freeCircBuffer>:

//this function frees the Circular Buffer CB Ref
	void freeCircBuffer (CBRef* cB){
		// if it is already null, nothing to free
		if (cB == NULL || *cB == NULL) {return;}
   10ab4:	00 00 e0    	cp0.w     w0
   10ab6:	03 00 32    	bra       Z, 0x10abe <.L4>
   10ab8:	10 00 e0    	cp0.w     [w0]
   10aba:	01 00 32    	bra       Z, 0x10abe <.L4>

		// free and nil the pointer
		//free(*cB);
		*cB = NULL;
   10abc:	00 08 eb    	clr.w     [w0]

00010abe <.L4>:
	}
   10abe:	00 00 06    	return    

00010ac0 <_getLength>:


#else
	CBRef newCircBuffer (int pm_size){
		// create the circular buffer pointer
		CBRef cB;

		// allocate memory for it
		cB = (CBRef) malloc(sizeof(CircBuffer));

		// allocate memory for the buffer
		cB->buffer = (unsigned char *)calloc(pm_size, sizeof(unsigned char));

		// initialize the data members
		cB->head = 0;
		cB->tail = 0;
		cB->size = pm_size;
		cB->overflowCount = 0;

		// return the buffer pointer
		return (cB);

	}



	// this function frees the Circular Buffer CB Ref
	void freeCircBuffer (CBRef* cB){
		// if it is already null, nothing to free
		if (cB == NULL || *cB == NULL) {return;}

		// free the buffer
		free((*cB)->buffer);

		// free and nil the pointer
		free(*cB);
		*cB = NULL;
	}

#endif



// Accesor Methods
// ===============

// returns the amount of unread bytes in the circular buffer
unsigned int getLength (CBRef cB){
	// if the circular buffer is not null
	if (cB != NULL){
		if (cB->head <= cB->tail){
			return (cB->tail-cB->head);
		} else{
			return (cB->size + cB->tail - cB->head);
		}
	}
	else{
		return 0;
   10ac0:	80 00 eb    	clr.w     w1
   10ac2:	00 00 e0    	cp0.w     w0
   10ac4:	09 00 32    	bra       Z, 0x10ad8 <.L7>
   10ac6:	00 01 92    	mov.w     [w0+512], w2
   10ac8:	90 00 92    	mov.w     [w0+514], w1
   10aca:	81 0f 51    	sub.w     w2, w1, [w15]
   10acc:	02 00 3c    	bra       GT, 0x10ad2 <.L8>
   10ace:	82 80 50    	sub.w     w1, w2, w1
   10ad0:	03 00 37    	bra       0x10ad8 <.L7>

00010ad2 <.L8>:
   10ad2:	20 00 92    	mov.w     [w0+516], w0
   10ad4:	80 80 40    	add.w     w1, w0, w1
   10ad6:	82 80 50    	sub.w     w1, w2, w1

00010ad8 <.L7>:
	}


}
   10ad8:	01 00 78    	mov.w     w1, w0
   10ada:	00 00 06    	return    

00010adc <_readHead>:

// returns the actual index of the head
int readHead (CBRef cB){
   10adc:	80 00 78    	mov.w     w0, w1
	// if the circular buffer is not null
	if (cB != NULL){
		return (cB->head);
	}
	else{
		return 0;
   10ade:	00 00 eb    	clr.w     w0
   10ae0:	01 00 e0    	cp0.w     w1
   10ae2:	01 00 32    	bra       Z, 0x10ae6 <.L11>
   10ae4:	01 00 92    	mov.w     [w1+512], w0

00010ae6 <.L11>:
	}

}
   10ae6:	00 00 06    	return    

00010ae8 <_readTail>:

// returns the actual index of the tail
int readTail (CBRef cB){
   10ae8:	80 00 78    	mov.w     w0, w1
	// if the circular buffer is not null
	if (cB != NULL){
		return (cB->tail);
	}
	else{
		return 0;
   10aea:	00 00 eb    	clr.w     w0
   10aec:	01 00 e0    	cp0.w     w1
   10aee:	01 00 32    	bra       Z, 0x10af2 <.L14>
   10af0:	11 00 92    	mov.w     [w1+514], w0

00010af2 <.L14>:
	}

}
   10af2:	00 00 06    	return    

00010af4 <_peak>:

// returns the byte (actual value) that the head points to. this
// does not mark the byte as read, so succesive calls to peak will
// always return the same value
unsigned char peak(CBRef cB){
   10af4:	88 1f 78    	mov.w     w8, [w15++]
   10af6:	00 04 78    	mov.w     w0, w8
	// if the circular buffer is not null
	if (cB != NULL)
	{
		// if there are bytes in the buffer
		if (getLength(cB) > 0){
			return cB->buffer[cB->head];
		}
	}
	return 0;
   10af8:	00 40 eb    	clr.b     w0
   10afa:	08 00 e0    	cp0.w     w8
   10afc:	09 00 32    	bra       Z, 0x10b10 <.L17>

00010afe <.L0>:
   10afe:	08 00 78    	mov.w     w8, w0
   10b00:	df ff 07    	rcall     0x10ac0 <_getLength> <L0> <.LFB2> <.LFE1>
   10b02:	80 00 78    	mov.w     w0, w1

00010b04 <.L0>:
   10b04:	00 40 eb    	clr.b     w0
   10b06:	01 00 e0    	cp0.w     w1
   10b08:	03 00 32    	bra       Z, 0x10b10 <.L17>
   10b0a:	08 00 92    	mov.w     [w8+512], w0
   10b0c:	00 04 44    	add.w     w8, w0, w8
   10b0e:	18 40 78    	mov.b     [w8], w0

00010b10 <.L17>:
}
   10b10:	4f 04 78    	mov.w     [--w15], w8
   10b12:	00 00 06    	return    

00010b14 <_readFront>:


// Manipulation Procedures
// ======================
// returns the front of the circular buffer and marks the byte as read
unsigned char readFront (CBRef cB){
   10b14:	88 1f 78    	mov.w     w8, [w15++]
   10b16:	00 04 78    	mov.w     w0, w8
	// if the circular buffer is not null
	if (cB != NULL)
	{
		char retVal;
		// if there are bytes in the buffer
		if (getLength(cB) > 0){
			retVal = cB->buffer[cB->head];
			cB->head = cB->head < (cB->size -1)? cB->head+1: 0;
			return retVal;
		}
		return 128;
	}
	return 254;
   10b18:	e0 cf b3    	mov.b     #0xfe, w0
   10b1a:	08 00 e0    	cp0.w     w8
   10b1c:	10 00 32    	bra       Z, 0x10b3e <.L21> <.LBE2>

00010b1e <.L0>:
   10b1e:	08 00 78    	mov.w     w8, w0
   10b20:	cf ff 07    	rcall     0x10ac0 <_getLength> <L0> <.LFB2> <.LFE1>
   10b22:	80 00 78    	mov.w     w0, w1

00010b24 <.L0>:
   10b24:	00 c8 b3    	mov.b     #0x80, w0
   10b26:	01 00 e0    	cp0.w     w1
   10b28:	0a 00 32    	bra       Z, 0x10b3e <.L21> <.LBE2>
   10b2a:	88 00 92    	mov.w     [w8+512], w1
   10b2c:	01 00 44    	add.w     w8, w1, w0
   10b2e:	10 40 78    	mov.b     [w0], w0
   10b30:	a8 01 92    	mov.w     [w8+516], w3
   10b32:	83 01 e9    	dec.w     w3, w3
   10b34:	00 01 eb    	clr.w     w2
   10b36:	83 8f 50    	sub.w     w1, w3, [w15]
   10b38:	01 00 31    	bra       C, 0x10b3c <.L22>
   10b3a:	01 01 e8    	inc.w     w1, w2

00010b3c <.L22>:
   10b3c:	02 04 9a    	mov.w     w2, [w8+512]

00010b3e <.L21>:
}
   10b3e:	4f 04 78    	mov.w     [--w15], w8
   10b40:	00 00 06    	return    

00010b42 <_writeBack>:


// writes one byte at the end of the circular buffer,
// increments overflow count if overflow occurs
unsigned char writeBack (CBRef cB, unsigned char data){
   10b42:	88 9f be    	mov.d     w8, [w15++]
   10b44:	00 04 78    	mov.w     w0, w8
   10b46:	81 44 78    	mov.b     w1, w9
	// if the circular buffer is not null
        unsigned char outvalue = 1;
   10b48:	10 c0 b3    	mov.b     #0x1, w0
	if (cB != NULL){
   10b4a:	08 00 e0    	cp0.w     w8
   10b4c:	13 00 32    	bra       Z, 0x10b74 <.L27>

00010b4e <.L0>:
		if (getLength (cB) == (cB->size -1)){
   10b4e:	08 00 78    	mov.w     w8, w0
   10b50:	b7 ff 07    	rcall     0x10ac0 <_getLength> <L0> <.LFB2> <.LFE1>
   10b52:	a8 00 92    	mov.w     [w8+516], w1
   10b54:	81 00 e9    	dec.w     w1, w1
   10b56:	81 0f 50    	sub.w     w0, w1, [w15]
   10b58:	04 00 3a    	bra       NZ, 0x10b62 <.L28>

00010b5a <.L0>:
			cB->overflowCount ++;
   10b5a:	68 20 b0    	add.w     #0x206, w8
   10b5c:	18 4c e8    	inc.b     [w8], [w8]
   10b5e:	10 c0 b3    	mov.b     #0x1, w0
   10b60:	09 00 37    	bra       0x10b74 <.L27>

00010b62 <.L28>:
			//return 1;
		} else {
			cB->buffer[cB->tail] = data;
   10b62:	18 00 92    	mov.w     [w8+514], w0
   10b64:	00 01 44    	add.w     w8, w0, w2
   10b66:	09 49 78    	mov.b     w9, [w2]
			cB->tail = cB->tail < (cB->size -1)? cB->tail+1: 0;
   10b68:	00 01 eb    	clr.w     w2
   10b6a:	80 8f 50    	sub.w     w1, w0, [w15]
   10b6c:	01 00 36    	bra       LEU, 0x10b70 <.L29>
   10b6e:	00 01 e8    	inc.w     w0, w2

00010b70 <.L29>:
   10b70:	12 04 9a    	mov.w     w2, [w8+514]
			outvalue = 0;
   10b72:	00 40 eb    	clr.b     w0

00010b74 <.L27>:
		}
		//return 0;
	}
	return outvalue;
}
   10b74:	4f 04 be    	mov.d     [--w15], w8
   10b76:	00 00 06    	return    

00010b78 <_makeEmpty>:

// empties the circular buffer. It does not change the size. use with caution!!
void makeEmpty(CBRef cB){
	if (cB != NULL){
   10b78:	00 00 e0    	cp0.w     w0
   10b7a:	0f 00 32    	bra       Z, 0x10b9a <.L32>

00010b7c <.LBB3>:
		int i;
		for(i = 0; i < cB->size; ++i)
   10b7c:	20 02 92    	mov.w     [w0+516], w4
   10b7e:	04 00 e0    	cp0.w     w4
   10b80:	07 00 32    	bra       Z, 0x10b90 <.L34>
   10b82:	00 01 78    	mov.w     w0, w2

00010b84 <.LBE3>:
   10b84:	80 00 eb    	clr.w     w1
		{
			cB->buffer[i]= 0;
   10b86:	80 41 eb    	clr.b     w3

00010b88 <.L35>:
   10b88:	03 59 78    	mov.b     w3, [w2++]
   10b8a:	81 00 e8    	inc.w     w1, w1
   10b8c:	84 8f 50    	sub.w     w1, w4, [w15]
   10b8e:	fc ff 3a    	bra       NZ, 0x10b88 <.L35>

00010b90 <.L34>:
		}
		cB->head = 0;
   10b90:	80 00 eb    	clr.w     w1
   10b92:	01 00 9a    	mov.w     w1, [w0+512]
		cB->tail = 0;
   10b94:	11 00 9a    	mov.w     w1, [w0+514]
		cB->overflowCount = 0;
   10b96:	60 20 b0    	add.w     #0x206, w0
   10b98:	01 48 78    	mov.b     w1, [w0]

00010b9a <.L32>:
	}
}
   10b9a:	00 00 06    	return    

00010b9c <_rt_atan2f_snf>:
#include "AUAV_V3_TestSensors.h"
#include "AUAV_V3_TestSensors_private.h"

real32_T rt_atan2f_snf(real32_T u0, real32_T u1)
{
   10b9c:	88 9f be    	mov.d     w8, [w15++]
   10b9e:	8a 9f be    	mov.d     w10, [w15++]
   10ba0:	8c 1f 78    	mov.w     w12, [w15++]
   10ba2:	00 04 be    	mov.d     w0, w8
   10ba4:	02 05 be    	mov.d     w2, w10

00010ba6 <.L0>:
  real32_T y;
  int16_T u0_0;
  int16_T u1_0;
  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {
   10ba6:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
   10ba8:	01 00 00 
   10baa:	00 04 e0    	cp0.b     w0
   10bac:	05 00 3a    	bra       NZ, 0x10bb8 <.L0> <.L2>
   10bae:	0a 00 be    	mov.d     w10, w0
   10bb0:	22 0e 02    	call      0x10e22 <_rtIsNaNF>
   10bb2:	01 00 00 
   10bb4:	00 04 e0    	cp0.b     w0
   10bb6:	03 00 32    	bra       Z, 0x10bbe <.L0> <.L3>

00010bb8 <.L0>:
    y = (rtNaNF);
   10bb8:	b0 23 82    	mov.w     0x4476, w0
   10bba:	c1 23 82    	mov.w     0x4478, w1
   10bbc:	44 00 37    	bra       0x10c46 <.L4>

00010bbe <.L0>:
  } else if (rtIsInfF(u0) && rtIsInfF(u1)) {
   10bbe:	08 00 be    	mov.d     w8, w0
   10bc0:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
   10bc2:	01 00 00 
   10bc4:	00 04 e0    	cp0.b     w0
   10bc6:	21 00 32    	bra       Z, 0x10c0a <.L0> <.L0> <.L5>
   10bc8:	0a 00 be    	mov.d     w10, w0
   10bca:	e0 0d 02    	call      0x10de0 <_rtIsInfF>
   10bcc:	01 00 00 
   10bce:	00 04 e0    	cp0.b     w0
   10bd0:	1c 00 32    	bra       Z, 0x10c0a <.L0> <.L0> <.L5>

00010bd2 <.L0>:
    if (u0 > 0.0F) {
   10bd2:	60 11 b8    	mul.uu    w2, #0x0, w2
   10bd4:	08 00 be    	mov.d     w8, w0
   10bd6:	90 18 02    	call      0x1890 <___gesf2>
   10bd8:	00 00 00 

00010bda <.L0>:
      u0_0 = 1;
   10bda:	1c 00 20    	mov.w     #0x1, w12
   10bdc:	00 00 e0    	cp0.w     w0
   10bde:	01 00 3c    	bra       GT, 0x10be2 <.L0> <.L6>
    } else {
      u0_0 = -1;
   10be0:	00 86 eb    	setm.w    w12

00010be2 <.L0>:
    }

    if (u1 > 0.0F) {
   10be2:	60 11 b8    	mul.uu    w2, #0x0, w2
   10be4:	0a 00 be    	mov.d     w10, w0
   10be6:	90 18 02    	call      0x1890 <___gesf2>
   10be8:	00 00 00 
   10bea:	80 00 78    	mov.w     w0, w1

00010bec <.L0>:
      u1_0 = 1;
   10bec:	10 00 20    	mov.w     #0x1, w0
   10bee:	01 00 e0    	cp0.w     w1
   10bf0:	01 00 3c    	bra       GT, 0x10bf4 <.L0> <.L8>
    } else {
      u1_0 = -1;
   10bf2:	00 80 eb    	setm.w    w0

00010bf4 <.L0>:
    }

    y = (real32_T)atan2(u0_0, u1_0);
   10bf4:	cf 80 de    	asr.w     w0, #0xf, w1
   10bf6:	0c 19 02    	call      0x190c <___floatsisf>
   10bf8:	00 00 00 
   10bfa:	00 04 be    	mov.d     w0, w8
   10bfc:	61 60 b9    	mul.su    w12, #0x1, w0
   10bfe:	0c 19 02    	call      0x190c <___floatsisf>
   10c00:	00 00 00 
   10c02:	08 01 be    	mov.d     w8, w2
   10c04:	1e 16 02    	call      0x161e <_atan2f>
   10c06:	00 00 00 
   10c08:	1e 00 37    	bra       0x10c46 <.L4>

00010c0a <.L0>:
  } else if (u1 == 0.0F) {
   10c0a:	60 11 b8    	mul.uu    w2, #0x0, w2
   10c0c:	0a 00 be    	mov.d     w10, w0
   10c0e:	8c 18 02    	call      0x188c <___eqsf2>
   10c10:	00 00 00 
   10c12:	00 00 e0    	cp0.w     w0
   10c14:	0f 00 3a    	bra       NZ, 0x10c34 <.L0> <.L21>

00010c16 <.L0>:
    if (u0 > 0.0F) {
   10c16:	60 11 b8    	mul.uu    w2, #0x0, w2
   10c18:	08 00 be    	mov.d     w8, w0
   10c1a:	90 18 02    	call      0x1890 <___gesf2>
   10c1c:	00 00 00 
   10c1e:	00 00 e0    	cp0.w     w0
   10c20:	0e 00 3c    	bra       GT, 0x10c3e <.L0> <.L15>

00010c22 <.L0>:
      y = RT_PIF / 2.0F;
    } else if (u0 < 0.0F) {
   10c22:	60 11 b8    	mul.uu    w2, #0x0, w2
   10c24:	08 00 be    	mov.d     w8, w0
   10c26:	8c 18 02    	call      0x188c <___eqsf2>
   10c28:	00 00 00 
   10c2a:	00 00 e0    	cp0.w     w0
   10c2c:	0b 00 3d    	bra       GE, 0x10c44 <.L22>

00010c2e <.L0>:
      y = -(RT_PIF / 2.0F);
   10c2e:	b0 fd 20    	mov.w     #0xfdb, w0
   10c30:	91 fc 2b    	mov.w     #0xbfc9, w1
   10c32:	09 00 37    	bra       0x10c46 <.L4>

00010c34 <.L0>:
    } else {
      y = 0.0F;
    }
  } else {
    y = (real32_T)atan2(u0, u1);
   10c34:	0a 01 be    	mov.d     w10, w2
   10c36:	08 00 be    	mov.d     w8, w0
   10c38:	1e 16 02    	call      0x161e <_atan2f>
   10c3a:	00 00 00 
   10c3c:	04 00 37    	bra       0x10c46 <.L4>

00010c3e <.L0>:
   10c3e:	b0 fd 20    	mov.w     #0xfdb, w0
   10c40:	91 fc 23    	mov.w     #0x3fc9, w1
   10c42:	01 00 37    	bra       0x10c46 <.L4>

00010c44 <.L22>:
   10c44:	60 00 b8    	mul.uu    w0, #0x0, w0

00010c46 <.L4>:
  }

  return y;
}
   10c46:	4f 06 78    	mov.w     [--w15], w12
   10c48:	4f 05 be    	mov.d     [--w15], w10
   10c4a:	4f 04 be    	mov.d     [--w15], w8
   10c4c:	00 00 06    	return    

00010c4e <_AUAV_V3_Test_AxisRotZeroR3>:

/*
 * Output and update for action system:
 *    '<S490>/AxisRotZeroR3'
 *    '<S700>/AxisRotZeroR3'
 */
void AUAV_V3_Test_AxisRotZeroR3(const real32_T rtu_In1[7], real32_T *rty_1,
  real32_T *rty_2, real32_T *rty_3)
{
   10c4e:	88 9f be    	mov.d     w8, [w15++]
   10c50:	8a 9f be    	mov.d     w10, [w15++]
   10c52:	00 04 be    	mov.d     w0, w8
   10c54:	02 05 be    	mov.d     w2, w10

00010c56 <.L0>:
  real32_T rtu_In1_0;

  /* Fcn: '<S509>/Fcn1' */
  *rty_1 = rt_atan2f_snf(rtu_In1[5], rtu_In1[6]);
   10c56:	48 09 90    	mov.w     [w8+24], w2
   10c58:	d8 09 90    	mov.w     [w8+26], w3
   10c5a:	28 08 90    	mov.w     [w8+20], w0
   10c5c:	b8 08 90    	mov.w     [w8+22], w1
   10c5e:	9e ff 07    	rcall     0x10b9c <_rt_atan2f_snf> <L0> <.L0> <.L0> <.LFB1465> <.LFE8> <.Letext0> <.Ltext0>
   10c60:	80 8c be    	mov.d     w0, [w9]

00010c62 <.L0>:

  /* Fcn: '<S509>/Fcn2' */
  if (rtu_In1[2] > 1.0F) {
   10c62:	d8 04 90    	mov.w     [w8+10], w9
   10c64:	48 04 90    	mov.w     [w8+8], w8
   10c66:	02 00 20    	mov.w     #0x0, w2
   10c68:	03 f8 23    	mov.w     #0x3f80, w3
   10c6a:	08 00 be    	mov.d     w8, w0
   10c6c:	90 18 02    	call      0x1890 <___gesf2>
   10c6e:	00 00 00 
   10c70:	00 00 e0    	cp0.w     w0
   10c72:	0a 00 3c    	bra       GT, 0x10c88 <.L26>

00010c74 <.L0>:
    rtu_In1_0 = 1.0F;
  } else if (rtu_In1[2] < -1.0F) {
   10c74:	02 00 20    	mov.w     #0x0, w2
   10c76:	03 f8 2b    	mov.w     #0xbf80, w3
   10c78:	08 00 be    	mov.d     w8, w0
   10c7a:	8c 18 02    	call      0x188c <___eqsf2>
   10c7c:	00 00 00 
   10c7e:	00 00 e0    	cp0.w     w0
   10c80:	05 00 3d    	bra       GE, 0x10c8c <.L0> <.L24>

00010c82 <.L0>:
    rtu_In1_0 = -1.0F;
   10c82:	08 00 20    	mov.w     #0x0, w8
   10c84:	09 f8 2b    	mov.w     #0xbf80, w9
   10c86:	02 00 37    	bra       0x10c8c <.L0> <.L24>

00010c88 <.L26>:
   10c88:	08 00 20    	mov.w     #0x0, w8
   10c8a:	09 f8 23    	mov.w     #0x3f80, w9

00010c8c <.L0>:
  } else {
    rtu_In1_0 = rtu_In1[2];
  }

  *rty_2 = (real32_T)asin(rtu_In1_0);
   10c8c:	08 00 be    	mov.d     w8, w0
   10c8e:	1a 16 02    	call      0x161a <_asinf>
   10c90:	00 00 00 
   10c92:	00 8d be    	mov.d     w0, [w10]

00010c94 <.L0>:

  /* End of Fcn: '<S509>/Fcn2' */

  /* Fcn: '<S509>/Fcn3' */
  *rty_3 = 0.0F;
   10c94:	60 00 b8    	mul.uu    w0, #0x0, w0
   10c96:	80 8d be    	mov.d     w0, [w11]
}
   10c98:	4f 05 be    	mov.d     [--w15], w10
   10c9a:	4f 04 be    	mov.d     [--w15], w8
   10c9c:	00 00 06    	return    

00010c9e <_cubeInit>:
   10c9e:	00 00 06    	return    

00010ca0 <_getCubeData>:
   10ca0:	e2 39 24    	mov.w     #0x439e, w2
   10ca2:	92 40 e8    	inc.b     [w2], w1
   10ca4:	01 49 78    	mov.b     w1, [w2]
   10ca6:	81 80 fb    	ze        w1, w1
   10ca8:	11 08 98    	mov.w     w1, [w0+18]
//	// Update the state structure with the collected values
//	updateCubeData();
	
	// Return the averaged values
	cubeData[0] = mlRawImuData.xgyro;
   10caa:	51 85 80    	mov.w     0x10aa, w1
   10cac:	01 08 78    	mov.w     w1, [w0]
	cubeData[1] = mlRawImuData.ygyro;
   10cae:	61 85 80    	mov.w     0x10ac, w1
   10cb0:	11 00 98    	mov.w     w1, [w0+2]
	cubeData[2] = mlRawImuData.zgyro;
   10cb2:	71 85 80    	mov.w     0x10ae, w1
   10cb4:	21 00 98    	mov.w     w1, [w0+4]
	cubeData[3] = mlRawImuData.xacc;
   10cb6:	21 85 80    	mov.w     0x10a4, w1
   10cb8:	31 00 98    	mov.w     w1, [w0+6]
	cubeData[4] = mlRawImuData.yacc;
   10cba:	31 85 80    	mov.w     0x10a6, w1
   10cbc:	41 00 98    	mov.w     w1, [w0+8]
	cubeData[5] = mlRawImuData.zacc;
   10cbe:	41 85 80    	mov.w     0x10a8, w1
   10cc0:	51 00 98    	mov.w     w1, [w0+10]
	cubeData[6] = mlRawImuData.xmag;
   10cc2:	81 85 80    	mov.w     0x10b0, w1
   10cc4:	61 00 98    	mov.w     w1, [w0+12]
	cubeData[7] = mlRawImuData.ymag;
   10cc6:	91 85 80    	mov.w     0x10b2, w1
   10cc8:	71 00 98    	mov.w     w1, [w0+14]
	cubeData[8] = mlRawImuData.zmag;
   10cca:	a1 85 80    	mov.w     0x10b4, w1
   10ccc:	01 08 98    	mov.w     w1, [w0+16]
	
	// Turn on the timer for the first MAX_CUBE_READ readings
	//T5CONbits.TON				= 1;
}
   10cce:	00 00 06    	return    

00010cd0 <_averageData>:

void updateCubeData(void){
		
	// Read the buffered measurements
	mlRawImuData.xgyro = averageData(cubeBuffer.gx, cubeBuffer.sampleCount);
	mlRawImuData.ygyro = averageData(cubeBuffer.gy, cubeBuffer.sampleCount);
	mlRawImuData.zgyro = averageData(cubeBuffer.gz, cubeBuffer.sampleCount);

	mlRawImuData.xacc = averageData(cubeBuffer.ax, cubeBuffer.sampleCount);
	mlRawImuData.yacc = averageData(cubeBuffer.ay, cubeBuffer.sampleCount);
	mlRawImuData.zacc = averageData(cubeBuffer.az, cubeBuffer.sampleCount);
	
	mlRawImuData.xmag = averageData(cubeBuffer.mx, cubeBuffer.sampleCount);
	mlRawImuData.ymag = averageData(cubeBuffer.my, cubeBuffer.sampleCount);
	mlRawImuData.zmag = averageData(cubeBuffer.mz, cubeBuffer.sampleCount);
	
	// Clear the count for the next reading
	cubeBuffer.sampleCount = 0;
 
}

int16_t averageData(int16_t* theData, uint8_t count){			
	char i;
	short value = 0;
	for (i=0; i< count; i++){
   10cd0:	81 82 fb    	ze        w1, w5
   10cd2:	00 02 eb    	clr.w     w4
   10cd4:	42 40 a9    	bclr.b    0x42, #0x2
   10cd6:	09 00 34    	bra       LE, 0x10cea <.L4>
   10cd8:	00 41 eb    	clr.b     w2

00010cda <.L5>:
		value+= theData[(int)i];
   10cda:	82 01 fb    	se        w2, w3
   10cdc:	83 81 41    	add.w     w3, w3, w3
   10cde:	83 01 40    	add.w     w0, w3, w3
   10ce0:	13 02 42    	add.w     w4, [w3], w4
   10ce2:	02 41 e8    	inc.b     w2, w2
   10ce4:	82 01 fb    	se        w2, w3
   10ce6:	85 8f 51    	sub.w     w3, w5, [w15]
   10ce8:	f8 ff 35    	bra       LT, 0x10cda <.L5>

00010cea <.L4>:
	}
	
	return (count>0)? ((int16_t)(value/count)) : 0;
   10cea:	00 00 eb    	clr.w     w0
   10cec:	01 04 e0    	cp0.b     w1
   10cee:	02 00 32    	bra       Z, 0x10cf4 <.L6>
   10cf0:	11 00 09    	.pword 0x090011
   10cf2:	05 02 d8    	div.sw    w4, w5

00010cf4 <.L6>:
}
   10cf4:	00 00 06    	return    

00010cf6 <_updateCubeData>:
   10cf6:	88 9f be    	mov.d     w8, [w15++]

00010cf8 <.L0>:
   10cf8:	e9 39 24    	mov.w     #0x439e, w9
   10cfa:	19 44 78    	mov.b     [w9], w8
   10cfc:	88 40 78    	mov.b     w8, w1
   10cfe:	00 fd 2f    	mov.w     #0xffd0, w0
   10d00:	09 00 40    	add.w     w0, w9, w0
   10d02:	e6 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d04:	50 85 88    	mov.w     w0, 0x10aa

00010d06 <.L0>:
   10d06:	88 40 78    	mov.b     w8, w1
   10d08:	80 fd 2f    	mov.w     #0xffd8, w0
   10d0a:	09 00 40    	add.w     w0, w9, w0
   10d0c:	e1 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d0e:	60 85 88    	mov.w     w0, 0x10ac

00010d10 <.L0>:
   10d10:	88 40 78    	mov.b     w8, w1
   10d12:	00 fe 2f    	mov.w     #0xffe0, w0
   10d14:	09 00 40    	add.w     w0, w9, w0
   10d16:	dc ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d18:	70 85 88    	mov.w     w0, 0x10ae

00010d1a <.L0>:
   10d1a:	88 40 78    	mov.b     w8, w1
   10d1c:	80 fb 2f    	mov.w     #0xffb8, w0
   10d1e:	09 00 40    	add.w     w0, w9, w0
   10d20:	d7 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d22:	20 85 88    	mov.w     w0, 0x10a4

00010d24 <.L0>:
   10d24:	88 40 78    	mov.b     w8, w1
   10d26:	00 fc 2f    	mov.w     #0xffc0, w0
   10d28:	09 00 40    	add.w     w0, w9, w0
   10d2a:	d2 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d2c:	30 85 88    	mov.w     w0, 0x10a6

00010d2e <.L0>:
   10d2e:	88 40 78    	mov.b     w8, w1
   10d30:	80 fc 2f    	mov.w     #0xffc8, w0
   10d32:	09 00 40    	add.w     w0, w9, w0
   10d34:	cd ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d36:	40 85 88    	mov.w     w0, 0x10a8

00010d38 <.L0>:
   10d38:	88 40 78    	mov.b     w8, w1
   10d3a:	78 80 54    	sub.w     w9, #0x18, w0
   10d3c:	c9 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d3e:	80 85 88    	mov.w     w0, 0x10b0

00010d40 <.L0>:
   10d40:	88 40 78    	mov.b     w8, w1
   10d42:	70 80 54    	sub.w     w9, #0x10, w0
   10d44:	c5 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d46:	90 85 88    	mov.w     w0, 0x10b2

00010d48 <.L0>:
   10d48:	88 40 78    	mov.b     w8, w1
   10d4a:	68 80 54    	sub.w     w9, #0x8, w0
   10d4c:	c1 ff 07    	rcall     0x10cd0 <_averageData> <L0> <.LFB1466> <.LFE1464>
   10d4e:	a0 85 88    	mov.w     w0, 0x10b4

00010d50 <.L0>:
   10d50:	80 4c eb    	clr.b     [w9]
   10d52:	4f 04 be    	mov.d     [--w15], w8
   10d54:	00 00 06    	return    

00010d56 <_write2Cube>:

// SPI Primitives
// ==============
unsigned short write2Cube (unsigned short data2Send) {
	unsigned short temp = 3;
	
	// Drive SS Low
	/* selectCube();
	Nop(); Nop();
	
	// Write the data to the SPI buffer
	WriteSPI2(data2Send);
	
	// Wait for the TX buffer to empty
	while(SPI2STATbits.SPITBF);
	
	// Wait for the RX buffer to be full
	while(!SPI2STATbits.SPIRBF);
	
	// Read the receive buffer
	temp =  ReadSPI2();
	
	Nop(); Nop();

	//Drive SS High
	deselectCube();
	
	// Clear the overflow for safekeeping
	// If overflow occurs and the flag is not cleared the module will freeze
	SPI2STATbits.SPIROV  = 0;   
	
	// Delay for 33uS for a total of 40uS which is the max data rate
	for(i = 0; i < 330; i += 1 )
	{
		Nop();
	} */
	return temp;
}
   10d56:	30 00 20    	mov.w     #0x3, w0
   10d58:	00 00 06    	return    

00010d5a <_convert14BitToShort>:

// interrupcion del timer5
//void __attribute__ ((interrupt, no_auto_psv)) _T5Interrupt(void)
//{
//	// Do the reading
//	// lee datos del gyro
//	write2Cube(R_GYROX);
//	cubeBuffer.gx[cubeBuffer.sampleCount] = convert14BitToShort(write2Cube(R_GYROY));
//	cubeBuffer.gy[cubeBuffer.sampleCount] = convert14BitToShort(write2Cube(R_GYROZ));
//	//lee datos del acelerometro
//	cubeBuffer.gz[cubeBuffer.sampleCount] = convert14BitToShort(write2Cube(R_ACCELX));
//	cubeBuffer.ax[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_ACCELY));
//	cubeBuffer.ay[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_ACCELZ));
//	// lee datos del magnetometro
//	cubeBuffer.az[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_MAGNX)); 
//	cubeBuffer.mx[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_MAGNY)); 
//	cubeBuffer.my[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_MAGNZ)); 
//	cubeBuffer.mz[cubeBuffer.sampleCount] =convert14BitToShort(write2Cube(R_STATUS)); // dummy write
//	cubeBuffer.sampleCount++;
//		
//	// If this is the MAX_CUBE_READ read value turn the timer off
//	if(MAX_CUBE_READ <= cubeBuffer.sampleCount){
//		T5CONbits.TON = 0;
//	}
//	
//	IFS1bits.T5IF = 0;		// clear the interrupt flag
//	TMR5 = 0;							// Start the count again
//}

short convert14BitToShort (short wordData) {
	return (wordData & BITTEST_14)? (wordData | BITEXTEND_14) : (wordData & BITMASK_14);
   10d5a:	80 00 78    	mov.w     w0, w1
   10d5c:	00 d8 a3    	btst.z    w0, #0xd
   10d5e:	03 00 32    	bra       Z, 0x10d66 <.L13>
   10d60:	00 00 2c    	mov.w     #0xc000, w0
   10d62:	01 00 70    	ior.w     w0, w1, w0
   10d64:	02 00 37    	bra       0x10d6a <.L14>

00010d66 <.L13>:
   10d66:	f1 ff 23    	mov.w     #0x3fff, w1
   10d68:	01 00 60    	and.w     w0, w1, w0

00010d6a <.L14>:
}
   10d6a:	00 00 06    	return    

00010d6c <_convert12BitToShort>:

short convert12BitToShort (short wordData) {
	return (wordData & BITTEST_12)? (wordData | BITEXTEND_12) : (wordData & BITMASK_12);
   10d6c:	80 00 78    	mov.w     w0, w1
   10d6e:	00 b8 a3    	btst.z    w0, #0xb
   10d70:	03 00 32    	bra       Z, 0x10d78 <.L16>
   10d72:	00 00 2f    	mov.w     #0xf000, w0
   10d74:	01 00 70    	ior.w     w0, w1, w0
   10d76:	02 00 37    	bra       0x10d7c <.L17>

00010d78 <.L16>:
   10d78:	f1 ff 20    	mov.w     #0xfff, w1
   10d7a:	01 00 60    	and.w     w0, w1, w0

00010d7c <.L17>:
}
   10d7c:	00 00 06    	return    

00010d7e <_isCube16405>:

unsigned char isCube16405 (void){
	return 1;
}
   10d7e:	10 c0 b3    	mov.b     #0x1, w0
   10d80:	00 00 06    	return    

00010d82 <_rt_InitInfAndNaN>:
 */
void rt_InitInfAndNaN(size_t realSize)
{
  (void) (realSize);
  rtNaN = rtGetNaN();
   10d82:	7a 12 02    	call      0x1127a <_rtGetNaN>
   10d84:	01 00 00 
   10d86:	50 23 8a    	mov.w     w0, 0x446a
   10d88:	61 23 8a    	mov.w     w1, 0x446c

00010d8a <.L0>:
  rtNaNF = rtGetNaNF();
   10d8a:	74 12 02    	call      0x11274 <_rtGetNaNF>
   10d8c:	01 00 00 
   10d8e:	b0 23 8a    	mov.w     w0, 0x4476
   10d90:	c1 23 8a    	mov.w     w1, 0x4478

00010d92 <.L0>:
  rtInf = rtGetInf();
   10d92:	5a 12 02    	call      0x1125a <_rtGetInf>
   10d94:	01 00 00 
   10d96:	10 23 8a    	mov.w     w0, 0x4462
   10d98:	21 23 8a    	mov.w     w1, 0x4464

00010d9a <.L0>:
  rtInfF = rtGetInfF();
   10d9a:	54 12 02    	call      0x11254 <_rtGetInfF>
   10d9c:	01 00 00 
   10d9e:	70 23 8a    	mov.w     w0, 0x446e
   10da0:	81 23 8a    	mov.w     w1, 0x4470

00010da2 <.L0>:
  rtMinusInf = rtGetMinusInf();
   10da2:	64 12 02    	call      0x11264 <_rtGetMinusInf>
   10da4:	01 00 00 
   10da6:	30 23 8a    	mov.w     w0, 0x4466
   10da8:	41 23 8a    	mov.w     w1, 0x4468

00010daa <.L0>:
  rtMinusInfF = rtGetMinusInfF();
   10daa:	5e 12 02    	call      0x1125e <_rtGetMinusInfF>
   10dac:	01 00 00 
   10dae:	90 23 8a    	mov.w     w0, 0x4472
   10db0:	a1 23 8a    	mov.w     w1, 0x4474
}
   10db2:	00 00 06    	return    

00010db4 <_rtIsInf>:

/* Test if value is infinite */
boolean_T rtIsInf(real_T value)
{
   10db4:	88 9f be    	mov.d     w8, [w15++]
   10db6:	8a 1f 78    	mov.w     w10, [w15++]
   10db8:	00 04 be    	mov.d     w0, w8

00010dba <.L0>:
  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);
   10dba:	12 23 82    	mov.w     0x4462, w2
   10dbc:	23 23 82    	mov.w     0x4464, w3
   10dbe:	8c 18 02    	call      0x188c <___eqsf2>
   10dc0:	00 00 00 
   10dc2:	1a c0 b3    	mov.b     #0x1, w10
   10dc4:	00 00 e0    	cp0.w     w0
   10dc6:	08 00 32    	bra       Z, 0x10dd8 <.L0> <.L3>
   10dc8:	32 23 82    	mov.w     0x4466, w2
   10dca:	43 23 82    	mov.w     0x4468, w3
   10dcc:	08 00 be    	mov.d     w8, w0
   10dce:	8c 18 02    	call      0x188c <___eqsf2>
   10dd0:	00 00 00 
   10dd2:	00 00 e0    	cp0.w     w0
   10dd4:	01 00 32    	bra       Z, 0x10dd8 <.L0> <.L3>
   10dd6:	00 45 eb    	clr.b     w10

00010dd8 <.L0>:
}
   10dd8:	0a 40 78    	mov.b     w10, w0
   10dda:	4f 05 78    	mov.w     [--w15], w10
   10ddc:	4f 04 be    	mov.d     [--w15], w8
   10dde:	00 00 06    	return    

00010de0 <_rtIsInfF>:

/* Test if single-precision value is infinite */
boolean_T rtIsInfF(real32_T value)
{
   10de0:	88 9f be    	mov.d     w8, [w15++]
   10de2:	8a 1f 78    	mov.w     w10, [w15++]
   10de4:	00 04 be    	mov.d     w0, w8

00010de6 <.L0>:
  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);
   10de6:	72 23 82    	mov.w     0x446e, w2
   10de8:	83 23 82    	mov.w     0x4470, w3
   10dea:	8c 18 02    	call      0x188c <___eqsf2>
   10dec:	00 00 00 
   10dee:	1a c0 b3    	mov.b     #0x1, w10
   10df0:	00 00 e0    	cp0.w     w0
   10df2:	08 00 32    	bra       Z, 0x10e04 <.L0> <.L7>
   10df4:	92 23 82    	mov.w     0x4472, w2
   10df6:	a3 23 82    	mov.w     0x4474, w3
   10df8:	08 00 be    	mov.d     w8, w0
   10dfa:	8c 18 02    	call      0x188c <___eqsf2>
   10dfc:	00 00 00 
   10dfe:	00 00 e0    	cp0.w     w0
   10e00:	01 00 32    	bra       Z, 0x10e04 <.L0> <.L7>
   10e02:	00 45 eb    	clr.b     w10

00010e04 <.L0>:
}
   10e04:	0a 40 78    	mov.b     w10, w0
   10e06:	4f 05 78    	mov.w     [--w15], w10
   10e08:	4f 04 be    	mov.d     [--w15], w8
   10e0a:	00 00 06    	return    

00010e0c <_rtIsNaN>:

/* Test if value is not a number */
boolean_T rtIsNaN(real_T value)
{
   10e0c:	88 1f 78    	mov.w     w8, [w15++]

00010e0e <.L0>:
  return (boolean_T)((value!=value) ? 1U : 0U);
   10e0e:	18 c0 b3    	mov.b     #0x1, w8
   10e10:	00 01 be    	mov.d     w0, w2
   10e12:	c8 19 02    	call      0x19c8 <___nesf2>
   10e14:	00 00 00 
   10e16:	00 00 e0    	cp0.w     w0
   10e18:	01 00 3a    	bra       NZ, 0x10e1c <.L0> <.L11>
   10e1a:	00 44 eb    	clr.b     w8

00010e1c <.L0>:
}
   10e1c:	08 40 78    	mov.b     w8, w0
   10e1e:	4f 04 78    	mov.w     [--w15], w8
   10e20:	00 00 06    	return    

00010e22 <_rtIsNaNF>:

/* Test if single-precision value is not a number */
boolean_T rtIsNaNF(real32_T value)
{
   10e22:	88 1f 78    	mov.w     w8, [w15++]

00010e24 <.L0>:
  return (boolean_T)(((value!=value) ? 1U : 0U));
   10e24:	18 c0 b3    	mov.b     #0x1, w8
   10e26:	00 01 be    	mov.d     w0, w2
   10e28:	c8 19 02    	call      0x19c8 <___nesf2>
   10e2a:	00 00 00 
   10e2c:	00 00 e0    	cp0.w     w0
   10e2e:	01 00 3a    	bra       NZ, 0x10e32 <.L0> <.L13>
   10e30:	00 44 eb    	clr.b     w8

00010e32 <.L0>:
}
   10e32:	08 40 78    	mov.b     w8, w0
   10e34:	4f 04 78    	mov.w     [--w15], w8
   10e36:	00 00 06    	return    

00010e38 <_updatePWM>:
#include "apUtils.h"

void updatePWM(unsigned short * PWMData){
	// dT dA dR dE Failsafe
	mlPwmCommands.servo1_raw = PWMData[0];
   10e38:	90 00 78    	mov.w     [w0], w1
   10e3a:	71 88 88    	mov.w     w1, 0x110e
	mlPwmCommands.servo2_raw = PWMData[1];
   10e3c:	90 00 90    	mov.w     [w0+2], w1
   10e3e:	81 88 88    	mov.w     w1, 0x1110
	mlPwmCommands.servo3_raw = PWMData[2];
   10e40:	a0 00 90    	mov.w     [w0+4], w1
   10e42:	91 88 88    	mov.w     w1, 0x1112
	mlPwmCommands.servo4_raw = PWMData[3];
   10e44:	30 00 90    	mov.w     [w0+6], w0
   10e46:	a0 88 88    	mov.w     w0, 0x1114
        mlPwmCommands.time_usec = mlRawImuData.time_usec; // Is this okay?
   10e48:	e0 84 80    	mov.w     0x109c, w0
   10e4a:	f1 84 80    	mov.w     0x109e, w1
   10e4c:	50 88 88    	mov.w     w0, 0x110a
   10e4e:	61 88 88    	mov.w     w1, 0x110c
}
   10e50:	00 00 06    	return    

00010e52 <_updatePWMTrim>:

void updatePWMTrim(unsigned short PWMData, unsigned char channel ){
	switch (channel){
   10e52:	e1 cf 50    	sub.b     w1, #0x1, [w15]
   10e54:	08 00 32    	bra       Z, 0x10e66 <.L5>
   10e56:	05 00 39    	bra       NC, 0x10e62 <.L4>
   10e58:	e2 cf 50    	sub.b     w1, #0x2, [w15]
   10e5a:	07 00 32    	bra       Z, 0x10e6a <.L6>
   10e5c:	e3 cf 50    	sub.b     w1, #0x3, [w15]
   10e5e:	08 00 3a    	bra       NZ, 0x10e70 <.L2>
   10e60:	06 00 37    	bra       0x10e6e <.L8>

00010e62 <.L4>:
		case 0:
			mlPwmCommands.servo5_raw = PWMData;
   10e62:	b0 88 88    	mov.w     w0, 0x1116
		break; 
   10e64:	05 00 37    	bra       0x10e70 <.L2>

00010e66 <.L5>:
		case 1:
			mlPwmCommands.servo6_raw = PWMData;
   10e66:	c0 88 88    	mov.w     w0, 0x1118
		break; 
   10e68:	03 00 37    	bra       0x10e70 <.L2>

00010e6a <.L6>:
		case 2:
			mlPwmCommands.servo7_raw = PWMData;
   10e6a:	d0 88 88    	mov.w     w0, 0x111a
		break; 
   10e6c:	01 00 37    	bra       0x10e70 <.L2>

00010e6e <.L8>:
		case 3:
			mlPwmCommands.servo8_raw = PWMData;
   10e6e:	e0 88 88    	mov.w     w0, 0x111c

00010e70 <.L2>:
		break; 								
	}
}
   10e70:	00 00 06    	return    

00010e72 <_updateLoad>:

void updateLoad (uint8_t mcuLoad){
	mlCpuLoadData.ctrlLoad =  mcuLoad;
   10e72:	f1 15 24    	mov.w     #0x415f, w1
   10e74:	80 48 78    	mov.b     w0, [w1]
	mlSystemStatus.load = mcuLoad*10;
   10e76:	a2 c0 b3    	mov.b     #0xa, w2
   10e78:	04 40 bc    	mul.b     0x4
   10e7a:	12 14 8a    	mov.w     w2, 0x4282
}
   10e7c:	00 00 06    	return    

00010e7e <_updateEuler>:

void updateEuler(float* newEuler){
	mlAttitudeRotated.roll	= newEuler[0];
   10e7e:	10 01 be    	mov.d     [w0], w2
   10e80:	72 11 8a    	mov.w     w2, 0x422e
   10e82:	83 11 8a    	mov.w     w3, 0x4230
	mlAttitudeRotated.pitch = newEuler[1];
   10e84:	20 01 90    	mov.w     [w0+4], w2
   10e86:	b0 01 90    	mov.w     [w0+6], w3
   10e88:	92 11 8a    	mov.w     w2, 0x4232
   10e8a:	a3 11 8a    	mov.w     w3, 0x4234
	mlAttitudeRotated.yaw   = newEuler[2];
   10e8c:	40 01 90    	mov.w     [w0+8], w2
   10e8e:	d0 01 90    	mov.w     [w0+10], w3
   10e90:	b2 11 8a    	mov.w     w2, 0x4236
   10e92:	c3 11 8a    	mov.w     w3, 0x4238
	//mlAttitudeRotated.usec  = mlAttitudeData.usec;
        mlAttitudeRotated.time_boot_ms = mlAttitudeData.time_boot_ms;
   10e94:	30 86 80    	mov.w     0x10c6, w0
   10e96:	41 86 80    	mov.w     0x10c8, w1
   10e98:	50 11 8a    	mov.w     w0, 0x422a
   10e9a:	61 11 8a    	mov.w     w1, 0x422c
		
	// mlAttitudeRotated.roll	= mlAttitudeData.roll;
	// mlAttitudeRotated.pitch = mlAttitudeData.pitch;
	// mlAttitudeRotated.yaw   = mlAttitudeData.yaw;
	// mlAttitudeRotated.usec  = mlAttitudeData.usec;
}
   10e9c:	00 00 06    	return    

00010e9e <_updatePQR>:


void updatePQR(float* newPQR){
	mlAttitudeRotated.rollspeed 	= newPQR[0];
   10e9e:	10 01 be    	mov.d     [w0], w2
   10ea0:	d2 11 8a    	mov.w     w2, 0x423a
   10ea2:	e3 11 8a    	mov.w     w3, 0x423c
	mlAttitudeRotated.pitchspeed 	= newPQR[1];
   10ea4:	20 01 90    	mov.w     [w0+4], w2
   10ea6:	b0 01 90    	mov.w     [w0+6], w3
   10ea8:	f2 11 8a    	mov.w     w2, 0x423e
   10eaa:	03 12 8a    	mov.w     w3, 0x4240
	mlAttitudeRotated.yawspeed 		= newPQR[2];
   10eac:	40 01 90    	mov.w     [w0+8], w2
   10eae:	d0 01 90    	mov.w     [w0+10], w3
   10eb0:	12 12 8a    	mov.w     w2, 0x4242
   10eb2:	23 12 8a    	mov.w     w3, 0x4244
	
	// mlAttitudeRotated.rollspeed 	= mlAttitudeData.rollspeed;
	// mlAttitudeRotated.pitchspeed 	= mlAttitudeData.pitchspeed;
	// mlAttitudeRotated.yawspeed 		= mlAttitudeData.yawspeed;
}
   10eb4:	00 00 06    	return    

00010eb6 <_getHilOnOff>:

// void updatePilotCommands (unsigned short*  pilCom){
// 	pilCom[0] = mlPilotConsoleData.dt;
// 	pilCom[1] = mlPilotConsoleData.dla;
// 	pilCom[2] = mlPilotConsoleData.dra;
// 	pilCom[3] = mlPilotConsoleData.dr;
// 	pilCom[4] = mlPilotConsoleData.de;
// }

unsigned char getHilOnOff (void){
    return hasMode(mlHeartbeatLocal.base_mode, MAV_MODE_FLAG_HIL_ENABLED);
   10eb6:	01 c2 b3    	mov.b     #0x20, w1
   10eb8:	60 12 21    	mov.w     #0x1126, w0
   10eba:	10 40 78    	mov.b     [w0], w0
   10ebc:	6e 10 02    	call      0x1106e <_hasMode>
   10ebe:	01 00 00 

00010ec0 <.L0>:
}
   10ec0:	00 00 06    	return    

00010ec2 <_getLightsOnOff>:

// void getGSLocation(float* altLatLon) {

    // altLatLon[0] = mlWpValues.alt[MAX_NUM_WPS-1]  * 0.001;
    // altLatLon[1] = mlWpValues.lat[MAX_NUM_WPS-1]  * 0.0000001;
    // altLatLon[2] = mlWpValues.lon[MAX_NUM_WPS-1]  * 0.0000001;
// }

uint8_t getLightsOnOff (void){
    return mlLights.state;
   10ec2:	e0 29 24    	mov.w     #0x429e, w0
   10ec4:	10 40 78    	mov.b     [w0], w0
}
   10ec6:	00 00 06    	return    

00010ec8 <_getLightsDayNight>:

uint8_t getLightsDayNight (void){
    return mlLights.type;
   10ec8:	f0 29 24    	mov.w     #0x429f, w0
   10eca:	10 40 78    	mov.b     [w0], w0
}
   10ecc:	00 00 06    	return    

00010ece <_updateVISensor>:
    
// 00 - I
// 01 - Sr Pr
// 10 - Sr Pp
// 11 - RPM

void updateVISensor (uint16_t* data){
    mlVISensor.voltage = data[0];
   10ece:	90 00 78    	mov.w     [w0], w1
   10ed0:	01 a7 88    	mov.w     w1, 0x14e0
    mlVISensor.reading2 = data[1];
   10ed2:	10 00 90    	mov.w     [w0+2], w0
   10ed4:	10 a7 88    	mov.w     w0, 0x14e2
}
   10ed6:	00 00 06    	return    

00010ed8 <_updatePTZ>:

void updatePTZ (int16_t* ptz){
    mlPtzStatus.pan = ptz[0];
   10ed8:	90 00 78    	mov.w     [w0], w1
   10eda:	21 15 8a    	mov.w     w1, 0x42a4
    mlPtzStatus.tilt   = ptz[1];
   10edc:	90 00 90    	mov.w     [w0+2], w1
   10ede:	31 15 8a    	mov.w     w1, 0x42a6
    mlPtzStatus.zoom = (uint8_t) ptz[2];
   10ee0:	81 2a 24    	mov.w     #0x42a8, w1
   10ee2:	40 40 90    	mov.b     [w0+4], w0
   10ee4:	80 48 78    	mov.b     w0, [w1]
}   10ee6:	00 00 06    	return    

00010ee8 <_EmbeddedMATLABFunctio_Init>:
   10ee8:	80 40 eb    	clr.b     w1
   10eea:	01 50 98    	mov.b     w1, [w0+16]
   10eec:	00 00 06    	return    

00010eee <_AUA_EmbeddedMATLABFunction>:
   10eee:	e4 87 47    	add.w     w15, #0x4, w15
   10ef0:	88 9f be    	mov.d     w8, [w15++]
   10ef2:	8a 9f be    	mov.d     w10, [w15++]
   10ef4:	8c 9f be    	mov.d     w12, [w15++]
   10ef6:	8e 1f 78    	mov.w     w14, [w15++]
   10ef8:	00 05 be    	mov.d     w0, w10
   10efa:	02 04 be    	mov.d     w2, w8
   10efc:	04 00 be    	mov.d     w4, w0
   10efe:	86 bf 9f    	mov.w     w6, [w15-16]
   10f00:	07 07 78    	mov.w     w7, w14
   10f02:	0e 51 90    	mov.b     [w14+16], w2
   10f04:	02 04 e0    	cp0.b     w2
   10f06:	24 00 3a    	bra       NZ, 0x10f50 <.L0> <.L3>

00010f08 <.L0>:
   10f08:	b2 fd 20    	mov.w     #0xfdb, w2
   10f0a:	93 0c 24    	mov.w     #0x40c9, w3
   10f0c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   10f0e:	00 00 00 
    /* '<S112>:1:9' */
    /* tf = [T*omega/(2+T*omega) T*omega/(2+T*omega)],[1 (T*omega-2)/(T*omega+2)] */
    /* tf = [a a],[1 -b] */
    /* '<S112>:1:12' */
    omega = 6.2831853071795862 * rtu_f;
   10f10:	00 01 be    	mov.d     w0, w2

00010f12 <.L0>:

    /* '<S112>:1:13' */
    localDW->a = rtu_T * omega / (rtu_T * omega + 2.0);
   10f12:	08 00 be    	mov.d     w8, w0
   10f14:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   10f16:	00 00 00 
   10f18:	00 04 be    	mov.d     w0, w8
   10f1a:	02 00 20    	mov.w     #0x0, w2
   10f1c:	03 00 24    	mov.w     #0x4000, w3
   10f1e:	92 14 02    	call      0x1492 <___addsf3>
   10f20:	00 00 00 
   10f22:	00 06 be    	mov.d     w0, w12
   10f24:	00 01 be    	mov.d     w0, w2
   10f26:	08 00 be    	mov.d     w8, w0
   10f28:	26 17 02    	call      0x1726 <___divsf3>
   10f2a:	00 00 00 
   10f2c:	00 8f be    	mov.d     w0, [w14]

00010f2e <.L0>:
    localDW->a_not_empty = true;
   10f2e:	10 c0 b3    	mov.b     #0x1, w0
   10f30:	00 57 98    	mov.b     w0, [w14+16]

00010f32 <.L0>:

    /* '<S112>:1:14' */
    localDW->b = -(rtu_T * omega - 2.0) / (rtu_T * omega + 2.0);
   10f32:	02 00 20    	mov.w     #0x0, w2
   10f34:	03 00 24    	mov.w     #0x4000, w3
   10f36:	08 00 be    	mov.d     w8, w0
   10f38:	90 14 02    	call      0x1490 <___subsf3>
   10f3a:	00 00 00 
   10f3c:	01 f0 a2    	btg.w     w1, #0xf
   10f3e:	0c 01 be    	mov.d     w12, w2
   10f40:	26 17 02    	call      0x1726 <___divsf3>
   10f42:	00 00 00 
   10f44:	20 07 98    	mov.w     w0, [w14+4]
   10f46:	31 07 98    	mov.w     w1, [w14+6]

00010f48 <.L0>:

    /* '<S112>:1:15' */
    localDW->y_km1 = rtu_u;
   10f48:	4a 07 98    	mov.w     w10, [w14+8]
   10f4a:	5b 07 98    	mov.w     w11, [w14+10]

    /* '<S112>:1:16' */
    localDW->u_km1 = rtu_u;
   10f4c:	6a 07 98    	mov.w     w10, [w14+12]
   10f4e:	7b 07 98    	mov.w     w11, [w14+14]

00010f50 <.L0>:
  }

  /* '<S112>:1:19' */
  localB->y = (rtu_u + localDW->u_km1) * (real32_T)localDW->a + (real32_T)
   10f50:	6e 01 90    	mov.w     [w14+12], w2
   10f52:	fe 01 90    	mov.w     [w14+14], w3
   10f54:	0a 00 be    	mov.d     w10, w0
   10f56:	92 14 02    	call      0x1492 <___addsf3>
   10f58:	00 00 00 
   10f5a:	1e 01 be    	mov.d     [w14], w2
   10f5c:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   10f5e:	00 00 00 
   10f60:	00 04 be    	mov.d     w0, w8

00010f62 <.L0>:
    localDW->b * localDW->y_km1;
   10f62:	4e 01 90    	mov.w     [w14+8], w2
   10f64:	de 01 90    	mov.w     [w14+10], w3
   10f66:	2e 00 90    	mov.w     [w14+4], w0
   10f68:	be 00 90    	mov.w     [w14+6], w1
   10f6a:	b6 1a 02    	call      0x1ab6 <___mulsf3>
   10f6c:	00 00 00 
   10f6e:	00 01 be    	mov.d     w0, w2

00010f70 <.L0>:
   10f70:	08 00 be    	mov.d     w8, w0
   10f72:	92 14 02    	call      0x1492 <___addsf3>
   10f74:	00 00 00 
   10f76:	0f b9 97    	mov.w     [w15-16], w2
   10f78:	00 89 be    	mov.d     w0, [w2]

00010f7a <.L0>:

  /* '<S112>:1:20' */
  localDW->y_km1 = localB->y;
   10f7a:	40 07 98    	mov.w     w0, [w14+8]
   10f7c:	51 07 98    	mov.w     w1, [w14+10]

  /* '<S112>:1:21' */
  localDW->u_km1 = rtu_u;
   10f7e:	6a 07 98    	mov.w     w10, [w14+12]
   10f80:	7b 07 98    	mov.w     w11, [w14+14]
}
   10f82:	4f 07 78    	mov.w     [--w15], w14
   10f84:	4f 06 be    	mov.d     [--w15], w12
   10f86:	4f 05 be    	mov.d     [--w15], w10
   10f88:	4f 04 be    	mov.d     [--w15], w8
   10f8a:	4f 00 b1    	sub.w     #0x4, w15
   10f8c:	00 00 06    	return    

00010f8e <_mavlinkInit>:
   10f8e:	a0 05 21    	mov.w     #0x105a, w0
   10f90:	0e 00 09    	.pword 0x09000e
   10f92:	00 18 eb    	clr.w     [w0++]
   10f94:	60 00 b8    	mul.uu    w0, #0x0, w0
   10f96:	e0 0a 8a    	mov.w     w0, 0x415c
   10f98:	f1 0a 8a    	mov.w     w1, 0x415e
   10f9a:	82 07 21    	mov.w     #0x1078, w2
   10f9c:	06 00 09    	.pword 0x090006
   10f9e:	00 19 eb    	clr.w     [w2++]
   10fa0:	02 16 24    	mov.w     #0x4160, w2
   10fa2:	0b 00 09    	.pword 0x09000b
   10fa4:	00 19 eb    	clr.w     [w2++]
    memset(&mlGpsData, 0, sizeof (mavlink_gps_raw_int_t));
    memset(&mlCpuLoadData, 0, sizeof (mavlink_cpu_load_t));
    memset(&mlAirData, 0, sizeof (mavlink_scaled_pressure_t));
    memset(&mlSensorBiasData, 0, sizeof (mavlink_sensor_bias_t));
    memset(&mlDiagnosticData, 0, sizeof (mavlink_diagnostic_t));
   10fa6:	82 17 24    	mov.w     #0x4178, w2
   10fa8:	08 00 09    	.pword 0x090008
   10faa:	00 19 eb    	clr.w     [w2++]
    memset(&mlPilotConsoleData, 0, sizeof (mavlink_rc_channels_raw_t));
   10fac:	62 08 21    	mov.w     #0x1086, w2
   10fae:	0a 00 09    	.pword 0x09000a
   10fb0:	00 19 eb    	clr.w     [w2++]
    memset(&mlRawImuData, 0, sizeof (mavlink_raw_imu_t));
   10fb2:	c2 09 21    	mov.w     #0x109c, w2
   10fb4:	0c 00 09    	.pword 0x09000c
   10fb6:	00 19 eb    	clr.w     [w2++]
    memset(&mlRawPressureData, 0, sizeof (mavlink_raw_pressure_t));
   10fb8:	62 0b 21    	mov.w     #0x10b6, w2
   10fba:	07 00 09    	.pword 0x090007
   10fbc:	00 19 eb    	clr.w     [w2++]
    memset(&mlAttitudeData, 0, sizeof (mavlink_attitude_t));
   10fbe:	62 0c 21    	mov.w     #0x10c6, w2
   10fc0:	0d 00 09    	.pword 0x09000d
   10fc2:	00 19 eb    	clr.w     [w2++]
    memset(&mlLocalPositionData, 0, sizeof (mavlink_local_position_ned_t));
   10fc4:	22 0e 21    	mov.w     #0x10e2, w2
   10fc6:	0d 00 09    	.pword 0x09000d
   10fc8:	00 19 eb    	clr.w     [w2++]
    memset(&mlFilteredData, 0, sizeof (mavlink_scaled_imu_t));
   10fca:	a2 18 24    	mov.w     #0x418a, w2
   10fcc:	0a 00 09    	.pword 0x09000a
   10fce:	00 19 eb    	clr.w     [w2++]
    memset(&mlBoot, 0, sizeof (mavlink_boot_t));
   10fd0:	00 0d 8a    	mov.w     w0, 0x41a0
   10fd2:	11 0d 8a    	mov.w     w1, 0x41a2
    memset(&mlGpsDateTime, 0, sizeof (mavlink_gps_date_time_t));
   10fd4:	42 1a 24    	mov.w     #0x41a4, w2
   10fd6:	05 00 09    	.pword 0x090005
   10fd8:	00 19 eb    	clr.w     [w2++]
    memset(&mlGSLocationFloat, 0, sizeof (mavlink_coordinate_float_t));
   10fda:	e2 0f 21    	mov.w     #0x10fe, w2
   10fdc:	05 00 09    	.pword 0x090005
   10fde:	00 19 eb    	clr.w     [w2++]
#if USE_NMEA
    memset(&mlGpsStatus, 0, sizeof(mavlink_status_gps_t));
   10fe0:	02 1b 24    	mov.w     #0x41b0, w2
   10fe2:	05 00 09    	.pword 0x090005
   10fe4:	00 19 eb    	clr.w     [w2++]
#else 
    memset(&mlNovatelStatus, 0, sizeof(mavlink_novatel_diag_t));
#endif
    memset(&mlSensorDiag, 0, sizeof(mavlink_sensor_diag_t));
   10fe6:	a2 1c 24    	mov.w     #0x41ca, w2
   10fe8:	05 00 09    	.pword 0x090005
   10fea:	00 19 eb    	clr.w     [w2++]

    //spi	
    memset(&mlGSLocation, 0, sizeof (mavlink_set_gps_global_origin_t));
   10fec:	82 45 22    	mov.w     #0x2458, w2
   10fee:	06 00 09    	.pword 0x090006
   10ff0:	00 19 eb    	clr.w     [w2++]
    memset(&mlCommandAck, 0, sizeof (mavlink_command_ack_t));
   10ff2:	b0 0e 8a    	mov.w     w0, 0x41d6
   10ff4:	c1 0e 8a    	mov.w     w1, 0x41d8
    memset(&mlPwmCommands, 0, sizeof (mavlink_servo_output_raw_t));
   10ff6:	a0 10 21    	mov.w     #0x110a, w0
   10ff8:	0a 00 09    	.pword 0x09000a
   10ffa:	00 18 eb    	clr.w     [w0++]

    // Debug
    memset(&mlStatustext, 0, sizeof(mavlink_statustext_t));
   10ffc:	a2 1d 24    	mov.w     #0x41da, w2
   10ffe:	18 00 09    	.pword 0x090018
   11000:	00 19 eb    	clr.w     [w2++]
   11002:	00 59 eb    	clr.b     [w2++]

    // Flags
    sendCommandAcknowledgement = FALSE;
   11004:	d0 20 24    	mov.w     #0x420d, w0
   11006:	00 48 eb    	clr.b     [w0]

}
   11008:	00 00 06    	return    

0001100a <_myAtan2>:
   1100a:	1e 16 02    	call      0x161e <_atan2f>
   1100c:	00 00 00 

0001100e <.L0>:
   1100e:	00 00 06    	return    

00011010 <_myPow>:
   11010:	1e 1b 02    	call      0x1b1e <_powf>
   11012:	00 00 00 

00011014 <.L0>:
   11014:	00 00 06    	return    

00011016 <_mySqrt>:
   11016:	ba 1d 02    	call      0x1dba <_sqrtf>
   11018:	00 00 00 
   1101a:	00 00 06    	return    

0001101c <_myAbs>:
   1101c:	01 f0 a1    	bclr.w    w1, #0xf

0001101e <.L0>:
   1101e:	00 00 06    	return    

00011020 <_myAtan>:
   11020:	58 16 02    	call      0x1658 <_atanf>
   11022:	00 00 00 

00011024 <.L0>:
   11024:	00 00 06    	return    

00011026 <_myAsin>:
   11026:	1a 16 02    	call      0x161a <_asinf>
   11028:	00 00 00 

0001102a <.L0>:
   1102a:	00 00 06    	return    

0001102c <_mySin>:
   1102c:	b6 1d 02    	call      0x1db6 <_sinf>
   1102e:	00 00 00 

00011030 <.L0>:
   11030:	00 00 06    	return    

00011032 <_myCos>:
   11032:	22 17 02    	call      0x1722 <_cosf>
   11034:	00 00 00 

00011036 <.L0>:
   11036:	00 00 06    	return    

00011038 <_myTan>:
   11038:	24 1e 02    	call      0x1e24 <_tanf>
   1103a:	00 00 00 

0001103c <.L0>:
   1103c:	00 00 06    	return    

0001103e <_myAcos>:
   1103e:	8c 14 02    	call      0x148c <_acosf>
   11040:	00 00 00 

00011042 <.L0>:
   11042:	00 00 06    	return    

00011044 <_myExp>:
   11044:	c8 17 02    	call      0x17c8 <_expf>
   11046:	00 00 00 
   11048:	00 00 06    	return    

0001104a <_hugeDelay>:
   1104a:	e1 2e 20    	mov.w     #0x2ee, w1
   1104c:	c2 fb 27    	mov.w     #0x7fbc, w2
   1104e:	04 00 37    	bra       0x11058 <.L13>

00011050 <.L14>:
   11050:	00 00 e9    	dec.w     w0, w0
   11052:	fe ff 3a    	bra       NZ, 0x11050 <.L14>
   11054:	81 00 e9    	dec.w     w1, w1
   11056:	02 00 32    	bra       Z, 0x1105c <.L12>

00011058 <.L13>:
   11058:	02 00 78    	mov.w     w2, w0
   1105a:	fa ff 37    	bra       0x11050 <.L14>

0001105c <.L12>:
   1105c:	00 00 06    	return    

0001105e <_smallDelay>:
   1105e:	80 38 21    	mov.w     #0x1388, w0

00011060 <.L18>:
   11060:	00 00 e9    	dec.w     w0, w0
   11062:	fe ff 3a    	bra       NZ, 0x11060 <.L18>
   11064:	00 00 06    	return    

00011066 <_tinyDelay>:
   11066:	20 03 20    	mov.w     #0x32, w0

00011068 <.L21>:
   11068:	00 00 e9    	dec.w     w0, w0
   1106a:	fe ff 3a    	bra       NZ, 0x11068 <.L21>
   1106c:	00 00 06    	return    

0001106e <_hasMode>:
   1106e:	00 c0 60    	and.b     w1, w0, w0
   11070:	00 80 fb    	ze        w0, w0
   11072:	00 00 ea    	neg.w     w0, w0
   11074:	4f 00 de    	lsr.w     w0, #0xf, w0
   11076:	00 00 06    	return    

00011078 <_AUAV_V3_TestSe_LEDs_DriverTID1>:
   11078:	a0 70 80    	mov.w     0xe14, w0
   1107a:	64 00 60    	and.w     w0, #0x4, w0
   1107c:	00 00 e9    	dec.w     w0, w0
   1107e:	4f 00 de    	lsr.w     w0, #0xf, w0
   11080:	61 ac 21    	mov.w     #0x1ac6, w1
   11082:	80 48 78    	mov.b     w0, [w1]
   11084:	42 00 dd    	sl.w      w0, #0x2, w0
   */
  AUAV_V3_TestSensors_B.LogicalOperator = !LATBbits.LATB2;

  /* S-Function (MCHP_Digital_Output_Write): '<S465>/Digital Output Write' */
  LATBbits.LATB2 = AUAV_V3_TestSensors_B.LogicalOperator;
   11086:	b1 ff 2f    	mov.w     #0xfffb, w1
   11088:	a2 70 80    	mov.w     0xe14, w2
   1108a:	82 80 60    	and.w     w1, w2, w1
   1108c:	81 00 70    	ior.w     w0, w1, w1
   1108e:	a1 70 88    	mov.w     w1, 0xe14
}
   11090:	00 00 06    	return    

00011092 <_AUAV_V3_TestSe_LEDs_DriverTID2>:

/* Outputs for atomic system: '<Root>/LEDs_Driver' */
void AUAV_V3_TestSe_LEDs_DriverTID2(void)
{
  /* S-Function (MCHP_Digital_Output_Read): '<S466>/Digital Output Read' */
  /* MCHP_Digital_Output_Read Block: <S466>/Digital Output Read/Output */

  /* Logic: '<S7>/Logical Operator1' incorporates:
   *  S-Function (MCHP_Digital_Output_Read): '<S466>/Digital Output Read'
   */
  AUAV_V3_TestSensors_B.LogicalOperator1 = !LATBbits.LATB3;
   11092:	a0 70 80    	mov.w     0xe14, w0
   11094:	68 00 60    	and.w     w0, #0x8, w0
   11096:	00 00 e9    	dec.w     w0, w0
   11098:	4f 00 de    	lsr.w     w0, #0xf, w0
   1109a:	81 ac 21    	mov.w     #0x1ac8, w1
   1109c:	80 48 78    	mov.b     w0, [w1]

  /* S-Function (MCHP_Digital_Output_Write): '<S466>/Digital Output Write' */
  LATBbits.LATB3 = AUAV_V3_TestSensors_B.LogicalOperator1;
   1109e:	43 00 dd    	sl.w      w0, #0x3, w0
   110a0:	71 ff 2f    	mov.w     #0xfff7, w1
   110a2:	a2 70 80    	mov.w     0xe14, w2
   110a4:	82 80 60    	and.w     w1, w2, w1
   110a6:	81 00 70    	ior.w     w0, w1, w1
   110a8:	a1 70 88    	mov.w     w1, 0xe14
}
   110aa:	00 00 06    	return    

000110ac <_AUAV_V3_TestSe_LEDs_DriverTID8>:

/* Outputs for atomic system: '<Root>/LEDs_Driver' */
void AUAV_V3_TestSe_LEDs_DriverTID8(void)
{
  /* S-Function (MCHP_Digital_Output_Read): '<S467>/Digital Output Read' */
  /* MCHP_Digital_Output_Read Block: <S467>/Digital Output Read/Output */

  /* Logic: '<S7>/Logical Operator2' incorporates:
   *  S-Function (MCHP_Digital_Output_Read): '<S467>/Digital Output Read'
   */
  AUAV_V3_TestSensors_B.LogicalOperator2 = !LATBbits.LATB4;
   110ac:	a0 70 80    	mov.w     0xe14, w0
   110ae:	70 00 60    	and.w     w0, #0x10, w0
   110b0:	00 00 e9    	dec.w     w0, w0
   110b2:	4f 00 de    	lsr.w     w0, #0xf, w0
   110b4:	a1 ac 21    	mov.w     #0x1aca, w1
   110b6:	80 48 78    	mov.b     w0, [w1]

  /* S-Function (MCHP_Digital_Output_Write): '<S467>/Digital Output Write' */
  LATBbits.LATB4 = AUAV_V3_TestSensors_B.LogicalOperator2;
   110b8:	44 00 dd    	sl.w      w0, #0x4, w0
   110ba:	f1 fe 2f    	mov.w     #0xffef, w1
   110bc:	a2 70 80    	mov.w     0xe14, w2
   110be:	82 80 60    	and.w     w1, w2, w1
   110c0:	81 00 70    	ior.w     w0, w1, w1
   110c2:	a1 70 88    	mov.w     w1, 0xe14
}
   110c4:	00 00 06    	return    

000110c6 <_AUAV_V3_TestSe_LEDs_DriverTID9>:

/* Outputs for atomic system: '<Root>/LEDs_Driver' */
void AUAV_V3_TestSe_LEDs_DriverTID9(void)
{
  /* S-Function (MCHP_Digital_Output_Read): '<S468>/Digital Output Read' */
  /* MCHP_Digital_Output_Read Block: <S468>/Digital Output Read/Output */

  /* Logic: '<S7>/Logical Operator3' incorporates:
   *  S-Function (MCHP_Digital_Output_Read): '<S468>/Digital Output Read'
   */
  AUAV_V3_TestSensors_B.LogicalOperator3 = !LATBbits.LATB5;
   110c6:	00 02 20    	mov.w     #0x20, w0
   110c8:	14 0e b6    	and.w     0xe14, WREG
   110ca:	00 00 e9    	dec.w     w0, w0
   110cc:	4f 00 de    	lsr.w     w0, #0xf, w0
   110ce:	c1 ac 21    	mov.w     #0x1acc, w1
   110d0:	80 48 78    	mov.b     w0, [w1]

  /* S-Function (MCHP_Digital_Output_Write): '<S468>/Digital Output Write' */
  LATBbits.LATB5 = AUAV_V3_TestSensors_B.LogicalOperator3;
   110d2:	45 00 dd    	sl.w      w0, #0x5, w0
   110d4:	f1 fd 2f    	mov.w     #0xffdf, w1
   110d6:	a2 70 80    	mov.w     0xe14, w2
   110d8:	82 80 60    	and.w     w1, w2, w1
   110da:	81 00 70    	ior.w     w0, w1, w1
   110dc:	a1 70 88    	mov.w     w1, 0xe14
}
   110de:	00 00 06    	return    

000110e0 <_AUAV_V3_Tes_AxisRotDefault>:
 *    '<S700>/AxisRotDefault'
 */
void AUAV_V3_Tes_AxisRotDefault(const real32_T rtu_In1[7], real32_T *rty_1,
  real32_T *rty_2, real32_T *rty_3)
{
   110e0:	88 9f be    	mov.d     w8, [w15++]
   110e2:	8a 9f be    	mov.d     w10, [w15++]
   110e4:	8c 1f 78    	mov.w     w12, [w15++]
   110e6:	00 05 78    	mov.w     w0, w10
   110e8:	01 04 78    	mov.w     w1, w8
   110ea:	82 05 78    	mov.w     w2, w11
   110ec:	03 06 78    	mov.w     w3, w12

000110ee <.L0>:
  real32_T rtu_In1_0;

  /* Fcn: '<S508>/Fcn1' */
  *rty_1 = rt_atan2f_snf(rtu_In1[0], rtu_In1[1]);
   110ee:	2a 01 90    	mov.w     [w10+4], w2
   110f0:	ba 01 90    	mov.w     [w10+6], w3
   110f2:	1a 00 be    	mov.d     [w10], w0
   110f4:	9c 0b 02    	call      0x10b9c <_rt_atan2f_snf>
   110f6:	01 00 00 
   110f8:	00 8c be    	mov.d     w0, [w8]

000110fa <.L0>:

  /* Fcn: '<S508>/Fcn2' */
  if (rtu_In1[2] > 1.0F) {
   110fa:	4a 04 90    	mov.w     [w10+8], w8
   110fc:	da 04 90    	mov.w     [w10+10], w9
   110fe:	02 00 20    	mov.w     #0x0, w2
   11100:	03 f8 23    	mov.w     #0x3f80, w3
   11102:	08 00 be    	mov.d     w8, w0
   11104:	90 18 02    	call      0x1890 <___gesf2>
   11106:	00 00 00 
   11108:	00 00 e0    	cp0.w     w0
   1110a:	0a 00 3c    	bra       GT, 0x11120 <.L4>

0001110c <.L0>:
    rtu_In1_0 = 1.0F;
  } else if (rtu_In1[2] < -1.0F) {
   1110c:	02 00 20    	mov.w     #0x0, w2
   1110e:	03 f8 2b    	mov.w     #0xbf80, w3
   11110:	08 00 be    	mov.d     w8, w0
   11112:	8c 18 02    	call      0x188c <___eqsf2>
   11114:	00 00 00 
   11116:	00 00 e0    	cp0.w     w0
   11118:	05 00 3d    	bra       GE, 0x11124 <.L0> <.L2>

0001111a <.L0>:
    rtu_In1_0 = -1.0F;
   1111a:	08 00 20    	mov.w     #0x0, w8
   1111c:	09 f8 2b    	mov.w     #0xbf80, w9
   1111e:	02 00 37    	bra       0x11124 <.L0> <.L2>

00011120 <.L4>:
   11120:	08 00 20    	mov.w     #0x0, w8
   11122:	09 f8 23    	mov.w     #0x3f80, w9

00011124 <.L0>:
  } else {
    rtu_In1_0 = rtu_In1[2];
  }

  *rty_2 = (real32_T)asin(rtu_In1_0);
   11124:	08 00 be    	mov.d     w8, w0
   11126:	1a 16 02    	call      0x161a <_asinf>
   11128:	00 00 00 
   1112a:	80 8d be    	mov.d     w0, [w11]

0001112c <.L0>:

  /* End of Fcn: '<S508>/Fcn2' */

  /* Fcn: '<S508>/Fcn3' */
  *rty_3 = rt_atan2f_snf(rtu_In1[3], rtu_In1[4]);
   1112c:	0a 09 90    	mov.w     [w10+16], w2
   1112e:	9a 09 90    	mov.w     [w10+18], w3
   11130:	6a 00 90    	mov.w     [w10+12], w0
   11132:	fa 00 90    	mov.w     [w10+14], w1
   11134:	9c 0b 02    	call      0x10b9c <_rt_atan2f_snf>
   11136:	01 00 00 
   11138:	00 8e be    	mov.d     w0, [w12]

0001113a <.L0>:
}
   1113a:	4f 06 78    	mov.w     [--w15], w12
   1113c:	4f 05 be    	mov.d     [--w15], w10
   1113e:	4f 04 be    	mov.d     [--w15], w8
   11140:	00 00 06    	return    

00011142 <_EnablesDisablestheCom_Init>:
   11142:	02 00 20    	mov.w     #0x0, w2
   11144:	03 f8 23    	mov.w     #0x3f80, w3
   11146:	02 88 be    	mov.d     w2, [w0]
   11148:	22 00 98    	mov.w     w2, [w0+4]
   1114a:	33 00 98    	mov.w     w3, [w0+6]
void EnablesDisablestheCom_Init(rtDW_EnablesDisablestheComput_T *localDW)
{
  localDW->aveCount = 1.0;
  localDW->tIni = 1.0;
}
   1114c:	00 00 06    	return    

0001114e <_EnablesDisablestheComputat>:

/*
 * Output and update for atomic system:
 *    '<S28>/Enables//Disables the Computation of  initial Baro Bias'
 *    '<S622>/Enables//Disables the Computation of  initial Baro Bias'
 */
void EnablesDisablestheComputat(rtB_EnablesDisablestheComputa_T *localB,
  rtDW_EnablesDisablestheComput_T *localDW)
{
   1114e:	88 9f be    	mov.d     w8, [w15++]
   11150:	8a 9f be    	mov.d     w10, [w15++]
   11152:	80 05 78    	mov.w     w0, w11
   11154:	01 05 78    	mov.w     w1, w10

00011156 <.L0>:
  /* MATLAB Function 'Barometer_Driver/Baro Altimeter/Enables//Disables the Computation of  initial Baro Bias': '<S39>:1' */
  if (localDW->aveCount < 2500.0) {
   11156:	1a 04 be    	mov.d     [w10], w8
   11158:	02 00 24    	mov.w     #0x4000, w2
   1115a:	c3 51 24    	mov.w     #0x451c, w3
   1115c:	08 00 be    	mov.d     w8, w0
   1115e:	8c 18 02    	call      0x188c <___eqsf2>
   11160:	00 00 00 
   11162:	00 00 e0    	cp0.w     w0
   11164:	06 00 3d    	bra       GE, 0x11172 <.L0> <.L0> <.L3>

00011166 <.L0>:
    /* '<S39>:1:11' */
    /* '<S39>:1:12' */
    localDW->aveCount++;
   11166:	02 00 20    	mov.w     #0x0, w2
   11168:	03 f8 23    	mov.w     #0x3f80, w3
   1116a:	08 00 be    	mov.d     w8, w0
   1116c:	92 14 02    	call      0x1492 <___addsf3>
   1116e:	00 00 00 
   11170:	00 8d be    	mov.d     w0, [w10]

00011172 <.L0>:
  }

  if (localDW->aveCount == 2500.0) {
   11172:	02 00 24    	mov.w     #0x4000, w2
   11174:	c3 51 24    	mov.w     #0x451c, w3
   11176:	1a 00 be    	mov.d     [w10], w0
   11178:	8c 18 02    	call      0x188c <___eqsf2>
   1117a:	00 00 00 
   1117c:	00 00 e0    	cp0.w     w0
   1117e:	06 00 3a    	bra       NZ, 0x1118c <.L5>

00011180 <.L0>:
    /* '<S39>:1:15' */
    /* '<S39>:1:16' */
    localDW->tIni = 0.0;
   11180:	60 00 b8    	mul.uu    w0, #0x0, w0
   11182:	20 05 98    	mov.w     w0, [w10+4]
   11184:	31 05 98    	mov.w     w1, [w10+6]

    /* '<S39>:1:17' */
    localDW->aveCount++;
   11186:	00 00 25    	mov.w     #0x5000, w0
   11188:	c1 51 24    	mov.w     #0x451c, w1
   1118a:	00 8d be    	mov.d     w0, [w10]

0001118c <.L5>:
  }

  /* '<S39>:1:20' */
  localB->tOut = localDW->tIni;
   1118c:	2a 00 90    	mov.w     [w10+4], w0
   1118e:	ba 00 90    	mov.w     [w10+6], w1
   11190:	80 8d be    	mov.d     w0, [w11]

  /* if aveCount > 500 */
  /*     tIni = 0; */
  /* end */
  /*  if isempty(aveCount) */
  /*      aveCount =1; */
  /*      initBias = [0.0 0.0 0.0]'; */
  /*  end; */
  /*       */
  /*  if (aveCount<10) */
  /*      initBias = initBias+ Raw; */
  /*      bias = initBias/aveCount; */
  /*      aveCount = aveCount +1; */
  /*  end; */
  /*   */
  /*  if (aveCount == 10) */
  /*      initBias = initBias/(aveCount-1); */
  /*      aveCount = 100; */
  /*  end; */
  /*   */
  /*  if (aveCount == 100) */
  /*      bias = initBias; */
  /*  end; */
}
   11192:	4f 05 be    	mov.d     [--w15], w10
   11194:	4f 04 be    	mov.d     [--w15], w8
   11196:	00 00 06    	return    

00011198 <_uartBufferInit>:
   11198:	60 05 20    	mov.w     #0x56, w0
   1119a:	c0 36 88    	mov.w     w0, 0x6d8
   1119c:	60 43 80    	mov.w     0x86c, w0
   1119e:	00 00 a0    	bset.w    w0, #0x0
   111a0:	00 10 a1    	bclr.w    w0, #0x1
   111a2:	00 20 a0    	bset.w    w0, #0x2
   111a4:	60 43 88    	mov.w     w0, 0x86c
   111a6:	0b 08 a9    	bclr.b    0x80b, #0x0
   111a8:	2b 08 a8    	bset.b    0x82b, #0x0

000111aa <.L0>:
   111aa:	a0 65 23    	mov.w     #0x365a, w0
   111ac:	c0 b2 89    	mov.w     w0, 0x3658

000111ae <.L0>:
   111ae:	94 0a 02    	call      0x10a94 <_newCircBuffer>
   111b0:	01 00 00 
   111b2:	00 00 06    	return    

000111b4 <__U4RXInterrupt>:

}
#ifndef WIN
// Interrupt service routine for U4 GPS port
void __attribute__((__interrupt__, no_auto_psv)) _U4RXInterrupt(void) {
   111b4:	36 00 f8    	push      0x36
   111b6:	80 9f be    	mov.d     w0, [w15++]
   111b8:	82 9f be    	mov.d     w2, [w15++]
   111ba:	84 9f be    	mov.d     w4, [w15++]
   111bc:	86 9f be    	mov.d     w6, [w15++]
      _U4RXIF = 0;
   111be:	0b 08 a9    	bclr.b    0x80b, #0x0
    // Read the buffer while it has data
    // and add it to the circular buffer
    while (U4STAbits.URXDA == 1) {
   111c0:	b2 02 ab    	btst.b    0x2b2, #0x0
   111c2:	06 00 32    	bra       Z, 0x111d0 <.L3>

000111c4 <.L0>:
        writeBack(uartBuffer, (unsigned char) U4RXREG);
   111c4:	b1 15 80    	mov.w     0x2b6, w1
   111c6:	c0 b2 81    	mov.w     0x3658, w0
   111c8:	42 0b 02    	call      0x10b42 <_writeBack>
   111ca:	01 00 00 

000111cc <.L0>:
   111cc:	b2 02 ab    	btst.b    0x2b2, #0x0
   111ce:	fa ff 3a    	bra       NZ, 0x111c4 <.L0> <.L6>

000111d0 <.L3>:
    }

    // If there was an overun error clear it and continue
    if (U4STAbits.OERR == 1) {
   111d0:	b2 22 ab    	btst.b    0x2b2, #0x1
   111d2:	02 00 32    	bra       Z, 0x111d8 <.L5>
        _U4RXIF = 0;
   111d4:	0b 08 a9    	bclr.b    0x80b, #0x0
        U4STAbits.OERR = 0;
   111d6:	b2 22 a9    	bclr.b    0x2b2, #0x1

000111d8 <.L5>:
    }

    // clear the interrupt
    IFS5bits.U4RXIF = 0;
   111d8:	0b 08 a9    	bclr.b    0x80b, #0x0
}
   111da:	4f 03 be    	mov.d     [--w15], w6
   111dc:	4f 02 be    	mov.d     [--w15], w4
   111de:	4f 01 be    	mov.d     [--w15], w2
   111e0:	4f 00 be    	mov.d     [--w15], w0
   111e2:	36 00 f9    	pop       0x36
   111e4:	00 40 06    	retfie    

000111e6 <_getGPSRawData>:
#endif
void getGPSRawData(unsigned char* gpsBuffer) {
	
}
   111e6:	00 00 06    	return    

000111e8 <_isGPSNovatel>:
unsigned char isGPSNovatel (void){
    return (unsigned char) USE_NOVATEL_GPS;
}
   111e8:	00 40 eb    	clr.b     w0
   111ea:	00 00 06    	return    

000111ec <_A_EmbeddedMATLABFunction_l>:
 *    '<S21>/Embedded MATLAB Function1'
 */
void A_EmbeddedMATLABFunction_l(real32_T rtu_u, rtB_EmbeddedMATLABFunction_d_T
  *localB)
{
   111ec:	88 9f be    	mov.d     w8, [w15++]
   111ee:	8a 1f 78    	mov.w     w10, [w15++]
   111f0:	00 04 be    	mov.d     w0, w8
   111f2:	02 05 78    	mov.w     w2, w10

000111f4 <.L0>:
  /* MATLAB Function 'Position_and_Attitude_Filter/Attitude Complimentary Filter COG/Embedded MATLAB Function': '<S491>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  if (rtu_u < 0.0F) {
   111f4:	60 11 b8    	mul.uu    w2, #0x0, w2
   111f6:	8c 18 02    	call      0x188c <___eqsf2>
   111f8:	00 00 00 
   111fa:	00 00 e0    	cp0.w     w0
   111fc:	07 00 3d    	bra       GE, 0x1120c <.L0> <.L6>

000111fe <.L0>:
    /* '<S491>:1:5' */
    /* '<S491>:1:6' */
    localB->y = rtu_u + 6.28318548F;
   111fe:	b2 fd 20    	mov.w     #0xfdb, w2
   11200:	93 0c 24    	mov.w     #0x40c9, w3
   11202:	08 00 be    	mov.d     w8, w0
   11204:	92 14 02    	call      0x1492 <___addsf3>
   11206:	00 00 00 
   11208:	00 8d be    	mov.d     w0, [w10]
   1120a:	01 00 37    	bra       0x1120e <.L1>

0001120c <.L0>:
  } else {
    /* '<S491>:1:8' */
    localB->y = rtu_u;
   1120c:	08 8d be    	mov.d     w8, [w10]

0001120e <.L1>:
  }
}
   1120e:	4f 05 78    	mov.w     [--w15], w10
   11210:	4f 04 be    	mov.d     [--w15], w8
   11212:	00 00 06    	return    

00011214 <_AUAV_V3_TestSen_negprotect>:
   11214:	88 9f be    	mov.d     w8, [w15++]
   11216:	8a 1f 78    	mov.w     w10, [w15++]
   11218:	00 04 be    	mov.d     w0, w8
   1121a:	02 05 78    	mov.w     w2, w10

0001121c <.L0>:
   1121c:	f2 26 21    	mov.w     #0x126f, w2
   1121e:	33 a8 23    	mov.w     #0x3a83, w3
{
  /* MATLAB Function 'Inner Loop// Navigation/Lateral Channel Encaps [updated 4.28.16]/Lateral Channel/Sideslip Compensation/Bank to Psi Dot/negprotect': '<S122>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  if (rtu_val >= 0.001F) {
   11220:	90 18 02    	call      0x1890 <___gesf2>
   11222:	00 00 00 
   11224:	00 00 e0    	cp0.w     w0
   11226:	02 00 35    	bra       LT, 0x1122c <.L6>

00011228 <.L0>:
    /* '<S122>:1:5' */
    /* '<S122>:1:6' */
    localB->zpVal = rtu_val;
   11228:	08 8d be    	mov.d     w8, [w10]
   1122a:	03 00 37    	bra       0x11232 <.L1>

0001122c <.L6>:
  } else {
    /* '<S122>:1:8' */
    localB->zpVal = 0.001F;
   1122c:	f0 26 21    	mov.w     #0x126f, w0
   1122e:	31 a8 23    	mov.w     #0x3a83, w1
   11230:	00 8d be    	mov.d     w0, [w10]

00011232 <.L1>:
  }
}
   11232:	4f 05 78    	mov.w     [--w15], w10
   11234:	4f 04 be    	mov.d     [--w15], w8
   11236:	00 00 06    	return    
Disassembly of section .init.delay32:

00011238 <___delay32>:
   11238:	f0 3f b1    	sub.w     #0x3ff, w0
   1123a:	01 80 b1    	subb.w    #0x0, w1
   1123c:	06 00 35    	bra       LT, 0x1124a <L21>

0001123e <L41>:
   1123e:	ee 03 09    	.pword 0x0903ee
   11240:	00 00 00    	nop       
   11242:	40 3f b1    	sub.w     #0x3f4, w0
   11244:	01 80 b1    	subb.w    #0x0, w1
   11246:	fb ff 3d    	bra       GE, 0x1123e <L41>
   11248:	10 00 b0    	add.w     #0x1, w0

0001124a <L21>:
   1124a:	20 3f b0    	add.w     #0x3f2, w0
   1124c:	02 00 35    	bra       LT, 0x11252 <L31>
   1124e:	00 80 09    	repeat    w0
   11250:	00 00 00    	nop       

00011252 <L31>:
   11252:	00 00 06    	return    
Disassembly of section .text:

00011254 <_rtGetInfF>:
{
  IEEESingle infF;
  infF.wordL.wordLuint = 0x7F800000U;
  return infF.wordL.wordLreal;
}
   11254:	00 00 20    	mov.w     #0x0, w0
   11256:	01 f8 27    	mov.w     #0x7f80, w1

00011258 <.L0>:
   11258:	00 00 06    	return    

0001125a <_rtGetInf>:
   1125a:	fc ff 07    	rcall     0x11254 <_rtGetInfF> <.L0> <.L0> <.LFB1> <.Ltext0>
   1125c:	00 00 06    	return    

0001125e <_rtGetMinusInfF>:

/*
 * Initialize rtMinusInf needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real_T rtGetMinusInf(void)
{
  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
  real_T minf = 0.0;
  if (bitsPerReal == 32U) {
    minf = rtGetMinusInfF();
  } else {
    union {
      LittleEndianIEEEDouble bitVal;
      real_T fltVal;
    } tmpVal;

    tmpVal.bitVal.words.wordH = 0xFFF00000U;
    tmpVal.bitVal.words.wordL = 0x00000000U;
    minf = tmpVal.fltVal;
  }

  return minf;
}

/*
 * Initialize rtMinusInfF needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real32_T rtGetMinusInfF(void)
{
  IEEESingle minfF;
  minfF.wordL.wordLuint = 0xFF800000U;
  return minfF.wordL.wordLreal;
}
   1125e:	00 00 20    	mov.w     #0x0, w0
   11260:	01 f8 2f    	mov.w     #0xff80, w1

00011262 <.L0>:
   11262:	00 00 06    	return    

00011264 <_rtGetMinusInf>:
   11264:	fc ff 07    	rcall     0x1125e <_rtGetMinusInfF> <L0> <.L0> <.LFB3> <.LFE0>
   11266:	00 00 06    	return    

00011268 <_AUAV_V3_TestSe_myMuxFun1_e>:
  /* MATLAB Function 'Position_and_Attitude_Filter/Position Filter/BlendPosVel/myMux Fun1': '<S561>:1' */
  /*  This block supports an embeddable subset of the MATLAB language. */
  /*  See the help menu for details.  */
  /* '<S561>:1:5' */
  localB->y[0] = rtu_u1;
   11268:	00 8b be    	mov.d     w0, [w6]
  localB->y[1] = rtu_u2;
   1126a:	22 03 98    	mov.w     w2, [w6+4]
   1126c:	33 03 98    	mov.w     w3, [w6+6]
  localB->y[2] = rtu_u3;
   1126e:	44 03 98    	mov.w     w4, [w6+8]
   11270:	55 03 98    	mov.w     w5, [w6+10]
}
   11272:	00 00 06    	return    

00011274 <_rtGetNaNF>:
   11274:	00 00 20    	mov.w     #0x0, w0
   11276:	01 fc 2f    	mov.w     #0xffc0, w1

00011278 <.L0>:
   11278:	00 00 06    	return    

0001127a <_rtGetNaN>:
   1127a:	fc ff 07    	rcall     0x11274 <_rtGetNaNF> <L0> <.L0> <.L0> <.LFB1> <.LFE1465> <.Letext0> <.Ltext0>
   1127c:	00 00 06    	return    

0001127e <_AUAV_V3_T_EnabledSubsystem>:
   1127e:	00 04 e0    	cp0.b     w0
{
  /* Outputs for Enabled SubSystem: '<S28>/Enabled Subsystem' incorporates:
   *  EnablePort: '<S38>/Enable'
   */
  if (rtu_Enable) {
   11280:	01 00 32    	bra       Z, 0x11284 <.L1>
    /* Inport: '<S38>/In1' */
    localB->In1 = rtu_In1;
   11282:	82 88 be    	mov.d     w2, [w1]

00011284 <.L1>:
  }

  /* End of Outputs for SubSystem: '<S28>/Enabled Subsystem' */
}
   11284:	00 00 06    	return    
Disassembly of section .shared.dinit:

00011286 <.shared.dinit>:
   11286:	00 00 00    	nop       
